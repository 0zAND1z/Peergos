(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Doppio = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],2:[function(_dereq_,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],3:[function(_dereq_,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],4:[function(_dereq_,module,exports){
'use strict';

var utils   = _dereq_('../utils/common');
var trees   = _dereq_('./trees');
var adler32 = _dereq_('./adler32');
var crc32   = _dereq_('./crc32');
var msg     = _dereq_('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state
 */
//function deflateCopy(dest, source) {
//
//}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":1,"./adler32":2,"./crc32":3,"./messages":8,"./trees":9}],5:[function(_dereq_,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],6:[function(_dereq_,module,exports){
'use strict';


var utils         = _dereq_('../utils/common');
var adler32       = _dereq_('./adler32');
var crc32         = _dereq_('./crc32');
var inflate_fast  = _dereq_('./inffast');
var inflate_table = _dereq_('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}


exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":1,"./adler32":2,"./crc32":3,"./inffast":5,"./inftrees":7}],7:[function(_dereq_,module,exports){
'use strict';


var utils = _dereq_('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":1}],8:[function(_dereq_,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],9:[function(_dereq_,module,exports){
'use strict';


var utils = _dereq_('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":1}],10:[function(_dereq_,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],11:[function(_dereq_,module,exports){
module.exports={
  "name": "@hrj/doppiojvm-snapshot",
  "version": "0.4.10",
  "engine": "node >= 4.0.0",
  "license": "MIT",
  "main": "dist/release/doppio.js",
  "typings": "dist/typings/src/doppiojvm",
  "dependencies": {
    "async": "^1.5.2",
    "browserfs": "^0.5.12",
    "glob": "^7.0.0",
    "gunzip-maybe": "^1.3.1",
    "optimist": "~0.6",
    "pako": "^1.0.0",
    "rimraf": "^2.5.2",
    "source-map-support": "^0.4.0",
    "tar-fs": "^1.10.0"
  },
  "devDependencies": {
    "bfs-buffer": "^0.1.1",
    "bfs-path": "^0.1.1",
    "bfs-process": "^0.1.5",
    "browserify": "^13.0.0",
    "browserify-derequire": "^0.9.4",
    "browserify-shim": "^3.8.12",
    "cpr": "^1.0.0",
    "escodegen": "^1.8.0",
    "esprima": "^2.7.2",
    "estraverse": "^4.1.0",
    "grunt": "^0.4.5",
    "grunt-browserify": "^4.0.1",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-connect": "^0.11.2",
    "grunt-contrib-copy": "^0.8.1",
    "grunt-contrib-uglify": "^0.11.1",
    "grunt-exorcise": "^2.1.1",
    "grunt-karma": "^0.12.1",
    "grunt-lineending": "^0.2.4",
    "grunt-merge-source-maps": "^0.1.0",
    "grunt-ts": "^5.3.2",
    "jasmine-core": "^2.3.4",
    "karma": "^0.13.21",
    "karma-browserify": "^5.0.2",
    "karma-chrome-launcher": "^0.2.1",
    "karma-firefox-launcher": "^0.1.6",
    "karma-ie-launcher": "^0.2.0",
    "karma-jasmine": "^0.3.7",
    "karma-opera-launcher": "^0.3.0",
    "karma-safari-launcher": "^0.1.1",
    "locate-java-home": "^0.1.4",
    "semver": "^5.1.0",
    "tsify": "^0.13.2",
    "typescript": "^1.8.2",
    "uglify-js": "^2.6.2",
    "undebugify": "^0.1.0",
    "underscore": "^1.8.3"
  },
  "scripts": {
    "test": "grunt test",
    "prepublish": "node ./prepublish.js",
    "install": "node ./install.js",
    "appveyor-test": "grunt test-browser-appveyor"
  },
  "browserify-shim": {
    "browserfs": "global:BrowserFS"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/plasma-umass/doppio.git"
  },
  "bin": {
    "doppio": "./bin/doppio",
    "doppioh": "./bin/doppioh",
    "doppio-dev": "./bin/doppio-dev",
    "doppio-fast-dev": "./bin/doppio-fast-dev"
  }
}

},{}],12:[function(_dereq_,module,exports){
module.exports=BrowserFS.BFSRequire('buffer');

},{}],13:[function(_dereq_,module,exports){
module.exports=BrowserFS.BFSRequire('fs');

},{}],14:[function(_dereq_,module,exports){
module.exports=BrowserFS.BFSRequire('path');

},{}],15:[function(_dereq_,module,exports){
"use strict";
var gLong = _dereq_('./gLong');
var assert = _dereq_('./assert');
/**
 * A ByteStream, implemented using a NodeBuffer.
 */
var ByteStream = (function () {
    function ByteStream(buffer) {
        this.buffer = buffer;
        this._index = 0;
    }
    /**
     * Returns the current read index, and increments the index by the indicated
     * amount.
     */
    ByteStream.prototype.incIndex = function (inc) {
        var readIndex = this._index;
        this._index += inc;
        return readIndex;
    };
    ByteStream.prototype.rewind = function () {
        this._index = 0;
    };
    ByteStream.prototype.seek = function (idx) {
        assert(idx >= 0 && idx < this.buffer.length, "Invalid seek position.");
        this._index = idx;
    };
    ByteStream.prototype.pos = function () {
        return this._index;
    };
    ByteStream.prototype.skip = function (bytesCount) {
        this._index += bytesCount;
    };
    ByteStream.prototype.hasBytes = function () {
        return this._index < this.buffer.length;
    };
    ByteStream.prototype.getFloat = function () {
        return this.buffer.readFloatBE(this.incIndex(4));
    };
    ByteStream.prototype.getDouble = function () {
        return this.buffer.readDoubleBE(this.incIndex(8));
    };
    ByteStream.prototype.getUint = function (byteCount) {
        switch (byteCount) {
            case 1:
                return this.getUint8();
            case 2:
                return this.getUint16();
            case 4:
                return this.getUint32();
            default:
                throw new Error("Invalid byte count for getUint: " + byteCount);
        }
    };
    ByteStream.prototype.getInt = function (byteCount) {
        switch (byteCount) {
            case 1:
                return this.getInt8();
            case 2:
                return this.getInt16();
            case 4:
                return this.getInt32();
            default:
                throw new Error("Invalid byte count for getUint: " + byteCount);
        }
    };
    ByteStream.prototype.getUint8 = function () {
        return this.buffer.readUInt8(this.incIndex(1));
    };
    ByteStream.prototype.getUint16 = function () {
        return this.buffer.readUInt16BE(this.incIndex(2));
    };
    ByteStream.prototype.getUint32 = function () {
        return this.buffer.readUInt32BE(this.incIndex(4));
    };
    ByteStream.prototype.getInt8 = function () {
        return this.buffer.readInt8(this.incIndex(1));
    };
    ByteStream.prototype.getInt16 = function () {
        return this.buffer.readInt16BE(this.incIndex(2));
    };
    ByteStream.prototype.getInt32 = function () {
        return this.buffer.readInt32BE(this.incIndex(4));
    };
    ByteStream.prototype.getInt64 = function () {
        var high = this.getUint32();
        var low = this.getUint32();
        return gLong.fromBits(low, high);
    };
    ByteStream.prototype.read = function (bytesCount) {
        var rv = this.buffer.slice(this._index, this._index + bytesCount);
        this._index += bytesCount;
        return rv;
    };
    ByteStream.prototype.peek = function () {
        return this.buffer.readUInt8(this._index);
    };
    ByteStream.prototype.size = function () {
        return this.buffer.length - this._index;
    };
    ByteStream.prototype.slice = function (len) {
        var arr = new ByteStream(this.buffer.slice(this._index, this._index + len));
        this._index += len;
        return arr;
    };
    ByteStream.prototype.getBuffer = function () {
        return this.buffer;
    };
    return ByteStream;
})();
module.exports = ByteStream;

},{"./assert":26,"./gLong":32}],16:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var util = _dereq_('./util');
var ByteStream = _dereq_('./ByteStream');
var ConstantPool = _dereq_('./ConstantPool');
var attributes = _dereq_('./attributes');
var threading_1 = _dereq_('./threading');
var logging = _dereq_('./logging');
var methods = _dereq_('./methods');
var enums = _dereq_('./enums');
var ClassLock = _dereq_('./ClassLock');
var assert = _dereq_('./assert');
var gLong = _dereq_('./gLong');
var StringOutputStream = _dereq_('./StringOutputStream');
var ClassState = enums.ClassState;
var trace = logging.trace;
var debug = logging.debug;
var global = _dereq_('./global');
if (typeof RELEASE === 'undefined')
    global.RELEASE = false;
/**
 * Auto-incrementing reference number. Uniquely identifies each object allocated
 * by the JVM. Started at 1 because we use 0 to identify NULL.
 */
var ref = 1;
/**
 * Defines special JVM-injected fields. The map stores the TypeScript type of
 * the field and the default value for the field, which will be assigned in the
 * JavaScript constructor for the class.
 */
var injectedFields = {
    'Ljava/lang/invoke/MemberName;': {
        vmtarget: ["(thread: JVMThread, descriptor: string, args: any[], cb?: (e?: JVMTypes.java_lang_Throwable, rv?: any) => void) => void", "null"],
        vmindex: ["number", "-1"]
    },
    'Ljava/lang/Object;': {
        'ref': ["number", "ref++"],
        '$monitor': ["Monitor", "null"]
    },
    'Ljava/net/PlainSocketImpl;': {
        '$is_shutdown': ['boolean', 'false'],
        '$ws': ['Interfaces.IWebsock', 'null']
    },
    'Ljava/io/FileDescriptor;': {
        '$pos': ['number', '-1']
    },
    'Ljava/lang/Class;': {
        '$cls': ['ClassData', 'null']
    },
    'Ljava/lang/ClassLoader;': {
        '$loader': ['ClassLoader', 'new ClassLoader.CustomClassLoader(thread.getBsCl(), this);']
    },
    'Ljava/lang/Thread;': {
        // Note: Need to handle initial case when thread is NULL.
        '$thread': ['JVMThread', 'thread ? new thread.constructor(thread.getJVM(), thread.getThreadPool(), this) : null']
    }
};
/**
 * Defines special JVM-injected method. The map stores the TypeScript type
 * signature of the method and the JavaScript body of the method, keyed on the
 * method's name. These are all instance methods (e.g. non-static).
 */
var injectedMethods = {
    'Ljava/lang/Object;': {
        'getClass': ["(): ClassData", "function() { return this.constructor.cls }"],
        'getMonitor': ["(): Monitor", "function() {\n  if (this.$monitor === null) {\n    this.$monitor = new Monitor();\n  }\n  return this.$monitor;\n}"]
    },
    'Ljava/lang/String;': {
        'toString': ["(): string", "function() { return util.chars2jsStr(this['java/lang/String/value']); }"]
    },
    'Ljava/lang/Byte;': {
        'unbox': ["(): number", "function() { return this['java/lang/Byte/value']; }"]
    },
    'Ljava/lang/Character;': {
        'unbox': ["(): number", "function() { return this['java/lang/Character/value']; }"]
    },
    'Ljava/lang/Double;': {
        'unbox': ["(): number", "function() { return this['java/lang/Double/value']; }"]
    },
    'Ljava/lang/Float;': {
        'unbox': ["(): number", "function() { return this['java/lang/Float/value']; }"]
    },
    'Ljava/lang/Integer;': {
        'unbox': ["(): number", "function() { return this['java/lang/Integer/value']; }"]
    },
    'Ljava/lang/Long;': {
        'unbox': ["(): Long", "function() { return this['java/lang/Long/value']; }"]
    },
    'Ljava/lang/Short;': {
        'unbox': ["(): number", "function() { return this['java/lang/Short/value']; }"]
    },
    'Ljava/lang/Boolean;': {
        'unbox': ["(): number", "function() { return this['java/lang/Boolean/value']; }"]
    },
    // To catch any errors. Should never actually happen; Voids don't show up in arg lists.
    'Ljava/lang/Void;': {
        'unbox': ["(): number", "function() { throw new Error(\"Cannot unbox a Void type.\"); }"]
    },
    'Ljava/lang/invoke/MethodType;': {
        'toString': ["(): string", "function() { return \"(\" + this['java/lang/invoke/MethodType/ptypes'].array.map(function (type) { return type.$cls.getInternalName(); }).join(\"\") + \")\" + this['java/lang/invoke/MethodType/rtype'].$cls.getInternalName(); }"]
    }
};
/**
 * Same as injected methods, but these are static.
 */
var injectedStaticMethods = {
    'Ljava/lang/Byte;': {
        'box': ["(val: number): java_lang_Byte", "function(val) { var rv = new this(null); rv['java/lang/Byte/value'] = val; return rv; }"]
    },
    'Ljava/lang/Character;': {
        'box': ["(val: number): java_lang_Character", "function(val) { var rv = new this(null); rv['java/lang/Character/value'] = val; return rv; }"]
    },
    'Ljava/lang/Double;': {
        'box': ["(val: number): java_lang_Double", "function(val) { var rv = new this(null); rv['java/lang/Double/value'] = val; return rv; }"]
    },
    'Ljava/lang/Float;': {
        'box': ["(val: number): java_lang_Float", "function(val) { var rv = new this(null); rv['java/lang/Float/value'] = val; return rv; }"]
    },
    'Ljava/lang/Integer;': {
        'box': ["(val: number): java_lang_Integer", "function(val) { var rv = new this(null); rv['java/lang/Integer/value'] = val; return rv; }"]
    },
    'Ljava/lang/Long;': {
        'box': ["(val: Long): java_lang_Long", "function(val) { var rv = new this(null); rv['java/lang/Long/value'] = val; return rv; }"]
    },
    'Ljava/lang/Short;': {
        'box': ["(val: number): java_lang_Short", "function(val) { var rv = new this(null); rv['java/lang/Short/value'] = val; return rv; }"]
    },
    'Ljava/lang/Boolean;': {
        'box': ["(val: number): java_lang_Boolean", "function(val) { var rv = new this(null); rv['java/lang/Boolean/value'] = val; return rv; }"]
    },
    'Ljava/lang/Void;': {
        'box': ["(): java_lang_Void", "function() { return new this(null); }"]
    }
};
/**
 * Extends a JVM class by making its prototype a blank instantiation of an
 * object with the super class's prototype as its prototype. Inspired from
 * TypeScript's __extend function.
 */
function extendClass(cls, superCls) {
    function __() { this.constructor = cls; }
    __.prototype = superCls.prototype;
    cls.prototype = new __();
}
/**
 * Represents a single class in the JVM.
 */
var ClassData = (function () {
    /**
     * Responsible for setting up all of the fields that are guaranteed to be
     * present on any ClassData object.
     */
    function ClassData(loader) {
        this.accessFlags = null;
        /**
         * We make this private to *enforce* call sites to use our getter functions.
         * The actual state of this class depends on the state of its parents, and
         * parents do not inform their children when they change state.
         */
        this.state = enums.ClassState.LOADED;
        this.jco = null;
        this.superClass = null;
        this.loader = loader;
    }
    /**
     * Get the external form of this class's name (e.g. java.lang.String).
     */
    ClassData.prototype.getExternalName = function () {
        return util.ext_classname(this.className);
    };
    /**
     * Get the internal form of this class's name (e.g. Ljava/lang/String;).
     */
    ClassData.prototype.getInternalName = function () {
        return this.className;
    };
    /**
     * Get the name of the package that this class belongs to (e.g. java.lang).
     */
    ClassData.prototype.getPackageName = function () {
        var extName = this.getExternalName(), i;
        // Find the index of the last '.' in the name.
        for (i = extName.length - 1; i >= 0 && extName[i] !== '.'; i--) { }
        if (i >= 0) {
            return extName.slice(0, i);
        }
        else {
            return "";
        }
    };
    /**
     * Returns the ClassLoader object of the classloader that initialized this
     * class. Returns null for the default classloader.
     */
    ClassData.prototype.getLoader = function () {
        return this.loader;
    };
    /**
     * Get the class's super class, which is always going to be a reference
     * class.
     */
    ClassData.prototype.getSuperClass = function () {
        return this.superClass;
    };
    /**
     * Get all of the interfaces that the class implements.
     */
    ClassData.prototype.getInterfaces = function () {
        return [];
    };
    /**
     * Get all of the injected fields for this class. The value for each field
     * in the returned map is its type.
     */
    ClassData.prototype.getInjectedFields = function () {
        var rv = {};
        if (injectedFields[this.getInternalName()] !== undefined) {
            var fields = injectedFields[this.getInternalName()];
            Object.keys(fields).forEach(function (fieldName) {
                rv[fieldName] = fields[fieldName][0];
            });
        }
        return rv;
    };
    /**
     * Get all of the injected methods for this class. The value for each method
     * in the returned map is its type.
     */
    ClassData.prototype.getInjectedMethods = function () {
        var rv = {}, lookupName = this.getInternalName();
        // All array classes share the same injected methods.
        if (lookupName[0] === '[') {
            lookupName = '[';
        }
        if (injectedMethods[lookupName] !== undefined) {
            var methods = injectedMethods[lookupName];
            Object.keys(methods).forEach(function (methodName) {
                rv[methodName] = methods[methodName][0];
            });
        }
        return rv;
    };
    /**
     * Get all of the injected static methods for this class. The value for each
     * method in the returned map is its type.
     */
    ClassData.prototype.getInjectedStaticMethods = function () {
        var rv = {}, lookupName = this.getInternalName();
        // All array classes share the same injected methods.
        if (lookupName[0] === '[') {
            lookupName = '[';
        }
        if (injectedStaticMethods[lookupName] !== undefined) {
            var methods = injectedStaticMethods[lookupName];
            Object.keys(methods).forEach(function (methodName) {
                rv[methodName] = methods[methodName][0];
            });
        }
        return rv;
    };
    /**
     * Get a java.lang.Class object corresponding to this class.
     */
    ClassData.prototype.getClassObject = function (thread) {
        if (this.jco === null) {
            this.jco = new (thread.getBsCl().getResolvedClass('Ljava/lang/Class;').getConstructor(thread))(thread);
            this.jco.$cls = this;
            this.jco['java/lang/Class/classLoader'] = this.getLoader().getLoaderObject();
        }
        return this.jco;
    };
    /**
     * Get the protection domain of this class.
     * This value is NULL for all but reference classes loaded by app classloaders.
     */
    ClassData.prototype.getProtectionDomain = function () {
        return null;
    };
    /**
     * Retrieves the method defined in this particular class by the given method
     * signature *without* invoking method lookup.
     * @param methodSignature The method's full signature, e.g. <clinit>()V
     */
    ClassData.prototype.getMethod = function (methodSignature) {
        return null;
    };
    /**
     * Retrieve all of the methods defined on this class.
     */
    ClassData.prototype.getMethods = function () {
        return [];
    };
    /**
     * Retrieve the set of fields defined on this class.
     */
    ClassData.prototype.getFields = function () {
        return [];
    };
    /**
     * Set the state of this particular class to LOADED/RESOLVED/INITIALIZED.
     */
    ClassData.prototype.setState = function (state) {
        this.state = state;
    };
    /**
     * Gets the current state of this class.
     */
    ClassData.prototype.getState = function () {
        if (this.state === ClassState.RESOLVED && this.getMethod('<clinit>()V') === null) {
            // We can promote to INITIALIZED if this class has no static initialization
            // logic, and its parent class is initialized.
            var scls = this.getSuperClass();
            if (scls !== null && scls.getState() === ClassState.INITIALIZED) {
                this.state = ClassState.INITIALIZED;
            }
        }
        return this.state;
    };
    /**
     * Check if the class is initialized.
     * @param thread The thread that is performing the check. If initialization
     *   is in progress on that thread, then the class is, for all intents and
     *   purposes, initialized.
     */
    ClassData.prototype.isInitialized = function (thread) {
        return this.getState() === ClassState.INITIALIZED;
    };
    // Convenience function.
    ClassData.prototype.isResolved = function () { return this.getState() !== ClassState.LOADED; };
    ClassData.prototype.isSubinterface = function (target) {
        return false;
    };
    ClassData.prototype.isSubclass = function (target) {
        if (this === target) {
            return true;
        }
        if (this.getSuperClass() === null) {
            return false;
        }
        return this.getSuperClass().isSubclass(target);
    };
    ClassData.prototype.resolve = function (thread, cb, explicit) {
        if (explicit === void 0) { explicit = true; }
        throw new Error("Unimplemented.");
    };
    ClassData.prototype.initialize = function (thread, cb, explicit) {
        if (explicit === void 0) { explicit = true; }
        throw new Error("Unimplemented.");
    };
    ClassData.prototype.outputInjectedMethods = function (jsClassName, outputStream) {
        var lookupName = this.getInternalName();
        if (lookupName[0] === '[') {
            lookupName = '[';
        }
        if (injectedMethods[lookupName] !== undefined) {
            var methods = injectedMethods[lookupName];
            Object.keys(methods).forEach(function (methodName) {
                outputStream.write("  " + jsClassName + ".prototype." + methodName + " = " + methods[methodName][1] + ";\n");
            });
        }
        if (injectedStaticMethods[lookupName] !== undefined) {
            var staticMethods = injectedStaticMethods[lookupName];
            Object.keys(staticMethods).forEach(function (methodName) {
                outputStream.write("  " + jsClassName + "." + methodName + " = " + staticMethods[methodName][1] + ";\n");
            });
        }
    };
    return ClassData;
})();
exports.ClassData = ClassData;
var PrimitiveClassData = (function (_super) {
    __extends(PrimitiveClassData, _super);
    function PrimitiveClassData(className, loader) {
        _super.call(this, loader);
        this.className = className;
        // PrimitiveClassData objects are ABSTRACT, FINAL, and PUBLIC.
        this.accessFlags = new util.Flags(0x411);
        this.setState(ClassState.INITIALIZED);
    }
    /**
     * Returns a boolean indicating if this class is an instance of the target class.
     * "target" is a ClassData object.
     * The ClassData objects do not need to be initialized; just loaded.
     */
    PrimitiveClassData.prototype.isCastable = function (target) {
        return this.className === target.getInternalName();
    };
    /**
     * Returns the internal class name for the corresponding boxed type.
     */
    PrimitiveClassData.prototype.boxClassName = function () {
        return util.boxClassName(this.className);
    };
    /**
     * Returns a boxed version of the given primitive.
     */
    PrimitiveClassData.prototype.createWrapperObject = function (thread, value) {
        var boxName = this.boxClassName();
        var boxCls = thread.getBsCl().getInitializedClass(thread, boxName);
        // these are all initialized in preinit (for the BSCL, at least)
        var boxCons = boxCls.getConstructor(thread);
        var wrapped = new boxCons(thread);
        if (boxName !== 'V') {
            // XXX: all primitive wrappers store their value in a private static final field named 'value'
            wrapped[util.descriptor2typestr(boxName) + '/value'] = value;
            assert(typeof value === "number" || typeof value === "boolean" || typeof value.low_ === "number", "Invalid primitive value: " + value);
        }
        return wrapped;
    };
    PrimitiveClassData.prototype.tryToResolve = function () {
        return true;
    };
    PrimitiveClassData.prototype.tryToInitialize = function () {
        return true;
    };
    /**
     * Primitive classes are already resolved.
     */
    PrimitiveClassData.prototype.resolve = function (thread, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        setImmediate(function () { return cb(_this); });
    };
    return PrimitiveClassData;
})(ClassData);
exports.PrimitiveClassData = PrimitiveClassData;
var ArrayClassData = (function (_super) {
    __extends(ArrayClassData, _super);
    function ArrayClassData(componentType, loader) {
        _super.call(this, loader);
        this._constructor = null;
        this.className = "[" + componentType;
        // ArrayClassData objects are ABSTRACT, FINAL, and PUBLIC.
        this.accessFlags = new util.Flags(0x411);
        this.componentClassName = componentType;
    }
    /**
     * Looks up a method with the given signature. Returns null if no method
     * found.
     */
    ArrayClassData.prototype.methodLookup = function (signature) {
        return this.superClass.methodLookup(signature);
    };
    ArrayClassData.prototype.fieldLookup = function (name) {
        return this.superClass.fieldLookup(name);
    };
    /**
     * Resolve the class.
     */
    ArrayClassData.prototype.resolve = function (thread, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        if (this.isResolved()) {
            // Short circuit.
            setImmediate(function () { return cb(_this); });
            return;
        }
        util.asyncForEach(["Ljava/lang/Object;", this.componentClassName], function (cls, nextItem) {
            _this.loader.resolveClass(thread, cls, function (cdata) {
                if (cdata !== null) {
                    nextItem();
                }
                else {
                    nextItem("Failed.");
                }
            });
        }, function (err) {
            if (!err) {
                _this.setResolved(_this.loader.getResolvedClass("Ljava/lang/Object;"), _this.loader.getResolvedClass(_this.componentClassName));
                cb(_this);
            }
            else {
                cb(null);
            }
        });
    };
    ArrayClassData.prototype.getComponentClass = function () {
        return this.componentClass;
    };
    /**
     * Resolved and initialized are the same for array types.
     */
    ArrayClassData.prototype.setResolved = function (super_class_cdata, component_class_cdata) {
        this.superClass = super_class_cdata;
        this.componentClass = component_class_cdata;
        this.setState(ClassState.INITIALIZED);
    };
    ArrayClassData.prototype.tryToResolve = function () {
        var loader = this.loader, superClassCdata = loader.getResolvedClass("Ljava/lang/Object;"), componentClassCdata = loader.getResolvedClass(this.componentClassName);
        if (superClassCdata === null || componentClassCdata === null) {
            return false;
        }
        else {
            this.setResolved(superClassCdata, componentClassCdata);
            return true;
        }
    };
    ArrayClassData.prototype.tryToInitialize = function () {
        // Arrays are initialized once resolved.
        return this.tryToResolve();
    };
    /**
     * Returns a boolean indicating if this class is an instance of the target class.
     * "target" is a ClassData object.
     * The ClassData objects do not need to be initialized; just loaded.
     * See §2.6.7 for casting rules.
     */
    ArrayClassData.prototype.isCastable = function (target) {
        if (!(target instanceof ArrayClassData)) {
            if (target instanceof PrimitiveClassData) {
                return false;
            }
            // Must be a reference type.
            if (target.accessFlags.isInterface()) {
                // Interface reference type
                var type = target.getInternalName();
                return type === 'Ljava/lang/Cloneable;' || type === 'Ljava/io/Serializable;';
            }
            // Non-interface reference type
            return target.getInternalName() === 'Ljava/lang/Object;';
        }
        // We are both array types, so it only matters if my component type can be
        // cast to its component type.
        return this.getComponentClass().isCastable(target.getComponentClass());
    };
    ArrayClassData.prototype.initialize = function (thread, cb, explicit) {
        if (explicit === void 0) { explicit = true; }
        this.resolve(thread, cb, explicit);
    };
    /**
     * Get the array constructor for this particular JVM array class.
     * Uses typed arrays when available for primitive arrays.
     */
    ArrayClassData.prototype.getJSArrayConstructor = function () {
        if (!util.typedArraysSupported) {
            return 'Array';
        }
        switch (this.componentClassName) {
            case 'B':
                return 'Int8Array';
            case 'C':
                return 'Uint16Array';
            case 'S':
                return 'Int16Array';
            case 'I':
                return 'Int32Array';
            case 'F':
                return 'Float32Array';
            case 'D':
                return 'Float64Array';
            default:
                return 'Array';
        }
    };
    /**
     * Get the initial value placed into each array element.
     */
    ArrayClassData.prototype.getJSDefaultArrayElement = function () {
        switch (this.componentClassName[0]) {
            case '[':
                return "new (cls.getComponentClass().getConstructor())(thread, otherLengths)";
            case 'L':
                return "null";
            case 'J':
                return "gLongZero";
            default:
                return "0";
        }
    };
    /**
     * Creates a specialized `slice` method that creates a shallow slice of this
     * array. Specialized to the type of array (JS or Typed).
     */
    ArrayClassData.prototype._getSliceMethod = function () {
        var output = new StringOutputStream(), jsArrCons = this.getJSArrayConstructor();
        output.write("function(start, end) {\n    var newObj = new this.constructor(null, 0);\n");
        if (jsArrCons === 'Array') {
            output.write("    newObj.array = this.array.slice(start, end);\n");
        }
        else {
            var elementSize;
            switch (jsArrCons) {
                case 'Int8Array':
                    elementSize = 1;
                    break;
                case 'Int16Array':
                case 'Uint16Array':
                    elementSize = 2;
                    break;
                case 'Int32Array':
                case 'Float32Array':
                    elementSize = 4;
                    break;
                case 'Float64Array':
                    elementSize = 8;
                    break;
                default:
                    assert(false, "Illegal array type returned??");
            }
            // Although ArrayBuffer.slice has an optional end argument, we need to
            // multiply it if it does exist.
            output.write("    if (end === undefined) end = this.array.length;\n      " + (elementSize > 1 ? "start *= " + elementSize + ";\nend *= " + elementSize + ";" : '') + "\n      newObj.array = new " + jsArrCons + "(this.array.buffer.slice(start, end));\n");
        }
        output.write("    return newObj;\n  }");
        return output.flush();
    };
    ArrayClassData.prototype._constructConstructor = function (thread) {
        assert(this._constructor === null, "Tried to construct constructor twice for " + this.getExternalName() + "!");
        var outputStream = new StringOutputStream(), jsClassName = util.jvmName2JSName(this.getInternalName());
        outputStream.write("function _create(extendClass, cls, superCls, gLongZero, thread) {\n  extendClass(" + jsClassName + ", superCls.getConstructor(thread));\n  function " + jsClassName + "(thread, lengths) {\n");
        this.superClass.outputInjectedFields(outputStream);
        // Initialize array.
        if (this.componentClassName[0] !== '[') {
            // Array elements are a non-array type.
            outputStream.write("    this.array = new " + this.getJSArrayConstructor() + "(lengths);\n");
            if (this.getJSArrayConstructor() === 'Array') {
                // TypedArrays are already initialized to 0, so this check skips array
                // initialization in that case.
                outputStream.write("    for (var i = 0; i < lengths; i++) {\n      this.array[i] = " + this.getJSDefaultArrayElement() + ";\n    }\n");
            }
        }
        else {
            // Multi-dimensional array.
            outputStream.write("    if (typeof lengths === 'number') {\n        this.array = new " + this.getJSArrayConstructor() + "(lengths);\n        for (var i = 0; i < length; i++) {\n          this.array[i] = null;\n        }\n      } else {\n        var length = lengths[0], otherLengths = lengths.length > 2 ? lengths.slice(1) : lengths[1];\n        this.array = new " + this.getJSArrayConstructor() + "(length);\n        for (var i = 0; i < length; i++) {\n          this.array[i] = " + this.getJSDefaultArrayElement() + ";\n        }\n      }\n");
        }
        outputStream.write("  }\n\n  " + jsClassName + ".prototype.slice = " + this._getSliceMethod() + ";\n  " + jsClassName + ".cls = cls;\n");
        this.outputInjectedMethods(jsClassName, outputStream);
        outputStream.write("\n  return " + jsClassName + ";\n}\n// Last statement is return value of eval.\n_create");
        // All arrays extend java/lang/Object
        return eval(outputStream.flush())(extendClass, this, this.superClass, gLong.ZERO, thread);
    };
    ArrayClassData.prototype.getConstructor = function (thread) {
        assert(this.isResolved(), "Tried to get constructor for class " + this.getInternalName() + " before it was resolved.");
        if (this._constructor === null) {
            this._constructor = this._constructConstructor(thread);
        }
        return this._constructor;
    };
    return ArrayClassData;
})(ClassData);
exports.ArrayClassData = ArrayClassData;
/**
 * Represents a "reference" Class -- that is, a class that neither represents a
 * primitive nor an array.
 */
var ReferenceClassData = (function (_super) {
    __extends(ReferenceClassData, _super);
    function ReferenceClassData(buffer, protectionDomain, loader, cpPatches) {
        _super.call(this, loader);
        this.interfaceClasses = null;
        this.superClassRef = null;
        /**
         * Initialization lock.
         */
        this.initLock = new ClassLock();
        /**
         * Stores the JavaScript constructor for this class.
         */
        this._constructor = null;
        /**
         * Virtual field table
         */
        this._fieldLookup = {};
        /**
         * All fields in object instantiations. Fields from super classes are in front
         * of fields from this class. A field's offset in the array is its *vmindex*.
         */
        this._objectFields = [];
        /**
         * All static fields in this particular class. The field's offset in this
         * array is its *vmindex*.
         */
        this._staticFields = [];
        /**
         * Virtual method table, keyed by method signature. Unlike _vmTable,
         * _methodLookup contains static methods and constructors, too.
         */
        this._methodLookup = {};
        /**
         * Virtual method table, keyed by vmindex. Methods originally defined by
         * super classes are in front of methods defined in this class. Overriding
         * methods are placed into the vmindex of the originating method.
         */
        this._vmTable = [];
        /**
         * Default method implementations that this class did *not* inherit, but are
         * still invocable in the class via their full name (e.g. through an
         * invokespecial bytecode).
         */
        this._uninheritedDefaultMethods = [];
        this._protectionDomain = protectionDomain ? protectionDomain : null;
        var byteStream = new ByteStream(buffer), i = 0;
        if ((byteStream.getUint32()) !== 0xCAFEBABE) {
            throw new Error("Magic number invalid");
        }
        this.minorVersion = byteStream.getUint16();
        this.majorVersion = byteStream.getUint16();
        if (!(45 <= this.majorVersion && this.majorVersion <= 52)) {
            throw new Error("Major version invalid");
        }
        this.constantPool = new ConstantPool.ConstantPool();
        this.constantPool.parse(byteStream, cpPatches);
        // bitmask for {public,final,super,interface,abstract} class modifier
        this.accessFlags = new util.Flags(byteStream.getUint16());
        this.className = this.constantPool.get(byteStream.getUint16()).name;
        // super reference is 0 when there's no super (basically just java.lang.Object)
        var superRef = byteStream.getUint16();
        if (superRef !== 0) {
            this.superClassRef = this.constantPool.get(superRef);
        }
        // direct interfaces of this class
        var isize = byteStream.getUint16();
        this.interfaceRefs = new Array(isize);
        for (i = 0; i < isize; ++i) {
            this.interfaceRefs[i] = this.constantPool.get(byteStream.getUint16());
        }
        // fields of this class
        var numFields = byteStream.getUint16();
        this.fields = new Array(numFields);
        for (i = 0; i < numFields; ++i) {
            this.fields[i] = new methods.Field(this, this.constantPool, i, byteStream);
        }
        // class methods
        var numMethods = byteStream.getUint16();
        this.methods = new Array(numMethods);
        for (i = 0; i < numMethods; i++) {
            var m = new methods.Method(this, this.constantPool, i, byteStream);
            this.methods[i] = m;
        }
        // class attributes
        this.attrs = attributes.makeAttributes(byteStream, this.constantPool);
        if (byteStream.hasBytes()) {
            throw "Leftover bytes in classfile: " + byteStream;
        }
    }
    ReferenceClassData.prototype.getSuperClassReference = function () {
        return this.superClassRef;
    };
    ReferenceClassData.prototype.getInterfaceClassReferences = function () {
        return this.interfaceRefs.slice(0);
    };
    /**
     * Retrieve the set of interfaces that this class implements.
     * DO NOT MUTATE!
     */
    ReferenceClassData.prototype.getInterfaces = function () {
        return this.interfaceClasses;
    };
    /**
     * The set of fields that this class has.
     * DO NOT MUTATE!
     */
    ReferenceClassData.prototype.getFields = function () {
        return this.fields;
    };
    /**
     * Get the Virtual Method table for this class.
     */
    ReferenceClassData.prototype.getVMTable = function () {
        return this._vmTable;
    };
    /**
     * Returns the VM index for the given method. Returns -1 if not present in the
     * virtual method table (e.g. is static or a constructor).
     */
    ReferenceClassData.prototype.getVMIndexForMethod = function (m) {
        // Use M's signature, as we might override the method and use a different
        // method object in the table for its vmindex.
        return this._vmTable.indexOf(this.methodLookup(m.signature));
    };
    /**
     * Returns the method corresponding to the given VMIndex.
     */
    ReferenceClassData.prototype.getMethodFromVMIndex = function (i) {
        if (this._vmTable[i] !== undefined) {
            return this._vmTable[i];
        }
        return null;
    };
    /**
     * Get the VM index for the given field
     * NOTE: A static and non-static field can have the same vmindex! Caller must
     * be able to differentiate between static and non-static behavior!
     */
    ReferenceClassData.prototype.getVMIndexForField = function (f) {
        if (f.accessFlags.isStatic()) {
            assert(f.cls === this, "Looks like we actually need to support static field lookups!");
            return this._staticFields.indexOf(f);
        }
        else {
            return this._objectFields.indexOf(f);
        }
    };
    ReferenceClassData.prototype.getStaticFieldFromVMIndex = function (index) {
        var f = this._staticFields[index];
        if (f !== undefined) {
            return f;
        }
        return null;
    };
    ReferenceClassData.prototype.getObjectFieldFromVMIndex = function (index) {
        var f = this._objectFields[index];
        if (f !== undefined) {
            return f;
        }
        return null;
    };
    /**
     * Get a field from its "slot". A "slot" is just the field's index in its
     * defining class's field array.
     */
    ReferenceClassData.prototype.getFieldFromSlot = function (slot) {
        return this.fields[slot];
    };
    /**
     * Get a method from its "slot". A "slot" is just the method's index in its
     * defining class's method array.
     */
    ReferenceClassData.prototype.getMethodFromSlot = function (slot) {
        return this.methods[slot];
    };
    /**
     * Retrieve a method with the given signature from this particular class.
     * Does not search superclasses / interfaces.
     */
    ReferenceClassData.prototype.getMethod = function (sig) {
        var m = this._methodLookup[sig];
        if (m.cls === this) {
            return m;
        }
        return null;
    };
    ReferenceClassData.prototype.getSpecificMethod = function (definingCls, sig) {
        if (this.getInternalName() === definingCls) {
            return this.getMethod(sig);
        }
        var searchClasses = this.interfaceClasses.slice(0), m;
        if (this.superClass) {
            searchClasses.push(this.superClass);
        }
        for (var i = 0; i < searchClasses.length; i++) {
            if (null !== (m = searchClasses[i].getSpecificMethod(definingCls, sig))) {
                return m;
            }
        }
        return null;
    };
    /**
     * Get the methods belonging to this particular class.
     * DO NOT MUTATE!
     */
    ReferenceClassData.prototype.getMethods = function () {
        return this.methods;
    };
    /**
     * Get the set of default methods that are invocable on this object, but were
     * not inherited in the virtual method table.
     * DO NOT MUTATE!
     */
    ReferenceClassData.prototype.getUninheritedDefaultMethods = function () {
        return this._uninheritedDefaultMethods;
    };
    ReferenceClassData.prototype.getProtectionDomain = function () {
        return this._protectionDomain;
    };
    /**
     * Resolves this class's virtual method table according to the JVM
     * specification:
     * http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3
     */
    ReferenceClassData.prototype._resolveMethods = function () {
        var _this = this;
        if (this.superClass !== null) {
            // Start off with my parents' method table.
            this._vmTable = this._vmTable.concat(this.superClass._vmTable);
            Object.keys(this.superClass._methodLookup).forEach(function (m) {
                _this._methodLookup[m] = _this.superClass._methodLookup[m];
            });
        }
        // My methods override my super class'.
        this.methods.forEach(function (m) {
            var superM = _this._methodLookup[m.signature];
            if (!m.accessFlags.isStatic() && m.name !== "<init>") {
                // Only non-static non-constructor methods are placed into the virtual
                // method table.
                if (superM === undefined) {
                    // New vmindex.
                    _this._vmTable.push(m);
                }
                else {
                    // Old vmindex. Inherit the super class method's vmindex.
                    _this._vmTable[_this._vmTable.indexOf(superM)] = m;
                }
            }
            _this._methodLookup[m.signature] = m;
        });
        // Root out any miranda / default / static interface methods. Only install
        // them if there are no alternatives already in the table.
        this.interfaceClasses.forEach(function (iface) {
            Object.keys(iface._methodLookup).forEach(function (ifaceMethodSig) {
                var ifaceM = iface._methodLookup[ifaceMethodSig];
                if (_this._methodLookup[ifaceMethodSig] === undefined) {
                    if (!ifaceM.accessFlags.isStatic()) {
                        // New vmindex.
                        _this._vmTable.push(ifaceM);
                    }
                    _this._methodLookup[ifaceMethodSig] = ifaceM;
                }
                else if (ifaceM.isDefault()) {
                    // Default method; uninherited, but still callable via full signature.
                    _this._uninheritedDefaultMethods.push(ifaceM);
                }
            });
        });
    };
    /**
     * Resolves all of the fields for this class according to the JVM
     * specification:
     * http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2
     */
    ReferenceClassData.prototype._resolveFields = function () {
        var _this = this;
        if (this.superClass !== null) {
            // Start off w/ my parent class' fields.
            this._objectFields = this._objectFields.concat(this.superClass._objectFields);
            Object.keys(this.superClass._fieldLookup).forEach(function (f) {
                _this._fieldLookup[f] = _this.superClass._fieldLookup[f];
            });
        }
        // Superinterface fields trump superclass fields.
        this.interfaceClasses.forEach(function (iface) {
            Object.keys(iface._fieldLookup).forEach(function (ifaceFieldName) {
                var ifaceF = iface._fieldLookup[ifaceFieldName];
                assert(ifaceF.accessFlags.isStatic(), "Interface fields must be static.");
                _this._fieldLookup[ifaceFieldName] = ifaceF;
            });
        });
        // My fields override all other fields.
        this.fields.forEach(function (f) {
            _this._fieldLookup[f.name] = f;
            if (f.accessFlags.isStatic()) {
                _this._staticFields.push(f);
            }
            else {
                _this._objectFields.push(f);
            }
        });
    };
    /**
     * Looks up a method with the given signature. Returns null if no method
     * found.
     */
    ReferenceClassData.prototype.methodLookup = function (signature) {
        var m = this._methodLookup[signature];
        if (m !== undefined) {
            return m;
        }
        else {
            return null;
        }
    };
    /**
     * Performs method lookup, and includes signature polymorphic results if
     * the method is signature polymorphic.
     */
    ReferenceClassData.prototype.signaturePolymorphicAwareMethodLookup = function (signature) {
        var m;
        if (null !== (m = this.methodLookup(signature))) {
            return m;
        }
        else if (this.className === 'Ljava/lang/invoke/MethodHandle;') {
            // Check if this is a signature polymorphic method.
            // From S2.9:
            // A method is signature polymorphic if and only if all of the following conditions hold :
            // * It is declared in the java.lang.invoke.MethodHandle class.
            // * It has a single formal parameter of type Object[].
            // * It has a return type of Object.
            // * It has the ACC_VARARGS and ACC_NATIVE flags set.
            var polySig = signature.slice(0, signature.indexOf('(')) + "([Ljava/lang/Object;)Ljava/lang/Object;", m = this._methodLookup[polySig];
            if (m !== undefined && m.accessFlags.isNative() && m.accessFlags.isVarArgs() && m.cls === this) {
                return m;
            }
        }
        else if (this.superClass !== null) {
            return this.superClass.signaturePolymorphicAwareMethodLookup(signature);
        }
        return null;
    };
    /**
     * Looks up a field with the given name. Returns null if no method found.
     */
    ReferenceClassData.prototype.fieldLookup = function (name) {
        var f = this._fieldLookup[name];
        if (f !== undefined) {
            return f;
        }
        else {
            return null;
        }
    };
    ReferenceClassData.prototype.getAttribute = function (name) {
        var attrs = this.attrs;
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            if (attr.getName() === name) {
                return attr;
            }
        }
        return null;
    };
    ReferenceClassData.prototype.getAttributes = function (name) {
        var attrs = this.attrs;
        var results = [];
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i];
            if (attr.getName() === name) {
                results.push(attr);
            }
        }
        return results;
    };
    /**
     * Get the bootstrap method information for an InvokeDynamic opcode.
     */
    ReferenceClassData.prototype.getBootstrapMethod = function (idx) {
        var bms = this.getAttribute('BootstrapMethods');
        return bms.bootstrapMethods[idx];
    };
    /**
     * Returns the initial value for a given static field in the class. Should
     * only be called when the constructor is created.
     */
    ReferenceClassData.prototype._getInitialStaticFieldValue = function (thread, name) {
        var f = this.fieldLookup(name);
        if (f !== null && f.accessFlags.isStatic()) {
            var cva = f.getAttribute('ConstantValue');
            if (cva !== null) {
                switch (cva.value.getType()) {
                    case enums.ConstantPoolItemType.STRING:
                        var stringCPI = cva.value;
                        if (stringCPI.value === null) {
                            stringCPI.value = thread.getJVM().internString(stringCPI.stringValue);
                        }
                        return stringCPI.value;
                    default:
                        // TODO: Type better.
                        return cva.value.value;
                }
            }
            else {
                return util.initialValue(f.rawDescriptor);
            }
        }
        assert(false, "Tried to construct a static field value that " + (f !== null ? "isn't static" : "doesn't exist") + ": " + (f !== null ? f.cls.getInternalName() : this.getInternalName()) + " " + name);
    };
    ReferenceClassData.prototype.setResolved = function (superClazz, interfaceClazzes) {
        this.superClass = superClazz;
        
        this.interfaceClasses = interfaceClazzes;
        // TODO: Assert we are not already resolved or initialized?
        this._resolveMethods();
        this._resolveFields();
        this.setState(ClassState.RESOLVED);
    };
    ReferenceClassData.prototype.tryToResolve = function () {
        if (this.getState() === ClassState.LOADED) {
            // Need to grab the super class, and interfaces.
            var loader = this.loader, toResolve = this.superClassRef !== null ? this.interfaceRefs.concat(this.superClassRef) : this.interfaceRefs, allGood = true, resolvedItems = [], i, item;
            for (i = 0; i < toResolve.length; i++) {
                item = toResolve[i];
                if (item.tryResolve(loader)) {
                    resolvedItems.push(item.cls);
                }
                else {
                    return false;
                }
            }
            // It worked!
            this.setResolved(this.superClassRef !== null ? resolvedItems.pop() : null, resolvedItems);
        }
        return true;
    };
    /**
     * Attempt to synchronously initialize. This is possible if there is no
     * static initializer, and the parent classes are properly initialized.
     */
    ReferenceClassData.prototype.tryToInitialize = function () {
        if (this.getState() === ClassState.INITIALIZED) {
            // Already initialized.
            return true;
        }
        if (this.getState() === ClassState.RESOLVED || this.tryToResolve()) {
            // Ensure parent is initialized.
            if (this.superClass !== null && !this.superClass.tryToInitialize()) {
                // Parent failed to initialize.
                return false;
            }
            // Check if this class has a static initializer.
            var clinit = this.getMethod('<clinit>()V');
            if (clinit !== null) {
                // Nope; this class needs to do the full initialization song-and-dance.
                return false;
            }
            else {
                // No static initializer! This class is initialized!
                this.setState(ClassState.INITIALIZED);
                return true;
            }
        }
        // This class is not resolved.
        return false;
    };
    /**
     * Returns a boolean indicating if this class is an instance of the target class.
     * "target" is a ClassData object.
     * The ClassData objects do not need to be initialized; just loaded.
     * See §2.6.7 for casting rules.
     * @todo Determine this statically to make this a constant time operation.
     */
    ReferenceClassData.prototype.isCastable = function (target) {
        if (!(target instanceof ReferenceClassData)) {
            return false;
        }
        if (this.accessFlags.isInterface()) {
            // We are both interfaces
            if (target.accessFlags.isInterface()) {
                return this.isSubinterface(target);
            }
            // Only I am an interface
            if (!target.accessFlags.isInterface()) {
                return target.getInternalName() === 'Ljava/lang/Object;';
            }
        }
        else {
            // I am a regular class, target is an interface
            if (target.accessFlags.isInterface()) {
                return this.isSubinterface(target);
            }
            // We are both regular classes
            return this.isSubclass(target);
        }
    };
    /**
     * Returns 'true' if I implement the target interface.
     */
    ReferenceClassData.prototype.isSubinterface = function (target) {
        if (this.className === target.getInternalName()) {
            return true;
        }
        var ifaces = this.getInterfaces();
        for (var i = 0; i < ifaces.length; i++) {
            var superIface = ifaces[i];
            if (superIface.isSubinterface(target)) {
                return true;
            }
        }
        if (this.getSuperClass() == null) {
            return false;
        }
        return this.getSuperClass().isSubinterface(target);
    };
    /**
     * Asynchronously *initializes* the class and its super classes.
     * Throws a Java exception on the thread if initialization fails.
     * @param thread The thread that is performing the initialization.
     * @param cb Callback to invoke when completed. Contains a reference to the
     *   class if it succeeds, or NULL if a failure occurs.
     * @param [explicit] Defaults to true. If true, this class is being
     *   *explicitly* initialized by a user. If false, the JVM is implicitly
     *   initializing the class.
     */
    ReferenceClassData.prototype.initialize = function (thread, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        if (this.isResolved()) {
            if (this.isInitialized(thread)) {
                // Nothing to do! Either resolution failed and an exception has already
                // been thrown, cdata is already initialized, or the current thread is
                // initializing the class.
                setImmediate(function () {
                    cb(_this);
                });
            }
            else if (this.initLock.tryLock(thread, cb)) {
                // Initialize the super class, and then this class.
                if (this.superClass != null) {
                    this.superClass.initialize(thread, function (cdata) {
                        if (cdata == null) {
                            // Nothing to do. Initializing the super class failed.
                            _this.initLock.unlock(null);
                        }
                        else {
                            // Initialize myself.
                            _this._initialize(thread, function (cdata) {
                                _this.initLock.unlock(cdata);
                            });
                        }
                    }, explicit);
                }
                else {
                    // java/lang/Object's parent is NULL.
                    // Continue initializing this class.
                    this._initialize(thread, function (cdata) {
                        _this.initLock.unlock(cdata);
                    });
                }
            }
        }
        else {
            // Resolve first, then initialize.
            this.resolve(thread, function (cdata) {
                if (cdata !== null) {
                    _this.initialize(thread, cb, explicit);
                }
                else {
                    // Else: An exception was thrown.
                    cb(cdata);
                }
            }, explicit);
        }
    };
    /**
     * Helper function. Initializes this class alone. Assumes super class is
     * already initialized.
     */
    ReferenceClassData.prototype._initialize = function (thread, cb) {
        var _this = this;
        var cons = this.getConstructor(thread);
        if (cons['<clinit>()V'] !== undefined) {
            
            cons['<clinit>()V'](thread, null, function (e) {
                if (e) {
                    
                    _this.setState(enums.ClassState.RESOLVED);
                    /**
                     * "The class or interface initialization method must have completed
                     *  abruptly by throwing some exception E. If the class of E is not
                     *  Error or one of its subclasses, then create a new instance of the
                     *  class ExceptionInInitializerError with E as the argument, and use
                     *  this object in place of E."
                     * @url http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5
                     */
                    if (e.getClass().isCastable(thread.getBsCl().getResolvedClass('Ljava/lang/Error;'))) {
                        // 'e' is 'Error or one of its subclasses'.
                        thread.throwException(e);
                        cb(null);
                    }
                    else {
                        // Wrap the error.
                        thread.getBsCl().initializeClass(thread, 'Ljava/lang/ExceptionInInitializerError;', function (cdata) {
                            if (cdata == null) {
                                // Exceptional failure right here: *We failed to construct ExceptionInInitializerError*!
                                // initializeClass will throw an exception on our behalf;
                                // nothing to do.
                                cb(null);
                            }
                            else {
                                // Construct the object!
                                var eCons = cdata.getConstructor(thread), e2 = new eCons(thread);
                                // Construct the ExceptionInInitializerError!
                                e2["<init>(Ljava/lang/Throwable;)V"](thread, [e], function (e) {
                                    // Throw the newly-constructed error!
                                    thread.throwException(e2);
                                    cb(null);
                                });
                            }
                        });
                    }
                }
                else {
                    _this.setState(enums.ClassState.INITIALIZED);
                    
                    // Normal case! Initialization succeeded.
                    cb(_this);
                }
            });
        }
        else {
            // Class doesn't have a static initializer.
            this.setState(enums.ClassState.INITIALIZED);
            cb(this);
        }
    };
    /**
     * A reference class can be treated as initialized in a thread if that thread
     * is in the process of initializing it.
     */
    ReferenceClassData.prototype.isInitialized = function (thread) {
        return this.getState() === ClassState.INITIALIZED || this.initLock.getOwner() === thread;
    };
    /**
     * Resolve the class.
     */
    ReferenceClassData.prototype.resolve = function (thread, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        var toResolve = this.interfaceRefs.slice(0);
        if (this.superClassRef !== null) {
            toResolve.push(this.superClassRef);
        }
        toResolve = toResolve.filter(function (item) { return !item.isResolved(); });
        util.asyncForEach(toResolve, function (clsRef, nextItem) {
            clsRef.resolve(thread, _this.loader, _this, function (status) {
                if (!status) {
                    nextItem("Failed.");
                }
                else {
                    nextItem();
                }
            }, explicit);
        }, function (err) {
            if (!err) {
                _this.setResolved(_this.superClassRef !== null ? _this.superClassRef.cls : null, _this.interfaceRefs.map(function (ref) { return ref.cls; }));
                cb(_this);
            }
            else {
                cb(null);
            }
        });
    };
    /**
     * Find Miranda and default interface methods in this class. These
     * methods manifest as new vmindices in the virtual method table compared with
     * the superclass, and are not defined in this class itself.
     */
    ReferenceClassData.prototype.getMirandaAndDefaultMethods = function () {
        var _this = this;
        var superClsMethodTable = this.superClass !== null ? this.superClass.getVMTable() : [];
        return this.getVMTable().slice(superClsMethodTable.length).filter(function (method) { return method.cls !== _this; });
    };
    ReferenceClassData.prototype.outputInjectedFields = function (outputStream) {
        if (this.superClass !== null) {
            this.superClass.outputInjectedFields(outputStream);
        }
        var injected = injectedFields[this.getInternalName()];
        if (injected !== undefined) {
            Object.keys(injected).forEach(function (fieldName) {
                outputStream.write("this." + fieldName + " = " + injected[fieldName][1] + ";\n");
            });
        }
    };
    ReferenceClassData.prototype._constructConstructor = function (thread) {
        assert(this._constructor === null, "Attempted to construct constructor twice for class " + this.getExternalName() + "!");
        var jsClassName = util.jvmName2JSName(this.getInternalName()), outputStream = new StringOutputStream();
        outputStream.write("function _create(extendClass, cls, InternalStackFrame, NativeStackFrame, BytecodeStackFrame, gLongZero, ClassLoader, Monitor, thread) {\n  if (cls.superClass !== null) {\n    extendClass(" + jsClassName + ", cls.superClass.getConstructor(thread));\n  }\n  function " + jsClassName + "(thread) {\n");
        // Injected fields.
        this.outputInjectedFields(outputStream);
        // Output instance field assignments.
        this._objectFields.forEach(function (f) { return f.outputJavaScriptField(jsClassName, outputStream); });
        outputStream.write("  }\n  " + jsClassName + ".cls = cls;\n");
        // Injected methods.
        this.outputInjectedMethods(jsClassName, outputStream);
        // Static fields.
        this._staticFields.forEach(function (f) { return f.outputJavaScriptField(jsClassName, outputStream); });
        // Static and instance methods.
        this.getMethods().forEach(function (m) { return m.outputJavaScriptFunction(jsClassName, outputStream); });
        // Miranda and default interface methods.
        this.getMirandaAndDefaultMethods().forEach(function (m) { return m.outputJavaScriptFunction(jsClassName, outputStream); });
        // Uninherited default methods.
        this.getUninheritedDefaultMethods().forEach(function (m) { return m.outputJavaScriptFunction(jsClassName, outputStream, true); });
        outputStream.write("  return " + jsClassName + ";\n}\n_create");
        var evalText = outputStream.flush();
        // NOTE: Thread will be null during system bootstrapping.
        if (typeof RELEASE === 'undefined' && thread !== null && thread.getJVM().shouldDumpCompiledCode()) {
            thread.getJVM().dumpObjectDefinition(this, evalText);
        }
        return eval(evalText)(extendClass, this, threading_1.InternalStackFrame, threading_1.NativeStackFrame, threading_1.BytecodeStackFrame, gLong.ZERO, _dereq_('./ClassLoader'), _dereq_('./Monitor'), thread);
    };
    ReferenceClassData.prototype.getConstructor = function (thread) {
        if (this._constructor == null) {
            assert(this.isResolved(), "Cannot construct " + this.getInternalName() + "'s constructor until it is resolved.");
            this._constructor = this._constructConstructor(thread);
        }
        return this._constructor;
    };
    return ReferenceClassData;
})(ClassData);
exports.ReferenceClassData = ReferenceClassData;

},{"./ByteStream":15,"./ClassLoader":18,"./ClassLock":19,"./ConstantPool":20,"./Monitor":22,"./StringOutputStream":24,"./assert":26,"./attributes":27,"./enums":31,"./gLong":32,"./global":33,"./logging":39,"./methods":40,"./threading":45,"./util":47}],17:[function(_dereq_,module,exports){
/**
 * Aggregates .class file-related APIs under a single interface (Doppio.VM.ClassFile)
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var ConstantPool = _dereq_('./ConstantPool');
exports.ConstantPool = ConstantPool;
var Attributes = _dereq_('./attributes');
exports.Attributes = Attributes;
__export(_dereq_('./ClassData'));
__export(_dereq_('./methods'));
__export(_dereq_('./ClassLoader'));
__export(_dereq_('./classpath'));

},{"./ClassData":16,"./ClassLoader":18,"./ConstantPool":20,"./attributes":27,"./classpath":28,"./methods":40}],18:[function(_dereq_,module,exports){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ClassData_1 = _dereq_('./ClassData');
var ClassLock = _dereq_('./ClassLock');
var classpath_1 = _dereq_('./classpath');
var enums_1 = _dereq_('./enums');
var util = _dereq_('./util');
var logging = _dereq_('./logging');
var assert = _dereq_('./assert');
var debug = logging.debug;
/**
 * Used to lock classes for loading.
 */
var ClassLocks = (function () {
    function ClassLocks() {
        /**
         * typrStr => array of callbacks to trigger when operation completes.
         */
        this.locks = {};
    }
    /**
     * Checks if the lock for the given class is already taken. If not, it takes
     * the lock. If it is taken, we enqueue the callback.
     * NOTE: For convenience, will handle triggering the owner's callback as well.
     */
    ClassLocks.prototype.tryLock = function (typeStr, thread, cb) {
        if (typeof this.locks[typeStr] === 'undefined') {
            this.locks[typeStr] = new ClassLock();
        }
        return this.locks[typeStr].tryLock(thread, cb);
    };
    /**
     * Releases the lock on the given string.
     */
    ClassLocks.prototype.unlock = function (typeStr, cdata) {
        this.locks[typeStr].unlock(cdata);
        // No need for this lock to remain.
        delete this.locks[typeStr];
    };
    /**
     * Returns the owning thread of a given lock. Returns null if the specified
     * type string is not locked.
     */
    ClassLocks.prototype.getOwner = function (typeStr) {
        if (this.locks[typeStr]) {
            return this.locks[typeStr].getOwner();
        }
        return null;
    };
    return ClassLocks;
})();
/**
 * Base classloader class. Contains common class resolution and instantiation
 * logic.
 */
var ClassLoader = (function () {
    /**
     * @param bootstrap The JVM's bootstrap classloader. ClassLoaders use it
     *   to retrieve primitive types.
     */
    function ClassLoader(bootstrap) {
        this.bootstrap = bootstrap;
        /**
         * Stores loaded *reference* and *array* classes.
         */
        this.loadedClasses = {};
        /**
         * Stores callbacks that are waiting for another thread to finish loading
         * the specified class.
         */
        this.loadClassLocks = new ClassLocks();
    }
    /**
     * Retrieve a listing of classes that are loaded in this class loader.
     */
    ClassLoader.prototype.getLoadedClassNames = function () {
        return Object.keys(this.loadedClasses);
    };
    /**
     * Adds the specified class to the classloader. As opposed to defineClass,
     * which defines a new class from bytes with the classloader.
     *
     * What's the difference?
     * * Classes created with defineClass are defined by this classloader.
     * * Classes added with addClass may have been defined by a different
     *   classloader. This happens when a custom class loader's loadClass
     *   function proxies classloading to a different classloader.
     *
     * @param typeStr The type string of the class.
     * @param classData The class data object representing the class.
     */
    ClassLoader.prototype.addClass = function (typeStr, classData) {
        // If the class is already added, ensure it is the same class we are adding again.
        assert(this.loadedClasses[typeStr] != null ? this.loadedClasses[typeStr] === classData : true);
        this.loadedClasses[typeStr] = classData;
    };
    /**
     * No-frills. Get the class if it's defined in the class loader, no matter
     * what shape it is in.
     *
     * Should only be used internally by ClassLoader subclasses.
     */
    ClassLoader.prototype.getClass = function (typeStr) {
        return this.loadedClasses[typeStr];
    };
    /**
     * Defines a new class with the class loader from an array of bytes.
     * @param thread The thread that is currently in control when this class is
     *   being defined. An exception may be thrown if there is an issue parsing
     *   the class file.
     * @param typeStr The type string of the class (e.g. "Ljava/lang/Object;")
     * @param data The data associated with the class as a binary blob.
     * @param protectionDomain The protection domain for the class (can be NULL).
     * @return The defined class, or null if there was an issue.
     */
    ClassLoader.prototype.defineClass = function (thread, typeStr, data, protectionDomain) {
        try {
            var classData = new ClassData_1.ReferenceClassData(data, protectionDomain, this);
            this.addClass(typeStr, classData);
            if (this instanceof BootstrapClassLoader) {
                
            }
            else {
                
            }
            return classData;
        }
        catch (e) {
            if (thread === null) {
                // This will only happen when we're loading java/lang/Thread for
                // the very first time.
                logging.error("JVM initialization failed: " + e);
                logging.error(e.stack);
            }
            else {
                thread.throwNewException('Ljava/lang/ClassFormatError;', e);
            }
            return null;
        }
    };
    /**
     * Defines a new array class with this loader.
     */
    ClassLoader.prototype.defineArrayClass = function (typeStr) {
        assert(this.getLoadedClass(util.get_component_type(typeStr)) != null);
        var arrayClass = new ClassData_1.ArrayClassData(util.get_component_type(typeStr), this);
        this.addClass(typeStr, arrayClass);
        return arrayClass;
    };
    /**
     * Attempts to retrieve the given loaded class.
     * @param typeStr The name of the class.
     * @return Returns the loaded class, or null if no such class is currently
     *   loaded.
     */
    ClassLoader.prototype.getLoadedClass = function (typeStr) {
        var cls = this.loadedClasses[typeStr];
        if (cls != null) {
            return cls;
        }
        else {
            if (util.is_primitive_type(typeStr)) {
                // Primitive classes must be fetched from the bootstrap classloader.
                return this.bootstrap.getPrimitiveClass(typeStr);
            }
            else if (util.is_array_type(typeStr)) {
                // We might be able to load this array class synchronously.
                // Component class must be loaded. And we must define the array class
                // with the component class's loader.
                var component = this.getLoadedClass(util.get_component_type(typeStr));
                if (component != null) {
                    var componentCl = component.getLoader();
                    if (componentCl === this) {
                        // We're responsible for defining the array class.
                        return this.defineArrayClass(typeStr);
                    }
                    else {
                        // Delegate to the other loader, then add the class to our loaded
                        // roster.
                        cls = componentCl.getLoadedClass(typeStr);
                        this.addClass(typeStr, cls);
                        return cls;
                    }
                }
            }
            return null;
        }
    };
    /**
     * Attempts to retrieve the given resolved class.
     * @param typeStr The name of the class.
     * @return Returns the class if it is both loaded and resolved. Returns null
     *   if this is not the case.
     */
    ClassLoader.prototype.getResolvedClass = function (typeStr) {
        var cls = this.getLoadedClass(typeStr);
        if (cls !== null) {
            if (cls.isResolved() || cls.tryToResolve()) {
                return cls;
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    };
    /**
     * Attempts to retrieve the given initialized class.
     * @param typeStr The name of the class.
     * @return Returns the class if it is initialized. Returns null if this is
     *   not the case.
     */
    ClassLoader.prototype.getInitializedClass = function (thread, typeStr) {
        var cls = this.getLoadedClass(typeStr);
        if (cls !== null) {
            if (cls.isInitialized(thread) || cls.tryToInitialize()) {
                return cls;
            }
            else {
                return null;
            }
        }
        else {
            return cls;
        }
    };
    /**
     * Asynchronously loads the given class.
     */
    ClassLoader.prototype.loadClass = function (thread, typeStr, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        // See if we can grab this synchronously first.
        var cdata = this.getLoadedClass(typeStr);
        if (cdata) {
            setImmediate(function () {
                cb(cdata);
            });
        }
        else {
            // Check the loadClass lock for this class.
            if (this.loadClassLocks.tryLock(typeStr, thread, cb)) {
                // Async it is!
                if (util.is_reference_type(typeStr)) {
                    this._loadClass(thread, typeStr, function (cdata) {
                        _this.loadClassLocks.unlock(typeStr, cdata);
                    }, explicit);
                }
                else {
                    // Array
                    this.loadClass(thread, util.get_component_type(typeStr), function (cdata) {
                        if (cdata != null) {
                            // Synchronously will work now.
                            _this.loadClassLocks.unlock(typeStr, _this.getLoadedClass(typeStr));
                        }
                    }, explicit);
                }
            }
        }
    };
    /**
     * Convenience function: Resolve many classes. Calls cb with null should
     * an error occur.
     */
    ClassLoader.prototype.resolveClasses = function (thread, typeStrs, cb) {
        var _this = this;
        var classes = {};
        util.asyncForEach(typeStrs, function (typeStr, next_item) {
            _this.resolveClass(thread, typeStr, function (cdata) {
                if (cdata === null) {
                    next_item("Error resolving class: " + typeStr);
                }
                else {
                    classes[typeStr] = cdata;
                    next_item();
                }
            });
        }, function (err) {
            if (err) {
                cb(null);
            }
            else {
                cb(classes);
            }
        });
    };
    /**
     * Asynchronously *resolves* the given class by loading the class and
     * resolving its super class, interfaces, and/or component classes.
     */
    ClassLoader.prototype.resolveClass = function (thread, typeStr, cb, explicit) {
        if (explicit === void 0) { explicit = true; }
        this.loadClass(thread, typeStr, function (cdata) {
            if (cdata === null || cdata.isResolved()) {
                // Nothing to do! Either cdata is null, an exception triggered, and we
                // failed, or cdata is already resolved.
                setImmediate(function () { cb(cdata); });
            }
            else {
                cdata.resolve(thread, cb, explicit);
            }
        }, explicit);
    };
    /**
     * Asynchronously *initializes* the given class and its super classes.
     */
    ClassLoader.prototype.initializeClass = function (thread, typeStr, cb, explicit) {
        if (explicit === void 0) { explicit = true; }
        // Get the resolved class.
        this.resolveClass(thread, typeStr, function (cdata) {
            if (cdata === null || cdata.isInitialized(thread)) {
                // Nothing to do! Either resolution failed and an exception has already
                // been thrown, cdata is already initialized, or the current thread is
                // initializing the class.
                setImmediate(function () {
                    cb(cdata);
                });
            }
            else {
                assert(util.is_reference_type(typeStr));
                cdata.initialize(thread, cb, explicit);
            }
        }, explicit);
    };
    /**
     * Throws the appropriate exception/error for a class not being found.
     * If loading was implicitly triggered by the JVM, we call NoClassDefFoundError.
     * If the program explicitly called loadClass, then we throw the ClassNotFoundException.
     */
    ClassLoader.prototype.throwClassNotFoundException = function (thread, typeStr, explicit) {
        thread.throwNewException(explicit ? 'Ljava/lang/ClassNotFoundException;' : 'Ljava/lang/NoClassDefFoundError;', "Cannot load class: " + util.ext_classname(typeStr));
    };
    return ClassLoader;
})();
exports.ClassLoader = ClassLoader;
/**
 * The JVM's bootstrap class loader. Loads classes directly from files on the
 * file system.
 */
var BootstrapClassLoader = (function (_super) {
    __extends(BootstrapClassLoader, _super);
    /**
     * Constructs the bootstrap classloader with the given classpath.
     * @param classPath The classpath, where the *first* item is the *last*
     *   classpath searched. Meaning, the classPath[0] should be the bootstrap
     *   class path.
     * @param extractionPath The path where jar files should be extracted.
     * @param cb Called once all of the classpath items have been checked.
     *   Passes an error if one occurs.
     */
    function BootstrapClassLoader(javaHome, classpath, cb) {
        var _this = this;
        // The correct way to do this would be super(this), but we cannot reference this before calling super()
        _super.call(this, null);
        this.bootstrap = this;
        this.classpath = null;
        this.loadedPackages = {};
        classpath_1.ClasspathFactory(javaHome, classpath, function (items) {
            _this.classpath = items.reverse();
            cb();
        });
    }
    /**
     * Registers that a given class has successfully been loaded from the specified
     * classpath item.
     */
    BootstrapClassLoader.prototype._registerLoadedClass = function (clsType, cpItem) {
        var pkgName = clsType.slice(0, clsType.lastIndexOf('/')), itemLoader = this.loadedPackages[pkgName];
        if (!itemLoader) {
            this.loadedPackages[pkgName] = [cpItem];
        }
        else if (itemLoader[0] !== cpItem && itemLoader.indexOf(cpItem) === -1) {
            // Common case optimization: Simply check the first array element.
            itemLoader.push(cpItem);
        }
    };
    /**
     * Returns a listing of tuples containing:
     * * The package name (e.g. java/lang)
     * * Classpath locations where classes in the package were loaded.
     */
    BootstrapClassLoader.prototype.getPackages = function () {
        var _this = this;
        return Object.keys(this.loadedPackages).map(function (pkgName) {
            return [pkgName, _this.loadedPackages[pkgName].map(function (item) { return item.getPath(); })];
        });
    };
    /**
     * Retrieves or defines the specified primitive class.
     */
    BootstrapClassLoader.prototype.getPrimitiveClass = function (typeStr) {
        var cdata = this.getClass(typeStr);
        if (cdata == null) {
            cdata = new ClassData_1.PrimitiveClassData(typeStr, this);
            this.addClass(typeStr, cdata);
        }
        return cdata;
    };
    /**
     * Asynchronously load the given class from the classpath.
     *
     * SHOULD ONLY BE INVOKED INTERNALLY BY THE CLASSLOADER.
     */
    BootstrapClassLoader.prototype._loadClass = function (thread, typeStr, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        
        // This method is only valid for reference types!
        assert(util.is_reference_type(typeStr));
        // Search the class path for the class.
        var clsFilePath = util.descriptor2typestr(typeStr), cPathLen = this.classpath.length, toSearch = [], clsData;
        searchLoop: for (var i = 0; i < cPathLen; i++) {
            var item = this.classpath[i];
            switch (item.hasClass(clsFilePath)) {
                case enums_1.TriState.INDETERMINATE:
                    toSearch.push(item);
                    break;
                case enums_1.TriState.TRUE:
                    // Break out of the loop; TRUE paths are guaranteed to have the class.
                    toSearch.push(item);
                    break searchLoop;
            }
        }
        util.asyncFind(toSearch, function (pItem, callback) {
            pItem.loadClass(clsFilePath, function (err, data) {
                if (err) {
                    callback(false);
                }
                else {
                    clsData = data;
                    callback(true);
                }
            });
        }, function (pItem) {
            if (pItem) {
                var cls = _this.defineClass(thread, typeStr, clsData, null);
                if (cls !== null) {
                    _this._registerLoadedClass(clsFilePath, pItem);
                }
                cb(cls);
            }
            else {
                // No such class.
                
                _this.throwClassNotFoundException(thread, typeStr, explicit);
                cb(null);
            }
        });
    };
    /**
     * Returns a listing of reference classes loaded in the bootstrap loader.
     */
    BootstrapClassLoader.prototype.getLoadedClassFiles = function () {
        var loadedClasses = this.getLoadedClassNames();
        return loadedClasses.filter(function (clsName) { return util.is_reference_type(clsName); });
    };
    /**
     * Returns the JVM object corresponding to this ClassLoader.
     * @todo Represent the bootstrap by something other than 'null'.
     * @todo These should be one-in-the-same.
     */
    BootstrapClassLoader.prototype.getLoaderObject = function () {
        return null;
    };
    /**
     * Returns the current classpath.
     */
    BootstrapClassLoader.prototype.getClassPath = function () {
        var cpLen = this.classpath.length, cpStrings = new Array(cpLen);
        for (var i = 0; i < cpLen; i++) {
            // Reverse it so it is the expected order (last item is first search target)
            cpStrings[i] = this.classpath[cpLen - i - 1].getPath();
        }
        return cpStrings;
    };
    /**
     * Returns the classpath item objects in the classpath.
     */
    BootstrapClassLoader.prototype.getClassPathItems = function () {
        return this.classpath.slice(0);
    };
    return BootstrapClassLoader;
})(ClassLoader);
exports.BootstrapClassLoader = BootstrapClassLoader;
/**
 * A Custom ClassLoader. Loads classes by calling loadClass on the user-defined
 * loader.
 */
var CustomClassLoader = (function (_super) {
    __extends(CustomClassLoader, _super);
    function CustomClassLoader(bootstrap, loaderObj) {
        _super.call(this, bootstrap);
        this.loaderObj = loaderObj;
    }
    /**
     * Asynchronously load the given class from the classpath. Calls the
     * classloader's loadClass method.
     *
     * SHOULD ONLY BE INVOKED BY THE CLASS LOADER.
     *
     * @param thread The thread that triggered the loading.
     * @param typeStr The type string of the class.
     * @param cb The callback that will be called with the loaded class. It will
     *   be passed a null if there is an error -- which also indicates that it
     *   threw an exception on the JVM thread.
     * @param explicit 'True' if loadClass was explicitly invoked by the program,
     *   false otherwise. This changes the exception/error that we throw.
     */
    CustomClassLoader.prototype._loadClass = function (thread, typeStr, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        
        // This method is only valid for reference types!
        assert(util.is_reference_type(typeStr));
        // Invoke the custom class loader.
        this.loaderObj['loadClass(Ljava/lang/String;)Ljava/lang/Class;'](thread, [util.initString(this.bootstrap, util.ext_classname(typeStr))], function (e, jco) {
            if (e) {
                // Exception! There was an issue defining the class.
                _this.throwClassNotFoundException(thread, typeStr, explicit);
                cb(null);
            }
            else {
                // Add the class returned by loadClass, in case the classloader
                // proxied loading to another classloader.
                var cls = jco.$cls;
                _this.addClass(typeStr, cls);
                cb(cls);
            }
        });
    };
    /**
     * Returns the JVM object corresponding to this ClassLoader.
     * @todo These should be one-in-the-same.
     */
    CustomClassLoader.prototype.getLoaderObject = function () {
        return this.loaderObj;
    };
    return CustomClassLoader;
})(ClassLoader);
exports.CustomClassLoader = CustomClassLoader;

},{"./ClassData":16,"./ClassLock":19,"./assert":26,"./classpath":28,"./enums":31,"./logging":39,"./util":47}],19:[function(_dereq_,module,exports){
/**
 * A single class lock, used for load/initialization locks.
 */
var ClassLock = (function () {
    function ClassLock() {
        this.queue = [];
    }
    /**
     * Checks if the lock is taken. If so, it enqueues the callback. Otherwise,
     * it takes the lock and returns true.
     */
    ClassLock.prototype.tryLock = function (thread, cb) {
        // We're the owner if the queue was previously empty.
        return this.queue.push({ thread: thread, cb: cb }) === 1;
    };
    /**
     * Releases the lock on the class, and passes the object to all enqueued
     * callbacks.
     */
    ClassLock.prototype.unlock = function (cdata) {
        var i, num = this.queue.length;
        for (i = 0; i < num; i++) {
            this.queue[i].cb(cdata);
        }
        this.queue = [];
    };
    /**
     * Get the owner of this lock.
     */
    ClassLock.prototype.getOwner = function () {
        if (this.queue.length > 0) {
            return this.queue[0].thread;
        }
        return null;
    };
    return ClassLock;
})();
module.exports = ClassLock;

},{}],20:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_('./util');
var enums = _dereq_('./enums');
var assert = _dereq_('./assert');
/**
 * Stores all of the constant pool classes, keyed on their enum value.
 */
var CP_CLASSES = {};
// #region Tier 0
/**
 * Represents a constant UTF-8 string.
 * ```
 * CONSTANT_Utf8_info {
 *   u1 tag;
 *   u2 length;
 *   u1 bytes[length];
 * }
 * ```
 */
var ConstUTF8 = (function () {
    function ConstUTF8(rawBytes) {
        this.value = this.bytes2str(rawBytes);
    }
    /**
     * Parse Java's pseudo-UTF-8 strings into valid UTF-16 codepoints (spec 4.4.7)
     * Note that Java uses UTF-16 internally by default for string representation,
     * and the pseudo-UTF-8 strings are *only* used for serialization purposes.
     * Thus, there is no reason for other parts of the code to call this routine!
     * TODO: To avoid copying, create a character array for this data.
     * http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7
     */
    ConstUTF8.prototype.bytes2str = function (bytes) {
        var y, z, v, w, x, charCode, idx = 0, rv = '';
        while (idx < bytes.length) {
            x = bytes.readUInt8(idx++) & 0xff;
            // While the standard specifies that surrogate pairs should be handled, it seems like
            // they are by default with the three byte format. See parsing code here:
            // http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/file/3623f1b29b58/src/share/classes/java/io/DataInputStream.java#l618
            // One UTF-16 character.
            if (x <= 0x7f) {
                // One character, one byte.
                charCode = x;
            }
            else if (x <= 0xdf) {
                // One character, two bytes.
                y = bytes.readUInt8(idx++);
                charCode = ((x & 0x1f) << 6) + (y & 0x3f);
            }
            else {
                // One character, three bytes.
                y = bytes.readUInt8(idx++);
                z = bytes.readUInt8(idx++);
                charCode = ((x & 0xf) << 12) + ((y & 0x3f) << 6) + (z & 0x3f);
            }
            rv += String.fromCharCode(charCode);
        }
        return rv;
    };
    ConstUTF8.prototype.getType = function () {
        return enums.ConstantPoolItemType.UTF8;
    };
    ConstUTF8.prototype.getConstant = function (thread) { return this.value; };
    ConstUTF8.prototype.isResolved = function () { return true; };
    ConstUTF8.fromBytes = function (byteStream, constantPool) {
        var strlen = byteStream.getUint16();
        return new this(byteStream.read(strlen));
    };
    ConstUTF8.size = 1;
    // Variable-size.
    ConstUTF8.infoByteSize = 0;
    return ConstUTF8;
})();
exports.ConstUTF8 = ConstUTF8;
CP_CLASSES[enums.ConstantPoolItemType.UTF8] = ConstUTF8;
/**
 * Represents a constant 32-bit integer.
 * ```
 * CONSTANT_Integer_info {
 *   u1 tag;
 *   u4 bytes;
 * }
 * ```
 */
var ConstInt32 = (function () {
    function ConstInt32(value) {
        this.value = value;
    }
    ConstInt32.prototype.getType = function () {
        return enums.ConstantPoolItemType.INTEGER;
    };
    ConstInt32.prototype.getConstant = function (thread) { return this.value; };
    ConstInt32.prototype.isResolved = function () { return true; };
    ConstInt32.fromBytes = function (byteStream, constantPool) {
        return new this(byteStream.getInt32());
    };
    ConstInt32.size = 1;
    ConstInt32.infoByteSize = 4;
    return ConstInt32;
})();
exports.ConstInt32 = ConstInt32;
CP_CLASSES[enums.ConstantPoolItemType.INTEGER] = ConstInt32;
/**
 * Represents a constant 32-bit floating point number.
 * ```
 * CONSTANT_Float_info {
 *   u1 tag;
 *   u4 bytes;
 * }
 * ```
 */
var ConstFloat = (function () {
    function ConstFloat(value) {
        this.value = value;
    }
    ConstFloat.prototype.getType = function () {
        return enums.ConstantPoolItemType.FLOAT;
    };
    ConstFloat.prototype.getConstant = function (thread) { return this.value; };
    ConstFloat.prototype.isResolved = function () { return true; };
    ConstFloat.fromBytes = function (byteStream, constantPool) {
        return new this(byteStream.getFloat());
    };
    ConstFloat.size = 1;
    ConstFloat.infoByteSize = 4;
    return ConstFloat;
})();
exports.ConstFloat = ConstFloat;
CP_CLASSES[enums.ConstantPoolItemType.FLOAT] = ConstFloat;
/**
 * Represents a constant 64-bit integer.
 * ```
 * CONSTANT_Long_info {
 *   u1 tag;
 *   u4 high_bytes;
 *   u4 low_bytes;
 * }
 * ```
 */
var ConstLong = (function () {
    function ConstLong(value) {
        this.value = value;
    }
    ConstLong.prototype.getType = function () {
        return enums.ConstantPoolItemType.LONG;
    };
    ConstLong.prototype.getConstant = function (thread) { return this.value; };
    ConstLong.prototype.isResolved = function () { return true; };
    ConstLong.fromBytes = function (byteStream, constantPool) {
        return new this(byteStream.getInt64());
    };
    ConstLong.size = 2;
    ConstLong.infoByteSize = 8;
    return ConstLong;
})();
exports.ConstLong = ConstLong;
CP_CLASSES[enums.ConstantPoolItemType.LONG] = ConstLong;
/**
 * Represents a constant 64-bit floating point number.
 * ```
 * CONSTANT_Double_info {
 *   u1 tag;
 *   u4 high_bytes;
 *   u4 low_bytes;
 * }
 * ```
 */
var ConstDouble = (function () {
    function ConstDouble(value) {
        this.value = value;
    }
    ConstDouble.prototype.getType = function () {
        return enums.ConstantPoolItemType.DOUBLE;
    };
    ConstDouble.prototype.getConstant = function (thread) { return this.value; };
    ConstDouble.prototype.isResolved = function () { return true; };
    ConstDouble.fromBytes = function (byteStream, constantPool) {
        return new this(byteStream.getDouble());
    };
    ConstDouble.size = 2;
    ConstDouble.infoByteSize = 8;
    return ConstDouble;
})();
exports.ConstDouble = ConstDouble;
CP_CLASSES[enums.ConstantPoolItemType.DOUBLE] = ConstDouble;
// #endregion
// #region Tier 1
/**
 * Represents a class or interface.
 * ```
 * CONSTANT_Class_info {
 *   u1 tag;
 *   u2 name_index;
 * }
 * ```
 * @todo Have a classloader-local cache of class reference objects.
 */
var ClassReference = (function () {
    function ClassReference(name) {
        /**
         * The resolved class reference.
         */
        this.cls = null;
        /**
         * The JavaScript constructor for the referenced class.
         */
        this.clsConstructor = null;
        /**
         * The array class for the resolved class reference.
         */
        this.arrayClass = null;
        /**
         * The JavaScript constructor for the array class.
         */
        this.arrayClassConstructor = null;
        this.name = name;
    }
    /**
     * Attempt to synchronously resolve.
     */
    ClassReference.prototype.tryResolve = function (loader) {
        if (this.cls === null) {
            this.cls = loader.getResolvedClass(this.name);
        }
        return this.cls !== null;
    };
    /**
     * Resolves the class reference by resolving the class. Does not run
     * class initialization.
     */
    ClassReference.prototype.resolve = function (thread, loader, caller, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        // Because of Java 8 anonymous classes, THIS CHECK IS REQUIRED FOR CORRECTNESS.
        // (ClassLoaders do not know about anonymous classes, hence they are
        //  'anonymous')
        // (Anonymous classes are an 'Unsafe' feature, and are not part of the standard,
        //  but they are employed for lambdas and such.)
        // NOTE: Thread is 'null' during JVM bootstrapping.
        if (thread !== null) {
            var currentMethod = thread.currentMethod();
            // The stack might be empty during resolution, which occurs during JVM bootup.
            if (currentMethod !== null && this.name === currentMethod.cls.getInternalName()) {
                this.setResolved(thread, thread.currentMethod().cls);
                return cb(true);
            }
        }
        loader.resolveClass(thread, this.name, function (cdata) {
            _this.setResolved(thread, cdata);
            cb(cdata !== null);
        }, explicit);
    };
    ClassReference.prototype.setResolved = function (thread, cls) {
        this.cls = cls;
        if (cls !== null) {
            this.clsConstructor = cls.getConstructor(thread);
        }
    };
    ClassReference.prototype.getType = function () {
        return enums.ConstantPoolItemType.CLASS;
    };
    ClassReference.prototype.getConstant = function (thread) { return this.cls.getClassObject(thread); };
    ClassReference.prototype.isResolved = function () { return this.cls !== null; };
    ClassReference.fromBytes = function (byteStream, constantPool) {
        var nameIndex = byteStream.getUint16(), cpItem = constantPool.get(nameIndex);
        assert(cpItem.getType() === enums.ConstantPoolItemType.UTF8, 'ConstantPool ClassReference type != UTF8');
        // The ConstantPool stores class names without the L...; descriptor stuff
        return new this(util.typestr2descriptor(cpItem.value));
    };
    ClassReference.size = 1;
    ClassReference.infoByteSize = 2;
    return ClassReference;
})();
exports.ClassReference = ClassReference;
CP_CLASSES[enums.ConstantPoolItemType.CLASS] = ClassReference;
/**
 * Represents a field or method without indicating which class or interface
 * type it belongs to.
 * ```
 * CONSTANT_NameAndType_info {
 *   u1 tag;
 *   u2 name_index;
 *   u2 descriptor_index;
 * }
 * ```
 */
var NameAndTypeInfo = (function () {
    function NameAndTypeInfo(name, descriptor) {
        this.name = name;
        this.descriptor = descriptor;
    }
    NameAndTypeInfo.prototype.getType = function () {
        return enums.ConstantPoolItemType.NAME_AND_TYPE;
    };
    NameAndTypeInfo.prototype.isResolved = function () { return true; };
    NameAndTypeInfo.fromBytes = function (byteStream, constantPool) {
        var nameIndex = byteStream.getUint16(), descriptorIndex = byteStream.getUint16(), nameConst = constantPool.get(nameIndex), descriptorConst = constantPool.get(descriptorIndex);
        assert(nameConst.getType() === enums.ConstantPoolItemType.UTF8 &&
            descriptorConst.getType() === enums.ConstantPoolItemType.UTF8, 'ConstantPool NameAndTypeInfo types != UTF8');
        return new this(nameConst.value, descriptorConst.value);
    };
    NameAndTypeInfo.size = 1;
    NameAndTypeInfo.infoByteSize = 4;
    return NameAndTypeInfo;
})();
exports.NameAndTypeInfo = NameAndTypeInfo;
CP_CLASSES[enums.ConstantPoolItemType.NAME_AND_TYPE] = NameAndTypeInfo;
/**
 * Represents constant objects of the type java.lang.String.
 * ```
 * CONSTANT_String_info {
 *   u1 tag;
 *   u2 string_index;
 * }
 * ```
 */
var ConstString = (function () {
    function ConstString(stringValue) {
        this.value = null;
        this.stringValue = stringValue;
    }
    ConstString.prototype.getType = function () {
        return enums.ConstantPoolItemType.STRING;
    };
    ConstString.prototype.resolve = function (thread, loader, caller, cb) {
        this.value = thread.getJVM().internString(this.stringValue);
        setImmediate(function () { return cb(true); });
    };
    ConstString.prototype.getConstant = function (thread) { return this.value; };
    ConstString.prototype.isResolved = function () { return this.value !== null; };
    ConstString.fromBytes = function (byteStream, constantPool) {
        var stringIndex = byteStream.getUint16(), utf8Info = constantPool.get(stringIndex);
        assert(utf8Info.getType() === enums.ConstantPoolItemType.UTF8, 'ConstantPool ConstString type != UTF8');
        return new this(utf8Info.value);
    };
    ConstString.size = 1;
    ConstString.infoByteSize = 2;
    return ConstString;
})();
exports.ConstString = ConstString;
CP_CLASSES[enums.ConstantPoolItemType.STRING] = ConstString;
/**
 * Represents a given method type.
 * ```
 * CONSTANT_MethodType_info {
 *   u1 tag;
 *   u2 descriptor_index;
 * }
 * ```
 */
var MethodType = (function () {
    function MethodType(descriptor) {
        this.methodType = null;
        this.descriptor = descriptor;
    }
    MethodType.prototype.resolve = function (thread, cl, caller, cb) {
        var _this = this;
        util.createMethodType(thread, cl, this.descriptor, function (e, type) {
            if (e) {
                thread.throwException(e);
                cb(false);
            }
            else {
                _this.methodType = type;
                cb(true);
            }
        });
    };
    MethodType.prototype.getConstant = function (thread) { return this.methodType; };
    MethodType.prototype.getType = function () {
        return enums.ConstantPoolItemType.METHOD_TYPE;
    };
    MethodType.prototype.isResolved = function () { return this.methodType !== null; };
    MethodType.fromBytes = function (byteStream, constantPool) {
        var descriptorIndex = byteStream.getUint16(), utf8Info = constantPool.get(descriptorIndex);
        assert(utf8Info.getType() === enums.ConstantPoolItemType.UTF8, 'ConstantPool MethodType type != UTF8');
        return new this(utf8Info.value);
    };
    MethodType.size = 1;
    MethodType.infoByteSize = 2;
    return MethodType;
})();
exports.MethodType = MethodType;
CP_CLASSES[enums.ConstantPoolItemType.METHOD_TYPE] = MethodType;
// #endregion
// #region Tier 2
/**
 * Represents a particular method.
 * ```
 * CONSTANT_Methodref_info {
 *   u1 tag;
 *   u2 class_index;
 *   u2 name_and_type_index;
 * }
 * ```
 */
var MethodReference = (function () {
    function MethodReference(classInfo, nameAndTypeInfo) {
        this.method = null;
        /**
         * The signature of the method, including the owning class.
         * e.g. bar/Baz/foo(IJ)V
         */
        this.fullSignature = null;
        this.paramWordSize = -1;
        /**
         * Contains a reference to the MemberName object for the method that invokes
         * the desired function.
         */
        this.memberName = null;
        /**
         * Contains an object that needs to be pushed onto the stack before invoking
         * memberName.
         */
        this.appendix = null;
        /**
         * The JavaScript constructor for the class that the method belongs to.
         */
        this.jsConstructor = null;
        this.classInfo = classInfo;
        this.nameAndTypeInfo = nameAndTypeInfo;
        this.signature = this.nameAndTypeInfo.name + this.nameAndTypeInfo.descriptor;
    }
    MethodReference.prototype.getType = function () {
        return enums.ConstantPoolItemType.METHODREF;
    };
    /**
     * Checks the method referenced by this constant pool item in the specified
     * bytecode context.
     * Returns null if an error occurs.
     * - Throws a NoSuchFieldError if missing.
     * - Throws an IllegalAccessError if field is inaccessible.
     * - Throws an IncompatibleClassChangeError if the field is an incorrect type
     *   for the field access.
     */
    MethodReference.prototype.hasAccess = function (thread, frame, isStatic) {
        var method = this.method, accessingCls = frame.method.cls;
        if (method.accessFlags.isStatic() !== isStatic) {
            thread.throwNewException('Ljava/lang/IncompatibleClassChangeError;', "Method " + method.name + " from class " + method.cls.getExternalName() + " is " + (isStatic ? 'not ' : '') + "static.");
            frame.returnToThreadLoop = true;
            return false;
        }
        else if (!util.checkAccess(accessingCls, method.cls, method.accessFlags)) {
            thread.throwNewException('Ljava/lang/IllegalAccessError;', accessingCls.getExternalName() + " cannot access " + method.cls.getExternalName() + "." + method.name);
            frame.returnToThreadLoop = true;
            return false;
        }
        return true;
    };
    MethodReference.prototype.resolveMemberName = function (method, thread, cl, caller, cb) {
        var _this = this;
        var memberHandleNatives = thread.getBsCl().getInitializedClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;').getConstructor(thread), appendix = new (thread.getBsCl().getInitializedClass(thread, '[Ljava/lang/Object;').getConstructor(thread))(thread, 1);
        util.createMethodType(thread, cl, this.nameAndTypeInfo.descriptor, function (e, type) {
            if (e) {
                thread.throwException(e);
                cb(false);
            }
            else {
                /* MemberName linkMethod( int refKind, Class<?> defc,
                   String name, Object type,
                   Object[] appendixResult) */
                memberHandleNatives['java/lang/invoke/MethodHandleNatives/linkMethod(Ljava/lang/Class;ILjava/lang/Class;Ljava/lang/String;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/invoke/MemberName;'](thread, 
                // Class callerClass
                [caller.getClassObject(thread),
                    // int refKind
                    enums.MethodHandleReferenceKind.INVOKEVIRTUAL,
                    // Class defc
                    _this.classInfo.cls.getClassObject(thread),
                    // String name
                    thread.getJVM().internString(_this.nameAndTypeInfo.name),
                    // Object type, Object[] appendixResult
                    type, appendix], function (e, rv) {
                    if (e !== null) {
                        thread.throwException(e);
                        cb(false);
                    }
                    else {
                        _this.appendix = appendix.array[0];
                        _this.memberName = rv;
                        cb(true);
                    }
                });
            }
        });
    };
    MethodReference.prototype.resolve = function (thread, loader, caller, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        if (!this.classInfo.isResolved()) {
            this.classInfo.resolve(thread, loader, caller, function (status) {
                if (!status) {
                    cb(false);
                }
                else {
                    _this.resolve(thread, loader, caller, cb, explicit);
                }
            }, explicit);
        }
        else {
            var cls = this.classInfo.cls, method = cls.methodLookup(this.signature);
            if (method === null) {
                if (util.is_reference_type(cls.getInternalName())) {
                    // Signature polymorphic lookup.
                    method = cls.signaturePolymorphicAwareMethodLookup(this.signature);
                    if (method !== null && (method.name === 'invoke' || method.name === 'invokeExact')) {
                        // In order to completely resolve the signature polymorphic function,
                        // we need to resolve its MemberName object and Appendix.
                        return this.resolveMemberName(method, thread, loader, caller, function (status) {
                            if (status === true) {
                                _this.setResolved(thread, method);
                            }
                            else {
                                thread.throwNewException('Ljava/lang/NoSuchMethodError;', "Method " + _this.signature + " does not exist in class " + _this.classInfo.cls.getExternalName() + ".");
                            }
                            cb(status);
                        });
                    }
                }
            }
            if (method !== null) {
                this.setResolved(thread, method);
                cb(true);
            }
            else {
                thread.throwNewException('Ljava/lang/NoSuchMethodError;', "Method " + this.signature + " does not exist in class " + this.classInfo.cls.getExternalName() + ".");
                cb(false);
            }
        }
    };
    MethodReference.prototype.setResolved = function (thread, method) {
        this.method = method;
        this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);
        this.fullSignature = this.method.fullSignature;
        this.jsConstructor = this.method.cls.getConstructor(thread);
    };
    MethodReference.prototype.isResolved = function () { return this.method !== null; };
    MethodReference.prototype.getParamWordSize = function () {
        if (this.paramWordSize === -1) {
            this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);
        }
        return this.paramWordSize;
    };
    MethodReference.fromBytes = function (byteStream, constantPool) {
        var classIndex = byteStream.getUint16(), nameAndTypeIndex = byteStream.getUint16(), classInfo = constantPool.get(classIndex), nameAndTypeInfo = constantPool.get(nameAndTypeIndex);
        assert(classInfo.getType() === enums.ConstantPoolItemType.CLASS &&
            nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE, 'ConstantPool MethodReference types mismatch');
        return new this(classInfo, nameAndTypeInfo);
    };
    MethodReference.size = 1;
    MethodReference.infoByteSize = 4;
    return MethodReference;
})();
exports.MethodReference = MethodReference;
CP_CLASSES[enums.ConstantPoolItemType.METHODREF] = MethodReference;
/**
 * Represents a particular interface method.
 * ```
 * CONSTANT_InterfaceMethodref_info {
 *   u1 tag;
 *   u2 class_index;
 *   u2 name_and_type_index;
 * }
 * ```
 */
var InterfaceMethodReference = (function () {
    function InterfaceMethodReference(classInfo, nameAndTypeInfo) {
        /**
         * The signature of the method, including the owning class.
         * e.g. bar/Baz/foo(IJ)V
         */
        this.fullSignature = null;
        this.method = null;
        this.paramWordSize = -1;
        this.jsConstructor = null;
        this.classInfo = classInfo;
        this.nameAndTypeInfo = nameAndTypeInfo;
        this.signature = this.nameAndTypeInfo.name + this.nameAndTypeInfo.descriptor;
    }
    InterfaceMethodReference.prototype.getType = function () {
        return enums.ConstantPoolItemType.INTERFACE_METHODREF;
    };
    /**
     * Checks the method referenced by this constant pool item in the specified
     * bytecode context.
     * Returns null if an error occurs.
     * - Throws a NoSuchFieldError if missing.
     * - Throws an IllegalAccessError if field is inaccessible.
     * - Throws an IncompatibleClassChangeError if the field is an incorrect type
     *   for the field access.
     */
    InterfaceMethodReference.prototype.hasAccess = function (thread, frame, isStatic) {
        var method = this.method, accessingCls = frame.method.cls;
        if (method.accessFlags.isStatic() !== isStatic) {
            thread.throwNewException('Ljava/lang/IncompatibleClassChangeError;', "Method " + method.name + " from class " + method.cls.getExternalName() + " is " + (isStatic ? 'not ' : '') + "static.");
            frame.returnToThreadLoop = true;
            return false;
        }
        else if (!util.checkAccess(accessingCls, method.cls, method.accessFlags)) {
            thread.throwNewException('Ljava/lang/IllegalAccessError;', accessingCls.getExternalName() + " cannot access " + method.cls.getExternalName() + "." + method.name);
            frame.returnToThreadLoop = true;
            return false;
        }
        return true;
    };
    InterfaceMethodReference.prototype.resolve = function (thread, loader, caller, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        if (!this.classInfo.isResolved()) {
            this.classInfo.resolve(thread, loader, caller, function (status) {
                if (!status) {
                    cb(false);
                }
                else {
                    _this.resolve(thread, loader, caller, cb, explicit);
                }
            }, explicit);
        }
        else {
            var cls = this.classInfo.cls, method = cls.methodLookup(this.signature);
            this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);
            if (method !== null) {
                this.setResolved(thread, method);
                cb(true);
            }
            else {
                thread.throwNewException('Ljava/lang/NoSuchMethodError;', "Method " + this.signature + " does not exist in class " + this.classInfo.cls.getExternalName() + ".");
                cb(false);
            }
        }
    };
    InterfaceMethodReference.prototype.setResolved = function (thread, method) {
        this.method = method;
        this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);
        this.fullSignature = this.method.fullSignature;
        this.jsConstructor = this.method.cls.getConstructor(thread);
    };
    InterfaceMethodReference.prototype.getParamWordSize = function () {
        if (this.paramWordSize === -1) {
            this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);
        }
        return this.paramWordSize;
    };
    InterfaceMethodReference.prototype.isResolved = function () { return this.method !== null; };
    InterfaceMethodReference.fromBytes = function (byteStream, constantPool) {
        var classIndex = byteStream.getUint16(), nameAndTypeIndex = byteStream.getUint16(), classInfo = constantPool.get(classIndex), nameAndTypeInfo = constantPool.get(nameAndTypeIndex);
        assert(classInfo.getType() === enums.ConstantPoolItemType.CLASS &&
            nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE, 'ConstantPool InterfaceMethodReference types mismatch');
        return new this(classInfo, nameAndTypeInfo);
    };
    InterfaceMethodReference.size = 1;
    InterfaceMethodReference.infoByteSize = 4;
    return InterfaceMethodReference;
})();
exports.InterfaceMethodReference = InterfaceMethodReference;
CP_CLASSES[enums.ConstantPoolItemType.INTERFACE_METHODREF] = InterfaceMethodReference;
/**
 * Represents a particular field.
 * ```
 * CONSTANT_Fieldref_info {
 *   u1 tag;
 *   u2 class_index;
 *   u2 name_and_type_index;
 * }
 * ```
 */
var FieldReference = (function () {
    function FieldReference(classInfo, nameAndTypeInfo) {
        this.field = null;
        /**
         * The full name of the field, including the owning class.
         * e.g. java/lang/String/value
         */
        this.fullFieldName = null;
        /**
         * The constructor for the field owner. Used for static fields.
         */
        this.fieldOwnerConstructor = null;
        this.classInfo = classInfo;
        this.nameAndTypeInfo = nameAndTypeInfo;
    }
    FieldReference.prototype.getType = function () {
        return enums.ConstantPoolItemType.FIELDREF;
    };
    /**
     * Checks the field referenced by this constant pool item in the specified
     * bytecode context.
     * Returns null if an error occurs.
     * - Throws a NoSuchFieldError if missing.
     * - Throws an IllegalAccessError if field is inaccessible.
     * - Throws an IncompatibleClassChangeError if the field is an incorrect type
     *   for the field access.
     */
    FieldReference.prototype.hasAccess = function (thread, frame, isStatic) {
        var field = this.field, accessingCls = frame.method.cls;
        if (field.accessFlags.isStatic() !== isStatic) {
            thread.throwNewException('Ljava/lang/IncompatibleClassChangeError;', "Field " + name + " from class " + field.cls.getExternalName() + " is " + (isStatic ? 'not ' : '') + "static.");
            frame.returnToThreadLoop = true;
            return false;
        }
        else if (!util.checkAccess(accessingCls, field.cls, field.accessFlags)) {
            thread.throwNewException('Ljava/lang/IllegalAccessError;', accessingCls.getExternalName() + " cannot access " + field.cls.getExternalName() + "." + name);
            frame.returnToThreadLoop = true;
            return false;
        }
        return true;
    };
    FieldReference.prototype.resolve = function (thread, loader, caller, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        if (!this.classInfo.isResolved()) {
            this.classInfo.resolve(thread, loader, caller, function (status) {
                if (!status) {
                    cb(false);
                }
                else {
                    _this.resolve(thread, loader, caller, cb, explicit);
                }
            }, explicit);
        }
        else {
            var cls = this.classInfo.cls, field = cls.fieldLookup(this.nameAndTypeInfo.name);
            if (field !== null) {
                this.fullFieldName = util.descriptor2typestr(field.cls.getInternalName()) + "/" + field.name;
                this.field = field;
                cb(true);
            }
            else {
                thread.throwNewException('Ljava/lang/NoSuchFieldError;', "Field " + this.nameAndTypeInfo.name + " does not exist in class " + this.classInfo.cls.getExternalName() + ".");
                cb(false);
            }
        }
    };
    FieldReference.prototype.isResolved = function () { return this.field !== null; };
    FieldReference.fromBytes = function (byteStream, constantPool) {
        var classIndex = byteStream.getUint16(), nameAndTypeIndex = byteStream.getUint16(), classInfo = constantPool.get(classIndex), nameAndTypeInfo = constantPool.get(nameAndTypeIndex);
        assert(classInfo.getType() === enums.ConstantPoolItemType.CLASS &&
            nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE, 'ConstantPool FieldReference types mismatch');
        return new this(classInfo, nameAndTypeInfo);
    };
    FieldReference.size = 1;
    FieldReference.infoByteSize = 4;
    return FieldReference;
})();
exports.FieldReference = FieldReference;
CP_CLASSES[enums.ConstantPoolItemType.FIELDREF] = FieldReference;
/**
 * Used by an invokedynamic instruction to specify a bootstrap method,
 * the dynamic invocation name, the argument and return types of the call,
 * and optionally, a sequence of additional constants called static arguments
 * to the bootstrap method.
 * ```
 * CONSTANT_InvokeDynamic_info {
 *   u1 tag;
 *   u2 bootstrap_method_attr_index;
 *   u2 name_and_type_index;
 * }
 * ```
 */
var InvokeDynamic = (function () {
    function InvokeDynamic(bootstrapMethodAttrIndex, nameAndTypeInfo) {
        /**
         * Once a CallSite is defined for a particular lexical occurrence of
         * InvokeDynamic, the CallSite will be reused for each future execution
         * of that particular occurrence.
         *
         * We store the CallSite objects here for future retrieval, along with an
         * optional 'appendix' argument.
         */
        this.callSiteObjects = {};
        /**
         * A MethodType object corresponding to this InvokeDynamic call's
         * method descriptor.
         */
        this.methodType = null;
        this.bootstrapMethodAttrIndex = bootstrapMethodAttrIndex;
        this.nameAndTypeInfo = nameAndTypeInfo;
        this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);
    }
    InvokeDynamic.prototype.getType = function () {
        return enums.ConstantPoolItemType.INVOKE_DYNAMIC;
    };
    InvokeDynamic.prototype.isResolved = function () { return this.methodType !== null; };
    InvokeDynamic.prototype.resolve = function (thread, loader, caller, cb) {
        var _this = this;
        util.createMethodType(thread, loader, this.nameAndTypeInfo.descriptor, function (e, rv) {
            if (e) {
                thread.throwException(e);
                cb(false);
            }
            else {
                _this.methodType = rv;
                cb(true);
            }
        });
    };
    InvokeDynamic.prototype.getCallSiteObject = function (pc) {
        var cso = this.callSiteObjects[pc];
        if (cso) {
            return cso;
        }
        else {
            return null;
        }
    };
    InvokeDynamic.prototype.constructCallSiteObject = function (thread, cl, clazz, pc, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        /**
         * A call site specifier gives a symbolic reference to a method handle which
         * is to serve as the bootstrap method for a dynamic call site (§4.7.23).
         * The method handle is resolved to obtain a reference to an instance of
         * java.lang.invoke.MethodHandle (§5.4.3.5).
         */
        var bootstrapMethod = clazz.getBootstrapMethod(this.bootstrapMethodAttrIndex), unresolvedItems = bootstrapMethod[1].concat(bootstrapMethod[0], this).filter(function (item) { return !item.isResolved(); });
        if (unresolvedItems.length > 0) {
            // Resolve all needed constant pool items (including this one).
            return util.asyncForEach(unresolvedItems, function (cpItem, nextItem) {
                cpItem.resolve(thread, cl, clazz, function (status) {
                    if (!status) {
                        nextItem("Failed.");
                    }
                    else {
                        nextItem();
                    }
                }, explicit);
            }, function (err) {
                if (err) {
                    cb(false);
                }
                else {
                    // Rerun. This time, all items are resolved.
                    _this.constructCallSiteObject(thread, cl, clazz, pc, cb, explicit);
                }
            });
        }
        /**
         * A call site specifier gives zero or more static arguments, which
         * communicate application-specific metadata to the bootstrap method. Any
         * static arguments which are symbolic references to classes, method
         * handles, or method types are resolved, as if by invocation of the ldc
         * instruction (§ldc), to obtain references to Class objects,
         * java.lang.invoke.MethodHandle objects, and java.lang.invoke.MethodType
         * objects respectively. Any static arguments that are string literals are
         * used to obtain references to String objects.
         */
        function getArguments() {
            var cpItems = bootstrapMethod[1], i, cpItem, rvObj = new (thread.getBsCl().getInitializedClass(thread, '[Ljava/lang/Object;').getConstructor(thread))(thread, cpItems.length), rv = rvObj.array;
            for (i = 0; i < cpItems.length; i++) {
                cpItem = cpItems[i];
                switch (cpItem.getType()) {
                    case enums.ConstantPoolItemType.CLASS:
                        rv[i] = cpItem.cls.getClassObject(thread);
                        break;
                    case enums.ConstantPoolItemType.METHOD_HANDLE:
                        rv[i] = cpItem.methodHandle;
                        break;
                    case enums.ConstantPoolItemType.METHOD_TYPE:
                        rv[i] = cpItem.methodType;
                        break;
                    case enums.ConstantPoolItemType.STRING:
                        rv[i] = cpItem.value;
                        break;
                    case enums.ConstantPoolItemType.UTF8:
                        rv[i] = thread.getJVM().internString(cpItem.value);
                        break;
                    case enums.ConstantPoolItemType.INTEGER:
                        rv[i] = cl.getInitializedClass(thread, 'I').createWrapperObject(thread, cpItem.value);
                        break;
                    case enums.ConstantPoolItemType.LONG:
                        rv[i] = cl.getInitializedClass(thread, 'J').createWrapperObject(thread, cpItem.value);
                        break;
                    case enums.ConstantPoolItemType.FLOAT:
                        rv[i] = cl.getInitializedClass(thread, 'F').createWrapperObject(thread, cpItem.value);
                        break;
                    case enums.ConstantPoolItemType.DOUBLE:
                        rv[i] = cl.getInitializedClass(thread, 'D').createWrapperObject(thread, cpItem.value);
                        break;
                    default:
                        assert(false, "Invalid CPItem for static args: " + enums.ConstantPoolItemType[cpItem.getType()]);
                        break;
                }
            }
            assert((function () {
                var status = true;
                cpItems.forEach(function (cpItem, i) {
                    if (rv[i] === undefined) {
                        console.log("Undefined item at arg " + i + ": " + enums.ConstantPoolItemType[cpItem.getType()]);
                        status = false;
                    }
                    else if (rv[i] === null) {
                        console.log("Null item at arg " + i + ": " + enums.ConstantPoolItemType[cpItem.getType()]);
                        status = false;
                    }
                });
                return status;
            })(), "Arguments cannot be undefined or null.");
            return rvObj;
        }
        /**
         * A call site specifier gives a method descriptor, TD. A reference to an
         * instance of java.lang.invoke.MethodType is obtained as if by resolution
         * of a symbolic reference to a method type with the same parameter and
         * return types as TD (§5.4.3.5).
         *
         * Do what all OpenJDK-based JVMs do: Call
         * MethodHandleNatives.linkCallSite with:
         * - The class w/ the invokedynamic instruction
         * - The bootstrap method
         * - The name string from the nameAndTypeInfo
         * - The methodType object from the nameAndTypeInfo
         * - The static arguments from the bootstrap method.
         * - A 1-length appendix box.
         */
        var methodName = thread.getJVM().internString(this.nameAndTypeInfo.name), appendixArr = new (cl.getInitializedClass(thread, '[Ljava/lang/Object;').getConstructor(thread))(thread, 1), staticArgs = getArguments(), mhn = cl.getInitializedClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;').getConstructor(thread);
        mhn['java/lang/invoke/MethodHandleNatives/linkCallSite(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/invoke/MemberName;'](thread, [clazz.getClassObject(thread), bootstrapMethod[0].methodHandle, methodName, this.methodType, staticArgs, appendixArr], function (e, rv) {
            if (e) {
                thread.throwException(e);
                cb(false);
            }
            else {
                _this.setResolved(pc, [rv, appendixArr.array[0]]);
                cb(true);
            }
        });
    };
    InvokeDynamic.prototype.setResolved = function (pc, cso) {
        // Prevent resolution races. It's OK to create multiple CSOs, but only one
        // should ever be used!
        if (this.callSiteObjects[pc] === undefined) {
            this.callSiteObjects[pc] = cso;
        }
    };
    InvokeDynamic.fromBytes = function (byteStream, constantPool) {
        var bootstrapMethodAttrIndex = byteStream.getUint16(), nameAndTypeIndex = byteStream.getUint16(), nameAndTypeInfo = constantPool.get(nameAndTypeIndex);
        assert(nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE, 'ConstantPool InvokeDynamic types mismatch');
        return new this(bootstrapMethodAttrIndex, nameAndTypeInfo);
    };
    InvokeDynamic.size = 1;
    InvokeDynamic.infoByteSize = 4;
    return InvokeDynamic;
})();
exports.InvokeDynamic = InvokeDynamic;
CP_CLASSES[enums.ConstantPoolItemType.INVOKE_DYNAMIC] = InvokeDynamic;
/**
 * Represents a given method handle.
 * ```
 * CONSTANT_MethodHandle_info {
 *   u1 tag;
 *   u1 reference_kind;
 *   u2 reference_index;
 * }
 * ```
 */
var MethodHandle = (function () {
    function MethodHandle(reference, referenceType) {
        /**
         * The resolved MethodHandle object.
         */
        this.methodHandle = null;
        this.reference = reference;
        this.referenceType = referenceType;
    }
    MethodHandle.prototype.getType = function () {
        return enums.ConstantPoolItemType.METHOD_HANDLE;
    };
    MethodHandle.prototype.isResolved = function () { return this.methodHandle !== null; };
    MethodHandle.prototype.getConstant = function (thread) { return this.methodHandle; };
    /**
     * Asynchronously constructs a JVM-visible MethodHandle object for this
     * MethodHandle.
     *
     * Requires producing the following, and passing it to a MethodHandle
     * constructor:
     * * [java.lang.Class] The defining class.
     * * [java.lang.String] The name of the field/method/etc.
     * * [java.lang.invoke.MethodType | java.lang.Class] The type of the field OR,
     *   if a method, the type of the method descriptor.
     *
     * If needed, this function will resolve needed classes.
     */
    MethodHandle.prototype.resolve = function (thread, cl, caller, cb, explicit) {
        var _this = this;
        if (!this.reference.isResolved()) {
            return this.reference.resolve(thread, cl, caller, function (status) {
                if (!status) {
                    cb(false);
                }
                else {
                    _this.resolve(thread, cl, caller, cb, explicit);
                }
            }, explicit);
        }
        this.constructMethodHandleType(thread, cl, function (type) {
            if (type === null) {
                cb(false);
            }
            else {
                var methodHandleNatives = cl.getInitializedClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;').getConstructor(thread);
                methodHandleNatives['linkMethodHandleConstant(Ljava/lang/Class;ILjava/lang/Class;Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;'](thread, [caller.getClassObject(thread), _this.referenceType, _this.getDefiningClassObj(thread), thread.getJVM().internString(_this.reference.nameAndTypeInfo.name), type], function (e, methodHandle) {
                    if (e) {
                        thread.throwException(e);
                        cb(false);
                    }
                    else {
                        _this.methodHandle = methodHandle;
                        cb(true);
                    }
                });
            }
        });
    };
    MethodHandle.prototype.getDefiningClassObj = function (thread) {
        if (this.reference.getType() === enums.ConstantPoolItemType.FIELDREF) {
            return this.reference.field.cls.getClassObject(thread);
        }
        else {
            return this.reference.method.cls.getClassObject(thread);
        }
    };
    MethodHandle.prototype.constructMethodHandleType = function (thread, cl, cb) {
        if (this.reference.getType() === enums.ConstantPoolItemType.FIELDREF) {
            var resolveObj = this.reference.nameAndTypeInfo.descriptor;
            cl.resolveClass(thread, resolveObj, function (cdata) {
                if (cdata !== null) {
                    cb(cdata.getClassObject(thread));
                }
                else {
                    cb(null);
                }
            });
        }
        else {
            util.createMethodType(thread, cl, this.reference.nameAndTypeInfo.descriptor, function (e, rv) {
                if (e) {
                    thread.throwException(e);
                    cb(null);
                }
                else {
                    cb(rv);
                }
            });
        }
    };
    MethodHandle.fromBytes = function (byteStream, constantPool) {
        var referenceKind = byteStream.getUint8(), referenceIndex = byteStream.getUint16(), reference = constantPool.get(referenceIndex);
        assert(0 < referenceKind && referenceKind < 10, 'ConstantPool MethodHandle invalid referenceKind: ' + referenceKind);
        // Sanity check.
        assert((function () {
            switch (referenceKind) {
                case enums.MethodHandleReferenceKind.GETFIELD:
                case enums.MethodHandleReferenceKind.GETSTATIC:
                case enums.MethodHandleReferenceKind.PUTFIELD:
                case enums.MethodHandleReferenceKind.PUTSTATIC:
                    return reference.getType() === enums.ConstantPoolItemType.FIELDREF;
                case enums.MethodHandleReferenceKind.INVOKEINTERFACE:
                    return reference.getType() === enums.ConstantPoolItemType.INTERFACE_METHODREF
                        && reference.nameAndTypeInfo.name[0] !== '<';
                case enums.MethodHandleReferenceKind.INVOKEVIRTUAL:
                case enums.MethodHandleReferenceKind.INVOKESTATIC:
                case enums.MethodHandleReferenceKind.INVOKESPECIAL:
                    // NOTE: Spec says METHODREF, but I've found instances where
                    // INVOKESPECIAL is used on an INTERFACE_METHODREF.
                    return (reference.getType() === enums.ConstantPoolItemType.METHODREF
                        || reference.getType() === enums.ConstantPoolItemType.INTERFACE_METHODREF)
                        && reference.nameAndTypeInfo.name[0] !== '<';
                case enums.MethodHandleReferenceKind.NEWINVOKESPECIAL:
                    return reference.getType() === enums.ConstantPoolItemType.METHODREF
                        && reference.nameAndTypeInfo.name === '<init>';
            }
            return true;
        })(), "Invalid constant pool reference for method handle reference type: " + enums.MethodHandleReferenceKind[referenceKind]);
        return new this(reference, referenceKind);
    };
    MethodHandle.size = 1;
    MethodHandle.infoByteSize = 3;
    return MethodHandle;
})();
exports.MethodHandle = MethodHandle;
CP_CLASSES[enums.ConstantPoolItemType.METHOD_HANDLE] = MethodHandle;
// #endregion
/**
 * Constant pool type *resolution tiers*. Value is the tier, key is the
 * constant pool type.
 * Tier 0 has no references to other constant pool items, and can be resolved
 * first.
 * Tier 1 refers to tier 0 items.
 * Tier n refers to tier n-1 items and below.
 * Initialized in the given fashion to give the JS engine a tasty type hint.
 */
var CONSTANT_POOL_TIER = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
// Populate CONSTANT_POOL_TIER. Put into a closure to avoid scope pollution.
(function (tierInfos) {
    tierInfos.forEach(function (tierInfo, index) {
        tierInfo.forEach(function (type) {
            CONSTANT_POOL_TIER[type] = index;
        });
    });
})([
    // Tier 0
    [
        enums.ConstantPoolItemType.UTF8,
        enums.ConstantPoolItemType.INTEGER,
        enums.ConstantPoolItemType.FLOAT,
        enums.ConstantPoolItemType.LONG,
        enums.ConstantPoolItemType.DOUBLE
    ],
    // Tier 1
    [
        enums.ConstantPoolItemType.CLASS,
        enums.ConstantPoolItemType.STRING,
        enums.ConstantPoolItemType.NAME_AND_TYPE,
        enums.ConstantPoolItemType.METHOD_TYPE
    ],
    // Tier 2
    [
        enums.ConstantPoolItemType.FIELDREF,
        enums.ConstantPoolItemType.METHODREF,
        enums.ConstantPoolItemType.INTERFACE_METHODREF,
        enums.ConstantPoolItemType.INVOKE_DYNAMIC
    ],
    // Tier 3
    [
        enums.ConstantPoolItemType.METHOD_HANDLE
    ]
]);
/**
 * Represents a constant pool for a particular class.
 */
var ConstantPool = (function () {
    function ConstantPool() {
    }
    ConstantPool.prototype.parse = function (byteStream, cpPatches) {
        var _this = this;
        if (cpPatches === void 0) { cpPatches = null; }
        var cpCount = byteStream.getUint16(), 
        // First key is the tier.
        deferredQueue = [[], [], []], 
        // The ending offset of the constant pool items.
        endIdx = 0, idx = 1, 
        // Tag of the currently-being-processed item.
        tag = 0, 
        // Offset of the currently-being-processed item.
        itemOffset = 0, 
        // Tier of the currently-being-processed item.
        itemTier = 0;
        this.constantPool = new Array(cpCount);
        // Scan for tier info.
        while (idx < cpCount) {
            itemOffset = byteStream.pos();
            tag = byteStream.getUint8();
            assert(CP_CLASSES[tag] !== null && CP_CLASSES[tag] !== undefined, 'Unknown ConstantPool tag: ' + tag);
            itemTier = CONSTANT_POOL_TIER[tag];
            if (itemTier > 0) {
                deferredQueue[itemTier - 1].push({ offset: itemOffset, index: idx });
                byteStream.skip(CP_CLASSES[tag].infoByteSize);
            }
            else {
                this.constantPool[idx] = CP_CLASSES[tag].fromBytes(byteStream, this);
            }
            idx += CP_CLASSES[tag].size;
        }
        endIdx = byteStream.pos();
        // Process tiers.
        deferredQueue.forEach(function (deferredItems) {
            deferredItems.forEach(function (item) {
                byteStream.seek(item.offset);
                tag = byteStream.getUint8();
                _this.constantPool[item.index] = CP_CLASSES[tag].fromBytes(byteStream, _this);
                if (cpPatches !== null && cpPatches.array[item.index] !== null && cpPatches.array[item.index] !== undefined) {
                    /*
                     * For each CP entry, the corresponding CP patch must either be null or have
                     * the format that matches its tag:
                     *
                     * * Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
                     * * Utf8: a string (must have suitable syntax if used as signature or name)
                     * * Class: any java.lang.Class object
                     * * String: any object (not just a java.lang.String)
                     * * InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments
                     */
                    var patchObj = cpPatches.array[item.index];
                    switch (patchObj.getClass().getInternalName()) {
                        case 'Ljava/lang/Integer;':
                            assert(tag === enums.ConstantPoolItemType.INTEGER);
                            _this.constantPool[item.index].value = patchObj['java/lang/Integer/value'];
                            break;
                        case 'Ljava/lang/Long;':
                            assert(tag === enums.ConstantPoolItemType.LONG);
                            _this.constantPool[item.index].value = patchObj['java/lang/Long/value'];
                            break;
                        case 'Ljava/lang/Float;':
                            assert(tag === enums.ConstantPoolItemType.FLOAT);
                            _this.constantPool[item.index].value = patchObj['java/lang/Float/value'];
                            break;
                        case 'Ljava/lang/Double;':
                            assert(tag === enums.ConstantPoolItemType.DOUBLE);
                            _this.constantPool[item.index].value = patchObj['java/lang/Double/value'];
                            break;
                        case 'Ljava/lang/String;':
                            assert(tag === enums.ConstantPoolItemType.UTF8);
                            _this.constantPool[item.index].value = patchObj.toString();
                            break;
                        case 'Ljava/lang/Class;':
                            assert(tag === enums.ConstantPoolItemType.CLASS);
                            _this.constantPool[item.index].name = patchObj.$cls.getInternalName();
                            _this.constantPool[item.index].cls = patchObj.$cls;
                            break;
                        default:
                            assert(tag === enums.ConstantPoolItemType.STRING);
                            _this.constantPool[item.index].stringValue = "";
                            // XXX: Not actually a string, but the JVM does this.
                            _this.constantPool[item.index].value = patchObj;
                            break;
                    }
                }
            });
        });
        // Return to the correct offset, at the end of the CP data.
        byteStream.seek(endIdx);
        return byteStream;
    };
    ConstantPool.prototype.get = function (idx) {
        assert(this.constantPool[idx] !== undefined, "Invalid ConstantPool reference.");
        return this.constantPool[idx];
    };
    ConstantPool.prototype.each = function (fn) {
        this.constantPool.forEach(function (item, idx) {
            if (item !== undefined) {
                fn(idx, item);
            }
        });
    };
    return ConstantPool;
})();
exports.ConstantPool = ConstantPool;
/// Resolved forms of constant pool items.

},{"./assert":26,"./enums":31,"./util":47}],21:[function(_dereq_,module,exports){
/**
 * Top-level Doppio.Debug namespace.
 */
var Assert = _dereq_('./assert');
exports.Assert = Assert;
var Logging = _dereq_('./logging');
exports.Logging = Logging;
var Difflib = _dereq_('./difflib');
exports.Difflib = Difflib;

},{"./assert":26,"./difflib":29,"./logging":39}],22:[function(_dereq_,module,exports){
var enums = _dereq_('./enums');
var assert = _dereq_('./assert');
/**
 * Represents a JVM monitor.
 */
var Monitor = (function () {
    function Monitor() {
        /**
         * The owner of the monitor.
         */
        this.owner = null;
        /**
         * Number of times that the current owner has locked this monitor.
         */
        this.count = 0;
        /**
         * JVM threads that are waiting for the current owner to relinquish the
         * monitor.
         */
        this.blocked = {};
        /**
         * Queue of JVM threads that are waiting for a JVM thread to notify them.
         */
        this.waiting = {};
    }
    /**
     * Attempts to acquire the monitor.
     *
     * Thread transitions:
     * * RUNNABLE => BLOCKED [If fails to acquire lock]
     *
     * @param thread The thread that is trying to acquire the monitor.
     * @param cb If this method returns false, then this callback will be
     *   triggered once the thread becomes owner of the monitor. At that time,
     *   the thread will be in the RUNNABLE state.
     * @return True if successfull, false if not. If not successful, the thread
     *   becomes BLOCKED, and the input callback will be triggered once the
     *   thread owns the monitor and is RUNNABLE.
     */
    Monitor.prototype.enter = function (thread, cb) {
        if (this.owner === thread) {
            this.count++;
            return true;
        }
        else {
            return this.contendForLock(thread, 1, enums.ThreadStatus.BLOCKED, cb);
        }
    };
    /**
     * Generic version of Monitor.enter for contending for the lock.
     *
     * Thread transitions:
     * * RUNNABLE => UNINTERRUPTIBLY_BLOCKED [If fails to acquire lock]
     * * RUNNABLE => BLOCKED [If fails to acquire lock]
     *
     * @param thread The thread contending for the lock.
     * @param count The lock count to use once the thread owns the lock.
     * @param blockStatus The ThreadStatus to use should the thread need to
     *   contend for the lock (either BLOCKED or UNINTERRUPTIBLY_BLOCKED).
     * @param cb The callback to call once the thread becomes owner of the lock.
     * @return True if the thread immediately acquired the lock, false if the
     *   thread is now blocked on the lock.
     */
    Monitor.prototype.contendForLock = function (thread, count, blockStatus, cb) {
        var owner = this.owner;
        assert(owner != thread, "Thread attempting to contend for lock it already owns!");
        if (owner === null) {
            assert(this.count === 0);
            this.owner = thread;
            this.count = count;
            return true;
        }
        else {
            /**
             * "If another thread already owns the monitor associated with objectref,
             *  the thread blocks until the monitor's entry count is zero, then tries
             *  again to gain ownership."
             * @from http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter
             */
            this.blocked[thread.getRef()] = { thread: thread, cb: cb, count: count };
            thread.setStatus(blockStatus, this);
            return false;
        }
    };
    /**
     * Exits the monitor. Handles notifying the waiting threads if the lock
     * becomes available.
     *
     * Thread transitions:
     * * *NONE* on the argument thread.
     * * A *BLOCKED* thread may be scheduled if the owner gives up the monitor.
     *
     * @param thread The thread that is exiting the monitor.
     * @return True if exit succeeded, false if an exception occurred.
     */
    Monitor.prototype.exit = function (thread) {
        var owner = this.owner;
        if (owner === thread) {
            if (--this.count === 0) {
                this.owner = null;
                this.appointNewOwner();
            }
        }
        else {
            /**
             * "If the thread that executes monitorexit is not the owner of the
             *  monitor associated with the instance referenced by objectref,
             *  monitorexit throws an IllegalMonitorStateException."
             * @from http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorexit
             */
            thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', "Cannot exit a monitor that you do not own.");
        }
        return owner === thread;
    };
    /**
     * Chooses one of the blocked threads to become the monitor's owner.
     */
    Monitor.prototype.appointNewOwner = function () {
        var blockedThreadRefs = Object.keys(this.blocked);
        if (blockedThreadRefs.length > 0) {
            // Unblock a random thread.
            var unblockedRef = blockedThreadRefs[Math.floor(Math.random() * blockedThreadRefs.length)], 
            // XXX: Typing hack. Key must be a number.
            unblocked = this.blocked[unblockedRef];
            this.unblock(unblocked.thread, false);
        }
    };
    /**
     * "Causes the current thread to wait until another thread invokes the
     *  notify() method or the notifyAll() method for this object, or some other
     *  thread interrupts the current thread, or a certain amount of real time
     *  has elapsed.
     *
     *  This method causes the current thread (call it T) to place itself in the
     *  wait set for this object and then to relinquish any and all
     *  synchronization claims on this object."
     *
     * We coalesce all possible wait configurations into this one function.
     * @from http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait(long, int)
     * @param thread The thread that wants to wait on this monitor.
     * @param cb The callback triggered once the thread wakes up.
     * @param timeoutMs? An optional timeout that specifies how long the thread
     *   should wait, in milliseconds. If this value is 0, then we ignore it.
     * @param timeoutNs? An optional timeout that specifies how long the thread
     *   should wait, in nanosecond precision (currently ignored).
     * @todo Use high-precision timers in browsers that support it.
     * @return True if the wait succeeded, false if it triggered an exception.
     */
    Monitor.prototype.wait = function (thread, cb, timeoutMs, timeoutNs) {
        var _this = this;
        if (this.getOwner() === thread) {
            // INVARIANT: Thread shouldn't currently be blocked on a monitor.
            assert(thread.getStatus() !== enums.ThreadStatus.BLOCKED);
            this.waiting[thread.getRef()] = {
                thread: thread,
                cb: cb,
                count: this.count,
                isTimed: timeoutMs != null && timeoutMs !== 0
            };
            // Revoke ownership.
            this.owner = null;
            this.count = 0;
            if (timeoutMs != null && timeoutMs !== 0) {
                // Scheduler a timer that wakes up the thread.
                // XXX: Casting to 'number', since NodeJS typings specify a Timer.
                this.waiting[thread.getRef()].timer = setTimeout(function () {
                    _this.unwait(thread, true);
                }, timeoutMs);
                thread.setStatus(enums.ThreadStatus.TIMED_WAITING, this);
            }
            else {
                thread.setStatus(enums.ThreadStatus.WAITING, this);
            }
            // Select a new owner.
            this.appointNewOwner();
            return true;
        }
        else {
            /**
             * "The current thread must own this object's monitor"
             */
            thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', "Cannot wait on an object that you do not own.");
            return false;
        }
    };
    /**
     * Removes the specified thread from the waiting set, and makes it compete
     * for the monitor lock. Once it acquires the lock, we restore its lock
     * count prior to triggering the wait callback.
     *
     * If the thread is interrupted, the wait callback is *not* triggered.
     *
     * @param thread The thread to remove.
     * @param fromTimer Indicates if this function call was triggered from a
     *   timer event.
     * @param [interrupting] If true, then we are *interrupting* the wait. Do not
     *   trigger the wait callback.
     * @param [unwaitCb] If interrupting is true, then this callback is triggered
     *   once the thread reacquires the lock.
     */
    Monitor.prototype.unwait = function (thread, fromTimer, interrupting, unwaitCb) {
        if (interrupting === void 0) { interrupting = false; }
        if (unwaitCb === void 0) { unwaitCb = null; }
        // Step 1: Remove the thread from the waiting set.
        var waitEntry = this.waiting[thread.getRef()], 
        // Interrupting a previously-waiting thread before it acquires a lock
        // makes no semantic sense, as the thread is currently suspended in a
        // synchronized block that requires ownership of the monitor.
        blockStatus = enums.ThreadStatus.UNINTERRUPTABLY_BLOCKED, blockCb = function () {
            // Thread is RUNNABLE before we trigger the callback.
            thread.setStatus(enums.ThreadStatus.RUNNABLE);
            if (interrupting) {
                unwaitCb();
            }
            else {
                waitEntry.cb(fromTimer);
            }
        };
        assert(waitEntry != null);
        delete this.waiting[thread.getRef()];
        // Step 2: Remove the timer if the timer did not trigger this event.
        if (thread.getStatus() === enums.ThreadStatus.TIMED_WAITING && !fromTimer) {
            var timerId = waitEntry.timer;
            assert(timerId != null);
            clearTimeout(timerId);
        }
        // Step 3: Acquire the monitor [ASYNC]
        if (this.contendForLock(thread, waitEntry.count, blockStatus, blockCb)) {
            // Success! Trigger the blockCb anyway. If 'contendForLock' returns false,
            // it will trigger blockCb once the thread acquires the lock.
            blockCb();
        }
    };
    /**
     * Removes the specified thread from being blocked on the monitor so it can
     * re-compete for ownership.
     * @param [interrupting] If true, we are interrupting the monitor block. The
     *   thread should not acquire the lock, and the block callback should not
     *   be triggered.
     */
    Monitor.prototype.unblock = function (thread, interrupting) {
        if (interrupting === void 0) { interrupting = false; }
        var blockEntry = this.blocked[thread.getRef()];
        // Cannot interrupt an uninterruptibly blocked thread.
        assert(interrupting ? thread.getStatus() === enums.ThreadStatus.BLOCKED : true);
        if (blockEntry != null) {
            delete this.blocked[thread.getRef()];
            thread.setStatus(enums.ThreadStatus.RUNNABLE);
            if (!interrupting) {
                // No one else can own the monitor.
                assert(this.owner == null && this.count === 0, "T" + thread.getRef() + ": We're not interrupting a block, but someone else owns the monitor?! Owned by " + (this.owner == null ? "[no one]" : "" + this.owner.getRef()) + " Count: " + this.count);
                // Assign this thread as the monitor owner.
                this.owner = thread;
                this.count = blockEntry.count;
                // Trigger the callback.
                blockEntry.cb();
            }
        }
    };
    /**
     * Notifies a single waiting thread.
     * @param thread The notifying thread. *MUST* be the owner.
     */
    Monitor.prototype.notify = function (thread) {
        if (this.owner === thread) {
            var waitingRefs = Object.keys(this.waiting);
            if (waitingRefs.length > 0) {
                // Notify a random thread.
                this.unwait(this.waiting[waitingRefs[Math.floor(Math.random() * waitingRefs.length)]].thread, false);
            }
        }
        else {
            /**
             * "Throws IllegalMonitorStateException if the current thread is not the
             *  owner of this object's monitor."
             * @from http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notify()
             */
            thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', "Cannot notify on a monitor that you do not own.");
        }
    };
    /**
     * Notifies all waiting threads.
     * @param thread The notifying thread. *MUST* be the owner.
     */
    Monitor.prototype.notifyAll = function (thread) {
        if (this.owner === thread) {
            var waitingRefs = Object.keys(this.waiting), i;
            // Notify each thread.
            for (i = 0; i < waitingRefs.length; i++) {
                this.unwait(this.waiting[waitingRefs[i]].thread, false);
            }
        }
        else {
            /**
             * "Throws IllegalMonitorStateException if the current thread is not the
             *  owner of this object's monitor."
             * @from http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notifyAll()
             */
            thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', "Cannot notifyAll on a monitor that you do not own.");
        }
    };
    /**
     * @return The owner of the monitor.
     */
    Monitor.prototype.getOwner = function () {
        return this.owner;
    };
    Monitor.prototype.isWaiting = function (thread) {
        // Waiting, but *not* timed waiting.
        return this.waiting[thread.getRef()] != null && !this.waiting[thread.getRef()].isTimed;
    };
    Monitor.prototype.isTimedWaiting = function (thread) {
        // Timed waiting, *not* waiting.
        return this.waiting[thread.getRef()] != null && this.waiting[thread.getRef()].isTimed;
    };
    Monitor.prototype.isBlocked = function (thread) {
        // Blocked.
        return this.blocked[thread.getRef()] != null;
    };
    return Monitor;
})();
module.exports = Monitor;

},{"./assert":26,"./enums":31}],23:[function(_dereq_,module,exports){
/**
* A safe to use key value map.
*
* JavaScript objects cannot be used as general-purpose key value maps, as they
* contain a number of default fields. This class avoids those issues.
*/
var SafeMap = (function () {
    function SafeMap() {
        this.cache = Object.create(null); // has no defined properties aside from __proto__
    }
    /**
     * Mutates the key so that it cannot possibly conflict with existing object
     * properties.
     */
    SafeMap.prototype.fixKey = function (key) {
        return ';' + key;
    };
    SafeMap.prototype.get = function (key) {
        key = this.fixKey(key);
        if (this.cache[key] !== undefined) {
            return this.cache[key];
        }
        return undefined;
    };
    SafeMap.prototype.has = function (key) {
        return this.get(key) !== undefined;
    };
    SafeMap.prototype.set = function (key, value) {
        this.cache[this.fixKey(key)] = value;
    };
    return SafeMap;
})();
module.exports = SafeMap;

},{}],24:[function(_dereq_,module,exports){
/**
 * Utility class. "stream" out string data, and compile into a single string.
 */
var StringOutputStream = (function () {
    function StringOutputStream() {
        this._data = [];
    }
    StringOutputStream.prototype.write = function (data) { this._data.push(data); };
    StringOutputStream.prototype.flush = function () {
        var rv = this._data.join("");
        this._data = [];
        return rv;
    };
    return StringOutputStream;
})();
module.exports = StringOutputStream;

},{}],25:[function(_dereq_,module,exports){
/**
 * Top-level Doppio.VM API.
 */
var JVM = _dereq_('./jvm');
exports.JVM = JVM;
var CLI = _dereq_('./java_cli');
exports.CLI = CLI;
var ClassFile = _dereq_('./ClassFile');
exports.ClassFile = ClassFile;
var Threading = _dereq_('./threading');
exports.Threading = Threading;
var Long = _dereq_('./gLong');
exports.Long = Long;
var Util = _dereq_('./util');
exports.Util = Util;
var Enums = _dereq_('./enums');
exports.Enums = Enums;
var Interfaces = _dereq_('./interfaces');
exports.Interfaces = Interfaces;
var Monitor = _dereq_('./Monitor');
exports.Monitor = Monitor;

},{"./ClassFile":17,"./Monitor":22,"./enums":31,"./gLong":32,"./interfaces":36,"./java_cli":37,"./jvm":38,"./threading":45,"./util":47}],26:[function(_dereq_,module,exports){
/**
 * Checks the given assertion. Throws an error if it fails.
 */
function assert(assertion, msg, thread) {
    if (!assertion) {
        throw new Error("Assertion failed: " + msg + "\n" + (thread ? thread.getPrintableStackTrace() : ''));
    }
}
module.exports = assert;

},{}],27:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_('./util');
var enums = _dereq_('./enums');
var assert = _dereq_('./assert');
var global = _dereq_('./global');
if (typeof RELEASE === 'undefined')
    global.RELEASE = false;
var ExceptionHandler = (function () {
    function ExceptionHandler(startPC, endPC, handlerPC, catchType) {
        this.startPC = startPC;
        this.endPC = endPC;
        this.handlerPC = handlerPC;
        this.catchType = catchType;
    }
    ExceptionHandler.prototype.getName = function () {
        return 'ExceptionHandler';
    };
    ExceptionHandler.parse = function (bytesArray, constantPool) {
        var startPC = bytesArray.getUint16(), endPC = bytesArray.getUint16(), handlerPC = bytesArray.getUint16(), cti = bytesArray.getUint16(), catchType = cti === 0 ? "<any>" : constantPool.get(cti).name;
        return new this(startPC, endPC, handlerPC, catchType);
    };
    return ExceptionHandler;
})();
exports.ExceptionHandler = ExceptionHandler;
var Code = (function () {
    function Code(maxStack, maxLocals, exceptionHandlers, attrs, code) {
        this.maxStack = maxStack;
        this.maxLocals = maxLocals;
        this.exceptionHandlers = exceptionHandlers;
        this.attrs = attrs;
        this.code = code;
    }
    Code.prototype.getName = function () {
        return 'Code';
    };
    Code.prototype.getMaxStack = function () {
        return this.maxStack;
    };
    Code.parse = function (byteStream, constantPool) {
        var maxStack = byteStream.getUint16(), maxLocals = byteStream.getUint16(), codeLen = byteStream.getUint32();
        if (codeLen === 0) {
            if (RELEASE) {
                throw "Error parsing code: Code length is zero";
            }
        }
        var code = byteStream.slice(codeLen).getBuffer(), exceptLen = byteStream.getUint16(), exceptionHandlers = [];
        for (var i = 0; i < exceptLen; i++) {
            exceptionHandlers.push(ExceptionHandler.parse(byteStream, constantPool));
        }
        // yes, there are even attrs on attrs. BWOM... BWOM...
        var attrs = makeAttributes(byteStream, constantPool);
        return new this(maxStack, maxLocals, exceptionHandlers, attrs, code);
    };
    Code.prototype.getCode = function () {
        return this.code;
    };
    Code.prototype.getAttribute = function (name) {
        for (var i = 0; i < this.attrs.length; i++) {
            var attr = this.attrs[i];
            if (attr.getName() === name) {
                return attr;
            }
        }
        return null;
    };
    return Code;
})();
exports.Code = Code;
var LineNumberTable = (function () {
    function LineNumberTable(entries) {
        this.entries = entries;
    }
    LineNumberTable.prototype.getName = function () {
        return 'LineNumberTable';
    };
    /**
     * Returns the relevant source code line number for the specified program
     * counter.
     */
    LineNumberTable.prototype.getLineNumber = function (pc) {
        var j, lineNumber = -1;
        // get the last line number before the stack frame's pc
        for (j = 0; j < this.entries.length; j++) {
            var entry = this.entries[j];
            if (entry.startPC <= pc) {
                lineNumber = entry.lineNumber;
            }
            else {
                // Further entries are past the PC.
                break;
            }
        }
        return lineNumber;
    };
    LineNumberTable.parse = function (byteStream, constantPool) {
        var entries = [];
        var lntLen = byteStream.getUint16();
        for (var i = 0; i < lntLen; i++) {
            var spc = byteStream.getUint16();
            var ln = byteStream.getUint16();
            entries.push({
                'startPC': spc,
                'lineNumber': ln
            });
        }
        return new this(entries);
    };
    return LineNumberTable;
})();
exports.LineNumberTable = LineNumberTable;
var SourceFile = (function () {
    function SourceFile(filename) {
        this.filename = filename;
    }
    SourceFile.prototype.getName = function () {
        return 'SourceFile';
    };
    SourceFile.parse = function (byteStream, constantPool) {
        return new this(constantPool.get(byteStream.getUint16()).value);
    };
    return SourceFile;
})();
exports.SourceFile = SourceFile;
var StackMapTable = (function () {
    function StackMapTable(entries) {
        this.entries = entries;
    }
    StackMapTable.prototype.getName = function () {
        return 'StackMapTable';
    };
    StackMapTable.parse = function (byteStream, constantPool) {
        var numEntries = byteStream.getUint16(), entries = [];
        for (var i = 0; i < numEntries; i++) {
            entries.push(this.parseEntry(byteStream, constantPool));
        }
        return new this(entries);
    };
    StackMapTable.parseEntry = function (byteStream, constantPool) {
        var frameType = byteStream.getUint8(), locals, offsetDelta, i;
        if (frameType < 64) {
            return {
                type: enums.StackMapTableEntryType.SAME_FRAME,
                offsetDelta: frameType
            };
        }
        else if (frameType < 128) {
            return {
                type: enums.StackMapTableEntryType.SAME_LOCALS_1_STACK_ITEM_FRAME,
                offsetDelta: frameType - 64,
                stack: [this.parseVerificationTypeInfo(byteStream, constantPool)]
            };
        }
        else if (frameType < 247) {
        }
        else if (frameType === 247) {
            return {
                type: enums.StackMapTableEntryType.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED,
                offsetDelta: byteStream.getUint16(),
                stack: [this.parseVerificationTypeInfo(byteStream, constantPool)]
            };
        }
        else if (frameType < 251) {
            return {
                type: enums.StackMapTableEntryType.CHOP_FRAME,
                offsetDelta: byteStream.getUint16(),
                k: 251 - frameType
            };
        }
        else if (frameType === 251) {
            return {
                type: enums.StackMapTableEntryType.SAME_FRAME_EXTENDED,
                offsetDelta: byteStream.getUint16()
            };
        }
        else if (frameType < 255) {
            offsetDelta = byteStream.getUint16();
            locals = [];
            for (i = 0; i < frameType - 251; i++) {
                locals.push(this.parseVerificationTypeInfo(byteStream, constantPool));
            }
            return {
                type: enums.StackMapTableEntryType.APPEND_FRAME,
                offsetDelta: offsetDelta,
                locals: locals
            };
        }
        else if (frameType === 255) {
            offsetDelta = byteStream.getUint16();
            var numLocals = byteStream.getUint16();
            locals = [];
            for (i = 0; i < numLocals; i++) {
                locals.push(this.parseVerificationTypeInfo(byteStream, constantPool));
            }
            var numStackItems = byteStream.getUint16();
            var stack = [];
            for (i = 0; i < numStackItems; i++) {
                stack.push(this.parseVerificationTypeInfo(byteStream, constantPool));
            }
            return {
                type: enums.StackMapTableEntryType.FULL_FRAME,
                offsetDelta: offsetDelta,
                numLocals: numLocals,
                locals: locals,
                numStackItems: numStackItems,
                stack: stack
            };
        }
    };
    StackMapTable.parseVerificationTypeInfo = function (byteStream, constantPool) {
        var tag = byteStream.getUint8();
        if (tag === 7) {
            var cls = constantPool.get(byteStream.getUint16()).name;
            return 'class ' + (/\w/.test(cls[0]) ? util.descriptor2typestr(cls) : "\"" + cls + "\"");
        }
        else if (tag === 8) {
            return 'uninitialized ' + byteStream.getUint16();
        }
        else {
            var tagToType = ['bogus', 'int', 'float', 'double', 'long', 'null', 'this', 'object', 'uninitialized'];
            return tagToType[tag];
        }
    };
    return StackMapTable;
})();
exports.StackMapTable = StackMapTable;
var LocalVariableTable = (function () {
    function LocalVariableTable(entries) {
        this.entries = entries;
    }
    LocalVariableTable.prototype.getName = function () {
        return 'LocalVariableTable';
    };
    LocalVariableTable.parse = function (byteStream, constantPool) {
        var numEntries = byteStream.getUint16(), entries = [];
        for (var i = 0; i < numEntries; i++) {
            entries.push(this.parseEntries(byteStream, constantPool));
        }
        return new this(entries);
    };
    LocalVariableTable.parseEntries = function (bytes_array, constant_pool) {
        return {
            startPC: bytes_array.getUint16(),
            length: bytes_array.getUint16(),
            name: constant_pool.get(bytes_array.getUint16()).value,
            descriptor: constant_pool.get(bytes_array.getUint16()).value,
            ref: bytes_array.getUint16()
        };
    };
    return LocalVariableTable;
})();
exports.LocalVariableTable = LocalVariableTable;
var LocalVariableTypeTable = (function () {
    function LocalVariableTypeTable(entries) {
        this.entries = entries;
    }
    LocalVariableTypeTable.prototype.getName = function () {
        return 'LocalVariableTypeTable';
    };
    LocalVariableTypeTable.parse = function (byteStream, constantPool) {
        var numEntries = byteStream.getUint16(), i, entries = [];
        for (i = 0; i < numEntries; i++) {
            entries.push(this.parseTableEntry(byteStream, constantPool));
        }
        return new this(entries);
    };
    LocalVariableTypeTable.parseTableEntry = function (byteStream, constantPool) {
        return {
            startPC: byteStream.getUint16(),
            length: byteStream.getUint16(),
            name: constantPool.get(byteStream.getUint16()).value,
            signature: constantPool.get(byteStream.getUint16()).value,
            index: byteStream.getUint16()
        };
    };
    return LocalVariableTypeTable;
})();
exports.LocalVariableTypeTable = LocalVariableTypeTable;
var Exceptions = (function () {
    function Exceptions(exceptions) {
        this.exceptions = exceptions;
    }
    Exceptions.prototype.getName = function () {
        return 'Exceptions';
    };
    Exceptions.parse = function (byteStream, constantPool) {
        var numExceptions = byteStream.getUint16();
        var excRefs = [];
        for (var i = 0; i < numExceptions; i++) {
            excRefs.push(byteStream.getUint16());
        }
        return new this(excRefs.map(function (ref) { return constantPool.get(ref).name; }));
    };
    return Exceptions;
})();
exports.Exceptions = Exceptions;
var InnerClasses = (function () {
    function InnerClasses(classes) {
        this.classes = classes;
    }
    InnerClasses.prototype.getName = function () {
        return 'InnerClasses';
    };
    InnerClasses.parse = function (bytes_array, constant_pool) {
        var numClasses = bytes_array.getUint16(), classes = [];
        for (var i = 0; i < numClasses; i++) {
            classes.push(this.parseClass(bytes_array, constant_pool));
        }
        return new this(classes);
    };
    InnerClasses.parseClass = function (byteStream, constantPool) {
        return {
            innerInfoIndex: byteStream.getUint16(),
            outerInfoIndex: byteStream.getUint16(),
            innerNameIndex: byteStream.getUint16(),
            innerAccessFlags: byteStream.getUint16()
        };
    };
    return InnerClasses;
})();
exports.InnerClasses = InnerClasses;
var ConstantValue = (function () {
    function ConstantValue(value) {
        this.value = value;
    }
    ConstantValue.prototype.getName = function () {
        return 'ConstantValue';
    };
    ConstantValue.parse = function (bytes_array, constant_pool) {
        var ref = bytes_array.getUint16();
        return new this(constant_pool.get(ref));
    };
    return ConstantValue;
})();
exports.ConstantValue = ConstantValue;
var Synthetic = (function () {
    function Synthetic() {
    }
    Synthetic.prototype.getName = function () {
        return 'Synthetic';
    };
    Synthetic.parse = function (byteStream, constantPool) {
        return new this();
    };
    return Synthetic;
})();
exports.Synthetic = Synthetic;
var Deprecated = (function () {
    function Deprecated() {
    }
    Deprecated.prototype.getName = function () {
        return 'Deprecated';
    };
    Deprecated.parse = function (byteStream, constantPool) {
        return new this();
    };
    return Deprecated;
})();
exports.Deprecated = Deprecated;
var Signature = (function () {
    function Signature(sig) {
        this.sig = sig;
    }
    Signature.prototype.getName = function () {
        return 'Signature';
    };
    Signature.parse = function (byteStream, constantPool) {
        return new this(constantPool.get(byteStream.getUint16()).value);
    };
    return Signature;
})();
exports.Signature = Signature;
var RuntimeVisibleAnnotations = (function () {
    function RuntimeVisibleAnnotations(rawBytes, isHidden, isCallerSensitive, isCompiled) {
        this.rawBytes = rawBytes;
        this.isHidden = isHidden;
        this.isCallerSensitive = isCallerSensitive;
        this.isCompiled = isCompiled;
    }
    RuntimeVisibleAnnotations.prototype.getName = function () {
        return 'RuntimeVisibleAnnotations';
    };
    RuntimeVisibleAnnotations.parse = function (byteStream, constantPool, attrLen) {
        // No need to parse; OpenJDK parses these from within Java code from
        // the raw bytes.
        // ...but we need to look for the 'Hidden' annotation, which specifies if
        // the method should be omitted from stack frames.
        // And the 'compiled' annotation, which specifies if the method was
        // compiled.
        // And the 'CallerSensitive' annotation, which specifies that the function's
        // behavior differs depending on the caller.
        /**
         * Skip the current RuntimeVisibleAnnotation.
         */
        function skipAnnotation() {
            byteStream.skip(2); // type index
            var numValuePairs = byteStream.getUint16(), i;
            for (i = 0; i < numValuePairs; i++) {
                byteStream.skip(2); // element name index
                skipElementValue();
            }
        }
        /**
         * Skip this particular element value.
         */
        function skipElementValue() {
            var tag = String.fromCharCode(byteStream.getUint8());
            switch (tag) {
                case 'e':
                    // Fall-through.
                    byteStream.skip(2);
                case 'Z':
                case 'B':
                case 'C':
                case 'S':
                case 'I':
                case 'F':
                case 'J':
                case 'D':
                case 's':
                case 'c':
                    byteStream.skip(2);
                    break;
                case '@':
                    skipAnnotation();
                    break;
                case '[':
                    var numValues = byteStream.getUint16(), i;
                    for (i = 0; i < numValues; i++) {
                        skipElementValue();
                    }
                    break;
            }
        }
        var rawBytes = byteStream.read(attrLen), isHidden = false, isCompiled = false, isCallerSensitive = false;
        byteStream.seek(byteStream.pos() - rawBytes.length);
        var numAttributes = byteStream.getUint16(), i;
        for (i = 0; i < numAttributes; i++) {
            var typeName = constantPool.get(byteStream.getUint16());
            // Rewind.
            byteStream.seek(byteStream.pos() - 2);
            skipAnnotation();
            switch (typeName.value) {
                case 'Ljava/lang/invoke/LambdaForm$Hidden;':
                    isHidden = true;
                    break;
                case 'Lsig/sun/reflect/CallerSensitive;':
                    isCallerSensitive = true;
                    break;
                case 'Lsig/java/lang/invoke/LambdaForm$Compiled':
                    isCompiled = true;
                    break;
            }
        }
        return new this(rawBytes, isHidden, isCallerSensitive, isCompiled);
    };
    return RuntimeVisibleAnnotations;
})();
exports.RuntimeVisibleAnnotations = RuntimeVisibleAnnotations;
var AnnotationDefault = (function () {
    function AnnotationDefault(rawBytes) {
        this.rawBytes = rawBytes;
    }
    AnnotationDefault.prototype.getName = function () {
        return 'AnnotationDefault';
    };
    AnnotationDefault.parse = function (byteStream, constantPool, attrLen) {
        return new this(byteStream.read(attrLen));
    };
    return AnnotationDefault;
})();
exports.AnnotationDefault = AnnotationDefault;
var EnclosingMethod = (function () {
    function EnclosingMethod(encClass, encMethod) {
        this.encClass = encClass;
        this.encMethod = encMethod;
    }
    EnclosingMethod.prototype.getName = function () {
        return 'EnclosingMethod';
    };
    EnclosingMethod.parse = function (byteStream, constantPool) {
        var encClass = constantPool.get(byteStream.getUint16()), methodRef = byteStream.getUint16(), encMethod = null;
        if (methodRef > 0) {
            encMethod = constantPool.get(methodRef);
            assert(encMethod.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE, "Enclosing method must be a name and type info.");
        }
        return new this(encClass, encMethod);
    };
    return EnclosingMethod;
})();
exports.EnclosingMethod = EnclosingMethod;
var BootstrapMethods = (function () {
    function BootstrapMethods(bootstrapMethods) {
        this.bootstrapMethods = bootstrapMethods;
    }
    BootstrapMethods.prototype.getName = function () {
        return 'BootstrapMethods';
    };
    BootstrapMethods.parse = function (byteStream, constantPool) {
        var numBootstrapMethods = byteStream.getUint16(), bootstrapMethods = [];
        for (var i = 0; i < numBootstrapMethods; i++) {
            var methodHandle = constantPool.get(byteStream.getUint16());
            var numArgs = byteStream.getUint16();
            var args = [];
            for (var j = 0; j < numArgs; j++) {
                args.push(constantPool.get(byteStream.getUint16()));
            }
            bootstrapMethods.push([methodHandle, args]);
        }
        return new this(bootstrapMethods);
    };
    return BootstrapMethods;
})();
exports.BootstrapMethods = BootstrapMethods;
var RuntimeVisibleParameterAnnotations = (function () {
    function RuntimeVisibleParameterAnnotations(rawBytes) {
        this.rawBytes = rawBytes;
    }
    RuntimeVisibleParameterAnnotations.prototype.getName = function () {
        return 'RuntimeVisibleParameterAnnotations';
    };
    RuntimeVisibleParameterAnnotations.parse = function (byteStream, constantPool, attrLen) {
        return new this(byteStream.read(attrLen));
    };
    return RuntimeVisibleParameterAnnotations;
})();
exports.RuntimeVisibleParameterAnnotations = RuntimeVisibleParameterAnnotations;
function makeAttributes(byteStream, constantPool) {
    var attrTypes = {
        'Code': Code,
        'LineNumberTable': LineNumberTable,
        'SourceFile': SourceFile,
        'StackMapTable': StackMapTable,
        'LocalVariableTable': LocalVariableTable,
        'LocalVariableTypeTable': LocalVariableTypeTable,
        'ConstantValue': ConstantValue,
        'Exceptions': Exceptions,
        'InnerClasses': InnerClasses,
        'Synthetic': Synthetic,
        'Deprecated': Deprecated,
        'Signature': Signature,
        'RuntimeVisibleAnnotations': RuntimeVisibleAnnotations,
        'AnnotationDefault': AnnotationDefault,
        'EnclosingMethod': EnclosingMethod,
        'BootstrapMethods': BootstrapMethods,
        'RuntimeVisibleParameterAnnotations': RuntimeVisibleParameterAnnotations
    };
    var numAttrs = byteStream.getUint16();
    var attrs = [];
    for (var i = 0; i < numAttrs; i++) {
        var name = constantPool.get(byteStream.getUint16()).value;
        var attrLen = byteStream.getUint32();
        if (attrTypes[name] != null) {
            var oldLen = byteStream.size();
            var attr = attrTypes[name].parse(byteStream, constantPool, attrLen, name);
            var newLen = byteStream.size();
            assert((oldLen - newLen) <= attrLen, "A parsed attribute read beyond its data! " + name);
            if (oldLen - newLen !== attrLen) {
                byteStream.skip(attrLen - oldLen + newLen);
            }
            attrs.push(attr);
        }
        else {
            // we must silently ignore other attrs
            byteStream.skip(attrLen);
        }
    }
    return attrs;
}
exports.makeAttributes = makeAttributes;

},{"./assert":26,"./enums":31,"./global":33,"./util":47}],28:[function(_dereq_,module,exports){
(function (global){
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var enums_1 = _dereq_('./enums');
var assert = _dereq_('./assert');
var fs = _dereq_('fs');
var path = _dereq_('path');
var BrowserFS = (typeof window !== "undefined" ? window['BrowserFS'] : typeof global !== "undefined" ? global['BrowserFS'] : null);
var util = _dereq_('./util');
var BFSFS = BrowserFS.BFSRequire('fs');
var ZipFS = BrowserFS.FileSystem.ZipFS;
function win2nix(p) {
    return p.replace(/\\/g, '/');
}
/**
 * Represents a JAR file on the classpath.
 */
var AbstractClasspathJar = (function () {
    function AbstractClasspathJar(path) {
        this._fs = new BFSFS.FS();
        /**
         * Was the JAR file successfully read?
         * - TRUE: JAR file is read and mounted in this._fs.
         * - FALSE: JAR file could not be read.
         * - INDETERMINATE: We have yet to try reading this JAR file.
         */
        this._jarRead = enums_1.TriState.INDETERMINATE;
        this._path = path;
    }
    AbstractClasspathJar.prototype.getPath = function () { return this._path; };
    AbstractClasspathJar.prototype.loadJar = function (cb) {
        var _this = this;
        if (this._jarRead !== enums_1.TriState.TRUE) {
            fs.readFile(this._path, function (e, data) {
                if (e) {
                    _this._jarRead = enums_1.TriState.FALSE;
                    cb(e);
                }
                else {
                    try {
                        ZipFS.computeIndex(data, function (index) {
                            try {
                                _this._fs.initialize(new ZipFS(index, path.basename(_this._path)));
                                _this._jarRead = enums_1.TriState.TRUE;
                                cb();
                            }
                            catch (e) {
                                _this._jarRead = enums_1.TriState.FALSE;
                                cb(e);
                            }
                        });
                    }
                    catch (e) {
                        _this._jarRead = enums_1.TriState.FALSE;
                        cb(e);
                    }
                }
            });
        }
        else {
            setImmediate(function () { return cb(_this._jarRead === enums_1.TriState.TRUE ? null : new Error("Failed to load JAR file.")); });
        }
    };
    AbstractClasspathJar.prototype.tryLoadClassSync = function (type) {
        if (this._jarRead === enums_1.TriState.TRUE) {
            if (this.hasClass(type) !== enums_1.TriState.FALSE) {
                try {
                    // NOTE: Path must be absolute, otherwise BrowserFS
                    // will try to use process.cwd().
                    return this._fs.readFileSync("/" + type + ".class");
                }
                catch (e) {
                    return null;
                }
            }
            else {
                return null;
            }
        }
        else {
            // Must go the async route.
            return null;
        }
    };
    /**
     * Wrap an operation that depends on the jar being loaded.
     */
    AbstractClasspathJar.prototype._wrapOp = function (op, failCb) {
        var _this = this;
        switch (this._jarRead) {
            case enums_1.TriState.TRUE:
                op();
                break;
            case enums_1.TriState.FALSE:
                setImmediate(function () { return failCb(new Error("Unable to load JAR file.")); });
                break;
            default:
                this.loadJar(function () {
                    _this._wrapOp(op, failCb);
                });
                break;
        }
    };
    /**
     * Wrap a synchronous operation that depends on the jar being loaded.
     * Returns null if the jar isn't loaded, or if the operation fails.
     */
    AbstractClasspathJar.prototype._wrapSyncOp = function (op) {
        if (this._jarRead === enums_1.TriState.TRUE) {
            try {
                return op();
            }
            catch (e) {
                return null;
            }
        }
        else {
            return null;
        }
    };
    AbstractClasspathJar.prototype.loadClass = function (type, cb) {
        var _this = this;
        this._wrapOp(function () {
            // Path must be absolute to avoid relative path issues.
            _this._fs.readFile("/" + type + ".class", cb);
        }, cb);
    };
    AbstractClasspathJar.prototype.statResource = function (p, cb) {
        var _this = this;
        this._wrapOp(function () {
            _this._fs.stat(p, cb);
        }, cb);
    };
    AbstractClasspathJar.prototype.readdir = function (p, cb) {
        var _this = this;
        this._wrapOp(function () {
            _this._fs.readdir(win2nix(p), cb);
        }, cb);
    };
    AbstractClasspathJar.prototype.tryReaddirSync = function (p) {
        var _this = this;
        return this._wrapSyncOp(function () {
            return _this._fs.readdirSync(win2nix(p));
        });
    };
    AbstractClasspathJar.prototype.tryStatSync = function (p) {
        var _this = this;
        return this._wrapSyncOp(function () {
            return _this._fs.statSync(win2nix(p));
        });
    };
    AbstractClasspathJar.prototype.getFS = function () {
        return this._fs.getRootFS();
    };
    return AbstractClasspathJar;
})();
exports.AbstractClasspathJar = AbstractClasspathJar;
/**
 * A JAR item on the classpath that is not in the meta index.
 */
var UnindexedClasspathJar = (function (_super) {
    __extends(UnindexedClasspathJar, _super);
    function UnindexedClasspathJar(p) {
        _super.call(this, p);
        // Contains the list of classes accessible from this classpath item.
        this._classList = null;
    }
    UnindexedClasspathJar.prototype.hasClass = function (type) {
        if (this._jarRead === enums_1.TriState.FALSE) {
            return enums_1.TriState.FALSE;
        }
        else {
            return this._hasClass(type);
        }
    };
    UnindexedClasspathJar.prototype._hasClass = function (type) {
        if (this._classList) {
            return this._classList[type] ? enums_1.TriState.TRUE : enums_1.TriState.FALSE;
        }
        return enums_1.TriState.INDETERMINATE;
    };
    /**
     * Initialize this item on the classpath with the given classlist.
     * @param classes List of classes in pkg/path/Name format.
     */
    UnindexedClasspathJar.prototype.initializeWithClasslist = function (classes) {
        assert(this._classList === null, "Initializing a classpath item twice!");
        this._classList = {};
        var len = classes.length;
        for (var i = 0; i < len; i++) {
            this._classList[classes[i]] = true;
        }
    };
    UnindexedClasspathJar.prototype.initialize = function (cb) {
        var _this = this;
        this.loadJar(function (err) {
            if (err) {
                cb();
            }
            else {
                var pathStack = ['/'];
                var classlist = [];
                var fs_1 = _this._fs;
                while (pathStack.length > 0) {
                    var p = pathStack.pop();
                    try {
                        var stat = fs_1.statSync(p);
                        if (stat.isDirectory()) {
                            var listing = fs_1.readdirSync(p);
                            for (var i = 0; i < listing.length; i++) {
                                pathStack.push(path.join(p, listing[i]));
                            }
                        }
                        else if (path.extname(p) === '.class') {
                            // Cut off initial / from absolute path.
                            classlist.push(p.slice(1, p.length - 6));
                        }
                    }
                    catch (e) {
                    }
                }
                _this.initializeWithClasslist(classlist);
                cb();
            }
        });
    };
    return UnindexedClasspathJar;
})(AbstractClasspathJar);
exports.UnindexedClasspathJar = UnindexedClasspathJar;
/**
 * A JAR file on the classpath that is in the meta-index.
 */
var IndexedClasspathJar = (function (_super) {
    __extends(IndexedClasspathJar, _super);
    function IndexedClasspathJar(metaIndex, p) {
        _super.call(this, p);
        this._metaIndex = metaIndex;
        this._metaName = path.basename(p);
    }
    IndexedClasspathJar.prototype.initialize = function (cb) {
        setImmediate(function () { return cb(); });
    };
    IndexedClasspathJar.prototype.hasClass = function (type) {
        if (this._jarRead === enums_1.TriState.FALSE) {
            return enums_1.TriState.FALSE;
        }
        else {
            var pkgComponents = type.split('/');
            var search = this._metaIndex;
            // Pop off class name.
            pkgComponents.pop();
            for (var i = 0; i < pkgComponents.length; i++) {
                var item = search[pkgComponents[i]];
                if (!item) {
                    // item === undefined or false.
                    return enums_1.TriState.FALSE;
                }
                else if (item === true) {
                    return enums_1.TriState.INDETERMINATE;
                }
                else {
                    // Must be an object.
                    search = item;
                }
            }
            // Assume meta-index is complete.
            return enums_1.TriState.FALSE;
        }
    };
    return IndexedClasspathJar;
})(AbstractClasspathJar);
exports.IndexedClasspathJar = IndexedClasspathJar;
/**
 * Represents a folder on the classpath.
 */
var ClasspathFolder = (function () {
    function ClasspathFolder(path) {
        this._path = path;
    }
    ClasspathFolder.prototype.getPath = function () { return this._path; };
    ClasspathFolder.prototype.hasClass = function (type) {
        return enums_1.TriState.INDETERMINATE;
    };
    ClasspathFolder.prototype.initialize = function (cb) {
        // NOP.
        setImmediate(cb);
    };
    ClasspathFolder.prototype.tryLoadClassSync = function (type) {
        try {
            return fs.readFileSync(path.resolve(this._path, type + ".class"));
        }
        catch (e) {
            return null;
        }
    };
    ClasspathFolder.prototype.loadClass = function (type, cb) {
        fs.readFile(path.resolve(this._path, type + ".class"), cb);
    };
    ClasspathFolder.prototype.statResource = function (p, cb) {
        fs.stat(path.resolve(this._path, p), cb);
    };
    ClasspathFolder.prototype.readdir = function (p, cb) {
        fs.readdir(path.resolve(this._path, p), cb);
    };
    ClasspathFolder.prototype.tryReaddirSync = function (p) {
        try {
            return fs.readdirSync(path.resolve(this._path, p));
        }
        catch (e) {
            return null;
        }
    };
    ClasspathFolder.prototype.tryStatSync = function (p) {
        try {
            return fs.statSync(path.resolve(this._path, p));
        }
        catch (e) {
            return null;
        }
    };
    return ClasspathFolder;
})();
exports.ClasspathFolder = ClasspathFolder;
/**
 * Represents a classpath item that cannot be found.
 */
var ClasspathNotFound = (function () {
    function ClasspathNotFound(path) {
        this._path = path;
    }
    ClasspathNotFound.prototype.getPath = function () { return this._path; };
    ClasspathNotFound.prototype.hasClass = function (type) { return enums_1.TriState.FALSE; };
    ClasspathNotFound.prototype.initialize = function (cb) { setImmediate(cb); };
    ClasspathNotFound.prototype.initializeWithClasslist = function (classlist) { };
    ClasspathNotFound.prototype.tryLoadClassSync = function (type) { return null; };
    ClasspathNotFound.prototype._notFoundError = function (cb) { setImmediate(function () { return cb(new Error("Class cannot be found.")); }); };
    ClasspathNotFound.prototype.loadClass = function (type, cb) { this._notFoundError(cb); };
    ClasspathNotFound.prototype.statResource = function (p, cb) { this._notFoundError(cb); };
    ClasspathNotFound.prototype.readdir = function (p, cb) { this._notFoundError(cb); };
    ClasspathNotFound.prototype.tryReaddirSync = function (p) { return null; };
    ClasspathNotFound.prototype.tryStatSync = function (p) { return null; };
    return ClasspathNotFound;
})();
exports.ClasspathNotFound = ClasspathNotFound;
/**
 * Parse the meta index into a lookup table from package name (with slashes) to JAR file.
 * Returns a tuple of JAR files in the meta index and the meta index.
 */
function parseMetaIndex(metaIndex) {
    var lines = metaIndex.split("\n");
    var rv = {};
    var currentJar = null;
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line.length > 0) {
            switch (line[0]) {
                case '%':
                case '@':
                    // Comment or resource-only JAR file.
                    continue;
                case '!':
                case '#':
                    // JAR file w/ classes.
                    // Skip symbol and space.
                    var jarName = line.slice(2);
                    rv[jarName] = currentJar = {};
                    break;
                default:
                    // Package name. If it ends with /, then it's shared
                    // amongst multiple JAR files.
                    // We don't treat those separately, though, so standardize it.
                    if (line[line.length - 1] === '/') {
                        line = line.slice(0, line.length - 1);
                    }
                    var pkgComponents = line.split('/');
                    var current = currentJar;
                    var i_1 = void 0;
                    for (i_1 = 0; i_1 < pkgComponents.length - 1; i_1++) {
                        var cmp = pkgComponents[i_1], next = current[cmp];
                        if (!next) {
                            current = current[cmp] = {};
                        }
                        else {
                            // Invariant: You can't list a package and its subpackages
                            // for same jar file. Thus, current[cmp] cannot be a boolean.
                            current = current[cmp];
                        }
                    }
                    current[pkgComponents[i_1]] = true;
                    break;
            }
        }
    }
    return rv;
}
/**
 * Given a list of paths (which may or may not exist), produces a list of
 * classpath objects.
 */
function ClasspathFactory(javaHomePath, paths, cb) {
    var classpathItems = new Array(paths.length), i = 0;
    fs.readFile(path.join(javaHomePath, 'lib', 'meta-index'), function (err, data) {
        var metaIndex = {};
        if (!err) {
            metaIndex = parseMetaIndex(data.toString());
        }
        util.asyncForEach(paths, function (p, nextItem) {
            var pRelToHome = path.relative(javaHomePath + "/lib", p);
            fs.stat(p, function (err, stats) {
                var cpItem;
                if (err) {
                    cpItem = new ClasspathNotFound(p);
                }
                else if (stats.isDirectory()) {
                    cpItem = new ClasspathFolder(p);
                }
                else {
                    if (metaIndex[pRelToHome]) {
                        cpItem = new IndexedClasspathJar(metaIndex[pRelToHome], p);
                    }
                    else {
                        cpItem = new UnindexedClasspathJar(p);
                    }
                }
                classpathItems[i++] = cpItem;
                cpItem.initialize(nextItem);
            });
        }, function (e) {
            cb(classpathItems);
        });
    });
}
exports.ClasspathFactory = ClasspathFactory;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./assert":26,"./enums":31,"./util":47,"fs":13,"path":14}],29:[function(_dereq_,module,exports){
/***
This is modified from part of jsdifflib v1.0. <http://snowtide.com/jsdifflib>

Copyright (c) 2007, Snowtide Informatics Systems, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this
        list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.
    * Neither the name of the Snowtide Informatics Systems nor the names of its
        contributors may be used to endorse or promote products derived from this
        software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
***/
/* Original author: Chas Emerick <cemerick@snowtide.com> */
function text_diff(a_lines, b_lines, context) {
    return (new SequenceMatcher(a_lines, b_lines)).text_diff(context);
}
exports.text_diff = text_diff;
// comparison function for sorting lists of numeric tuples
function __ntuplecomp(a, b) {
    var mlen = Math.max(a.length, b.length);
    for (var i = 0; i < mlen; i++) {
        if (a[i] < b[i])
            return -1;
        if (a[i] > b[i])
            return 1;
    }
    return a.length == b.length ? 0 : (a.length < b.length ? -1 : 1);
}
// replacement for python's dict.get function -- need easy default values
function __dictget(dict, key, defaultValue) {
    return dict.hasOwnProperty(key) ? dict[key] : defaultValue;
}
var SequenceMatcher = (function () {
    function SequenceMatcher(a, b) {
        this.a = a;
        this.b = b;
        this.b2j = {};
        for (var i = 0; i < b.length; i++) {
            var elt = b[i];
            if (this.b2j.hasOwnProperty(elt)) {
                this.b2j[elt].push(i);
            }
            else {
                this.b2j[elt] = [i];
            }
        }
    }
    SequenceMatcher.prototype.find_longest_match = function (alo, ahi, blo, bhi) {
        var a = this.a;
        var b = this.b;
        var b2j = this.b2j;
        var besti = alo;
        var bestj = blo;
        var bestsize = 0;
        var j2len = {};
        for (var i = alo; i < ahi; i++) {
            var newj2len = {};
            var jdict = __dictget(b2j, a[i], []);
            for (var jkey in jdict) {
                if (jdict.hasOwnProperty(jkey)) {
                    var j = jdict[jkey];
                    if (j < blo)
                        continue;
                    if (j >= bhi)
                        break;
                    var k = __dictget(j2len, j - 1, 0) + 1;
                    newj2len[j] = k;
                    if (k > bestsize) {
                        besti = i - k + 1;
                        bestj = j - k + 1;
                        bestsize = k;
                    }
                }
            }
            j2len = newj2len;
        }
        while (besti > alo && bestj > blo && a[besti - 1] == b[bestj - 1]) {
            besti--;
            bestj--;
            bestsize++;
        }
        while (besti + bestsize < ahi && bestj + bestsize < bhi &&
            a[besti + bestsize] == b[bestj + bestsize]) {
            bestsize++;
        }
        return [besti, bestj, bestsize];
    };
    SequenceMatcher.prototype.get_matching_blocks = function () {
        if (this.matching_blocks != null)
            return this.matching_blocks;
        var la = this.a.length;
        var lb = this.b.length;
        var queue = [[0, la, 0, lb]];
        var matching_blocks = [];
        while (queue.length) {
            var qi = queue.pop();
            var alo = qi[0];
            var ahi = qi[1];
            var blo = qi[2];
            var bhi = qi[3];
            var x = this.find_longest_match(alo, ahi, blo, bhi);
            var i = x[0];
            var j = x[1];
            var k = x[2];
            if (k) {
                matching_blocks.push(x);
                if (alo < i && blo < j)
                    queue.push([alo, i, blo, j]);
                if (i + k < ahi && j + k < bhi)
                    queue.push([i + k, ahi, j + k, bhi]);
            }
        }
        matching_blocks.sort(__ntuplecomp);
        var i1 = 0, j1 = 0, k1 = 0;
        var non_adjacent = [];
        for (var idx = 0; idx < matching_blocks.length; idx++) {
            var block = matching_blocks[idx];
            var i2 = block[0];
            var j2 = block[1];
            var k2 = block[2];
            if (i1 + k1 == i2 && j1 + k1 == j2) {
                k1 += k2;
            }
            else {
                if (k1)
                    non_adjacent.push([i1, j1, k1]);
                i1 = i2;
                j1 = j2;
                k1 = k2;
            }
        }
        if (k1)
            non_adjacent.push([i1, j1, k1]);
        non_adjacent.push([la, lb, 0]);
        this.matching_blocks = non_adjacent;
        return this.matching_blocks;
    };
    SequenceMatcher.prototype.get_opcodes = function () {
        if (this.opcodes != null)
            return this.opcodes;
        var i = 0;
        var j = 0;
        var answer = [];
        this.opcodes = answer;
        var blocks = this.get_matching_blocks();
        for (var idx = 0; idx < blocks.length; idx++) {
            var block = blocks[idx];
            var ai = block[0];
            var bj = block[1];
            var size = block[2];
            var tag = '';
            if (i < ai && j < bj) {
                tag = 'replace';
            }
            else if (i < ai) {
                tag = 'delete';
            }
            else if (j < bj) {
                tag = 'insert';
            }
            if (tag)
                answer.push([tag, i, ai, j, bj]);
            i = ai + size;
            j = bj + size;
            if (size)
                answer.push(['equal', ai, i, bj, j]);
        }
        return answer;
    };
    SequenceMatcher.prototype.text_diff = function (context) {
        var opcodes = this.get_opcodes();
        var diff = [];
        var a_side = [];
        var b_side = [];
        var a_max_len = 0;
        var last_seen = -1;
        for (var op_idx = 0; op_idx < opcodes.length; op_idx++) {
            var op = opcodes[op_idx];
            if (op[0] === 'equal')
                continue;
            var ai = op[1];
            var bi = op[3];
            var aj = op[2] - 1;
            var bj = op[4] - 1;
            var start = Math.min(ai, bi);
            var end = Math.max(aj, bj);
            var c = '';
            switch (op[0]) {
                case 'delete':
                    c = ' < ';
                    break;
                case 'insert':
                    c = ' > ';
                    break;
                case 'replace':
                    c = ' | ';
                    break;
            }
            for (var i = Math.max(last_seen + 1, start - context); i < start; i++) {
                var prefix = i + ': ';
                if (i < this.a.length) {
                    a_side.push(prefix + this.a[i]);
                    a_max_len = Math.max(a_max_len, this.a[i].length + prefix.length);
                }
                else {
                    a_side.push(prefix);
                }
                if (i < this.b.length) {
                    b_side.push(this.b[i]);
                }
                else {
                    b_side.push('');
                }
                diff.push('   ');
            }
            for (var i = start; i <= end; i++) {
                var prefix = i + ': ';
                if (i >= ai && i <= aj) {
                    a_side.push(prefix + this.a[i]);
                    a_max_len = Math.max(a_max_len, this.a[i].length + prefix.length);
                }
                else {
                    a_side.push(prefix);
                }
                if (i >= bi && i <= bj) {
                    b_side.push(this.b[i]);
                }
                else {
                    b_side.push('');
                }
                diff.push(c);
            }
            last_seen = end;
        }
        for (var i = 0; i < diff.length; i++) {
            var a = a_side[i];
            var b = b_side[i];
            if (a.length < a_max_len)
                a += (new Array(a_max_len - a.length + 1)).join(' ');
            diff[i] = a + diff[i] + b;
        }
        return diff;
    };
    return SequenceMatcher;
})();
exports.SequenceMatcher = SequenceMatcher;

},{}],30:[function(_dereq_,module,exports){
/**
 * Top-level doppio interface. Exposed through the `DoppioJVM` global.
 */
var Testing = _dereq_('./testing');
exports.Testing = Testing;
var Heap = _dereq_('./heap');
exports.Heap = Heap;
var VM = _dereq_('./VM');
exports.VM = VM;
var Debug = _dereq_('./Debug');
exports.Debug = Debug;

},{"./Debug":21,"./VM":25,"./heap":34,"./testing":44}],31:[function(_dereq_,module,exports){
"use strict";
/**
 * A class can be in one of these states at any given point in time.
 */
(function (ClassState) {
    // The class has yet to be loaded.
    ClassState[ClassState["NOT_LOADED"] = 0] = "NOT_LOADED";
    // The class's definition has been downloaded and parsed.
    ClassState[ClassState["LOADED"] = 1] = "LOADED";
    // This class and its super classes' definitions have been downloaded and
    // parsed.
    ClassState[ClassState["RESOLVED"] = 2] = "RESOLVED";
    // This class, its super classes', and its interfaces have been downloaded,
    // parsed, and statically initialized.
    ClassState[ClassState["INITIALIZED"] = 3] = "INITIALIZED";
})(exports.ClassState || (exports.ClassState = {}));
var ClassState = exports.ClassState;
/**
 * A thread can be in one of these states at any given point in time.
 *
 * NOTE: When altering ThreadStatus, remember to update the following things.
 *
 * - Thread.validTransitions: Describes each valid thread transition.
 * - sun.misc.VM.getThreadStateValues: Maps ThreadStatus values to Thread.State
 *   values.
 * - Assertion statements in Thread regarding its status.
 */
(function (ThreadStatus) {
    // A thread that has not yet started is in this state.
    ThreadStatus[ThreadStatus["NEW"] = 0] = "NEW";
    // A thread that is able to be run. The thread may actually be running.
    // Query the ThreadPool to determine if this is the case.
    ThreadStatus[ThreadStatus["RUNNABLE"] = 1] = "RUNNABLE";
    // A thread that is blocked waiting for a monitor lock is in this state.
    ThreadStatus[ThreadStatus["BLOCKED"] = 2] = "BLOCKED";
    // A thread that is blocked waiting for a monitor lock that was previously
    // interrupted from waiting on a monitor is in this state.
    // Why? Well, the thread has *already* been interrupted once, but cannot
    // process the interruption until it regains the lock.
    ThreadStatus[ThreadStatus["UNINTERRUPTABLY_BLOCKED"] = 3] = "UNINTERRUPTABLY_BLOCKED";
    // A thread that is waiting indefinitely for another thread to perform a
    // particular action is in this state.
    ThreadStatus[ThreadStatus["WAITING"] = 4] = "WAITING";
    // A thread that is waiting for another thread to perform an action for up to
    // a specified waiting time is in this state.
    ThreadStatus[ThreadStatus["TIMED_WAITING"] = 5] = "TIMED_WAITING";
    // A thread that is waiting for an asynchronous browser operation to complete.
    ThreadStatus[ThreadStatus["ASYNC_WAITING"] = 6] = "ASYNC_WAITING";
    // A thread that is parked.
    ThreadStatus[ThreadStatus["PARKED"] = 7] = "PARKED";
    // A thread that has exited is in this state.
    ThreadStatus[ThreadStatus["TERMINATED"] = 8] = "TERMINATED";
})(exports.ThreadStatus || (exports.ThreadStatus = {}));
var ThreadStatus = exports.ThreadStatus;
/**
 * Java-visible thread state values.
 */
(function (JVMTIThreadState) {
    JVMTIThreadState[JVMTIThreadState["ALIVE"] = 1] = "ALIVE";
    JVMTIThreadState[JVMTIThreadState["TERMINATED"] = 2] = "TERMINATED";
    JVMTIThreadState[JVMTIThreadState["RUNNABLE"] = 4] = "RUNNABLE";
    JVMTIThreadState[JVMTIThreadState["BLOCKED_ON_MONITOR_ENTER"] = 1024] = "BLOCKED_ON_MONITOR_ENTER";
    JVMTIThreadState[JVMTIThreadState["WAITING_INDEFINITELY"] = 16] = "WAITING_INDEFINITELY";
    JVMTIThreadState[JVMTIThreadState["WAITING_WITH_TIMEOUT"] = 32] = "WAITING_WITH_TIMEOUT";
})(exports.JVMTIThreadState || (exports.JVMTIThreadState = {}));
var JVMTIThreadState = exports.JVMTIThreadState;
/**
 * Three-state boolean.
 */
(function (TriState) {
    TriState[TriState["TRUE"] = 0] = "TRUE";
    TriState[TriState["FALSE"] = 1] = "FALSE";
    TriState[TriState["INDETERMINATE"] = 2] = "INDETERMINATE";
})(exports.TriState || (exports.TriState = {}));
var TriState = exports.TriState;
/**
 * The current status of the JVM.
 */
(function (JVMStatus) {
    // The JVM is booting up.
    JVMStatus[JVMStatus["BOOTING"] = 0] = "BOOTING";
    // The JVM is booted, and waiting for a class to run.
    JVMStatus[JVMStatus["BOOTED"] = 1] = "BOOTED";
    // The JVM is running.
    JVMStatus[JVMStatus["RUNNING"] = 2] = "RUNNING";
    // The JVM has completed running, and is performing termination steps.
    JVMStatus[JVMStatus["TERMINATING"] = 3] = "TERMINATING";
    // The JVM is completely finished executing.
    JVMStatus[JVMStatus["TERMINATED"] = 4] = "TERMINATED";
})(exports.JVMStatus || (exports.JVMStatus = {}));
var JVMStatus = exports.JVMStatus;
/**
 * Indicates the type of a stack frame.
 */
(function (StackFrameType) {
    /**
     * A JVM internal stack frame. These should be completely invisible to the
     * JVM program.
     */
    StackFrameType[StackFrameType["INTERNAL"] = 0] = "INTERNAL";
    /**
     * A bytecode method's stack frame. These have an actual stack.
     */
    StackFrameType[StackFrameType["BYTECODE"] = 1] = "BYTECODE";
    /**
     * A native method's stack frame. These typically consist of just a JavaScript
     * function and a method association.
     */
    StackFrameType[StackFrameType["NATIVE"] = 2] = "NATIVE";
})(exports.StackFrameType || (exports.StackFrameType = {}));
var StackFrameType = exports.StackFrameType;
/**
 * Various constant values. Enum'd so they are inlined by the TypeScript
 * compiler.
 */
(function (Constants) {
    Constants[Constants["INT_MAX"] = Math.pow(2, 31) - 1] = "INT_MAX";
    Constants[Constants["INT_MIN"] = -Constants.INT_MAX - 1] = "INT_MIN";
    Constants[Constants["FLOAT_POS_INFINITY"] = Math.pow(2, 128)] = "FLOAT_POS_INFINITY";
    Constants[Constants["FLOAT_NEG_INFINITY"] = -1 * Constants.FLOAT_POS_INFINITY] = "FLOAT_NEG_INFINITY";
    Constants[Constants["FLOAT_POS_INFINITY_AS_INT"] = 2139095040] = "FLOAT_POS_INFINITY_AS_INT";
    Constants[Constants["FLOAT_NEG_INFINITY_AS_INT"] = -8388608] = "FLOAT_NEG_INFINITY_AS_INT";
    // We use the JavaScript NaN as our NaN value, and convert it to
    // a NaN value in the SNaN range when an int equivalent is requested.
    Constants[Constants["FLOAT_NaN_AS_INT"] = 2143289344] = "FLOAT_NaN_AS_INT";
})(exports.Constants || (exports.Constants = {}));
var Constants = exports.Constants;
/**
 * Integer indicating the type of a constant pool item.
 * @url https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4-140
 */
(function (ConstantPoolItemType) {
    ConstantPoolItemType[ConstantPoolItemType["CLASS"] = 7] = "CLASS";
    ConstantPoolItemType[ConstantPoolItemType["FIELDREF"] = 9] = "FIELDREF";
    ConstantPoolItemType[ConstantPoolItemType["METHODREF"] = 10] = "METHODREF";
    ConstantPoolItemType[ConstantPoolItemType["INTERFACE_METHODREF"] = 11] = "INTERFACE_METHODREF";
    ConstantPoolItemType[ConstantPoolItemType["STRING"] = 8] = "STRING";
    ConstantPoolItemType[ConstantPoolItemType["INTEGER"] = 3] = "INTEGER";
    ConstantPoolItemType[ConstantPoolItemType["FLOAT"] = 4] = "FLOAT";
    ConstantPoolItemType[ConstantPoolItemType["LONG"] = 5] = "LONG";
    ConstantPoolItemType[ConstantPoolItemType["DOUBLE"] = 6] = "DOUBLE";
    ConstantPoolItemType[ConstantPoolItemType["NAME_AND_TYPE"] = 12] = "NAME_AND_TYPE";
    ConstantPoolItemType[ConstantPoolItemType["UTF8"] = 1] = "UTF8";
    ConstantPoolItemType[ConstantPoolItemType["METHOD_HANDLE"] = 15] = "METHOD_HANDLE";
    ConstantPoolItemType[ConstantPoolItemType["METHOD_TYPE"] = 16] = "METHOD_TYPE";
    ConstantPoolItemType[ConstantPoolItemType["INVOKE_DYNAMIC"] = 18] = "INVOKE_DYNAMIC";
})(exports.ConstantPoolItemType || (exports.ConstantPoolItemType = {}));
var ConstantPoolItemType = exports.ConstantPoolItemType;
/**
 * Integer indicating the type of a StackMapTable entry.
 * @see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.4
 */
(function (StackMapTableEntryType) {
    StackMapTableEntryType[StackMapTableEntryType["SAME_FRAME"] = 0] = "SAME_FRAME";
    StackMapTableEntryType[StackMapTableEntryType["SAME_LOCALS_1_STACK_ITEM_FRAME"] = 1] = "SAME_LOCALS_1_STACK_ITEM_FRAME";
    StackMapTableEntryType[StackMapTableEntryType["SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED"] = 2] = "SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED";
    StackMapTableEntryType[StackMapTableEntryType["CHOP_FRAME"] = 3] = "CHOP_FRAME";
    StackMapTableEntryType[StackMapTableEntryType["SAME_FRAME_EXTENDED"] = 4] = "SAME_FRAME_EXTENDED";
    StackMapTableEntryType[StackMapTableEntryType["APPEND_FRAME"] = 5] = "APPEND_FRAME";
    StackMapTableEntryType[StackMapTableEntryType["FULL_FRAME"] = 6] = "FULL_FRAME";
})(exports.StackMapTableEntryType || (exports.StackMapTableEntryType = {}));
var StackMapTableEntryType = exports.StackMapTableEntryType;
/**
 * Integer indicating the reference type of a MethodHandle item in the constant
 * pool.
 * @see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8
 */
(function (MethodHandleReferenceKind) {
    MethodHandleReferenceKind[MethodHandleReferenceKind["GETFIELD"] = 1] = "GETFIELD";
    MethodHandleReferenceKind[MethodHandleReferenceKind["GETSTATIC"] = 2] = "GETSTATIC";
    MethodHandleReferenceKind[MethodHandleReferenceKind["PUTFIELD"] = 3] = "PUTFIELD";
    MethodHandleReferenceKind[MethodHandleReferenceKind["PUTSTATIC"] = 4] = "PUTSTATIC";
    MethodHandleReferenceKind[MethodHandleReferenceKind["INVOKEVIRTUAL"] = 5] = "INVOKEVIRTUAL";
    MethodHandleReferenceKind[MethodHandleReferenceKind["INVOKESTATIC"] = 6] = "INVOKESTATIC";
    MethodHandleReferenceKind[MethodHandleReferenceKind["INVOKESPECIAL"] = 7] = "INVOKESPECIAL";
    MethodHandleReferenceKind[MethodHandleReferenceKind["NEWINVOKESPECIAL"] = 8] = "NEWINVOKESPECIAL";
    MethodHandleReferenceKind[MethodHandleReferenceKind["INVOKEINTERFACE"] = 9] = "INVOKEINTERFACE";
})(exports.MethodHandleReferenceKind || (exports.MethodHandleReferenceKind = {}));
var MethodHandleReferenceKind = exports.MethodHandleReferenceKind;
/**
 * JVM op codes. The enum value corresponds to that opcode's value.
 */
(function (OpCode) {
    OpCode[OpCode["AALOAD"] = 50] = "AALOAD";
    OpCode[OpCode["AASTORE"] = 83] = "AASTORE";
    OpCode[OpCode["ACONST_NULL"] = 1] = "ACONST_NULL";
    OpCode[OpCode["ALOAD"] = 25] = "ALOAD";
    OpCode[OpCode["ALOAD_0"] = 42] = "ALOAD_0";
    OpCode[OpCode["ALOAD_1"] = 43] = "ALOAD_1";
    OpCode[OpCode["ALOAD_2"] = 44] = "ALOAD_2";
    OpCode[OpCode["ALOAD_3"] = 45] = "ALOAD_3";
    OpCode[OpCode["ANEWARRAY"] = 189] = "ANEWARRAY";
    OpCode[OpCode["ARETURN"] = 176] = "ARETURN";
    OpCode[OpCode["ARRAYLENGTH"] = 190] = "ARRAYLENGTH";
    OpCode[OpCode["ASTORE"] = 58] = "ASTORE";
    OpCode[OpCode["ASTORE_0"] = 75] = "ASTORE_0";
    OpCode[OpCode["ASTORE_1"] = 76] = "ASTORE_1";
    OpCode[OpCode["ASTORE_2"] = 77] = "ASTORE_2";
    OpCode[OpCode["ASTORE_3"] = 78] = "ASTORE_3";
    OpCode[OpCode["ATHROW"] = 191] = "ATHROW";
    OpCode[OpCode["BALOAD"] = 51] = "BALOAD";
    OpCode[OpCode["BASTORE"] = 84] = "BASTORE";
    OpCode[OpCode["BIPUSH"] = 16] = "BIPUSH";
    OpCode[OpCode["BREAKPOINT"] = 202] = "BREAKPOINT";
    OpCode[OpCode["CALOAD"] = 52] = "CALOAD";
    OpCode[OpCode["CASTORE"] = 85] = "CASTORE";
    OpCode[OpCode["CHECKCAST"] = 192] = "CHECKCAST";
    OpCode[OpCode["D2F"] = 144] = "D2F";
    OpCode[OpCode["D2I"] = 142] = "D2I";
    OpCode[OpCode["D2L"] = 143] = "D2L";
    OpCode[OpCode["DADD"] = 99] = "DADD";
    OpCode[OpCode["DALOAD"] = 49] = "DALOAD";
    OpCode[OpCode["DASTORE"] = 82] = "DASTORE";
    OpCode[OpCode["DCMPG"] = 152] = "DCMPG";
    OpCode[OpCode["DCMPL"] = 151] = "DCMPL";
    OpCode[OpCode["DCONST_0"] = 14] = "DCONST_0";
    OpCode[OpCode["DCONST_1"] = 15] = "DCONST_1";
    OpCode[OpCode["DDIV"] = 111] = "DDIV";
    OpCode[OpCode["DLOAD"] = 24] = "DLOAD";
    OpCode[OpCode["DLOAD_0"] = 38] = "DLOAD_0";
    OpCode[OpCode["DLOAD_1"] = 39] = "DLOAD_1";
    OpCode[OpCode["DLOAD_2"] = 40] = "DLOAD_2";
    OpCode[OpCode["DLOAD_3"] = 41] = "DLOAD_3";
    OpCode[OpCode["DMUL"] = 107] = "DMUL";
    OpCode[OpCode["DNEG"] = 119] = "DNEG";
    OpCode[OpCode["DREM"] = 115] = "DREM";
    OpCode[OpCode["DRETURN"] = 175] = "DRETURN";
    OpCode[OpCode["DSTORE"] = 57] = "DSTORE";
    OpCode[OpCode["DSTORE_0"] = 71] = "DSTORE_0";
    OpCode[OpCode["DSTORE_1"] = 72] = "DSTORE_1";
    OpCode[OpCode["DSTORE_2"] = 73] = "DSTORE_2";
    OpCode[OpCode["DSTORE_3"] = 74] = "DSTORE_3";
    OpCode[OpCode["DSUB"] = 103] = "DSUB";
    OpCode[OpCode["DUP"] = 89] = "DUP";
    OpCode[OpCode["DUP_X1"] = 90] = "DUP_X1";
    OpCode[OpCode["DUP_X2"] = 91] = "DUP_X2";
    OpCode[OpCode["DUP2"] = 92] = "DUP2";
    OpCode[OpCode["DUP2_X1"] = 93] = "DUP2_X1";
    OpCode[OpCode["DUP2_X2"] = 94] = "DUP2_X2";
    OpCode[OpCode["F2D"] = 141] = "F2D";
    OpCode[OpCode["F2I"] = 139] = "F2I";
    OpCode[OpCode["F2L"] = 140] = "F2L";
    OpCode[OpCode["FADD"] = 98] = "FADD";
    OpCode[OpCode["FALOAD"] = 48] = "FALOAD";
    OpCode[OpCode["FASTORE"] = 81] = "FASTORE";
    OpCode[OpCode["FCMPG"] = 150] = "FCMPG";
    OpCode[OpCode["FCMPL"] = 149] = "FCMPL";
    OpCode[OpCode["FCONST_0"] = 11] = "FCONST_0";
    OpCode[OpCode["FCONST_1"] = 12] = "FCONST_1";
    OpCode[OpCode["FCONST_2"] = 13] = "FCONST_2";
    OpCode[OpCode["FDIV"] = 110] = "FDIV";
    OpCode[OpCode["FLOAD"] = 23] = "FLOAD";
    OpCode[OpCode["FLOAD_0"] = 34] = "FLOAD_0";
    OpCode[OpCode["FLOAD_1"] = 35] = "FLOAD_1";
    OpCode[OpCode["FLOAD_2"] = 36] = "FLOAD_2";
    OpCode[OpCode["FLOAD_3"] = 37] = "FLOAD_3";
    OpCode[OpCode["FMUL"] = 106] = "FMUL";
    OpCode[OpCode["FNEG"] = 118] = "FNEG";
    OpCode[OpCode["FREM"] = 114] = "FREM";
    OpCode[OpCode["FRETURN"] = 174] = "FRETURN";
    OpCode[OpCode["FSTORE"] = 56] = "FSTORE";
    OpCode[OpCode["FSTORE_0"] = 67] = "FSTORE_0";
    OpCode[OpCode["FSTORE_1"] = 68] = "FSTORE_1";
    OpCode[OpCode["FSTORE_2"] = 69] = "FSTORE_2";
    OpCode[OpCode["FSTORE_3"] = 70] = "FSTORE_3";
    OpCode[OpCode["FSUB"] = 102] = "FSUB";
    OpCode[OpCode["GETFIELD"] = 180] = "GETFIELD";
    OpCode[OpCode["GETSTATIC"] = 178] = "GETSTATIC";
    OpCode[OpCode["GOTO"] = 167] = "GOTO";
    OpCode[OpCode["GOTO_W"] = 200] = "GOTO_W";
    OpCode[OpCode["I2B"] = 145] = "I2B";
    OpCode[OpCode["I2C"] = 146] = "I2C";
    OpCode[OpCode["I2D"] = 135] = "I2D";
    OpCode[OpCode["I2F"] = 134] = "I2F";
    OpCode[OpCode["I2L"] = 133] = "I2L";
    OpCode[OpCode["I2S"] = 147] = "I2S";
    OpCode[OpCode["IADD"] = 96] = "IADD";
    OpCode[OpCode["IALOAD"] = 46] = "IALOAD";
    OpCode[OpCode["IAND"] = 126] = "IAND";
    OpCode[OpCode["IASTORE"] = 79] = "IASTORE";
    OpCode[OpCode["ICONST_M1"] = 2] = "ICONST_M1";
    OpCode[OpCode["ICONST_0"] = 3] = "ICONST_0";
    OpCode[OpCode["ICONST_1"] = 4] = "ICONST_1";
    OpCode[OpCode["ICONST_2"] = 5] = "ICONST_2";
    OpCode[OpCode["ICONST_3"] = 6] = "ICONST_3";
    OpCode[OpCode["ICONST_4"] = 7] = "ICONST_4";
    OpCode[OpCode["ICONST_5"] = 8] = "ICONST_5";
    OpCode[OpCode["IDIV"] = 108] = "IDIV";
    OpCode[OpCode["IF_ACMPEQ"] = 165] = "IF_ACMPEQ";
    OpCode[OpCode["IF_ACMPNE"] = 166] = "IF_ACMPNE";
    OpCode[OpCode["IF_ICMPEQ"] = 159] = "IF_ICMPEQ";
    OpCode[OpCode["IF_ICMPGE"] = 162] = "IF_ICMPGE";
    OpCode[OpCode["IF_ICMPGT"] = 163] = "IF_ICMPGT";
    OpCode[OpCode["IF_ICMPLE"] = 164] = "IF_ICMPLE";
    OpCode[OpCode["IF_ICMPLT"] = 161] = "IF_ICMPLT";
    OpCode[OpCode["IF_ICMPNE"] = 160] = "IF_ICMPNE";
    OpCode[OpCode["IFEQ"] = 153] = "IFEQ";
    OpCode[OpCode["IFGE"] = 156] = "IFGE";
    OpCode[OpCode["IFGT"] = 157] = "IFGT";
    OpCode[OpCode["IFLE"] = 158] = "IFLE";
    OpCode[OpCode["IFLT"] = 155] = "IFLT";
    OpCode[OpCode["IFNE"] = 154] = "IFNE";
    OpCode[OpCode["IFNONNULL"] = 199] = "IFNONNULL";
    OpCode[OpCode["IFNULL"] = 198] = "IFNULL";
    OpCode[OpCode["IINC"] = 132] = "IINC";
    OpCode[OpCode["ILOAD"] = 21] = "ILOAD";
    OpCode[OpCode["ILOAD_0"] = 26] = "ILOAD_0";
    OpCode[OpCode["ILOAD_1"] = 27] = "ILOAD_1";
    OpCode[OpCode["ILOAD_2"] = 28] = "ILOAD_2";
    OpCode[OpCode["ILOAD_3"] = 29] = "ILOAD_3";
    // IMPDEP1 = 0xfe,
    // IMPDEP2 = 0xff,
    OpCode[OpCode["IMUL"] = 104] = "IMUL";
    OpCode[OpCode["INEG"] = 116] = "INEG";
    OpCode[OpCode["INSTANCEOF"] = 193] = "INSTANCEOF";
    OpCode[OpCode["INVOKEDYNAMIC"] = 186] = "INVOKEDYNAMIC";
    OpCode[OpCode["INVOKEINTERFACE"] = 185] = "INVOKEINTERFACE";
    OpCode[OpCode["INVOKESPECIAL"] = 183] = "INVOKESPECIAL";
    OpCode[OpCode["INVOKESTATIC"] = 184] = "INVOKESTATIC";
    OpCode[OpCode["INVOKEVIRTUAL"] = 182] = "INVOKEVIRTUAL";
    OpCode[OpCode["IOR"] = 128] = "IOR";
    OpCode[OpCode["IREM"] = 112] = "IREM";
    OpCode[OpCode["IRETURN"] = 172] = "IRETURN";
    OpCode[OpCode["ISHL"] = 120] = "ISHL";
    OpCode[OpCode["ISHR"] = 122] = "ISHR";
    OpCode[OpCode["ISTORE"] = 54] = "ISTORE";
    OpCode[OpCode["ISTORE_0"] = 59] = "ISTORE_0";
    OpCode[OpCode["ISTORE_1"] = 60] = "ISTORE_1";
    OpCode[OpCode["ISTORE_2"] = 61] = "ISTORE_2";
    OpCode[OpCode["ISTORE_3"] = 62] = "ISTORE_3";
    OpCode[OpCode["ISUB"] = 100] = "ISUB";
    OpCode[OpCode["IUSHR"] = 124] = "IUSHR";
    OpCode[OpCode["IXOR"] = 130] = "IXOR";
    OpCode[OpCode["JSR"] = 168] = "JSR";
    OpCode[OpCode["JSR_W"] = 201] = "JSR_W";
    OpCode[OpCode["L2D"] = 138] = "L2D";
    OpCode[OpCode["L2F"] = 137] = "L2F";
    OpCode[OpCode["L2I"] = 136] = "L2I";
    OpCode[OpCode["LADD"] = 97] = "LADD";
    OpCode[OpCode["LALOAD"] = 47] = "LALOAD";
    OpCode[OpCode["LAND"] = 127] = "LAND";
    OpCode[OpCode["LASTORE"] = 80] = "LASTORE";
    OpCode[OpCode["LCMP"] = 148] = "LCMP";
    OpCode[OpCode["LCONST_0"] = 9] = "LCONST_0";
    OpCode[OpCode["LCONST_1"] = 10] = "LCONST_1";
    OpCode[OpCode["LDC"] = 18] = "LDC";
    OpCode[OpCode["LDC_W"] = 19] = "LDC_W";
    OpCode[OpCode["LDC2_W"] = 20] = "LDC2_W";
    OpCode[OpCode["LDIV"] = 109] = "LDIV";
    OpCode[OpCode["LLOAD"] = 22] = "LLOAD";
    OpCode[OpCode["LLOAD_0"] = 30] = "LLOAD_0";
    OpCode[OpCode["LLOAD_1"] = 31] = "LLOAD_1";
    OpCode[OpCode["LLOAD_2"] = 32] = "LLOAD_2";
    OpCode[OpCode["LLOAD_3"] = 33] = "LLOAD_3";
    OpCode[OpCode["LMUL"] = 105] = "LMUL";
    OpCode[OpCode["LNEG"] = 117] = "LNEG";
    OpCode[OpCode["LOOKUPSWITCH"] = 171] = "LOOKUPSWITCH";
    OpCode[OpCode["LOR"] = 129] = "LOR";
    OpCode[OpCode["LREM"] = 113] = "LREM";
    OpCode[OpCode["LRETURN"] = 173] = "LRETURN";
    OpCode[OpCode["LSHL"] = 121] = "LSHL";
    OpCode[OpCode["LSHR"] = 123] = "LSHR";
    OpCode[OpCode["LSTORE"] = 55] = "LSTORE";
    OpCode[OpCode["LSTORE_0"] = 63] = "LSTORE_0";
    OpCode[OpCode["LSTORE_1"] = 64] = "LSTORE_1";
    OpCode[OpCode["LSTORE_2"] = 65] = "LSTORE_2";
    OpCode[OpCode["LSTORE_3"] = 66] = "LSTORE_3";
    OpCode[OpCode["LSUB"] = 101] = "LSUB";
    OpCode[OpCode["LUSHR"] = 125] = "LUSHR";
    OpCode[OpCode["LXOR"] = 131] = "LXOR";
    OpCode[OpCode["MONITORENTER"] = 194] = "MONITORENTER";
    OpCode[OpCode["MONITOREXIT"] = 195] = "MONITOREXIT";
    OpCode[OpCode["MULTIANEWARRAY"] = 197] = "MULTIANEWARRAY";
    OpCode[OpCode["NEW"] = 187] = "NEW";
    OpCode[OpCode["NEWARRAY"] = 188] = "NEWARRAY";
    OpCode[OpCode["NOP"] = 0] = "NOP";
    OpCode[OpCode["POP"] = 87] = "POP";
    OpCode[OpCode["POP2"] = 88] = "POP2";
    OpCode[OpCode["PUTFIELD"] = 181] = "PUTFIELD";
    OpCode[OpCode["PUTSTATIC"] = 179] = "PUTSTATIC";
    OpCode[OpCode["RET"] = 169] = "RET";
    OpCode[OpCode["RETURN"] = 177] = "RETURN";
    OpCode[OpCode["SALOAD"] = 53] = "SALOAD";
    OpCode[OpCode["SASTORE"] = 86] = "SASTORE";
    OpCode[OpCode["SIPUSH"] = 17] = "SIPUSH";
    OpCode[OpCode["SWAP"] = 95] = "SWAP";
    OpCode[OpCode["TABLESWITCH"] = 170] = "TABLESWITCH";
    OpCode[OpCode["WIDE"] = 196] = "WIDE";
    // Special Doppio 'fast' opcodes
    OpCode[OpCode["GETSTATIC_FAST32"] = 208] = "GETSTATIC_FAST32";
    OpCode[OpCode["GETSTATIC_FAST64"] = 209] = "GETSTATIC_FAST64";
    OpCode[OpCode["NEW_FAST"] = 210] = "NEW_FAST";
    OpCode[OpCode["ANEWARRAY_FAST"] = 213] = "ANEWARRAY_FAST";
    OpCode[OpCode["CHECKCAST_FAST"] = 214] = "CHECKCAST_FAST";
    OpCode[OpCode["INSTANCEOF_FAST"] = 215] = "INSTANCEOF_FAST";
    OpCode[OpCode["MULTIANEWARRAY_FAST"] = 216] = "MULTIANEWARRAY_FAST";
    OpCode[OpCode["PUTSTATIC_FAST32"] = 217] = "PUTSTATIC_FAST32";
    OpCode[OpCode["PUTSTATIC_FAST64"] = 218] = "PUTSTATIC_FAST64";
    OpCode[OpCode["GETFIELD_FAST32"] = 219] = "GETFIELD_FAST32";
    OpCode[OpCode["GETFIELD_FAST64"] = 220] = "GETFIELD_FAST64";
    OpCode[OpCode["PUTFIELD_FAST32"] = 221] = "PUTFIELD_FAST32";
    OpCode[OpCode["PUTFIELD_FAST64"] = 222] = "PUTFIELD_FAST64";
    OpCode[OpCode["INVOKENONVIRTUAL_FAST"] = 223] = "INVOKENONVIRTUAL_FAST";
    OpCode[OpCode["INVOKESTATIC_FAST"] = 240] = "INVOKESTATIC_FAST";
    OpCode[OpCode["INVOKEVIRTUAL_FAST"] = 241] = "INVOKEVIRTUAL_FAST";
    OpCode[OpCode["INVOKEINTERFACE_FAST"] = 242] = "INVOKEINTERFACE_FAST";
    OpCode[OpCode["INVOKEHANDLE"] = 243] = "INVOKEHANDLE";
    OpCode[OpCode["INVOKEBASIC"] = 244] = "INVOKEBASIC";
    OpCode[OpCode["LINKTOSPECIAL"] = 245] = "LINKTOSPECIAL";
    OpCode[OpCode["LINKTOVIRTUAL"] = 247] = "LINKTOVIRTUAL";
    OpCode[OpCode["INVOKEDYNAMIC_FAST"] = 248] = "INVOKEDYNAMIC_FAST";
})(exports.OpCode || (exports.OpCode = {}));
var OpCode = exports.OpCode;
(function (OpcodeLayoutType) {
    OpcodeLayoutType[OpcodeLayoutType["OPCODE_ONLY"] = 0] = "OPCODE_ONLY";
    OpcodeLayoutType[OpcodeLayoutType["CONSTANT_POOL_UINT8"] = 1] = "CONSTANT_POOL_UINT8";
    OpcodeLayoutType[OpcodeLayoutType["CONSTANT_POOL"] = 2] = "CONSTANT_POOL";
    OpcodeLayoutType[OpcodeLayoutType["CONSTANT_POOL_AND_UINT8_VALUE"] = 3] = "CONSTANT_POOL_AND_UINT8_VALUE";
    OpcodeLayoutType[OpcodeLayoutType["UINT8_VALUE"] = 4] = "UINT8_VALUE";
    OpcodeLayoutType[OpcodeLayoutType["UINT8_AND_INT8_VALUE"] = 5] = "UINT8_AND_INT8_VALUE";
    OpcodeLayoutType[OpcodeLayoutType["INT8_VALUE"] = 6] = "INT8_VALUE";
    OpcodeLayoutType[OpcodeLayoutType["INT16_VALUE"] = 7] = "INT16_VALUE";
    OpcodeLayoutType[OpcodeLayoutType["INT32_VALUE"] = 8] = "INT32_VALUE";
    // LOOKUPSWITCH,
    // TABLESWITCH,
    OpcodeLayoutType[OpcodeLayoutType["ARRAY_TYPE"] = 9] = "ARRAY_TYPE";
    OpcodeLayoutType[OpcodeLayoutType["WIDE"] = 10] = "WIDE";
})(exports.OpcodeLayoutType || (exports.OpcodeLayoutType = {}));
var OpcodeLayoutType = exports.OpcodeLayoutType;
// Contains the opcode layout types for each valid opcode.
// To conserve code space, it's assumed all opcodes not in the table
// are OPCODE_ONLY.
var olt = new Array(0xff);
(function () {
    for (var i = 0; i < 0xff; i++) {
        olt[i] = OpcodeLayoutType.OPCODE_ONLY;
    }
})();
function assignOpcodeLayout(layoutType, opcodes) {
    opcodes.forEach(function (opcode) {
        olt[opcode] = layoutType;
    });
}
assignOpcodeLayout(OpcodeLayoutType.UINT8_VALUE, [OpCode.ALOAD, OpCode.ASTORE, OpCode.DLOAD, OpCode.DSTORE,
    OpCode.FLOAD, OpCode.FSTORE, OpCode.ILOAD, OpCode.ISTORE,
    OpCode.LLOAD, OpCode.LSTORE, OpCode.RET]);
assignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL_UINT8, [OpCode.LDC]);
assignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL, [OpCode.LDC_W, OpCode.LDC2_W,
    OpCode.ANEWARRAY, OpCode.CHECKCAST, OpCode.GETFIELD,
    OpCode.GETSTATIC, OpCode.INSTANCEOF, OpCode.INVOKEDYNAMIC,
    OpCode.INVOKESPECIAL, OpCode.INVOKESTATIC, OpCode.INVOKEVIRTUAL,
    OpCode.NEW, OpCode.PUTFIELD, OpCode.PUTSTATIC, OpCode.MULTIANEWARRAY_FAST,
    OpCode.INVOKENONVIRTUAL_FAST, OpCode.INVOKESTATIC_FAST, OpCode.CHECKCAST_FAST,
    OpCode.NEW_FAST,
    OpCode.ANEWARRAY_FAST, OpCode.INSTANCEOF_FAST, OpCode.GETSTATIC_FAST32,
    OpCode.GETSTATIC_FAST64, OpCode.PUTSTATIC_FAST32, OpCode.PUTSTATIC_FAST64,
    OpCode.PUTFIELD_FAST32, OpCode.PUTFIELD_FAST64,
    OpCode.GETFIELD_FAST32, OpCode.GETFIELD_FAST64, OpCode.INVOKEVIRTUAL_FAST
]);
assignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL_AND_UINT8_VALUE, [OpCode.INVOKEINTERFACE, OpCode.INVOKEINTERFACE_FAST, OpCode.MULTIANEWARRAY]);
assignOpcodeLayout(OpcodeLayoutType.INT8_VALUE, [OpCode.BIPUSH]);
assignOpcodeLayout(OpcodeLayoutType.INT16_VALUE, [OpCode.SIPUSH, OpCode.GOTO, OpCode.IFGT, OpCode.IFEQ, OpCode.IFGE, OpCode.IFLE,
    OpCode.IFLT, OpCode.IFNE, OpCode.IFNULL, OpCode.IFNONNULL, OpCode.IF_ICMPLE,
    OpCode.IF_ACMPEQ, OpCode.IF_ACMPNE, OpCode.IF_ICMPEQ, OpCode.IF_ICMPGE,
    OpCode.IF_ICMPGT, OpCode.IF_ICMPLT, OpCode.IF_ICMPNE, OpCode.JSR]);
assignOpcodeLayout(OpcodeLayoutType.INT32_VALUE, [OpCode.GOTO_W, OpCode.JSR_W]);
assignOpcodeLayout(OpcodeLayoutType.UINT8_AND_INT8_VALUE, [OpCode.IINC]);
assignOpcodeLayout(OpcodeLayoutType.ARRAY_TYPE, [OpCode.NEWARRAY]);
exports.OpcodeLayouts = olt;

},{}],32:[function(_dereq_,module,exports){
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "long". This
 * implementation is derived from LongLib in GWT.
 *
 */
var gLong = (function () {
    /**
     * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
     * values as *signed* integers.  See the from* functions below for more
     * convenient ways of constructing Longs.
     *
     * The internal representation of a long is the two given signed, 32-bit values.
     * We use 32-bit pieces because these are the size of integers on which
     * Javascript performs bit-operations.  For operations like addition and
     * multiplication, we split each number into 16-bit pieces, which can easily be
     * multiplied within Javascript's floating-point representation without overflow
     * or change in sign.
     *
     * In the algorithms below, we frequently reduce the negative case to the
     * positive case by negating the input(s) and then post-processing the result.
     * Note that we must ALWAYS check specially whether those values are MIN_VALUE
     * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
     * a positive number, it overflows back into a negative).  Not handling this
     * case would often result in infinite recursion.
     *
     * @param {number} low  The low (signed) 32 bits of the long.
     * @param {number} high  The high (signed) 32 bits of the long.
     * @constructor
     */
    function gLong(low, high) {
        this.low_ = low | 0; // force into 32 signed bits.
        this.high_ = high | 0; // force into 32 signed bits.
    }
    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @param {number} value The 32-bit integer in question.
     * @return {!gLong} The corresponding Long value.
     */
    gLong.fromInt = function (value) {
        if (-128 <= value && value < 128) {
            var cachedObj = gLong.IntCache_[value];
            if (cachedObj) {
                return cachedObj;
            }
        }
        var obj = new gLong(value, value < 0 ? -1 : 0);
        if (-128 <= value && value < 128) {
            gLong.IntCache_[value] = obj;
        }
        return obj;
    };
    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @param {number} value The number in question.
     * @return {!gLong} The corresponding Long value.
     */
    gLong.fromNumber = function (value) {
        if (isNaN(value) || !isFinite(value)) {
            return gLong.ZERO;
        }
        else if (value <= -gLong.TWO_PWR_63_DBL_) {
            return gLong.MIN_VALUE;
        }
        else if (value + 1 >= gLong.TWO_PWR_63_DBL_) {
            return gLong.MAX_VALUE;
        }
        else if (value < 0) {
            return gLong.fromNumber(-value).negate();
        }
        else {
            return new gLong((value % gLong.TWO_PWR_32_DBL_) | 0, (value / gLong.TWO_PWR_32_DBL_) | 0);
        }
    };
    /**
     * Returns a Long representing the 64-bit integer that comes by concatenating
     * the given high and low bits.  Each is assumed to use 32 bits.
     * @param {number} lowBits The low 32-bits.
     * @param {number} highBits The high 32-bits.
     * @return {!gLong} The corresponding Long value.
     */
    gLong.fromBits = function (lowBits, highBits) {
        return new gLong(lowBits, highBits);
    };
    /**
     * Returns a Long representation of the given string, written using the given
     * radix.
     * @param {string} str The textual representation of the Long.
     * @param {number=} opt_radix The radix in which the text is written.
     * @return {!gLong} The corresponding Long value.
     */
    gLong.fromString = function (str, opt_radix) {
        if (str.length == 0) {
            throw Error('number format error: empty string');
        }
        var radix = opt_radix || 10;
        if (radix < 2 || 36 < radix) {
            throw Error('radix out of range: ' + radix);
        }
        if (str.charAt(0) == '-') {
            return gLong.fromString(str.substring(1), radix).negate();
        }
        else if (str.indexOf('-') >= 0) {
            throw Error('number format error: interior "-" character: ' + str);
        }
        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = gLong.fromNumber(Math.pow(radix, 8));
        var result = gLong.ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i);
            var value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = gLong.fromNumber(Math.pow(radix, size));
                result = result.multiply(power).add(gLong.fromNumber(value));
            }
            else {
                result = result.multiply(radixToPower);
                result = result.add(gLong.fromNumber(value));
            }
        }
        return result;
    };
    /** @return {number} The value, assuming it is a 32-bit integer. */
    gLong.prototype.toInt = function () {
        return this.low_;
    };
    /** @return {number} The closest floating-point representation to this value. */
    gLong.prototype.toNumber = function () {
        return this.high_ * gLong.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    /**
     * @param {number=} opt_radix The radix in which the text should be written.
     * @return {string} The textual representation of this value.
     */
    gLong.prototype.toString = function (opt_radix) {
        var radix = opt_radix || 10;
        if (radix < 2 || 36 < radix) {
            throw Error('radix out of range: ' + radix);
        }
        if (this.isZero()) {
            return '0';
        }
        if (this.isNegative()) {
            if (this.equals(gLong.MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = gLong.fromNumber(radix);
                var div = this.div(radixLong);
                var rem = div.multiply(radixLong).subtract(this);
                return div.toString(radix) + rem.toInt().toString(radix);
            }
            else {
                return '-' + this.negate().toString(radix);
            }
        }
        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = gLong.fromNumber(Math.pow(radix, 6));
        var rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower);
            var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
            var digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero()) {
                return digits + result;
            }
            else {
                while (digits.length < 6) {
                    digits = '0' + digits;
                }
                result = '' + digits + result;
            }
        }
    };
    /** @return {number} The high 32-bits as a signed value. */
    gLong.prototype.getHighBits = function () {
        return this.high_;
    };
    /** @return {number} The low 32-bits as a signed value. */
    gLong.prototype.getLowBits = function () {
        return this.low_;
    };
    /** @return {number} The low 32-bits as an unsigned value. */
    gLong.prototype.getLowBitsUnsigned = function () {
        return (this.low_ >= 0) ? this.low_ : gLong.TWO_PWR_32_DBL_ + this.low_;
    };
    /**
     * @return {number} Returns the number of bits needed to represent the absolute
     *     value of this Long.
     */
    gLong.prototype.getNumBitsAbs = function () {
        if (this.isNegative()) {
            if (this.equals(gLong.MIN_VALUE)) {
                return 64;
            }
            else {
                return this.negate().getNumBitsAbs();
            }
        }
        else {
            var val = this.high_ != 0 ? this.high_ : this.low_;
            for (var bit = 31; bit > 0; bit--) {
                if ((val & (1 << bit)) != 0) {
                    break;
                }
            }
            return this.high_ != 0 ? bit + 33 : bit + 1;
        }
    };
    /** @return {boolean} Whether this value is zero. */
    gLong.prototype.isZero = function () {
        return this.high_ == 0 && this.low_ == 0;
    };
    /** @return {boolean} Whether this value is negative. */
    gLong.prototype.isNegative = function () {
        return this.high_ < 0;
    };
    /** @return {boolean} Whether this value is odd. */
    gLong.prototype.isOdd = function () {
        return (this.low_ & 1) == 1;
    };
    /**
     * @param {gLong} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     */
    gLong.prototype.equals = function (other) {
        return (this.high_ == other.high_) && (this.low_ == other.low_);
    };
    /**
     * @param {gLong} other Long to compare against.
     * @return {boolean} Whether this Long does not equal the other.
     */
    gLong.prototype.notEquals = function (other) {
        return (this.high_ != other.high_) || (this.low_ != other.low_);
    };
    /**
     * @param {gLong} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     */
    gLong.prototype.lessThan = function (other) {
        return this.compare(other) < 0;
    };
    /**
     * @param {gLong} other Long to compare against.
     * @return {boolean} Whether this Long is less than or equal to the other.
     */
    gLong.prototype.lessThanOrEqual = function (other) {
        return this.compare(other) <= 0;
    };
    /**
     * @param {gLong} other Long to compare against.
     * @return {boolean} Whether this Long is greater than the other.
     */
    gLong.prototype.greaterThan = function (other) {
        return this.compare(other) > 0;
    };
    /**
     * @param {gLong} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     */
    gLong.prototype.greaterThanOrEqual = function (other) {
        return this.compare(other) >= 0;
    };
    /**
     * Compares this Long with the given one.
     * @param {gLong} other Long to compare against.
     * @return {number} 0 if they are the same, 1 if the this is greater, and -1
     *     if the given one is greater.
     */
    gLong.prototype.compare = function (other) {
        if (this.equals(other)) {
            return 0;
        }
        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) {
            return -1;
        }
        if (!thisNeg && otherNeg) {
            return 1;
        }
        // at this point, the signs are the same, so subtraction will not overflow
        if (this.subtract(other).isNegative()) {
            return -1;
        }
        else {
            return 1;
        }
    };
    /** @return {!gLong} The negation of this value. */
    gLong.prototype.negate = function () {
        if (this.equals(gLong.MIN_VALUE)) {
            return gLong.MIN_VALUE;
        }
        else {
            return this.not().add(gLong.ONE);
        }
    };
    /**
     * Returns the sum of this and the given Long.
     * @param {gLong} other Long to add to this one.
     * @return {!gLong} The sum of this and the given Long.
     */
    gLong.prototype.add = function (other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xFFFF;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xFFFF;
        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xFFFF;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return gLong.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };
    /**
     * Returns the difference of this and the given Long.
     * @param {gLong} other Long to subtract from this.
     * @return {!gLong} The difference of this and the given Long.
     */
    gLong.prototype.subtract = function (other) {
        return this.add(other.negate());
    };
    /**
     * Returns the product of this and the given long.
     * @param {gLong} other Long to multiply with this.
     * @return {!gLong} The product of this and the other.
     */
    gLong.prototype.multiply = function (other) {
        if (this.isZero()) {
            return gLong.ZERO;
        }
        else if (other.isZero()) {
            return gLong.ZERO;
        }
        if (this.equals(gLong.MIN_VALUE)) {
            return other.isOdd() ? gLong.MIN_VALUE : gLong.ZERO;
        }
        else if (other.equals(gLong.MIN_VALUE)) {
            return this.isOdd() ? gLong.MIN_VALUE : gLong.ZERO;
        }
        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            }
            else {
                return this.negate().multiply(other).negate();
            }
        }
        else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }
        // If both longs are small, use float multiplication
        if (this.lessThan(gLong.TWO_PWR_24_) &&
            other.lessThan(gLong.TWO_PWR_24_)) {
            return gLong.fromNumber(this.toNumber() * other.toNumber());
        }
        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.
        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xFFFF;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xFFFF;
        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xFFFF;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return gLong.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };
    /**
     * Returns this Long divided by the given one.
     * @param {gLong} other Long by which to divide.
     * @return {!gLong} This Long divided by the given one.
     */
    gLong.prototype.div = function (other) {
        if (other.isZero()) {
            throw Error('division by zero');
        }
        else if (this.isZero()) {
            return gLong.ZERO;
        }
        if (this.equals(gLong.MIN_VALUE)) {
            if (other.equals(gLong.ONE) ||
                other.equals(gLong.NEG_ONE)) {
                return gLong.MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
            }
            else if (other.equals(gLong.MIN_VALUE)) {
                return gLong.ONE;
            }
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shiftRight(1);
                var l_approx = halfThis.div(other).shiftLeft(1);
                if (l_approx.equals(gLong.ZERO)) {
                    return other.isNegative() ? gLong.ONE : gLong.NEG_ONE;
                }
                else {
                    var rem = this.subtract(other.multiply(l_approx));
                    var result = l_approx.add(rem.div(other));
                    return result;
                }
            }
        }
        else if (other.equals(gLong.MIN_VALUE)) {
            return gLong.ZERO;
        }
        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().div(other.negate());
            }
            else {
                return this.negate().div(other).negate();
            }
        }
        else if (other.isNegative()) {
            return this.div(other.negate()).negate();
        }
        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        var res = gLong.ZERO;
        var rem = this;
        while (rem.greaterThanOrEqual(other)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2);
            var delta = 1;
            if (log2 > 48)
                delta = Math.pow(2, log2 - 48);
            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
            var approxRes = gLong.fromNumber(approx);
            var approxRem = approxRes.multiply(other);
            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                approx -= delta;
                approxRes = gLong.fromNumber(approx);
                approxRem = approxRes.multiply(other);
            }
            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero()) {
                approxRes = gLong.ONE;
            }
            res = res.add(approxRes);
            rem = rem.subtract(approxRem);
        }
        return res;
    };
    /**
     * Returns this Long modulo the given one.
     * @param {gLong} other Long by which to mod.
     * @return {!gLong} This Long modulo the given one.
     */
    gLong.prototype.modulo = function (other) {
        return this.subtract(this.div(other).multiply(other));
    };
    /** @return {!gLong} The bitwise-NOT of this value. */
    gLong.prototype.not = function () {
        return gLong.fromBits(~this.low_, ~this.high_);
    };
    /**
     * Returns the bitwise-AND of this Long and the given one.
     * @param {gLong} other The Long with which to AND.
     * @return {!gLong} The bitwise-AND of this and the other.
     */
    gLong.prototype.and = function (other) {
        return gLong.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    /**
     * Returns the bitwise-OR of this Long and the given one.
     * @param {gLong} other The Long with which to OR.
     * @return {!gLong} The bitwise-OR of this and the other.
     */
    gLong.prototype.or = function (other) {
        return gLong.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    /**
     * Returns the bitwise-XOR of this Long and the given one.
     * @param {gLong} other The Long with which to XOR.
     * @return {!gLong} The bitwise-XOR of this and the other.
     */
    gLong.prototype.xor = function (other) {
        return gLong.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!gLong} This shifted to the left by the given amount.
     */
    gLong.prototype.shiftLeft = function (numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        }
        else {
            var low = this.low_;
            if (numBits < 32) {
                var high = this.high_;
                return gLong.fromBits(low << numBits, (high << numBits) | (low >>> (32 - numBits)));
            }
            else {
                return gLong.fromBits(0, low << (numBits - 32));
            }
        }
    };
    /**
     * Returns this Long with bits shifted to the right by the given amount.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!gLong} This shifted to the right by the given amount.
     */
    gLong.prototype.shiftRight = function (numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        }
        else {
            var high = this.high_;
            if (numBits < 32) {
                var low = this.low_;
                return gLong.fromBits((low >>> numBits) | (high << (32 - numBits)), high >> numBits);
            }
            else {
                return gLong.fromBits(high >> (numBits - 32), high >= 0 ? 0 : -1);
            }
        }
    };
    /**
     * Returns this Long with bits shifted to the right by the given amount, with
     * the new top bits matching the current sign bit.
     * @param {number} numBits The number of bits by which to shift.
     * @return {!gLong} This shifted to the right by the given amount, with
     *     zeros placed into the new leading bits.
     */
    gLong.prototype.shiftRightUnsigned = function (numBits) {
        numBits &= 63;
        if (numBits == 0) {
            return this;
        }
        else {
            var high = this.high_;
            if (numBits < 32) {
                var low = this.low_;
                return gLong.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits);
            }
            else if (numBits == 32) {
                return gLong.fromBits(high, 0);
            }
            else {
                return gLong.fromBits(high >>> (numBits - 32), 0);
            }
        }
    };
    // A cache of the Long representations of small integer values.
    gLong.IntCache_ = {};
    // Commonly used constant values.
    gLong.TWO_PWR_16_DBL_ = 1 << 16;
    gLong.TWO_PWR_24_DBL_ = 1 << 24;
    gLong.TWO_PWR_32_DBL_ = gLong.TWO_PWR_16_DBL_ * gLong.TWO_PWR_16_DBL_;
    gLong.TWO_PWR_31_DBL_ = gLong.TWO_PWR_32_DBL_ / 2;
    gLong.TWO_PWR_48_DBL_ = gLong.TWO_PWR_32_DBL_ * gLong.TWO_PWR_16_DBL_;
    gLong.TWO_PWR_64_DBL_ = gLong.TWO_PWR_32_DBL_ * gLong.TWO_PWR_32_DBL_;
    gLong.TWO_PWR_63_DBL_ = gLong.TWO_PWR_64_DBL_ / 2;
    gLong.ZERO = gLong.fromInt(0);
    gLong.ONE = gLong.fromInt(1);
    gLong.NEG_ONE = gLong.fromInt(-1);
    gLong.MAX_VALUE = gLong.fromBits(0xFFFFFFFF, 0x7FFFFFFF);
    gLong.MIN_VALUE = gLong.fromBits(0, 0x80000000);
    gLong.TWO_PWR_24_ = gLong.fromInt(gLong.TWO_PWR_24_DBL_);
    return gLong;
})();
module.exports = gLong;

},{}],33:[function(_dereq_,module,exports){
(function (global){
var toExport;
if (typeof (window) !== 'undefined') {
    toExport = window;
}
else if (typeof (self) !== 'undefined') {
    toExport = self;
}
else {
    toExport = global;
}
module.exports = toExport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],34:[function(_dereq_,module,exports){
(function (Buffer){
// A power-of-two segregated freelist "heap",
// for explicit memory management into a buffer.
// by Emery Berger, www.cs.umass.edu/~emery
"use strict";
var Heap = (function () {
    // size = total amount of memory for the heap.
    function Heap(size) {
        this.size = size;
        // A map of size classes per chunk (see above).
        this._sizeMap = {};
        this._buffer = new Buffer(size);
        this._remaining = size; // the whole thing is available.
        this._offset = 0; // start of the buffer.
        // Initialize the freelists.
        this._freeLists = new Array(Heap._numSizeClasses);
        for (var i = 0; i < Heap._numSizeClasses; i++) {
            this._freeLists[i] = [];
        }
    }
    // Allocate size bytes, returning the "address".
    Heap.prototype.malloc = function (size) {
        // if size is less than a word, round it up to a word (4 bytes).
        if (size <= 4) {
            size = 4;
        }
        // if we are out of memory, throw an exception.
        if (this._remaining < size) {
            // TODO: could actually scan larger freelists to see if there's
            // free memory there.
            throw "out of memory";
        }
        // compute the size class.
        var addr;
        var cl;
        cl = Heap.size_to_class(size);
        addr = this._freeLists[cl].pop();
        // if there's no more memory, get some.
        if (addr === undefined) {
            addr = this.refill(cl);
        }
        return addr;
    };
    // Deallocate memory.
    Heap.prototype.free = function (addr) {
        // push this address onto the appropriate freelist.
        // first, mask the address.
        var masked = addr & ~(Heap._chunkSize - 1);
        // next, look up the class using the masked address.
        var cl = this._sizeMap[masked];
        // finally, push onto the appropriate free list.
        // TODO: for sanity, we could check to see if this was *really* freed
        // and drop it if not.
        this._freeLists[cl].push(addr);
    };
    // Store a word (32-bits) at this address.
    Heap.prototype.store_word = function (addr, value) {
        // TODO: add sanity checks?
        this._buffer.writeInt32LE(value, addr);
    };
    // Access a byte at this location.
    Heap.prototype.get_byte = function (addr) {
        // TODO: add sanity checks?
        return this._buffer.readUInt8(addr);
    };
    Heap.prototype.get_word = function (addr) {
        return this._buffer.readInt32LE(addr);
    };
    Heap.prototype.get_buffer = function (addr, len) {
        return this._buffer.slice(addr, addr + len);
    };
    Heap.prototype.get_signed_byte = function (addr) {
        return this._buffer.readInt8(addr);
    };
    Heap.prototype.set_byte = function (addr, value) {
        this._buffer.writeUInt8(value, addr);
    };
    Heap.prototype.set_signed_byte = function (addr, value) {
        this._buffer.writeInt8(value, addr);
    };
    /**
     * Copy len bytes from srcAddr to dstAddr.
     */
    Heap.prototype.memcpy = function (srcAddr, dstAddr, len) {
        this._buffer.copy(this._buffer, dstAddr, srcAddr, srcAddr + len);
    };
    // Get more memory for a particular size class.
    Heap.prototype.refill = function (cl) {
        // Get the largest size for this class.
        var sz = this.cl_to_size(cl);
        // Figure out how many objects we are going to "allocate".
        var count = Math.floor(Heap._chunkSize / sz);
        if (count < 1) {
            count = 1;
        }
        // Now store the size class *for the first object* only.
        // We will later look up this object via "pointer arithmetic".
        var addr = this._offset;
        this._sizeMap[addr] = cl;
        // Add each one to the freelist.
        for (var i = 0; i < count; i++) {
            this._remaining -= sz;
            addr = this._offset;
            this._freeLists[cl].push(addr);
            this._offset += sz;
        }
        return addr;
    };
    // Computes ceil(log2(num)).
    Heap.ilog2 = function (num) {
        var log2 = 0;
        var value = 1;
        while (value < num) {
            value <<= (1);
            log2++;
        }
        return (log2);
    };
    // power-of-two size classes (just a ref to ilog2).
    Heap.size_to_class = function (size) {
        return Heap.ilog2(size);
    };
    // see above: classes are just powers of two.
    Heap.prototype.cl_to_size = function (cl) {
        return (1 << cl);
    };
    // The total number of size classes.
    Heap._numSizeClasses = 64; // way more than we'll ever need.
    // How much to grab at one time.
    Heap._chunkSize = 4096; // should be a power of two.
    return Heap;
})();
module.exports = Heap;

}).call(this,BrowserFS.BFSRequire('buffer').Buffer)

},{}],35:[function(_dereq_,module,exports){
/// <reference path="../typings/main.d.ts" />
// Main entry point for browserify. Separate from doppiojvm.ts so we can reference
// main.d.ts here without polluting our official typings.
var doppiojvm = _dereq_('./doppiojvm');
module.exports = doppiojvm;

},{"./doppiojvm":30}],36:[function(_dereq_,module,exports){
/**
 * A module for generic interfaces. Like enums.ts, we use this to avoid
 * unneeded dependencies between modules, which can induce circular
 * dependencies.
 */

},{}],37:[function(_dereq_,module,exports){
(function (process){
var option_parser_1 = _dereq_('./option_parser');
var JVM = _dereq_('./jvm');
var util = _dereq_('./util');
var logging = _dereq_('./logging');
var parser = new option_parser_1.OptionParser({
    default: {
        classpath: {
            type: 3 /* NORMAL_VALUE_SYNTAX */,
            alias: 'cp',
            optDesc: ' <class search path of directories and zip/jar files>',
            desc: 'A : separated list of directories, JAR archives, and ZIP archives to search for class files.'
        },
        D: {
            type: 4 /* MAP_SYNTAX */,
            optDesc: '<name>=<value>',
            desc: 'set a system property'
        },
        jar: {
            type: 3 /* NORMAL_VALUE_SYNTAX */,
            stopParsing: true
        },
        help: { alias: '?', desc: 'print this help message' },
        X: { desc: 'print help on non-standard options' },
        enableassertions: {
            type: 2 /* COLON_VALUE_OR_FLAG_SYNTAX */,
            optDesc: '[:<packagename>...|:<classname>]',
            alias: 'ea',
            desc: 'enable assertions with specified granularity'
        },
        disableassertions: {
            type: 2 /* COLON_VALUE_OR_FLAG_SYNTAX */,
            optDesc: '[:<packagename>...|:<classname>]',
            alias: 'da',
            desc: 'disable assertions with specified granularity'
        },
        enablesystemassertions: { alias: 'esa', desc: 'enable system assertions' },
        disablesystemassertions: { alias: 'dsa', desc: 'disable system assertions ' }
    },
    X: {
        log: {
            desc: 'log level, [0-10]|vtrace|trace|debug|error',
            type: 3 /* NORMAL_VALUE_SYNTAX */
        },
        'vtrace-methods': {
            type: 3 /* NORMAL_VALUE_SYNTAX */,
            optDesc: ' <java/lang/Object/getHashCode()I:...>',
            desc: 'specify particular methods to vtrace separated by colons'
        },
        'list-class-cache': {
            desc: 'list all of the bootstrap loaded classes after execution'
        },
        'dump-compiled-code': {
            type: 3 /* NORMAL_VALUE_SYNTAX */,
            optDesc: ' <directory>',
            desc: 'location to dump compiled object definitions'
        },
        // TODO: Use -Djava.library.path
        'native-classpath': {
            type: 3 /* NORMAL_VALUE_SYNTAX */,
            optDesc: ' <class search path of directories>',
            desc: 'A : separated list of directories to search for native mathods in JS files.'
        },
        'bootclasspath/a': {
            type: 1 /* COLON_VALUE_SYNTAX */,
            optDesc: ':<directories and zip/jar files separated by :>',
            desc: 'append to end of bootstrap class path'
        },
        'bootclasspath/p': {
            type: 1 /* COLON_VALUE_SYNTAX */,
            optDesc: ':<directories and zip/jar files separated by :>',
            desc: 'prepend in front of bootstrap class path'
        },
        'bootclasspath': {
            type: 1 /* COLON_VALUE_SYNTAX */,
            optDesc: ':<directories and zip/jar files separated by :>',
            desc: 'set search path for bootstrap classes and resources'
        }
    }
});
/**
 * Consumes a `java` command line string. Constructs a JVM, launches the command, and
 * returns the JVM object. Throws an exception if parsing fails.
 *
 * Returns `null` if no JVM needed to be constructed (e.g. -h flag).
 *
 * @param args Arguments to the 'java' command.
 * @param opts Default options.
 * @param doneCb Called when JVM execution finishes. Passes a
 *   number to the callback indicating the exit value.
 * @param [jvmStarted] Called with the JVM object once we have invoked it.
 */
function java(args, opts, doneCb, jvmStarted) {
    if (jvmStarted === void 0) { jvmStarted = function (jvm) { }; }
    var parsedArgs = parser.parse(args), standard = parsedArgs['default'], nonStandard = parsedArgs['X'], jvmState;
    // System properties.
    opts.properties = standard.mapOption('D');
    if (standard.flag('help', false)) {
        return printHelp(opts.launcherName, parser.help('default'), doneCb, 0);
    }
    else if (standard.flag('X', false)) {
        return printNonStandardHelp(opts.launcherName, parser.help('X'), doneCb, 0);
    }
    // GLOBAL CONFIGURATION
    var logOption = nonStandard.stringOption('log', 'ERROR');
    if (/^[0-9]+$/.test(logOption)) {
        logging.log_level = parseInt(logOption, 10);
    }
    else {
        var level = logging[logOption.toUpperCase()];
        if (level == null) {
            process.stderr.write("Unrecognized log level: " + logOption + ".");
            return printHelp(opts.launcherName, parser.help('default'), doneCb, 1);
        }
        logging.log_level = level;
    }
    if (nonStandard.flag('list-class-cache', false)) {
        // Redefine done_cb so we print the loaded class files on JVM exit.
        doneCb = (function (old_done_cb) {
            return function (result) {
                var fpaths = jvmState.getBootstrapClassLoader().getLoadedClassFiles();
                process.stdout.write(fpaths.join('\n') + '\n');
                old_done_cb(result);
            };
        })(doneCb);
    }
    if (standard.flag('enablesystemassertions', false)) {
        opts.enableSystemAssertions = true;
    }
    if (standard.flag('disablesystemassertions', false)) {
        opts.enableSystemAssertions = false;
    }
    if (standard.flag('enableassertions', false)) {
        opts.enableAssertions = true;
    }
    else if (standard.stringOption('enableassertions', null)) {
        opts.enableAssertions = standard.stringOption('enableassertions', null).split(':');
    }
    if (standard.stringOption('disableassertions', null)) {
        opts.disableAssertions = standard.stringOption('disableassertions', null).split(':');
    }
    // NOTE: Boolean form of -disableassertions is a NOP.
    // Bootstrap classpath items.
    var bscl = nonStandard.stringOption('bootclasspath', null);
    if (bscl !== null) {
        opts.bootstrapClasspath = bscl.split(':');
    }
    var bsClAppend = nonStandard.stringOption('bootclasspath/a', null);
    if (bsClAppend) {
        opts.bootstrapClasspath = opts.bootstrapClasspath.concat(bsClAppend.split(':'));
    }
    var bsClPrepend = nonStandard.stringOption('bootclasspath/p', null);
    if (bsClPrepend) {
        opts.bootstrapClasspath = bsClPrepend.split(':').concat(opts.bootstrapClasspath);
    }
    // User-supplied classpath items.
    if (!opts.classpath) {
        opts.classpath = [];
    }
    if (standard.stringOption('jar', null)) {
        opts.classpath.push(standard.stringOption('jar', null));
    }
    else if (standard.stringOption('classpath', null)) {
        opts.classpath = opts.classpath.concat(standard.stringOption('classpath', null).split(':'));
    }
    else {
        // DEFAULT: If no user-supplied classpath, add the current directory to
        // the class path.
        opts.classpath.push(process.cwd());
    }
    // User-supplied native classpath.
    var nativeClasspath = standard.stringOption('native-classpath', null);
    if (nativeClasspath) {
        opts.nativeClasspath = opts.nativeClasspath.concat(nativeClasspath.split(':'));
    }
    // Construct the JVM.
    jvmState = new JVM(opts, function (err) {
        if (err) {
            process.stderr.write("Error constructing JVM:\n");
            process.stderr.write(err.toString() + "\n");
            doneCb(1);
        }
        else {
            launchJvm(standard, opts, jvmState, doneCb, jvmStarted);
        }
    });
    var vtraceMethods = nonStandard.stringOption('vtrace-methods', null);
    if (vtraceMethods) {
        vtraceMethods.split(':').forEach(function (m) { return jvmState.vtraceMethod(m); });
    }
    var dumpCompiledCode = nonStandard.stringOption('dumpCompiledCode', null);
    if (dumpCompiledCode) {
        jvmState.dumpCompiledCode(dumpCompiledCode);
    }
}
/**
 * Consumes a fully-configured JVM, parsed arguments, and a callback.
 * Figures out from this how to launch the JVM (e.g. using a JAR file or a
 * particular class).
 */
function launchJvm(standardOptions, opts, jvmState, doneCb, jvmStarted) {
    var mainArgs = standardOptions.unparsedArgs();
    if (standardOptions.stringOption('jar', null)) {
        jvmState.runJar(mainArgs, doneCb);
        jvmStarted(jvmState);
    }
    else if (mainArgs.length > 0) {
        var cname = mainArgs[0];
        if (cname.slice(-6) === '.class') {
            cname = cname.slice(0, -6);
        }
        if (cname.indexOf('.') !== -1) {
            // hack: convert java.foo.Bar to java/foo/Bar
            cname = util.descriptor2typestr(util.int_classname(cname));
        }
        jvmState.runClass(cname, mainArgs.slice(1), doneCb);
        jvmStarted(jvmState);
    }
    else {
        // No class specified, no jar specified!
        printHelp(opts.launcherName, parser.help('default'), doneCb, 0);
    }
}
function printHelp(launcherName, str, doneCb, rv) {
    process.stdout.write("Usage: " + launcherName + " [-options] class [args...]\n        (to execute a class)\nor  " + launcherName + " [-options] -jar jarfile [args...]\n        (to execute a jar file)\nwhere options include:\n" + str);
    doneCb(rv);
}
function printNonStandardHelp(launcherName, str, doneCb, rv) {
    process.stdout.write(str + "\n\nThe -X options are non-standard and subject to change without notice.\n");
    doneCb(rv);
}
module.exports = java;

}).call(this,BrowserFS.BFSRequire('process'))

},{"./jvm":38,"./logging":39,"./option_parser":42,"./util":47}],38:[function(_dereq_,module,exports){
(function (process,global){
"use strict";
var util = _dereq_('./util');
var SafeMap = _dereq_('./SafeMap');
var ClassLoader = _dereq_('./ClassLoader');
var fs = _dereq_('fs');
var path = _dereq_('path');
var buffer = _dereq_('buffer');
var threading_1 = _dereq_('./threading');
var enums_1 = _dereq_('./enums');
var Heap = _dereq_('./heap');
var assert = _dereq_('./assert');
var Parker = _dereq_('./parker');
var threadpool_1 = _dereq_('./threadpool');
var JDKInfo = _dereq_('../vendor/java_home/jdk.json');
// Do not import, otherwise TypeScript will prune it.
// Referenced only in eval'd code.
var BrowserFS = (typeof window !== "undefined" ? window['BrowserFS'] : typeof global !== "undefined" ? global['BrowserFS'] : null);
var deflate = _dereq_('pako/lib/zlib/deflate');
var inflate = _dereq_('pako/lib/zlib/inflate');
var zstream = _dereq_('pako/lib/zlib/zstream');
var crc32 = _dereq_('pako/lib/zlib/crc32');
var adler32 = _dereq_('pako/lib/zlib/adler32');
// For version information.
var pkg;
if (util.are_in_browser()) {
    pkg = _dereq_('../package.json');
}
else {
    pkg = _dereq_('../../../package.json');
}
// XXX: We currently initialize these classes at JVM bootup. This is expensive.
// We should attempt to prune this list as much as possible.
var coreClasses = [
    'Ljava/lang/String;',
    'Ljava/lang/Class;', 'Ljava/lang/ClassLoader;',
    'Ljava/lang/reflect/Constructor;', 'Ljava/lang/reflect/Field;',
    'Ljava/lang/reflect/Method;',
    'Ljava/lang/Error;', 'Ljava/lang/StackTraceElement;',
    'Ljava/lang/System;',
    'Ljava/lang/Thread;',
    'Ljava/lang/ThreadGroup;',
    'Ljava/lang/Throwable;',
    'Ljava/nio/ByteOrder;',
    'Lsun/misc/VM;', 'Lsun/reflect/ConstantPool;', 'Ljava/lang/Byte;',
    'Ljava/lang/Character;', 'Ljava/lang/Double;', 'Ljava/lang/Float;',
    'Ljava/lang/Integer;', 'Ljava/lang/Long;', 'Ljava/lang/Short;',
    'Ljava/lang/Void;', 'Ljava/io/FileDescriptor;',
    'Ljava/lang/Boolean;', '[Lsun/management/MemoryManagerImpl;',
    '[Lsun/management/MemoryPoolImpl;',
    // Contains important FS constants used by natives. These constants are
    // inlined into JCL class files, so it typically never gets initialized
    // implicitly by the JVM.
    'Lsun/nio/fs/UnixConstants;'
];
/**
 * Encapsulates a single JVM instance.
 */
var JVM = (function () {
    /**
     * (Async) Construct a new instance of the Java Virtual Machine.
     */
    function JVM(opts, cb) {
        var _this = this;
        this.systemProperties = null;
        this.internedStrings = new SafeMap();
        this.bsCl = null;
        this.threadPool = null;
        this.natives = {};
        // 20MB heap
        // @todo Make heap resizeable.
        this.heap = new Heap(20 * 1024 * 1024);
        this.nativeClasspath = null;
        this.startupTime = new Date();
        this.terminationCb = null;
        // The initial JVM thread used to kick off execution.
        this.firstThread = null;
        this.responsiveness = null;
        this.enableSystemAssertions = false;
        this.enabledAssertions = false;
        this.disabledAssertions = [];
        this.systemClassLoader = null;
        this.nextRef = 0;
        // Set of all of the methods we want vtrace to be enabled on.
        // DEBUG builds only.
        this.vtraceMethods = {};
        // [DEBUG] directory to dump compiled code to.
        this.dumpCompiledCodeDir = null;
        // Handles parking/unparking threads.
        this.parker = new Parker();
        // The current status of the JVM.
        this.status = enums_1.JVMStatus.BOOTING;
        // The JVM's planned exit code.
        this.exitCode = 0;
        if (typeof (opts.doppioHomePath) !== 'string') {
            throw new TypeError("opts.doppioHomePath *must* be specified.");
        }
        opts = util.merge(JVM.getDefaultOptions(opts.doppioHomePath), opts);
        var bootstrapClasspath = opts.bootstrapClasspath.map(function (p) { return path.resolve(p); }), 
        // JVM bootup tasks, from first to last task.
        bootupTasks = [], firstThread, firstThreadObj;
        // Sanity checks.
        if (!Array.isArray(opts.bootstrapClasspath) || opts.bootstrapClasspath.length === 0) {
            throw new TypeError("opts.bootstrapClasspath must be specified as an array of file paths.");
        }
        if (!Array.isArray(opts.classpath)) {
            throw new TypeError("opts.classpath must be specified as an array of file paths.");
        }
        if (typeof (opts.javaHomePath) !== 'string') {
            throw new TypeError("opts.javaHomePath must be specified.");
        }
        if (!Array.isArray(opts.nativeClasspath) || opts.nativeClasspath.length === 0) {
            throw new TypeError("opts.nativeClasspath must be specified as an array of file paths.");
        }
        this.nativeClasspath = opts.nativeClasspath;
        if (opts.enableSystemAssertions) {
            this.enableSystemAssertions = opts.enableSystemAssertions;
        }
        if (opts.enableAssertions) {
            this.enabledAssertions = opts.enableAssertions;
        }
        if (opts.disableAssertions) {
            this.disabledAssertions = opts.disableAssertions;
        }
        this.responsiveness = opts.responsiveness;
        this._initSystemProperties(bootstrapClasspath, opts.classpath.map(function (p) { return path.resolve(p); }), path.resolve(opts.javaHomePath), path.resolve(opts.tmpDir), opts.properties);
        /**
         * Task #1: Initialize native methods.
         */
        bootupTasks.push(function (next) {
            _this.initializeNatives(next);
        });
        /**
         * Task #2: Construct the bootstrap class loader.
         */
        bootupTasks.push(function (next) {
            _this.bsCl =
                new ClassLoader.BootstrapClassLoader(_this.systemProperties['java.home'], bootstrapClasspath, next);
        });
        /**
         * Task #3: Construct the thread pool, resolve thread class, and construct
         * the first thread.
         */
        bootupTasks.push(function (next) {
            _this.threadPool = new threadpool_1["default"](function () { return _this.threadPoolIsEmpty(); });
            // Resolve Ljava/lang/Thread so we can fake a thread.
            // NOTE: This should never actually use the Thread object unless
            // there's an error loading java/lang/Thread and associated classes.
            _this.bsCl.resolveClass(null, 'Ljava/lang/Thread;', function (threadCdata) {
                if (threadCdata == null) {
                    // Failed.
                    next("Failed to resolve java/lang/Thread.");
                }
                else {
                    // Construct a thread.
                    firstThreadObj = new (threadCdata.getConstructor(null))(null);
                    firstThreadObj.$thread = firstThread = _this.firstThread = new threading_1.JVMThread(_this, _this.threadPool, firstThreadObj);
                    firstThreadObj.ref = 1;
                    firstThreadObj['java/lang/Thread/priority'] = 5;
                    firstThreadObj['java/lang/Thread/name'] = util.initCarr(_this.bsCl, 'main');
                    firstThreadObj['java/lang/Thread/blockerLock'] = new (_this.bsCl.getResolvedClass('Ljava/lang/Object;').getConstructor(firstThread))(firstThread);
                    next();
                }
            });
        });
        /**
         * Task #4: Preinitialize some essential JVM classes, and initializes the
         * JVM's ThreadGroup once that class is initialized.
         */
        bootupTasks.push(function (next) {
            util.asyncForEach(coreClasses, function (coreClass, nextItem) {
                _this.bsCl.initializeClass(firstThread, coreClass, function (cdata) {
                    if (cdata == null) {
                        nextItem("Failed to initialize " + coreClass);
                    }
                    else {
                        // One of the later preinitialized classes references Thread.group.
                        // Initialize the system's ThreadGroup now.
                        if (coreClass === 'Ljava/lang/ThreadGroup;') {
                            // Construct a ThreadGroup object for the first thread.
                            var threadGroupCons = cdata.getConstructor(firstThread), groupObj = new threadGroupCons(firstThread);
                            groupObj['<init>()V'](firstThread, null, function (e) {
                                // Tell the initial thread to use this group.
                                firstThreadObj['java/lang/Thread/group'] = groupObj;
                                nextItem(e);
                            });
                        }
                        else {
                            nextItem();
                        }
                    }
                });
            }, next);
        });
        /**
         * Task #5: Initialize the system class.
         */
        bootupTasks.push(function (next) {
            // Initialize the system class (initializes things like println/etc).
            var sysInit = _this.bsCl.getInitializedClass(firstThread, 'Ljava/lang/System;').getConstructor(firstThread);
            sysInit['java/lang/System/initializeSystemClass()V'](firstThread, null, next);
            ;
        });
        /**
         * Task #6: Initialize the application's classloader.
         */
        bootupTasks.push(function (next) {
            var clCons = _this.bsCl.getInitializedClass(firstThread, 'Ljava/lang/ClassLoader;').getConstructor(firstThread);
            clCons['java/lang/ClassLoader/getSystemClassLoader()Ljava/lang/ClassLoader;'](firstThread, null, function (e, rv) {
                if (e) {
                    next(e);
                }
                else {
                    _this.systemClassLoader = rv.$loader;
                    firstThreadObj['java/lang/Thread/contextClassLoader'] = rv;
                    // Initialize assertion data.
                    // TODO: Is there a better way to force this? :|
                    var defaultAssertionStatus = _this.enabledAssertions === true ? 1 : 0;
                    rv['java/lang/ClassLoader/setDefaultAssertionStatus(Z)V'](firstThread, [defaultAssertionStatus], next);
                }
            });
        });
        // Perform bootup tasks, and then trigger the callback function.
        util.asyncSeries(bootupTasks, function (err) {
            // XXX: Without setImmediate, the firstThread won't clear out the stack
            // frame that triggered us, and the firstThread won't transition to a
            // 'terminated' status.
            setImmediate(function () {
                if (err) {
                    _this.status = enums_1.JVMStatus.TERMINATED;
                    cb(err);
                }
                else {
                    _this.status = enums_1.JVMStatus.BOOTED;
                    cb(null, _this);
                }
            });
        });
    }
    JVM.prototype.getResponsiveness = function () {
        var resp = this.responsiveness;
        if (typeof resp === 'number') {
            return resp;
        }
        else if (typeof resp === 'function') {
            return resp();
        }
    };
    JVM.getDefaultOptions = function (doppioHome) {
        var javaHome = path.join(doppioHome, 'vendor', 'java_home');
        return {
            doppioHomePath: doppioHome,
            classpath: ['.'],
            bootstrapClasspath: JDKInfo.classpath.map(function (item) { return path.join(javaHome, item); }),
            javaHomePath: javaHome,
            nativeClasspath: [path.join(doppioHome, 'natives')],
            enableSystemAssertions: false,
            enableAssertions: false,
            disableAssertions: null,
            properties: {},
            tmpDir: '/tmp',
            responsiveness: 1000
        };
    };
    /**
     * Get the URL to the version of the JDK that DoppioJVM was compiled with.
     */
    JVM.getCompiledJDKURL = function () {
        return JDKInfo.url;
    };
    /**
     * Get the JDK information that DoppioJVM was compiled against.
     */
    JVM.getJDKInfo = function () {
        return JDKInfo;
    };
    JVM.prototype.getSystemClassLoader = function () {
        return this.systemClassLoader;
    };
    JVM.isReleaseBuild = function () {
        return typeof (RELEASE) !== 'undefined' && RELEASE;
    };
    /**
     * Get the next "ref" number for JVM objects.
     */
    JVM.prototype.getNextRef = function () {
        return this.nextRef++;
    };
    /**
     * Retrieve the JVM's parker. Handles parking/unparking threads.
     */
    JVM.prototype.getParker = function () {
        return this.parker;
    };
    /**
     * Run the specified class on this JVM instance.
     * @param className The name of the class to run. Can be specified in either
     *   foo.bar.Baz or foo/bar/Baz format.
     * @param args Command line arguments passed to the class.
     * @param cb Called when the JVM finishes executing. Called with 'true' if
     *   the JVM exited normally, 'false' if there was an error.
     */
    JVM.prototype.runClass = function (className, args, cb) {
        var _this = this;
        if (this.status !== enums_1.JVMStatus.BOOTED) {
            switch (this.status) {
                case enums_1.JVMStatus.BOOTING:
                    throw new Error("JVM is currently booting up. Please wait for it to call the bootup callback, which you passed to the constructor.");
                case enums_1.JVMStatus.RUNNING:
                    throw new Error("JVM is already running.");
                case enums_1.JVMStatus.TERMINATED:
                    throw new Error("This JVM has already terminated. Please create a new JVM.");
                case enums_1.JVMStatus.TERMINATING:
                    throw new Error("This JVM is currently terminating. You should create a new JVM for each class you wish to run.");
            }
        }
        this.terminationCb = cb;
        var thread = this.firstThread;
        assert(thread != null, "Thread isn't created yet?");
        // Convert foo.bar.Baz => Lfoo/bar/Baz;
        className = util.int_classname(className);
        // Initialize the class.
        this.systemClassLoader.initializeClass(thread, className, function (cdata) {
            // If cdata is null, there was an error that ended execution.
            if (cdata != null) {
                // Convert the arguments.
                var strArrCons = _this.bsCl.getInitializedClass(thread, '[Ljava/lang/String;').getConstructor(thread), jvmifiedArgs = new strArrCons(thread, args.length), i;
                for (i = 0; i < args.length; i++) {
                    jvmifiedArgs.array[i] = util.initString(_this.bsCl, args[i]);
                }
                // Find the main method, and run it.
                _this.status = enums_1.JVMStatus.RUNNING;
                var cdataStatics = cdata.getConstructor(thread);
                if (cdataStatics['main([Ljava/lang/String;)V']) {
                    cdataStatics['main([Ljava/lang/String;)V'](thread, [jvmifiedArgs]);
                }
                else {
                    thread.throwNewException("Ljava/lang/NoSuchMethodError;", "Could not find main method in class " + cdata.getExternalName() + ".");
                }
            }
            else {
                process.stdout.write("Error: Could not find or load main class " + util.ext_classname(className) + "\n");
                // Erroneous exit.
                _this.terminationCb(1);
            }
        });
    };
    /**
     * [DEBUG] Returns 'true' if the specified method should be vtraced.
     */
    JVM.prototype.shouldVtrace = function (sig) {
        return this.vtraceMethods[sig] === true;
    };
    /**
     * [DEBUG] Specify a method to vtrace.
     */
    JVM.prototype.vtraceMethod = function (sig) {
        this.vtraceMethods[sig] = true;
    };
    /**
     * Run the specified JAR file on this JVM instance.
     * @param args Command line arguments passed to the class.
     * @param cb Called when the JVM finishes executing. Called with 'true' if
     *   the JVM exited normally, 'false' if there was an error.
     */
    JVM.prototype.runJar = function (args, cb) {
        this.runClass('doppio.JarLauncher', args, cb);
    };
    /**
     * Called when the ThreadPool is empty.
     */
    JVM.prototype.threadPoolIsEmpty = function () {
        var systemClass, systemCons;
        switch (this.status) {
            case enums_1.JVMStatus.BOOTING:
                // Ignore empty thread pools during boot process.
                return false;
            case enums_1.JVMStatus.BOOTED:
                assert(false, "Thread pool should not become empty after JVM is booted, but before it begins to run.");
                return false;
            case enums_1.JVMStatus.RUNNING:
                this.status = enums_1.JVMStatus.TERMINATING;
                systemClass = this.bsCl.getInitializedClass(this.firstThread, 'Ljava/lang/System;');
                assert(systemClass !== null, "Invariant failure: System class must be initialized when JVM is in RUNNING state.");
                systemCons = systemClass.getConstructor(this.firstThread);
                // This is a normal, non-erroneous exit. When this function completes, threadPoolIsEmpty() will be invoked again.
                systemCons['java/lang/System/exit(I)V'](this.firstThread, [0]);
                return false;
            case enums_1.JVMStatus.TERMINATED:
                assert(false, "Invariant failure: Thread pool cannot be emptied post-JVM termination.");
                return false;
            case enums_1.JVMStatus.TERMINATING:
                this.status = enums_1.JVMStatus.TERMINATED;
                if (this.terminationCb) {
                    this.terminationCb(this.exitCode);
                }
                this.firstThread.close();
                return true;
        }
    };
    /**
     * Check if the JVM has started running the main class.
     */
    JVM.prototype.hasVMBooted = function () {
        return !(this.status === enums_1.JVMStatus.BOOTING || this.status === enums_1.JVMStatus.BOOTED);
    };
    /**
     * Completely halt the JVM.
     */
    JVM.prototype.halt = function (status) {
        this.exitCode = status;
        this.status = enums_1.JVMStatus.TERMINATING;
        this.threadPool.getThreads().forEach(function (t) {
            t.setStatus(enums_1.ThreadStatus.TERMINATED);
        });
    };
    /**
     * Retrieve the given system property.
     */
    JVM.prototype.getSystemProperty = function (prop) {
        return this.systemProperties[prop];
    };
    /**
     * Retrieve an array of all of the system property names.
     */
    JVM.prototype.getSystemPropertyNames = function () {
        return Object.keys(this.systemProperties);
    };
    /**
     * Retrieve the unmanaged heap.
     */
    JVM.prototype.getHeap = function () {
        return this.heap;
    };
    /**
     * Interns the given JavaScript string. Returns the interned string.
     */
    JVM.prototype.internString = function (str, javaObj) {
        if (this.internedStrings.has(str)) {
            return this.internedStrings.get(str);
        }
        else {
            if (!javaObj) {
                javaObj = util.initString(this.bsCl, str);
            }
            this.internedStrings.set(str, javaObj);
            return javaObj;
        }
    };
    /**
     * Evaluate native modules. Emulates CommonJS functionality.
     */
    JVM.prototype.evalNativeModule = function (mod) {
        "use strict"; // Prevent eval from being terrible.
        var rv, 
        // Provide the natives with the Doppio API, if needed.
        DoppioJVM = _dereq_('./doppiojvm'), Buffer = buffer.Buffer, process2 = process, savedRequire = typeof _dereq_ !== 'undefined' ? _dereq_ : function (moduleName) {
            throw new Error("Cannot find module " + moduleName);
        };
        (function () {
            /* tslint:disable:no-unused-variable */
            /**
             * Called by the native method file. Registers the package's native
             * methods with the JVM.
             */
            function registerNatives(defs) {
                rv = defs;
            }
            /**
             * Emulates CommonJS require().
             * Placed into an eval() call to avoid browserify-dereq from
             * fucking renaming the goddamn thing to _dereq_.
             */
            eval("\nvar process = process2;\nfunction require(name) {\n  switch(name) {\n    case 'doppiojvm':\n    case '../doppiojvm':\n      return DoppioJVM;\n    case 'fs':\n      return fs;\n    case 'path':\n      return path;\n    case 'buffer':\n      return buffer;\n    case 'browserfs':\n      return BrowserFS;\n    case 'pako/lib/zlib/zstream':\n      return zstream;\n    case 'pako/lib/zlib/inflate':\n      return inflate;\n    case 'pako/lib/zlib/deflate':\n      return deflate;\n    case 'pako/lib/zlib/crc32':\n      return crc32;\n    case 'pako/lib/zlib/adler32':\n      return adler32;\n    default:\n      return savedRequire(name);\n  }\n}\n/**\n * Emulate AMD module 'define' function for natives compiled as AMD modules.\n */\nfunction define(resources, module) {\n  var args = [];\n  resources.forEach(function(resource) {\n    switch (resource) {\n      case 'require':\n        args.push(require);\n        break;\n      case 'exports':\n        args.push({});\n        break;\n      default:\n        args.push(require(resource));\n        break;\n    }\n  });\n  module.apply(null, args);\n}\neval(mod);\n");
            /* tslint:enable:no-unused-variable */
        })();
        return rv;
    };
    /**
     * Register native methods with the virtual machine.
     */
    JVM.prototype.registerNatives = function (newNatives) {
        var clsName, methSig;
        for (clsName in newNatives) {
            if (newNatives.hasOwnProperty(clsName)) {
                if (!this.natives.hasOwnProperty(clsName)) {
                    this.natives[clsName] = {};
                }
                var clsMethods = newNatives[clsName];
                for (methSig in clsMethods) {
                    if (clsMethods.hasOwnProperty(methSig)) {
                        // Don't check if it exists already. This allows us to overwrite
                        // native methods dynamically at runtime.
                        this.natives[clsName][methSig] = clsMethods[methSig];
                    }
                }
            }
        }
    };
    /**
     * Convenience function. Register a single native method with the virtual
     * machine. Can be used to update existing native methods based on runtime
     * information.
     */
    JVM.prototype.registerNative = function (clsName, methSig, native) {
        this.registerNatives({ clsName: { methSig: native } });
    };
    /**
     * Retrieve the native method for the given method of the given class.
     * Returns null if none found.
     */
    JVM.prototype.getNative = function (clsName, methSig) {
        clsName = util.descriptor2typestr(clsName);
        if (this.natives.hasOwnProperty(clsName)) {
            var clsMethods = this.natives[clsName];
            if (clsMethods.hasOwnProperty(methSig)) {
                return clsMethods[methSig];
            }
        }
        return null;
    };
    /**
     * !!DO NOT MUTATE THE RETURNED VALUE!!
     * Used by the find_invalid_natives tool.
     */
    JVM.prototype.getNatives = function () {
        return this.natives;
    };
    /**
     * Loads in all of the native method modules prior to execution.
     * Currently a hack around our classloader.
     * @todo Make neater with util.async stuff.
     */
    JVM.prototype.initializeNatives = function (doneCb) {
        var _this = this;
        var nextDir = function () {
            if (i === _this.nativeClasspath.length) {
                // Next phase: Load up the files.
                var count = processFiles.length;
                processFiles.forEach(function (file) {
                    fs.readFile(file, function (err, data) {
                        if (!err) {
                            _this.registerNatives(_this.evalNativeModule(data.toString()));
                        }
                        if (--count === 0) {
                            doneCb();
                        }
                    });
                });
            }
            else {
                var dir = _this.nativeClasspath[i++];
                fs.readdir(dir, function (err, files) {
                    if (err) {
                        return doneCb();
                    }
                    var j, file;
                    for (j = 0; j < files.length; j++) {
                        file = files[j];
                        if (file.substring(file.length - 3, file.length) === '.js') {
                            processFiles.push(path.join(dir, file));
                        }
                    }
                    nextDir();
                });
            }
        }, i = 0, processFiles = [];
        nextDir();
    };
    /**
     * [Private] Same as reset_system_properties, but called by the constructor.
     */
    JVM.prototype._initSystemProperties = function (bootstrapClasspath, javaClassPath, javaHomePath, tmpDir, opts) {
        this.systemProperties = util.merge({
            'java.class.path': javaClassPath.join(':'),
            'java.home': javaHomePath,
            'java.ext.dirs': path.join(javaHomePath, 'lib', 'ext'),
            'java.io.tmpdir': tmpDir,
            'sun.boot.class.path': bootstrapClasspath.join(':'),
            'file.encoding': 'UTF-8',
            'java.vendor': 'Doppio',
            'java.version': '1.8',
            'java.vendor.url': 'https://github.com/plasma-umass/doppio',
            'java.class.version': '52.0',
            'java.specification.version': '1.8',
            'line.separator': '\n',
            'file.separator': path.sep,
            'path.separator': ':',
            'user.dir': path.resolve('.'),
            'user.home': '.',
            'user.name': 'DoppioUser',
            'os.name': 'doppio',
            'os.arch': 'js',
            'os.version': '0',
            'java.vm.name': 'DoppioJVM 32-bit VM',
            'java.vm.version': pkg.version,
            'java.vm.vendor': 'PLASMA@UMass',
            'java.awt.headless': (util.are_in_browser()).toString(),
            'java.awt.graphicsenv': 'classes.awt.CanvasGraphicsEnvironment',
            'jline.terminal': 'jline.UnsupportedTerminal',
            'sun.arch.data.model': '32',
            'sun.jnu.encoding': "UTF-8" // Determines how Java parses command line options.
        }, opts);
    };
    /**
     * Retrieves the bootstrap class loader.
     */
    JVM.prototype.getBootstrapClassLoader = function () {
        return this.bsCl;
    };
    JVM.prototype.getStartupTime = function () {
        return this.startupTime;
    };
    /**
     * Returns `true` if system assertions are enabled, false otherwise.
     */
    JVM.prototype.areSystemAssertionsEnabled = function () {
        return this.enableSystemAssertions;
    };
    /**
     * Get a listing of classes with assertions enabled. Can also return 'true' or 'false.
     */
    JVM.prototype.getEnabledAssertions = function () {
        return this.enabledAssertions;
    };
    /**
     * Get a listing of classes with assertions disabled.
     */
    JVM.prototype.getDisabledAssertions = function () {
        return this.disabledAssertions;
    };
    /**
     * Specifies a directory to dump compiled code to.
     */
    JVM.prototype.dumpCompiledCode = function (dir) {
        this.dumpCompiledCodeDir = dir;
    };
    JVM.prototype.shouldDumpCompiledCode = function () {
        return this.dumpCompiledCodeDir !== null;
    };
    JVM.prototype.dumpObjectDefinition = function (cls, evalText) {
        if (this.shouldDumpCompiledCode()) {
            fs.writeFile(path.resolve(this.dumpCompiledCodeDir, cls.getExternalName() + "_object.dump"), evalText, function () { });
        }
    };
    JVM.prototype.dumpBridgeMethod = function (methodSig, evalText) {
        if (this.shouldDumpCompiledCode()) {
            fs.appendFile(path.resolve(this.dumpCompiledCodeDir, "vmtarget_bridge_methods.dump"), methodSig + ":\n" + evalText + "\n\n", function () { });
        }
    };
    /**
     * Asynchronously dumps JVM state to a file. Currently limited to thread
     * state.
     */
    JVM.prototype.dumpState = function (filename, cb) {
        fs.appendFile(filename, this.threadPool.getThreads().map(function (t) { return ("Thread " + t.getRef() + ":\n") + t.getPrintableStackTrace(); }).join("\n\n"), cb);
    };
    return JVM;
})();
module.exports = JVM;

}).call(this,BrowserFS.BFSRequire('process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../../package.json":undefined,"../package.json":11,"../vendor/java_home/jdk.json":48,"./ClassLoader":18,"./SafeMap":23,"./assert":26,"./doppiojvm":30,"./enums":31,"./heap":34,"./parker":43,"./threading":45,"./threadpool":46,"./util":47,"buffer":12,"fs":13,"pako/lib/zlib/adler32":2,"pako/lib/zlib/crc32":3,"pako/lib/zlib/deflate":4,"pako/lib/zlib/inflate":6,"pako/lib/zlib/zstream":10,"path":14}],39:[function(_dereq_,module,exports){
"use strict";
var gLong = _dereq_('./gLong');
// default module: logging
// used for debugging the stack and local variables
function debug_var(e) {
    if (e === null) {
        return '!';
    }
    else if (e === void 0) {
        return 'undef';
    }
    else if (e.ref != null) {
        return "*" + e.ref;
    }
    else if (e instanceof gLong) {
        return e + "L";
    }
    return e;
}
exports.debug_var = debug_var;
// used for debugging the stack and local variables
function debug_vars(arr) {
    return arr.map(debug_var);
}
exports.debug_vars = debug_vars;
// log levels
// TODO: turn this into an enum, if possible
exports.VTRACE = 10;
exports.TRACE = 9;
exports.DEBUG = 5;
exports.ERROR = 1;
exports.log_level = exports.ERROR;
function log(level, msgs) {
    if (level <= exports.log_level) {
        var msg = msgs.join(' ');
        if (level == 1) {
            console.error(msg);
        }
        else {
            console.log(msg);
        }
    }
}
function vtrace() {
    var msgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msgs[_i - 0] = arguments[_i];
    }
    log(exports.VTRACE, msgs);
}
exports.vtrace = vtrace;
function trace() {
    var msgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msgs[_i - 0] = arguments[_i];
    }
    log(exports.TRACE, msgs);
}
exports.trace = trace;
function debug() {
    var msgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msgs[_i - 0] = arguments[_i];
    }
    log(exports.DEBUG, msgs);
}
exports.debug = debug;
function error() {
    var msgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        msgs[_i - 0] = arguments[_i];
    }
    log(exports.ERROR, msgs);
}
exports.error = error;

},{"./gLong":32}],40:[function(_dereq_,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var util = _dereq_('./util');
var attributes = _dereq_('./attributes');
var assert = _dereq_('./assert');
var enums = _dereq_('./enums');
var StringOutputStream = _dereq_('./StringOutputStream');
var global = _dereq_('./global');
if (typeof RELEASE === 'undefined')
    global.RELEASE = false;
var trapped_methods = {
    'java/lang/ref/Reference': {
        // NOP, because we don't do our own GC and also this starts a thread?!?!?!
        '<clinit>()V': function (thread) { }
    },
    'java/lang/System': {
        'loadLibrary(Ljava/lang/String;)V': function (thread, libName) {
            // Some libraries test if native libraries are available,
            // and expect an exception if they are not.
            // List all of the native libraries we support.
            var lib = libName.toString();
            switch (lib) {
                case 'zip':
                case 'net':
                case 'nio':
                case 'awt':
                case 'fontmanager':
                case 'management':
                    return;
                default:
                    thread.throwNewException('Ljava/lang/UnsatisfiedLinkError;', "no " + lib + " in java.library.path");
                    break;
            }
        }
    },
    'java/lang/Terminator': {
        'setup()V': function (thread) {
            // XXX: We should probably fix this; we support threads now.
            // Historically: NOP'd because we didn't support threads.
        }
    },
    'java/nio/charset/Charset$3': {
        // this is trapped and NOP'ed for speed
        'run()Ljava/lang/Object;': function (thread, javaThis) {
            return null;
        }
    },
    'sun/nio/fs/DefaultFileSystemProvider': {
        // OpenJDK doesn't know what the "Doppio" platform is. Tell it to use the Linux file system.
        'create()Ljava/nio/file/spi/FileSystemProvider;': function (thread) {
            thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);
            var dfsp = thread.getBsCl().getInitializedClass(thread, 'Lsun/nio/fs/DefaultFileSystemProvider;'), dfspCls = dfsp.getConstructor(thread);
            dfspCls['createProvider(Ljava/lang/String;)Ljava/nio/file/spi/FileSystemProvider;'](thread, [thread.getJVM().internString('sun.nio.fs.LinuxFileSystemProvider')], util.forwardResult(thread));
        }
    }
};
function getTrappedMethod(clsName, methSig) {
    clsName = util.descriptor2typestr(clsName);
    if (trapped_methods.hasOwnProperty(clsName) && trapped_methods[clsName].hasOwnProperty(methSig)) {
        return trapped_methods[clsName][methSig];
    }
    return null;
}
/**
 * Shared functionality between Method and Field objects, as they are
 * represented similarly in class files.
 */
var AbstractMethodField = (function () {
    /**
     * Constructs a field or method object from raw class data.
     */
    function AbstractMethodField(cls, constantPool, slot, byteStream) {
        this.cls = cls;
        this.slot = slot;
        this.accessFlags = new util.Flags(byteStream.getUint16());
        this.name = constantPool.get(byteStream.getUint16()).value;
        this.rawDescriptor = constantPool.get(byteStream.getUint16()).value;
        this.attrs = attributes.makeAttributes(byteStream, constantPool);
    }
    AbstractMethodField.prototype.getAttribute = function (name) {
        for (var i = 0; i < this.attrs.length; i++) {
            var attr = this.attrs[i];
            if (attr.getName() === name) {
                return attr;
            }
        }
        return null;
    };
    AbstractMethodField.prototype.getAttributes = function (name) {
        return this.attrs.filter(function (attr) { return attr.getName() === name; });
    };
    /**
     * Get the particular type of annotation as a JVM byte array. Returns null
     * if the annotation does not exist.
     */
    AbstractMethodField.prototype.getAnnotationType = function (thread, name) {
        var annotation = this.getAttribute(name);
        if (annotation === null) {
            return null;
        }
        var byteArrCons = thread.getBsCl().getInitializedClass(thread, '[B').getConstructor(thread), rv = new byteArrCons(thread, 0);
        // TODO: Convert to typed array.
        var i, len = annotation.rawBytes.length, arr = new Array(len);
        for (i = 0; i < len; i++) {
            arr[i] = annotation.rawBytes.readInt8(i);
        }
        rv.array = arr;
        return rv;
    };
    // To satiate TypeScript. Consider it an 'abstract' method.
    AbstractMethodField.prototype.parseDescriptor = function (raw_descriptor) {
        throw new Error("Unimplemented error.");
    };
    return AbstractMethodField;
})();
exports.AbstractMethodField = AbstractMethodField;
var Field = (function (_super) {
    __extends(Field, _super);
    function Field(cls, constantPool, slot, byteStream) {
        _super.call(this, cls, constantPool, slot, byteStream);
        this.fullName = util.descriptor2typestr(cls.getInternalName()) + "/" + this.name;
    }
    /**
     * Calls cb with the reflectedField if it succeeds. Calls cb with null if it
     * fails.
     */
    Field.prototype.reflector = function (thread, cb) {
        var _this = this;
        var signatureAttr = this.getAttribute("Signature"), jvm = thread.getJVM(), bsCl = thread.getBsCl();
        var createObj = function (typeObj) {
            var fieldCls = bsCl.getInitializedClass(thread, 'Ljava/lang/reflect/Field;'), fieldObj = new (fieldCls.getConstructor(thread))(thread);
            fieldObj['java/lang/reflect/Field/clazz'] = _this.cls.getClassObject(thread);
            fieldObj['java/lang/reflect/Field/name'] = jvm.internString(_this.name);
            fieldObj['java/lang/reflect/Field/type'] = typeObj;
            fieldObj['java/lang/reflect/Field/modifiers'] = _this.accessFlags.getRawByte();
            fieldObj['java/lang/reflect/Field/slot'] = _this.slot;
            fieldObj['java/lang/reflect/Field/signature'] = signatureAttr !== null ? util.initString(bsCl, signatureAttr.sig) : null;
            fieldObj['java/lang/reflect/Field/annotations'] = _this.getAnnotationType(thread, 'RuntimeVisibleAnnotations');
            return fieldObj;
        };
        // Our field's type may not be loaded, so we asynchronously load it here.
        // In the future, we can speed up reflection by having a synchronous_reflector
        // method that we can try first, and which may fail.
        this.cls.getLoader().resolveClass(thread, this.rawDescriptor, function (cdata) {
            if (cdata != null) {
                cb(createObj(cdata.getClassObject(thread)));
            }
            else {
                cb(null);
            }
        });
    };
    Field.prototype.getDefaultFieldValue = function () {
        var desc = this.rawDescriptor;
        if (desc === 'J')
            return 'gLongZero';
        var c = desc[0];
        if (c === '[' || c === 'L')
            return 'null';
        return '0';
    };
    /**
     * Outputs a JavaScript field assignment for this field.
     */
    Field.prototype.outputJavaScriptField = function (jsConsName, outputStream) {
        if (this.accessFlags.isStatic()) {
            outputStream.write(jsConsName + "[\"" + util.reescapeJVMName(this.fullName) + "\"] = cls._getInitialStaticFieldValue(thread, \"" + util.reescapeJVMName(this.name) + "\");\n");
        }
        else {
            outputStream.write("this[\"" + util.reescapeJVMName(this.fullName) + "\"] = " + this.getDefaultFieldValue() + ";\n");
        }
    };
    return Field;
})(AbstractMethodField);
exports.Field = Field;
var Method = (function (_super) {
    __extends(Method, _super);
    function Method(cls, constantPool, slot, byteStream) {
        _super.call(this, cls, constantPool, slot, byteStream);
        var parsedDescriptor = util.getTypes(this.rawDescriptor), i, p;
        this.signature = this.name + this.rawDescriptor;
        this.fullSignature = util.descriptor2typestr(this.cls.getInternalName()) + "/" + this.signature;
        this.returnType = parsedDescriptor.pop();
        this.parameterTypes = parsedDescriptor;
        this.parameterWords = parsedDescriptor.length;
        // Double count doubles / longs.
        for (i = 0; i < this.parameterTypes.length; i++) {
            p = this.parameterTypes[i];
            if (p === 'D' || p === 'J') {
                this.parameterWords++;
            }
        }
        // Initialize 'code' property.
        var clsName = this.cls.getInternalName();
        if (getTrappedMethod(clsName, this.signature) !== null) {
            this.code = getTrappedMethod(clsName, this.signature);
            this.accessFlags.setNative(true);
        }
        else if (this.accessFlags.isNative()) {
            if (this.signature.indexOf('registerNatives()V', 0) < 0 && this.signature.indexOf('initIDs()V', 0) < 0) {
                // The first version of the native method attempts to fetch itself and
                // rewrite itself.
                var self = this;
                this.code = function (thread) {
                    // Try to fetch the native method.
                    var jvm = thread.getJVM(), c = jvm.getNative(clsName, self.signature);
                    if (c == null) {
                        thread.throwNewException('Ljava/lang/UnsatisfiedLinkError;', "Native method '" + self.getFullSignature() + "' not implemented.\nPlease fix or file a bug at https://github.com/plasma-umass/doppio/issues");
                    }
                    else {
                        self.code = c;
                        return c.apply(self, arguments);
                    }
                };
            }
            else {
                // Stub out initIDs and registerNatives.
                this.code = function () { };
            }
        }
        else if (!this.accessFlags.isAbstract()) {
            this.code = this.getAttribute('Code');
        }
    }
    /**
     * Checks if the method is a default method.
     * A default method is a public non-abstract instance method, that
     * is, a non-static method with a body, declared in an interface
     * type.
     */
    Method.prototype.isDefault = function () {
        return (this.accessFlags.isPublic() && !this.accessFlags.isAbstract() && !this.accessFlags.isStatic() && this.cls.accessFlags.isInterface());
    };
    Method.prototype.getFullSignature = function () {
        return this.cls.getExternalName() + "." + this.name + this.rawDescriptor;
    };
    /**
     * Checks if this particular method should be hidden in stack frames.
     * Used by OpenJDK's lambda implementation to hide lambda boilerplate.
     */
    Method.prototype.isHidden = function () {
        var rva = this.getAttribute('RuntimeVisibleAnnotations');
        return rva !== null && rva.isHidden;
    };
    /**
     * Checks if this particular method has the CallerSensitive annotation.
     */
    Method.prototype.isCallerSensitive = function () {
        var rva = this.getAttribute('RuntimeVisibleAnnotations');
        return rva !== null && rva.isCallerSensitive;
    };
    /**
     * Get the number of machine words (32-bit words) required to store the
     * parameters to this function. Includes adding in a machine word for 'this'
     * for non-static functions.
     */
    Method.prototype.getParamWordSize = function () {
        return this.parameterWords;
    };
    Method.prototype.getCodeAttribute = function () {
        assert(!this.accessFlags.isNative() && !this.accessFlags.isAbstract());
        return this.code;
    };
    Method.prototype.getNativeFunction = function () {
        assert(this.accessFlags.isNative() && typeof (this.code) === 'function');
        return this.code;
    };
    /**
     * Resolves all of the classes referenced through this method. Required in
     * order to create its reflection object.
     */
    Method.prototype._resolveReferencedClasses = function (thread, cb) {
        // Start with the return type + parameter types + reflection object types.
        var toResolve = this.parameterTypes.concat(this.returnType), code = this.code, exceptionAttribute = this.getAttribute("Exceptions");
        // Exception handler types.
        if (!this.accessFlags.isNative() && !this.accessFlags.isAbstract() && code.exceptionHandlers.length > 0) {
            toResolve.push('Ljava/lang/Throwable;'); // Mimic native Java (in case <any> is the only handler).
            // Filter out the <any> handlers.
            toResolve = toResolve.concat(code.exceptionHandlers.filter(function (handler) { return handler.catchType !== '<any>'; }).map(function (handler) { return handler.catchType; }));
        }
        // Resolve checked exception types.
        if (exceptionAttribute !== null) {
            toResolve = toResolve.concat(exceptionAttribute.exceptions);
        }
        this.cls.getLoader().resolveClasses(thread, toResolve, function (classes) {
            // Use bootstrap classloader for reflection classes.
            thread.getBsCl().resolveClasses(thread, ['Ljava/lang/reflect/Method;', 'Ljava/lang/reflect/Constructor;'], function (classes2) {
                if (classes === null || classes2 === null) {
                    cb(null);
                }
                else {
                    classes['Ljava/lang/reflect/Method;'] = classes2['Ljava/lang/reflect/Method;'];
                    classes['Ljava/lang/reflect/Constructor;'] = classes2['Ljava/lang/reflect/Constructor;'];
                    cb(classes);
                }
            });
        });
    };
    /**
     * Get a reflection object representing this method.
     */
    Method.prototype.reflector = function (thread, cb) {
        var _this = this;
        var bsCl = thread.getBsCl(), 
        // Grab the classes required to construct the needed arrays.
        clazzArray = bsCl.getInitializedClass(thread, '[Ljava/lang/Class;').getConstructor(thread), jvm = thread.getJVM(), 
        // Grab the needed attributes.
        signatureAttr = this.getAttribute("Signature"), exceptionAttr = this.getAttribute("Exceptions");
        // Retrieve all of the required class references.
        this._resolveReferencedClasses(thread, function (classes) {
            if (classes === null) {
                return cb(null);
            }
            // Construct the needed objects for the reflection object.
            var clazz = _this.cls.getClassObject(thread), name = jvm.internString(_this.name), parameterTypes = new clazzArray(thread, 0), returnType = classes[_this.returnType].getClassObject(thread), exceptionTypes = new clazzArray(thread, 0), modifiers = _this.accessFlags.getRawByte(), signature = signatureAttr !== null ? jvm.internString(signatureAttr.sig) : null;
            // Prepare the class arrays.
            parameterTypes.array = _this.parameterTypes.map(function (ptype) { return classes[ptype].getClassObject(thread); });
            if (exceptionAttr !== null) {
                exceptionTypes.array = exceptionAttr.exceptions.map(function (eType) { return classes[eType].getClassObject(thread); });
            }
            if (_this.name === '<init>') {
                // Constructor object.
                var consCons = classes['Ljava/lang/reflect/Constructor;'].getConstructor(thread), consObj = new consCons(thread);
                consObj['java/lang/reflect/Constructor/clazz'] = clazz;
                consObj['java/lang/reflect/Constructor/parameterTypes'] = parameterTypes;
                consObj['java/lang/reflect/Constructor/exceptionTypes'] = exceptionTypes;
                consObj['java/lang/reflect/Constructor/modifiers'] = modifiers;
                consObj['java/lang/reflect/Constructor/slot'] = _this.slot;
                consObj['java/lang/reflect/Constructor/signature'] = signature;
                consObj['java/lang/reflect/Constructor/annotations'] = _this.getAnnotationType(thread, 'RuntimeVisibleAnnotations');
                consObj['java/lang/reflect/Constructor/parameterAnnotations'] = _this.getAnnotationType(thread, 'RuntimeVisibleParameterAnnotations');
                cb(consObj);
            }
            else {
                // Method object.
                var methodCons = classes['Ljava/lang/reflect/Method;'].getConstructor(thread), methodObj = new methodCons(thread);
                methodObj['java/lang/reflect/Method/clazz'] = clazz;
                methodObj['java/lang/reflect/Method/name'] = name;
                methodObj['java/lang/reflect/Method/parameterTypes'] = parameterTypes;
                methodObj['java/lang/reflect/Method/returnType'] = returnType;
                methodObj['java/lang/reflect/Method/exceptionTypes'] = exceptionTypes;
                methodObj['java/lang/reflect/Method/modifiers'] = modifiers;
                methodObj['java/lang/reflect/Method/slot'] = _this.slot;
                methodObj['java/lang/reflect/Method/signature'] = signature;
                methodObj['java/lang/reflect/Method/annotations'] = _this.getAnnotationType(thread, 'RuntimeVisibleAnnotations');
                methodObj['java/lang/reflect/Method/annotationDefault'] = _this.getAnnotationType(thread, 'AnnotationDefault');
                methodObj['java/lang/reflect/Method/parameterAnnotations'] = _this.getAnnotationType(thread, 'RuntimeVisibleParameterAnnotations');
                cb(methodObj);
            }
        });
    };
    /**
     * Convert the arguments to this method into a form suitable for a native
     * implementation.
     *
     * The JVM uses two parameter slots for double and long values, since they
     * consist of two JVM machine words (32-bits). Doppio stores the entire value
     * in one slot, and stores a NULL in the second.
     *
     * This function strips out these NULLs so the arguments are in a more
     * consistent form. The return value is the arguments to this function without
     * these NULL values. It also adds the 'thread' object to the start of the
     * arguments array.
     */
    Method.prototype.convertArgs = function (thread, params) {
        if (this.isSignaturePolymorphic()) {
            // These don't need any conversion, and have arbitrary arguments.
            // Just append the thread object.
            params.unshift(thread);
            return params;
        }
        var convertedArgs = [thread], argIdx = 0, i;
        if (!this.accessFlags.isStatic()) {
            convertedArgs.push(params[0]);
            argIdx = 1;
        }
        for (i = 0; i < this.parameterTypes.length; i++) {
            var p = this.parameterTypes[i];
            convertedArgs.push(params[argIdx]);
            argIdx += (p === 'J' || p === 'D') ? 2 : 1;
        }
        return convertedArgs;
    };
    /**
     * Lock this particular method.
     */
    Method.prototype.methodLock = function (thread, frame) {
        if (this.accessFlags.isStatic()) {
            // Static methods lock the class.
            return this.cls.getClassObject(thread).getMonitor();
        }
        else {
            // Non-static methods lock the instance.
            return frame.locals[0].getMonitor();
        }
    };
    /**
     * Check if this is a signature polymorphic method.
     * From S2.9:
     * A method is signature polymorphic if and only if all of the following conditions hold :
     * * It is declared in the java.lang.invoke.MethodHandle class.
     * * It has a single formal parameter of type Object[].
     * * It has a return type of Object.
     * * It has the ACC_VARARGS and ACC_NATIVE flags set.
     */
    Method.prototype.isSignaturePolymorphic = function () {
        return this.cls.getInternalName() === 'Ljava/lang/invoke/MethodHandle;' &&
            this.accessFlags.isNative() && this.accessFlags.isVarArgs() &&
            this.rawDescriptor === '([Ljava/lang/Object;)Ljava/lang/Object;';
    };
    /**
     * Retrieve the MemberName/invokedynamic JavaScript "bridge method" that
     * encapsulates the logic required to call this particular method.
     */
    Method.prototype.getVMTargetBridgeMethod = function (thread, refKind) {
        // TODO: Could cache these in the Method object if desired.
        var outStream = new StringOutputStream(), virtualDispatch = !(refKind === enums.MethodHandleReferenceKind.INVOKESTATIC || refKind === enums.MethodHandleReferenceKind.INVOKESPECIAL);
        outStream.write("function _create(thread, cls, util) {\n");
        if (this.accessFlags.isStatic()) {
            assert(!virtualDispatch, "Can't have static virtual dispatch.");
            outStream.write("  var jsCons = cls.getConstructor(thread);\n");
        }
        outStream.write("  function bridgeMethod(thread, descriptor, args, cb) {\n");
        if (!this.accessFlags.isStatic()) {
            outStream.write("    var obj = args.shift();\n");
            outStream.write("    if (obj === null) { return thread.throwNewException('Ljava/lang/NullPointerException;', ''); }\n");
            outStream.write("    obj[\"" + util.reescapeJVMName(virtualDispatch ? this.signature : this.fullSignature) + "\"](thread, ");
        }
        else {
            outStream.write("    jsCons[\"" + util.reescapeJVMName(this.fullSignature) + "\"](thread, ");
        }
        // TODO: Is it ever appropriate to box arguments for varargs functions? It appears not.
        outStream.write("args");
        outStream.write(", cb);\n  }\n  return bridgeMethod;\n}\n_create");
        var evalText = outStream.flush();
        if (typeof RELEASE === 'undefined' && thread !== null && thread.getJVM().shouldDumpCompiledCode()) {
            thread.getJVM().dumpBridgeMethod(this.fullSignature, evalText);
        }
        return eval(evalText)(thread, this.cls, util);
    };
    /**
     * Generates JavaScript code for this particular method.
     * TODO: Move lock logic and such into this function! And other specialization.
     * TODO: Signature polymorphic functions...?
     */
    Method.prototype.outputJavaScriptFunction = function (jsConsName, outStream, nonVirtualOnly) {
        if (nonVirtualOnly === void 0) { nonVirtualOnly = false; }
        var i;
        if (this.accessFlags.isStatic()) {
            outStream.write(jsConsName + "[\"" + util.reescapeJVMName(this.fullSignature) + "\"] = " + jsConsName + "[\"" + util.reescapeJVMName(this.signature) + "\"] = ");
        }
        else {
            if (!nonVirtualOnly) {
                outStream.write(jsConsName + ".prototype[\"" + util.reescapeJVMName(this.signature) + "\"] = ");
            }
            outStream.write(jsConsName + ".prototype[\"" + util.reescapeJVMName(this.fullSignature) + "\"] = ");
        }
        // cb check is boilerplate, required for natives calling into JVM land.
        outStream.write("(function(method) {\n  return function(thread, args, cb) {\n    if (typeof cb === 'function') {\n      thread.stack.push(new InternalStackFrame(cb));\n    }\n    thread.stack.push(new " + (this.accessFlags.isNative() ? "NativeStackFrame" : "BytecodeStackFrame") + "(method, ");
        if (!this.accessFlags.isStatic()) {
            // Non-static functions need to add the implicit 'this' variable to the
            // local variables.
            outStream.write("[this");
            // Give the JS engine hints about the size, type, and contents of the array
            // by making it a literal.
            for (i = 0; i < this.parameterWords; i++) {
                outStream.write(", args[" + i + "]");
            }
            outStream.write("]");
        }
        else {
            // Static function doesn't need to mutate the arguments.
            if (this.parameterWords > 0) {
                outStream.write("args");
            }
            else {
                outStream.write("[]");
            }
        }
        outStream.write("));\n    thread.setStatus(" + enums.ThreadStatus.RUNNABLE + ");\n  };\n})(cls.getSpecificMethod(\"" + util.reescapeJVMName(this.cls.getInternalName()) + "\", \"" + util.reescapeJVMName(this.signature) + "\"));\n");
    };
    return Method;
})(AbstractMethodField);
exports.Method = Method;

},{"./StringOutputStream":24,"./assert":26,"./attributes":27,"./enums":31,"./global":33,"./util":47}],41:[function(_dereq_,module,exports){
/**
 * Contains JVM opcode implementations for the JVM interpreter.
 */
// We use snake case for the opcode names so they match the JVM spec.
// As for typedef:memberVariableDeclarator, we disable this so we can have
// member variable opcodes without explicitly typing them as IOpcodeImplementation.
/* tslint:disable:variable-name typedef:memberVariableDeclarator */
"use strict";
var gLong = _dereq_('./gLong');
var util = _dereq_('./util');
var enums = _dereq_('./enums');
var assert = _dereq_('./assert');
/**
 * Helper function: Checks if object is null. Throws a NullPointerException
 * if it is.
 * @return True if the object is null.
 */
function isNull(thread, frame, obj) {
    if (obj == null) {
        throwException(thread, frame, 'Ljava/lang/NullPointerException;', '');
        return true;
    }
    return false;
}
exports.isNull = isNull;
/**
 * Helper function: Pops off two items, returns the second.
 */
function pop2(opStack) {
    // Ignore NULL.
    opStack.pop();
    return opStack.pop();
}
exports.pop2 = pop2;
function resolveCPItem(thread, frame, cpItem) {
    thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);
    cpItem.resolve(thread, frame.getLoader(), frame.method.cls, function (status) {
        if (status) {
            thread.setStatus(enums.ThreadStatus.RUNNABLE);
        }
    }, false);
    frame.returnToThreadLoop = true;
}
exports.resolveCPItem = resolveCPItem;
function initializeClassFromClass(thread, frame, cls) {
    thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);
    cls.initialize(thread, function (cdata) {
        if (cdata != null) {
            thread.setStatus(enums.ThreadStatus.RUNNABLE);
        }
    }, false);
    frame.returnToThreadLoop = true;
}
exports.initializeClassFromClass = initializeClassFromClass;
/**
 * Helper function: Pauses the thread and initializes a class.
 */
function initializeClass(thread, frame, clsRef) {
    thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);
    function initialize(cls) {
        cls.initialize(thread, function (cdata) {
            if (cdata != null) {
                thread.setStatus(enums.ThreadStatus.RUNNABLE);
            }
        });
    }
    if (!clsRef.isResolved()) {
        clsRef.resolve(thread, frame.getLoader(), frame.method.cls, function (status) {
            if (status) {
                initialize(clsRef.cls);
            }
        }, false);
    }
    else {
        initialize(clsRef.cls);
    }
    frame.returnToThreadLoop = true;
}
exports.initializeClass = initializeClass;
/**
 * Interrupts the current method's execution and throws an exception.
 *
 * NOTE: This does *not* interrupt JavaScript control flow, so any opcode
 * calling this function must *return* and not do anything else.
 */
function throwException(thread, frame, clsName, msg) {
    thread.throwNewException(clsName, msg);
    frame.returnToThreadLoop = true;
}
exports.throwException = throwException;
exports.ArrayTypes = {
    4: 'Z', 5: 'C', 6: 'F', 7: 'D', 8: 'B', 9: 'S', 10: 'I', 11: 'J'
};
/**
 * Contains definitions for all JVM opcodes.
 */
var Opcodes = (function () {
    function Opcodes() {
    }
    /* 32-bit array load opcodes */
    /**
     * 32-bit array load opcode
     */
    Opcodes._aload_32 = function (thread, frame) {
        var opStack = frame.opStack, idx = opStack.pop(), obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            var len = obj.array.length;
            if (idx < 0 || idx >= len) {
                throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', idx + " not in length " + len + " array of type " + obj.getClass().getInternalName());
            }
            else {
                opStack.push(obj.array[idx]);
                frame.pc++;
            }
        }
        // 'obj' is NULL. isNull threw an exception for us.
    };
    /* 64-bit array load opcodes */
    /**
     * 64-bit array load opcode.
     */
    Opcodes._aload_64 = function (thread, frame) {
        var opStack = frame.opStack, idx = opStack.pop(), obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            var len = obj.array.length;
            if (idx < 0 || idx >= len) {
                throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', idx + " not in length " + len + " array of type " + obj.getClass().getInternalName());
            }
            else {
                opStack.push(obj.array[idx]);
                // 64-bit value.
                opStack.push(null);
                frame.pc++;
            }
        }
        // 'obj' is NULL. isNull threw an exception for us.
    };
    /* 32-bit array store opcodes */
    /**
     * 32-bit array store.
     * @private
     */
    Opcodes._astore_32 = function (thread, frame) {
        var opStack = frame.opStack, value = opStack.pop(), idx = opStack.pop(), obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            var len = obj.array.length;
            if (idx < 0 || idx >= len) {
                throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', idx + " not in length " + len + " array of type " + obj.getClass().getInternalName());
            }
            else {
                obj.array[idx] = value;
                frame.pc++;
            }
        }
        // 'obj' is NULL. isNull threw an exception for us.
    };
    /* 64-bit array store opcodes */
    /**
     * 64-bit array store.
     * @private
     */
    Opcodes._astore_64 = function (thread, frame) {
        var opStack = frame.opStack, value = opStack.pop2(), idx = opStack.pop(), obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            var len = obj.array.length;
            if (idx < 0 || idx >= len) {
                throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', idx + " not in length " + len + " array of type " + obj.getClass().getInternalName());
            }
            else {
                obj.array[idx] = value;
                frame.pc++;
            }
        }
        // 'obj' is NULL. isNull threw an exception for us.
    };
    /* 32-bit constants */
    Opcodes.aconst_null = function (thread, frame) {
        frame.opStack.push(null);
        frame.pc++;
    };
    Opcodes._const_0_32 = function (thread, frame) {
        frame.opStack.push(0);
        frame.pc++;
    };
    Opcodes._const_1_32 = function (thread, frame) {
        frame.opStack.push(1);
        frame.pc++;
    };
    Opcodes._const_2_32 = function (thread, frame) {
        frame.opStack.push(2);
        frame.pc++;
    };
    Opcodes.iconst_m1 = function (thread, frame) {
        frame.opStack.push(-1);
        frame.pc++;
    };
    Opcodes.iconst_3 = function (thread, frame) {
        frame.opStack.push(3);
        frame.pc++;
    };
    Opcodes.iconst_4 = function (thread, frame) {
        frame.opStack.push(4);
        frame.pc++;
    };
    Opcodes.iconst_5 = function (thread, frame) {
        frame.opStack.push(5);
        frame.pc++;
    };
    /* 64-bit constants */
    Opcodes.lconst_0 = function (thread, frame) {
        frame.opStack.pushWithNull(gLong.ZERO);
        frame.pc++;
    };
    Opcodes.lconst_1 = function (thread, frame) {
        frame.opStack.pushWithNull(gLong.ONE);
        frame.pc++;
    };
    Opcodes.dconst_0 = function (thread, frame) {
        frame.opStack.pushWithNull(0);
        frame.pc++;
    };
    Opcodes.dconst_1 = function (thread, frame) {
        frame.opStack.pushWithNull(1);
        frame.pc++;
    };
    /* 32-bit load opcodes */
    Opcodes._load_32 = function (thread, frame, code) {
        var pc = frame.pc;
        frame.opStack.push(frame.locals[code.readUInt8(pc + 1)]);
        frame.pc += 2;
    };
    Opcodes._load_0_32 = function (thread, frame) {
        frame.opStack.push(frame.locals[0]);
        frame.pc++;
    };
    Opcodes._load_1_32 = function (thread, frame) {
        frame.opStack.push(frame.locals[1]);
        frame.pc++;
    };
    Opcodes._load_2_32 = function (thread, frame) {
        frame.opStack.push(frame.locals[2]);
        frame.pc++;
    };
    Opcodes._load_3_32 = function (thread, frame) {
        frame.opStack.push(frame.locals[3]);
        frame.pc++;
    };
    /* 64-bit load opcodes */
    Opcodes._load_64 = function (thread, frame, code) {
        var pc = frame.pc;
        frame.opStack.pushWithNull(frame.locals[code.readUInt8(pc + 1)]);
        frame.pc += 2;
    };
    Opcodes._load_0_64 = function (thread, frame) {
        frame.opStack.pushWithNull(frame.locals[0]);
        frame.pc++;
    };
    Opcodes._load_1_64 = function (thread, frame) {
        frame.opStack.pushWithNull(frame.locals[1]);
        frame.pc++;
    };
    Opcodes._load_2_64 = function (thread, frame) {
        frame.opStack.pushWithNull(frame.locals[2]);
        frame.pc++;
    };
    Opcodes._load_3_64 = function (thread, frame) {
        frame.opStack.pushWithNull(frame.locals[3]);
        frame.pc++;
    };
    /* 32-bit store opcodes */
    Opcodes._store_32 = function (thread, frame, code) {
        var pc = frame.pc;
        frame.locals[code.readUInt8(pc + 1)] = frame.opStack.pop();
        frame.pc += 2;
    };
    Opcodes._store_0_32 = function (thread, frame) {
        frame.locals[0] = frame.opStack.pop();
        frame.pc++;
    };
    Opcodes._store_1_32 = function (thread, frame) {
        frame.locals[1] = frame.opStack.pop();
        frame.pc++;
    };
    Opcodes._store_2_32 = function (thread, frame) {
        frame.locals[2] = frame.opStack.pop();
        frame.pc++;
    };
    Opcodes._store_3_32 = function (thread, frame) {
        frame.locals[3] = frame.opStack.pop();
        frame.pc++;
    };
    /* 64-bit store opcodes */
    Opcodes._store_64 = function (thread, frame, code) {
        var pc = frame.pc;
        var offset = code.readUInt8(pc + 1);
        // NULL
        frame.locals[offset + 1] = frame.opStack.pop();
        // The actual value.
        frame.locals[offset] = frame.opStack.pop();
        frame.pc += 2;
    };
    Opcodes._store_0_64 = function (thread, frame) {
        frame.locals[1] = frame.opStack.pop();
        frame.locals[0] = frame.opStack.pop();
        frame.pc++;
    };
    Opcodes._store_1_64 = function (thread, frame) {
        frame.locals[2] = frame.opStack.pop();
        frame.locals[1] = frame.opStack.pop();
        frame.pc++;
    };
    Opcodes._store_2_64 = function (thread, frame) {
        frame.locals[3] = frame.opStack.pop();
        frame.locals[2] = frame.opStack.pop();
        frame.pc++;
    };
    Opcodes._store_3_64 = function (thread, frame) {
        frame.locals[4] = frame.opStack.pop();
        frame.locals[3] = frame.opStack.pop();
        frame.pc++;
    };
    /* Misc. */
    Opcodes.sipush = function (thread, frame, code) {
        var pc = frame.pc;
        frame.opStack.push(code.readInt16BE(pc + 1));
        frame.pc += 3;
    };
    Opcodes.bipush = function (thread, frame, code) {
        var pc = frame.pc;
        frame.opStack.push(code.readInt8(pc + 1));
        frame.pc += 2;
    };
    Opcodes.pop = function (thread, frame) {
        frame.opStack.dropFromTop(1);
        frame.pc++;
    };
    Opcodes.pop2 = function (thread, frame) {
        // http://i.imgur.com/MieF0KG.jpg
        frame.opStack.dropFromTop(2);
        frame.pc++;
    };
    Opcodes.dup = function (thread, frame) {
        frame.opStack.dup();
        frame.pc++;
    };
    Opcodes.dup_x1 = function (thread, frame) {
        frame.opStack.dup_x1();
        frame.pc++;
    };
    Opcodes.dup_x2 = function (thread, frame) {
        frame.opStack.dup_x2();
        frame.pc++;
    };
    Opcodes.dup2 = function (thread, frame) {
        frame.opStack.dup2();
        frame.pc++;
    };
    Opcodes.dup2_x1 = function (thread, frame) {
        frame.opStack.dup2_x1();
        frame.pc++;
    };
    Opcodes.dup2_x2 = function (thread, frame) {
        var opStack = frame.opStack, v1 = opStack.pop(), v2 = opStack.pop(), v3 = opStack.pop(), v4 = opStack.pop();
        opStack.push6(v2, v1, v4, v3, v2, v1);
        frame.pc++;
    };
    Opcodes.swap = function (thread, frame) {
        frame.opStack.swap();
        frame.pc++;
    };
    /* Math Opcodes */
    Opcodes.iadd = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push((opStack.pop() + opStack.pop()) | 0);
        frame.pc++;
    };
    Opcodes.ladd = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().add(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.fadd = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(util.wrapFloat(opStack.pop() + opStack.pop()));
        frame.pc++;
    };
    Opcodes.dadd = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2() + opStack.pop2());
        frame.pc++;
    };
    Opcodes.isub = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push((-opStack.pop() + opStack.pop()) | 0);
        frame.pc++;
    };
    Opcodes.fsub = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(util.wrapFloat(-opStack.pop() + opStack.pop()));
        frame.pc++;
    };
    Opcodes.dsub = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(-opStack.pop2() + opStack.pop2());
        frame.pc++;
    };
    Opcodes.lsub = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().negate().add(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.imul = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(Math.imul(opStack.pop(), opStack.pop()));
        frame.pc++;
    };
    Opcodes.lmul = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().multiply(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.fmul = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(util.wrapFloat(opStack.pop() * opStack.pop()));
        frame.pc++;
    };
    Opcodes.dmul = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2() * opStack.pop2());
        frame.pc++;
    };
    Opcodes.idiv = function (thread, frame) {
        var opStack = frame.opStack, b = opStack.pop(), a = opStack.pop();
        if (b === 0) {
            throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');
        }
        else {
            // spec: "if the dividend is the negative integer of largest possible magnitude
            // for the int type, and the divisor is -1, then overflow occurs, and the
            // result is equal to the dividend."
            if (a === enums.Constants.INT_MIN && b === -1) {
                opStack.push(a);
            }
            else {
                opStack.push((a / b) | 0);
            }
            frame.pc++;
        }
    };
    Opcodes.ldiv = function (thread, frame) {
        var opStack = frame.opStack, b = opStack.pop2(), a = opStack.pop2();
        if (b.isZero()) {
            throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');
        }
        else {
            opStack.pushWithNull(a.div(b));
            frame.pc++;
        }
    };
    Opcodes.fdiv = function (thread, frame) {
        var opStack = frame.opStack, a = opStack.pop();
        opStack.push(util.wrapFloat(opStack.pop() / a));
        frame.pc++;
    };
    Opcodes.ddiv = function (thread, frame) {
        var opStack = frame.opStack, v = opStack.pop2();
        opStack.pushWithNull(opStack.pop2() / v);
        frame.pc++;
    };
    Opcodes.irem = function (thread, frame) {
        var opStack = frame.opStack, b = opStack.pop(), a = opStack.pop();
        if (b === 0) {
            throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');
        }
        else {
            opStack.push(a % b);
            frame.pc++;
        }
    };
    Opcodes.lrem = function (thread, frame) {
        var opStack = frame.opStack, b = opStack.pop2(), a = opStack.pop2();
        if (b.isZero()) {
            throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');
        }
        else {
            opStack.pushWithNull(a.modulo(b));
            frame.pc++;
        }
    };
    Opcodes.frem = function (thread, frame) {
        var opStack = frame.opStack, b = opStack.pop();
        opStack.push(opStack.pop() % b);
        frame.pc++;
    };
    Opcodes.drem = function (thread, frame) {
        var opStack = frame.opStack, b = opStack.pop2();
        opStack.pushWithNull(opStack.pop2() % b);
        frame.pc++;
    };
    Opcodes.ineg = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(-opStack.pop() | 0);
        frame.pc++;
    };
    Opcodes.lneg = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().negate());
        frame.pc++;
    };
    Opcodes.fneg = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(-opStack.pop());
        frame.pc++;
    };
    Opcodes.dneg = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(-opStack.pop2());
        frame.pc++;
    };
    /* Bitwise Operations */
    Opcodes.ishl = function (thread, frame) {
        var opStack = frame.opStack, s = opStack.pop();
        opStack.push(opStack.pop() << s);
        frame.pc++;
    };
    Opcodes.lshl = function (thread, frame) {
        var opStack = frame.opStack, s = opStack.pop();
        opStack.pushWithNull(opStack.pop2().shiftLeft(gLong.fromInt(s)));
        frame.pc++;
    };
    Opcodes.ishr = function (thread, frame) {
        var opStack = frame.opStack, s = opStack.pop();
        opStack.push(opStack.pop() >> s);
        frame.pc++;
    };
    Opcodes.lshr = function (thread, frame) {
        var opStack = frame.opStack, s = opStack.pop();
        opStack.pushWithNull(opStack.pop2().shiftRight(gLong.fromInt(s)));
        frame.pc++;
    };
    Opcodes.iushr = function (thread, frame) {
        var opStack = frame.opStack, s = opStack.pop();
        opStack.push((opStack.pop() >>> s) | 0);
        frame.pc++;
    };
    Opcodes.lushr = function (thread, frame) {
        var opStack = frame.opStack, s = opStack.pop();
        opStack.pushWithNull(opStack.pop2().shiftRightUnsigned(gLong.fromInt(s)));
        frame.pc++;
    };
    Opcodes.iand = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(opStack.pop() & opStack.pop());
        frame.pc++;
    };
    Opcodes.land = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().and(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.ior = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(opStack.pop() | opStack.pop());
        frame.pc++;
    };
    Opcodes.lor = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().or(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.ixor = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(opStack.pop() ^ opStack.pop());
        frame.pc++;
    };
    Opcodes.lxor = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().xor(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.iinc = function (thread, frame, code) {
        var pc = frame.pc;
        var idx = code.readUInt8(pc + 1), val = code.readInt8(pc + 2);
        frame.locals[idx] = (frame.locals[idx] + val) | 0;
        frame.pc += 3;
    };
    Opcodes.i2l = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(gLong.fromInt(opStack.pop()));
        frame.pc++;
    };
    Opcodes.i2f = function (thread, frame) {
        // NOP; we represent ints as floats anyway.
        // @todo What about quantities unexpressable as floats?
        frame.pc++;
    };
    Opcodes.i2d = function (thread, frame) {
        frame.opStack.push(null);
        frame.pc++;
    };
    Opcodes.l2i = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(opStack.pop2().toInt());
        frame.pc++;
    };
    Opcodes.l2f = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(opStack.pop2().toNumber());
        frame.pc++;
    };
    Opcodes.l2d = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(opStack.pop2().toNumber());
        frame.pc++;
    };
    Opcodes.f2i = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(util.float2int(opStack.pop()));
        frame.pc++;
    };
    Opcodes.f2l = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pushWithNull(gLong.fromNumber(opStack.pop()));
        frame.pc++;
    };
    Opcodes.f2d = function (thread, frame) {
        frame.opStack.push(null);
        frame.pc++;
    };
    Opcodes.d2i = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(util.float2int(opStack.pop2()));
        frame.pc++;
    };
    Opcodes.d2l = function (thread, frame) {
        var opStack = frame.opStack, d_val = opStack.pop2();
        if (d_val === Number.POSITIVE_INFINITY) {
            opStack.pushWithNull(gLong.MAX_VALUE);
        }
        else if (d_val === Number.NEGATIVE_INFINITY) {
            opStack.pushWithNull(gLong.MIN_VALUE);
        }
        else {
            opStack.pushWithNull(gLong.fromNumber(d_val));
        }
        frame.pc++;
    };
    Opcodes.d2f = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.pop();
        opStack.push(util.wrapFloat(opStack.pop()));
        frame.pc++;
    };
    Opcodes.i2b = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push((opStack.pop() << 24) >> 24);
        frame.pc++;
    };
    Opcodes.i2c = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push(opStack.pop() & 0xFFFF);
        frame.pc++;
    };
    Opcodes.i2s = function (thread, frame) {
        var opStack = frame.opStack;
        opStack.push((opStack.pop() << 16) >> 16);
        frame.pc++;
    };
    Opcodes.lcmp = function (thread, frame) {
        var opStack = frame.opStack, v2 = opStack.pop2();
        opStack.push(opStack.pop2().compare(v2));
        frame.pc++;
    };
    Opcodes.fcmpl = function (thread, frame) {
        var opStack = frame.opStack, v2 = opStack.pop(), v1 = opStack.pop();
        if (v1 === v2) {
            opStack.push(0);
        }
        else if (v1 > v2) {
            opStack.push(1);
        }
        else {
            // v1 < v2, and if v1 or v2 is NaN.
            opStack.push(-1);
        }
        frame.pc++;
    };
    Opcodes.fcmpg = function (thread, frame) {
        var opStack = frame.opStack, v2 = opStack.pop(), v1 = opStack.pop();
        if (v1 === v2) {
            opStack.push(0);
        }
        else if (v1 < v2) {
            opStack.push(-1);
        }
        else {
            // v1 > v2, and if v1 or v2 is NaN.
            opStack.push(1);
        }
        frame.pc++;
    };
    Opcodes.dcmpl = function (thread, frame) {
        var opStack = frame.opStack, v2 = opStack.pop2(), v1 = opStack.pop2();
        if (v1 === v2) {
            opStack.push(0);
        }
        else if (v1 > v2) {
            opStack.push(1);
        }
        else {
            // v1 < v2, and if v1 or v2 is NaN.
            opStack.push(-1);
        }
        frame.pc++;
    };
    Opcodes.dcmpg = function (thread, frame) {
        var opStack = frame.opStack, v2 = opStack.pop2(), v1 = opStack.pop2();
        if (v1 === v2) {
            opStack.push(0);
        }
        else if (v1 < v2) {
            opStack.push(-1);
        }
        else {
            // v1 > v2, and if v1 or v2 is NaN.
            opStack.push(1);
        }
        frame.pc++;
    };
    /* Unary branch opcodes */
    Opcodes.ifeq = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() === 0) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.ifne = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() !== 0) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.iflt = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() < 0) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.ifge = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() >= 0) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.ifgt = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() > 0) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.ifle = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() <= 0) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    /* Binary branch opcodes */
    Opcodes.if_icmpeq = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 === v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_icmpne = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 !== v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_icmplt = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 < v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_icmpge = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 >= v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_icmpgt = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 > v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_icmple = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 <= v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_acmpeq = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 === v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.if_acmpne = function (thread, frame, code) {
        var pc = frame.pc;
        var v2 = frame.opStack.pop();
        var v1 = frame.opStack.pop();
        if (v1 !== v2) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    /* Jump opcodes */
    Opcodes.goto = function (thread, frame, code) {
        var pc = frame.pc;
        frame.pc += code.readInt16BE(pc + 1);
    };
    Opcodes.jsr = function (thread, frame, code) {
        var pc = frame.pc;
        frame.opStack.push(frame.pc + 3);
        frame.pc += code.readInt16BE(pc + 1);
    };
    Opcodes.ret = function (thread, frame, code) {
        var pc = frame.pc;
        frame.pc = frame.locals[code.readUInt8(pc + 1)];
    };
    Opcodes.tableswitch = function (thread, frame, code) {
        var pc = frame.pc;
        // Ignore padding bytes. The +1 is to skip the opcode byte.
        pc += ((4 - (pc + 1) % 4) % 4) + 1;
        var defaultOffset = code.readInt32BE(pc), low = code.readInt32BE(pc + 4), high = code.readInt32BE(pc + 8), offset = frame.opStack.pop();
        if (offset >= low && offset <= high) {
            frame.pc += code.readInt32BE(pc + 12 + ((offset - low) * 4));
        }
        else {
            frame.pc += defaultOffset;
        }
    };
    Opcodes.lookupswitch = function (thread, frame, code) {
        var pc = frame.pc;
        // Skip padding bytes. The +1 is to skip the opcode byte.
        pc += ((4 - (pc + 1) % 4) % 4) + 1;
        var defaultOffset = code.readInt32BE(pc), nPairs = code.readInt32BE(pc + 4), i, v = frame.opStack.pop();
        pc += 8;
        for (i = 0; i < nPairs; i++) {
            if (code.readInt32BE(pc) === v) {
                frame.pc += code.readInt32BE(pc + 4);
                return;
            }
            pc += 8;
        }
        // No match found.
        frame.pc += defaultOffset;
    };
    Opcodes.return = function (thread, frame) {
        frame.returnToThreadLoop = true;
        if (frame.method.accessFlags.isSynchronized()) {
            // monitorexit
            if (!frame.method.methodLock(thread, frame).exit(thread)) {
                // monitorexit threw an exception.
                return;
            }
        }
        thread.asyncReturn();
    };
    /* 32-bit return bytecodes */
    Opcodes._return_32 = function (thread, frame) {
        frame.returnToThreadLoop = true;
        if (frame.method.accessFlags.isSynchronized()) {
            // monitorexit
            if (!frame.method.methodLock(thread, frame).exit(thread)) {
                // monitorexit threw an exception.
                return;
            }
        }
        thread.asyncReturn(frame.opStack.bottom());
    };
    /* 64-bit return opcodes */
    Opcodes._return_64 = function (thread, frame) {
        frame.returnToThreadLoop = true;
        if (frame.method.accessFlags.isSynchronized()) {
            // monitorexit
            if (!frame.method.methodLock(thread, frame).exit(thread)) {
                // monitorexit threw an exception.
                return;
            }
        }
        thread.asyncReturn(frame.opStack.bottom(), null);
    };
    Opcodes.getstatic = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);
        if (fieldInfo.isResolved()) {
            // Get the *actual* class that owns this field.
            // This may not be initialized if it's an interface, so we need to check.
            var fieldOwnerCls = fieldInfo.field.cls;
            if (fieldOwnerCls.isInitialized(thread)) {
                // Opcode is ready to execute! Rewrite to a 'fast' version,
                // and run the fast version.
                if (fieldInfo.nameAndTypeInfo.descriptor === 'J' || fieldInfo.nameAndTypeInfo.descriptor === 'D') {
                    code.writeUInt8(enums.OpCode.GETSTATIC_FAST64, pc);
                }
                else {
                    code.writeUInt8(enums.OpCode.GETSTATIC_FAST32, pc);
                }
                // Stash the result of field lookup.
                fieldInfo.fieldOwnerConstructor = fieldOwnerCls.getConstructor(thread);
            }
            else {
                // Initialize class and rerun opcode
                initializeClassFromClass(thread, frame, fieldOwnerCls);
            }
        }
        else {
            // Resolve the field.
            resolveCPItem(thread, frame, fieldInfo);
        }
    };
    /**
     * A fast version of getstatic that assumes that relevant classes are
     * initialized.
     *
     * Retrieves a 32-bit value.
     */
    Opcodes.getstatic_fast32 = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        frame.opStack.push(fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName]);
        frame.pc += 3;
    };
    /**
     * A fast version of getstatic that assumes that relevant classes are
     * initialized.
     *
     * Retrieves a 64-bit value.
     */
    Opcodes.getstatic_fast64 = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        frame.opStack.pushWithNull(fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName]);
        frame.pc += 3;
    };
    Opcodes.putstatic = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);
        if (fieldInfo.isResolved()) {
            // Get the *actual* class that owns this field.
            // This may not be initialized if it's an interface, so we need to check.
            var fieldOwnerCls = fieldInfo.field.cls;
            if (fieldOwnerCls.isInitialized(thread)) {
                // Opcode is ready to execute! Rewrite to a 'fast' version,
                // and run the fast version.
                if (fieldInfo.nameAndTypeInfo.descriptor === 'J' || fieldInfo.nameAndTypeInfo.descriptor === 'D') {
                    code.writeUInt8(enums.OpCode.PUTSTATIC_FAST64, pc);
                }
                else {
                    code.writeUInt8(enums.OpCode.PUTSTATIC_FAST32, pc);
                }
                // Stash the result of field lookup.
                fieldInfo.fieldOwnerConstructor = fieldOwnerCls.getConstructor(thread);
            }
            else {
                // Initialize class and rerun opcode
                initializeClassFromClass(thread, frame, fieldOwnerCls);
            }
        }
        else {
            // Resolve the field.
            resolveCPItem(thread, frame, fieldInfo);
        }
    };
    /**
     * A fast version of putstatic that assumes that relevant classes are
     * initialized.
     *
     * Puts a 32-bit value.
     */
    Opcodes.putstatic_fast32 = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName] = frame.opStack.pop();
        frame.pc += 3;
    };
    /**
     * A fast version of putstatic that assumes that relevant classes are
     * initialized.
     *
     * Puts a 64-bit value.
     */
    Opcodes.putstatic_fast64 = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName] = frame.opStack.pop2();
        frame.pc += 3;
    };
    Opcodes.getfield = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), loader = frame.getLoader(), obj = frame.opStack.top();
        assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);
        // Check if the object is null; if we do not do this before get_class, then
        // we might try to get a class that we have not initialized!
        if (!isNull(thread, frame, obj)) {
            // cls is guaranteed to be in the inheritance hierarchy of obj, so it must be
            // initialized. However, it may not be loaded in the current class's
            // ClassLoader...
            if (fieldInfo.isResolved()) {
                var field = fieldInfo.field;
                if (field.rawDescriptor == 'J' || field.rawDescriptor == 'D') {
                    code.writeUInt8(enums.OpCode.GETFIELD_FAST64, pc);
                }
                else {
                    code.writeUInt8(enums.OpCode.GETFIELD_FAST32, pc);
                }
            }
            else {
                resolveCPItem(thread, frame, fieldInfo);
            }
        }
    };
    Opcodes.getfield_fast32 = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            opStack.push(obj[fieldInfo.fullFieldName]);
            frame.pc += 3;
        }
    };
    Opcodes.getfield_fast64 = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            opStack.pushWithNull(obj[fieldInfo.fullFieldName]);
            frame.pc += 3;
        }
    };
    Opcodes.putfield = function (thread, frame, code) {
        var pc = frame.pc;
        var fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), loader = frame.getLoader(), isLong = fieldInfo.nameAndTypeInfo.descriptor == 'J' || fieldInfo.nameAndTypeInfo.descriptor == 'D', obj = frame.opStack.fromTop(isLong ? 2 : 1);
        assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);
        // Check if the object is null; if we do not do this before get_class, then
        // we might try to get a class that we have not initialized!
        if (!isNull(thread, frame, obj)) {
            // cls is guaranteed to be in the inheritance hierarchy of obj, so it must be
            // initialized. However, it may not be loaded in the current class's
            // ClassLoader...
            if (fieldInfo.isResolved()) {
                var field = fieldInfo.field;
                if (isLong) {
                    code.writeUInt8(enums.OpCode.PUTFIELD_FAST64, pc);
                }
                else {
                    code.writeUInt8(enums.OpCode.PUTFIELD_FAST32, pc);
                }
                // Stash the resolved full field name.
                fieldInfo.fullFieldName = util.descriptor2typestr(field.cls.getInternalName()) + "/" + fieldInfo.nameAndTypeInfo.name;
            }
            else {
                resolveCPItem(thread, frame, fieldInfo);
            }
        }
    };
    Opcodes.putfield_fast32 = function (thread, frame, code) {
        var pc = frame.pc;
        var opStack = frame.opStack, val = opStack.pop(), obj = opStack.pop(), fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (!isNull(thread, frame, obj)) {
            obj[fieldInfo.fullFieldName] = val;
            frame.pc += 3;
        }
        // NPE has been thrown.
    };
    Opcodes.putfield_fast64 = function (thread, frame, code) {
        var pc = frame.pc;
        var opStack = frame.opStack, val = opStack.pop2(), obj = opStack.pop(), fieldInfo = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (!isNull(thread, frame, obj)) {
            obj[fieldInfo.fullFieldName] = val;
            frame.pc += 3;
        }
        // NPE has been thrown.
    };
    Opcodes.invokevirtual = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        // Ensure referenced class is loaded in the current classloader.
        // Even though we don't use this class for anything, and we know that it
        // must be loaded because it is in the object's inheritance hierarchy,
        // it needs to be present in the current classloader.
        if (methodReference.isResolved()) {
            var m = methodReference.method;
            if (m.isSignaturePolymorphic()) {
                switch (m.name) {
                    case 'invokeBasic':
                        code.writeUInt8(enums.OpCode.INVOKEBASIC, pc);
                        break;
                    case 'invoke':
                    case 'invokeExact':
                        code.writeUInt8(enums.OpCode.INVOKEHANDLE, pc);
                        break;
                    default:
                        throwException(thread, frame, 'Ljava/lang/AbstractMethodError;', "Invalid signature polymorphic method: " + m.cls.getExternalName() + "." + m.name);
                        break;
                }
            }
            else {
                code.writeUInt8(enums.OpCode.INVOKEVIRTUAL_FAST, pc);
            }
        }
        else {
            resolveCPItem(thread, frame, methodReference);
        }
    };
    Opcodes.invokeinterface = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (methodReference.isResolved()) {
            if (methodReference.method.cls.isInitialized(thread)) {
                // Rewrite to fast and rerun.
                code.writeUInt8(enums.OpCode.INVOKEINTERFACE_FAST, pc);
            }
            else {
                // Initialize our class and rerun opcode.
                // Note that the existance of an object of an interface type does *not*
                // mean that the interface is initialized!
                initializeClass(thread, frame, methodReference.classInfo);
            }
        }
        else {
            resolveCPItem(thread, frame, methodReference);
        }
    };
    Opcodes.invokedynamic = function (thread, frame, code) {
        var pc = frame.pc;
        var callSiteSpecifier = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);
        callSiteSpecifier.constructCallSiteObject(thread, frame.getLoader(), frame.method.cls, pc, function (status) {
            if (status) {
                assert(typeof (callSiteSpecifier.getCallSiteObject(pc)[0].vmtarget) === 'function', "MethodName should be resolved...");
                code.writeUInt8(enums.OpCode.INVOKEDYNAMIC_FAST, pc);
                // Resume and rerun fast opcode.
                thread.setStatus(enums.ThreadStatus.RUNNABLE);
            }
        });
        frame.returnToThreadLoop = true;
    };
    /**
     * XXX: Actually perform superclass method lookup.
     */
    Opcodes.invokespecial = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (methodReference.isResolved()) {
            // Rewrite and rerun.
            code.writeUInt8(enums.OpCode.INVOKENONVIRTUAL_FAST, pc);
        }
        else {
            resolveCPItem(thread, frame, methodReference);
        }
    };
    Opcodes.invokestatic = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (methodReference.isResolved()) {
            var m = methodReference.method;
            if (m.cls.isInitialized(thread)) {
                var newOpcode = enums.OpCode.INVOKESTATIC_FAST;
                if (methodReference.method.isSignaturePolymorphic()) {
                    switch (methodReference.method.name) {
                        case 'linkToInterface':
                        case 'linkToVirtual':
                            newOpcode = enums.OpCode.LINKTOVIRTUAL;
                            break;
                        case 'linkToStatic':
                        case 'linkToSpecial':
                            newOpcode = enums.OpCode.LINKTOSPECIAL;
                            break;
                        default:
                            assert(false, "Should be impossible.");
                            break;
                    }
                }
                // Rewrite and rerun.
                code.writeUInt8(newOpcode, pc);
            }
            else {
                initializeClassFromClass(thread, frame, m.cls);
            }
        }
        else {
            resolveCPItem(thread, frame, methodReference);
        }
    };
    /// Fast invoke opcodes.
    Opcodes.invokenonvirtual_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, paramSize = methodReference.paramWordSize, obj = opStack.fromTop(paramSize), args = opStack.sliceFromTop(paramSize);
        if (!isNull(thread, frame, obj)) {
            opStack.dropFromTop(paramSize + 1);
            assert(typeof obj[methodReference.fullSignature] === 'function', "Resolved method " + methodReference.fullSignature + " isn't defined?!", thread);
            obj[methodReference.fullSignature](thread, args);
            frame.returnToThreadLoop = true;
        }
    };
    Opcodes.invokestatic_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, paramSize = methodReference.paramWordSize, args = opStack.sliceFromTop(paramSize);
        opStack.dropFromTop(paramSize);
        assert(methodReference.jsConstructor != null, "jsConstructor is missing?!");
        assert(typeof (methodReference.jsConstructor[methodReference.fullSignature]) === 'function', "Resolved method isn't defined?!");
        methodReference.jsConstructor[methodReference.fullSignature](thread, args);
        frame.returnToThreadLoop = true;
    };
    Opcodes.invokevirtual_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), count = methodReference.paramWordSize, opStack = frame.opStack, obj = opStack.fromTop(count);
        if (!isNull(thread, frame, obj)) {
            // Use the class of the *object*.
            assert(typeof obj[methodReference.signature] === 'function', "Resolved method " + methodReference.signature + " isn't defined?!");
            obj[methodReference.signature](thread, opStack.sliceFromTop(count));
            opStack.dropFromTop(count + 1);
            frame.returnToThreadLoop = true;
        }
        // Object is NULL; NPE has been thrown.
    };
    Opcodes.invokedynamic_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var callSiteSpecifier = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), cso = callSiteSpecifier.getCallSiteObject(pc), appendix = cso[1], fcn = cso[0].vmtarget, opStack = frame.opStack, paramSize = callSiteSpecifier.paramWordSize, args = opStack.sliceFromTop(paramSize);
        opStack.dropFromTop(paramSize);
        if (appendix !== null) {
            args.push(appendix);
        }
        fcn(thread, null, args);
        frame.returnToThreadLoop = true;
    };
    /**
     * Opcode for MethodHandle.invoke and MethodHandle.invokeExact.
     */
    Opcodes.invokehandle = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, fcn = methodReference.memberName.vmtarget, 
        // Add in 1 for the method handle itself.
        paramSize = methodReference.paramWordSize + 1, appendix = methodReference.appendix, args = opStack.sliceFromTop(paramSize);
        if (appendix !== null) {
            args.push(appendix);
        }
        if (!isNull(thread, frame, args[0])) {
            opStack.dropFromTop(paramSize);
            // fcn will handle invoking 'this' and such.
            // TODO: If this can be varargs, pass in parameter types to the function.
            fcn(thread, null, args);
            frame.returnToThreadLoop = true;
        }
    };
    /**
     * Opcode for MethodHandle.invokeBasic.
     * Unlike invoke/invokeExact, invokeBasic does not call a generated bytecode
     * method. It calls the vmtarget embedded in the MethodHandler directly.
     * This can cause crashes with malformed calls, thus it is only accesssible
     * to trusted JDK code.
     */
    Opcodes.invokebasic = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), paramSize = methodReference.getParamWordSize(), opStack = frame.opStack, obj = opStack.fromTop(paramSize), 
        // Need to include the MethodHandle in the arguments to vmtarget. vmtarget
        // will appropriately invoke it.
        args = opStack.sliceFromTop(paramSize + 1), lmbdaForm, mn, m;
        // obj is a MethodHandle.
        if (!isNull(thread, frame, obj)) {
            opStack.dropFromTop(paramSize + 1);
            lmbdaForm = obj['java/lang/invoke/MethodHandle/form'];
            mn = lmbdaForm['java/lang/invoke/LambdaForm/vmentry'];
            assert(mn.vmtarget !== null && mn.vmtarget !== undefined, "vmtarget must be defined");
            mn.vmtarget(thread, methodReference.nameAndTypeInfo.descriptor, args);
            frame.returnToThreadLoop = true;
        }
    };
    /**
     * Also used for linkToStatic.
     * TODO: De-conflate the two.
     * TODO: Varargs functions.
     */
    Opcodes.linktospecial = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, paramSize = methodReference.paramWordSize, 
        // Final argument is the relevant MemberName. Function args are right
        // before it.
        args = opStack.sliceFromTop(paramSize), memberName = args.pop(), 
        // TODO: Use parsed descriptor.
        desc = methodReference.nameAndTypeInfo.descriptor;
        if (!isNull(thread, frame, memberName)) {
            opStack.dropFromTop(paramSize);
            assert(memberName.getClass().getInternalName() === "Ljava/lang/invoke/MemberName;");
            // parameterTypes for function are the same as the method reference, but without the trailing MemberName.
            // TODO: Use parsed descriptor, avoid re-doing work here.
            memberName.vmtarget(thread, desc.replace("Ljava/lang/invoke/MemberName;)", ")"), args);
            frame.returnToThreadLoop = true;
        }
    };
    // XXX: Varargs functions. We're supposed to box args if target is varargs.
    Opcodes.linktovirtual = function (thread, frame, code) {
        var pc = frame.pc;
        var methodReference = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), paramSize = methodReference.paramWordSize, opStack = frame.opStack, args = opStack.sliceFromTop(paramSize), 
        // Final argument is the relevant MemberName. Function args are right
        // before it.
        memberName = args.pop(), desc = methodReference.nameAndTypeInfo.descriptor;
        if (!isNull(thread, frame, memberName)) {
            opStack.dropFromTop(paramSize);
            assert(memberName.getClass().getInternalName() === "Ljava/lang/invoke/MemberName;");
            // parameterTypes for function are the same as the method reference, but without the trailing MemberName.
            memberName.vmtarget(thread, desc.replace("Ljava/lang/invoke/MemberName;)", ")"), args);
            frame.returnToThreadLoop = true;
        }
    };
    Opcodes.breakpoint = function (thread, frame) {
        throwException(thread, frame, "Ljava/lang/Error;", "breakpoint not implemented.");
    };
    Opcodes.new = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (classRef.isResolved()) {
            var cls = classRef.cls;
            if (cls.isInitialized(thread)) {
                code.writeUInt8(enums.OpCode.NEW_FAST, pc);
            }
            else {
                initializeClassFromClass(thread, frame, cls);
            }
        }
        else {
            resolveCPItem(thread, frame, classRef);
        }
    };
    Opcodes.new_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        frame.opStack.push(new classRef.clsConstructor(thread));
        frame.pc += 3;
    };
    Opcodes.newarray = function (thread, frame, code) {
        var pc = frame.pc;
        // TODO: Stash all of these array types during JVM startup.
        var opStack = frame.opStack, type = "[" + exports.ArrayTypes[code.readUInt8(pc + 1)], cls = frame.getLoader().getInitializedClass(thread, type), length = opStack.pop();
        if (length >= 0) {
            opStack.push(new (cls.getConstructor(thread))(thread, length));
            frame.pc += 2;
        }
        else {
            throwException(thread, frame, 'Ljava/lang/NegativeArraySizeException;', "Tried to init " + type + " array with length " + length);
        }
    };
    Opcodes.anewarray = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (classRef.isResolved()) {
            // Rewrite and rerun.
            code.writeUInt8(enums.OpCode.ANEWARRAY_FAST, pc);
            classRef.arrayClass = frame.getLoader().getInitializedClass(thread, "[" + classRef.cls.getInternalName());
            classRef.arrayClassConstructor = classRef.arrayClass.getConstructor(thread);
        }
        else {
            resolveCPItem(thread, frame, classRef);
        }
    };
    Opcodes.anewarray_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var opStack = frame.opStack, classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), length = opStack.pop();
        if (length >= 0) {
            opStack.push(new classRef.arrayClassConstructor(thread, length));
            frame.pc += 3;
        }
        else {
            throwException(thread, frame, 'Ljava/lang/NegativeArraySizeException;', "Tried to init " + classRef.arrayClass.getInternalName() + " array with length " + length);
        }
    };
    Opcodes.arraylength = function (thread, frame) {
        var opStack = frame.opStack, obj = opStack.pop();
        if (!isNull(thread, frame, obj)) {
            opStack.push(obj.array.length);
            frame.pc++;
        }
        // obj is NULL. isNull threw an exception for us.
    };
    Opcodes.athrow = function (thread, frame) {
        thread.throwException(frame.opStack.pop());
        frame.returnToThreadLoop = true;
    };
    Opcodes.checkcast = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (classRef.isResolved()) {
            // Rewrite to fast version, and re-execute.
            code.writeUInt8(enums.OpCode.CHECKCAST_FAST, pc);
        }
        else {
            resolveCPItem(thread, frame, classRef);
        }
    };
    Opcodes.checkcast_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), cls = classRef.cls, opStack = frame.opStack, o = opStack.top();
        if ((o != null) && !o.getClass().isCastable(cls)) {
            var targetClass = cls.getExternalName();
            var candidateClass = o.getClass().getExternalName();
            throwException(thread, frame, 'Ljava/lang/ClassCastException;', candidateClass + " cannot be cast to " + targetClass);
        }
        else {
            // Success!
            frame.pc += 3;
        }
    };
    Opcodes.instanceof = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (classRef.isResolved()) {
            // Rewrite and rerun.
            code.writeUInt8(enums.OpCode.INSTANCEOF_FAST, pc);
        }
        else {
            // Fetch class and rerun opcode.
            resolveCPItem(thread, frame, classRef);
        }
    };
    Opcodes.instanceof_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), cls = classRef.cls, opStack = frame.opStack, o = opStack.pop();
        opStack.push(o !== null ? (o.getClass().isCastable(cls) ? 1 : 0) : 0);
        frame.pc += 3;
    };
    Opcodes.monitorenter = function (thread, frame) {
        var opStack = frame.opStack, monitorObj = opStack.pop(), monitorEntered = function () {
            // [Note: Thread is now in the RUNNABLE state.]
            // Increment the PC.
            frame.pc++;
        };
        if (!monitorObj.getMonitor().enter(thread, monitorEntered)) {
            // Opcode failed. monitorEntered will be run once we own the monitor.
            // The thread is now in the BLOCKED state. Tell the frame to return to
            // the thread loop.
            frame.returnToThreadLoop = true;
        }
        else {
            monitorEntered();
        }
    };
    Opcodes.monitorexit = function (thread, frame) {
        var monitorObj = frame.opStack.pop();
        if (monitorObj.getMonitor().exit(thread)) {
            frame.pc++;
        }
        else {
            // monitorexit failed, and threw an exception.
            frame.returnToThreadLoop = true;
        }
    };
    Opcodes.multianewarray = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (classRef.isResolved()) {
            // Rewrite and rerun.
            code.writeUInt8(enums.OpCode.MULTIANEWARRAY_FAST, pc);
        }
        else {
            resolveCPItem(thread, frame, classRef);
        }
    };
    Opcodes.multianewarray_fast = function (thread, frame, code) {
        var pc = frame.pc;
        var classRef = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)), opStack = frame.opStack, dim = code.readUInt8(pc + 3), i, 
        // Arguments to the constructor.
        args = new Array(dim), dimSize;
        for (i = 0; i < dim; i++) {
            dimSize = opStack.pop();
            args[dim - i - 1] = dimSize;
            if (dimSize < 0) {
                throwException(thread, frame, 'Ljava/lang/NegativeArraySizeException;', "Tried to init " + classRef.cls.getInternalName() + " array with a dimension of length " + dimSize);
                return;
            }
        }
        opStack.push(new (classRef.cls.getConstructor(thread))(thread, args));
        frame.pc += 4;
    };
    Opcodes.ifnull = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() == null) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.ifnonnull = function (thread, frame, code) {
        var pc = frame.pc;
        if (frame.opStack.pop() != null) {
            frame.pc += code.readInt16BE(pc + 1);
        }
        else {
            frame.pc += 3;
        }
    };
    Opcodes.goto_w = function (thread, frame, code) {
        var pc = frame.pc;
        frame.pc += code.readInt32BE(pc + 1);
    };
    Opcodes.jsr_w = function (thread, frame, code) {
        var pc = frame.pc;
        frame.opStack.push(frame.pc + 5);
        frame.pc += code.readInt32BE(pc + 1);
    };
    Opcodes.nop = function (thread, frame) {
        frame.pc += 1;
    };
    Opcodes.ldc = function (thread, frame, code) {
        var pc = frame.pc;
        var constant = frame.method.cls.constantPool.get(code.readUInt8(pc + 1));
        if (constant.isResolved()) {
            assert((function () {
                switch (constant.getType()) {
                    case enums.ConstantPoolItemType.STRING:
                    case enums.ConstantPoolItemType.CLASS:
                    case enums.ConstantPoolItemType.METHOD_HANDLE:
                    case enums.ConstantPoolItemType.METHOD_TYPE:
                    case enums.ConstantPoolItemType.INTEGER:
                    case enums.ConstantPoolItemType.FLOAT:
                        return true;
                    default:
                        return false;
                }
            })(), "Constant pool item " + enums.ConstantPoolItemType[constant.getType()] + " is not appropriate for LDC.");
            frame.opStack.push(constant.getConstant(thread));
            frame.pc += 2;
        }
        else {
            resolveCPItem(thread, frame, constant);
        }
    };
    Opcodes.ldc_w = function (thread, frame, code) {
        var pc = frame.pc;
        var constant = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        if (constant.isResolved()) {
            assert((function () {
                switch (constant.getType()) {
                    case enums.ConstantPoolItemType.STRING:
                    case enums.ConstantPoolItemType.CLASS:
                    case enums.ConstantPoolItemType.METHOD_HANDLE:
                    case enums.ConstantPoolItemType.METHOD_TYPE:
                    case enums.ConstantPoolItemType.INTEGER:
                    case enums.ConstantPoolItemType.FLOAT:
                        return true;
                    default:
                        return false;
                }
            })(), "Constant pool item " + enums.ConstantPoolItemType[constant.getType()] + " is not appropriate for LDC_W.");
            frame.opStack.push(constant.getConstant(thread));
            frame.pc += 3;
        }
        else {
            resolveCPItem(thread, frame, constant);
        }
    };
    Opcodes.ldc2_w = function (thread, frame, code) {
        var pc = frame.pc;
        var constant = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));
        assert(constant.getType() === enums.ConstantPoolItemType.LONG
            || constant.getType() === enums.ConstantPoolItemType.DOUBLE, "Invalid ldc_w constant pool type: " + enums.ConstantPoolItemType[constant.getType()]);
        frame.opStack.pushWithNull(constant.value);
        frame.pc += 3;
    };
    Opcodes.wide = function (thread, frame, code) {
        var pc = frame.pc;
        var index = code.readUInt16BE(pc + 2);
        // Increment PC before switch to avoid issue where ret chances PC and we
        // erroneously increment the PC further.
        frame.pc += 4;
        switch (code.readUInt8(pc + 1)) {
            case enums.OpCode.ILOAD:
            case enums.OpCode.FLOAD:
            case enums.OpCode.ALOAD:
                frame.opStack.push(frame.locals[index]);
                break;
            case enums.OpCode.LLOAD:
            case enums.OpCode.DLOAD:
                frame.opStack.pushWithNull(frame.locals[index]);
                break;
            case enums.OpCode.ISTORE:
            case enums.OpCode.FSTORE:
            case enums.OpCode.ASTORE:
                frame.locals[index] = frame.opStack.pop();
                break;
            case enums.OpCode.LSTORE:
            case enums.OpCode.DSTORE:
                // NULL
                frame.locals[index + 1] = frame.opStack.pop();
                // The actual value.
                frame.locals[index] = frame.opStack.pop();
                break;
            case enums.OpCode.RET:
                frame.pc = frame.locals[index];
                break;
            case enums.OpCode.IINC:
                var value = code.readInt16BE(pc + 4);
                frame.locals[index] = (frame.locals[index] + value) | 0;
                // wide iinc has 2 extra bytes.
                frame.pc += 2;
                break;
            default:
                assert(false, "Unknown wide opcode: " + code.readUInt8(pc + 1));
                break;
        }
    };
    Opcodes.iaload = Opcodes._aload_32;
    Opcodes.faload = Opcodes._aload_32;
    Opcodes.aaload = Opcodes._aload_32;
    Opcodes.baload = Opcodes._aload_32;
    Opcodes.caload = Opcodes._aload_32;
    Opcodes.saload = Opcodes._aload_32;
    Opcodes.daload = Opcodes._aload_64;
    Opcodes.laload = Opcodes._aload_64;
    Opcodes.iastore = Opcodes._astore_32;
    Opcodes.fastore = Opcodes._astore_32;
    Opcodes.aastore = Opcodes._astore_32;
    Opcodes.bastore = Opcodes._astore_32;
    Opcodes.castore = Opcodes._astore_32;
    Opcodes.sastore = Opcodes._astore_32;
    Opcodes.lastore = Opcodes._astore_64;
    Opcodes.dastore = Opcodes._astore_64;
    Opcodes.iconst_0 = Opcodes._const_0_32;
    Opcodes.iconst_1 = Opcodes._const_1_32;
    Opcodes.iconst_2 = Opcodes._const_2_32;
    Opcodes.fconst_0 = Opcodes._const_0_32;
    Opcodes.fconst_1 = Opcodes._const_1_32;
    Opcodes.fconst_2 = Opcodes._const_2_32;
    Opcodes.iload = Opcodes._load_32;
    Opcodes.iload_0 = Opcodes._load_0_32;
    Opcodes.iload_1 = Opcodes._load_1_32;
    Opcodes.iload_2 = Opcodes._load_2_32;
    Opcodes.iload_3 = Opcodes._load_3_32;
    Opcodes.fload = Opcodes._load_32;
    Opcodes.fload_0 = Opcodes._load_0_32;
    Opcodes.fload_1 = Opcodes._load_1_32;
    Opcodes.fload_2 = Opcodes._load_2_32;
    Opcodes.fload_3 = Opcodes._load_3_32;
    Opcodes.aload = Opcodes._load_32;
    Opcodes.aload_0 = Opcodes._load_0_32;
    Opcodes.aload_1 = Opcodes._load_1_32;
    Opcodes.aload_2 = Opcodes._load_2_32;
    Opcodes.aload_3 = Opcodes._load_3_32;
    Opcodes.lload = Opcodes._load_64;
    Opcodes.lload_0 = Opcodes._load_0_64;
    Opcodes.lload_1 = Opcodes._load_1_64;
    Opcodes.lload_2 = Opcodes._load_2_64;
    Opcodes.lload_3 = Opcodes._load_3_64;
    Opcodes.dload = Opcodes._load_64;
    Opcodes.dload_0 = Opcodes._load_0_64;
    Opcodes.dload_1 = Opcodes._load_1_64;
    Opcodes.dload_2 = Opcodes._load_2_64;
    Opcodes.dload_3 = Opcodes._load_3_64;
    Opcodes.istore = Opcodes._store_32;
    Opcodes.istore_0 = Opcodes._store_0_32;
    Opcodes.istore_1 = Opcodes._store_1_32;
    Opcodes.istore_2 = Opcodes._store_2_32;
    Opcodes.istore_3 = Opcodes._store_3_32;
    Opcodes.fstore = Opcodes._store_32;
    Opcodes.fstore_0 = Opcodes._store_0_32;
    Opcodes.fstore_1 = Opcodes._store_1_32;
    Opcodes.fstore_2 = Opcodes._store_2_32;
    Opcodes.fstore_3 = Opcodes._store_3_32;
    Opcodes.astore = Opcodes._store_32;
    Opcodes.astore_0 = Opcodes._store_0_32;
    Opcodes.astore_1 = Opcodes._store_1_32;
    Opcodes.astore_2 = Opcodes._store_2_32;
    Opcodes.astore_3 = Opcodes._store_3_32;
    Opcodes.lstore = Opcodes._store_64;
    Opcodes.lstore_0 = Opcodes._store_0_64;
    Opcodes.lstore_1 = Opcodes._store_1_64;
    Opcodes.lstore_2 = Opcodes._store_2_64;
    Opcodes.lstore_3 = Opcodes._store_3_64;
    Opcodes.dstore = Opcodes._store_64;
    Opcodes.dstore_0 = Opcodes._store_0_64;
    Opcodes.dstore_1 = Opcodes._store_1_64;
    Opcodes.dstore_2 = Opcodes._store_2_64;
    Opcodes.dstore_3 = Opcodes._store_3_64;
    Opcodes.ireturn = Opcodes._return_32;
    Opcodes.freturn = Opcodes._return_32;
    Opcodes.areturn = Opcodes._return_32;
    Opcodes.lreturn = Opcodes._return_64;
    Opcodes.dreturn = Opcodes._return_64;
    Opcodes.invokeinterface_fast = Opcodes.invokevirtual_fast;
    return Opcodes;
})();
exports.Opcodes = Opcodes;
exports.LookupTable = new Array(0xff);
// Put in function closure to prevent scope pollution.
(function () {
    for (var i = 0; i < 0xff; i++) {
        if (enums.OpCode.hasOwnProperty("" + i)) {
            exports.LookupTable[i] = Opcodes[enums.OpCode[i].toLowerCase()];
            assert(exports.LookupTable[i] != null, "Missing implementation of opcode " + enums.OpCode[i]);
        }
    }
})();

},{"./assert":26,"./enums":31,"./gLong":32,"./util":47}],42:[function(_dereq_,module,exports){
// Usage.
var PrefixParseResult = (function () {
    function PrefixParseResult(result, unparsedArgs) {
        if (unparsedArgs === void 0) { unparsedArgs = []; }
        this._result = result;
        this._unparsedArgs = unparsedArgs;
    }
    PrefixParseResult.prototype.unparsedArgs = function () {
        return this._unparsedArgs;
    };
    PrefixParseResult.prototype.flag = function (name, defaultVal) {
        var val = this._result[name];
        if (typeof (val) === 'boolean') {
            return val;
        }
        return defaultVal;
    };
    PrefixParseResult.prototype.stringOption = function (name, defaultVal) {
        var val = this._result[name];
        if (typeof (val) === 'string') {
            return val;
        }
        return defaultVal;
    };
    PrefixParseResult.prototype.mapOption = function (name) {
        var val = this._result[name];
        if (typeof (val) === 'object') {
            return val;
        }
        return {};
    };
    return PrefixParseResult;
})();
exports.PrefixParseResult = PrefixParseResult;
function getOptName(prefix, name) {
    return prefix !== 'default' ? "" + prefix + name : name;
}
/**
 * Handles parsing for a specific options configuration.
 * Parses Java-style options.
 */
var OptionParser = (function () {
    function OptionParser(desc) {
        var _this = this;
        this._parseMap = {};
        this._prefixes = [];
        this._mapArgs = [];
        this._rawDesc = desc;
        this._prefixes = Object.keys(desc);
        this._prefixes.forEach(function (prefix) {
            var opts = desc[prefix];
            var optNames = Object.keys(opts);
            optNames.slice(0).forEach(function (optName) {
                var option = opts[optName];
                if (!option.type) {
                    option.type = 0 /* FLAG */;
                }
                if (option.type === 4 /* MAP_SYNTAX */) {
                    // ASSUMPTION: These do not have aliases.
                    _this._mapArgs.push(optName);
                }
                option.prefix = prefix;
                option.name = optName;
                _this._parseMap[getOptName(prefix, optName)] = option;
                if (option.alias) {
                    optNames.push(option.alias);
                    _this._parseMap[getOptName(prefix, option.alias)] = option;
                }
            });
        });
    }
    /**
     * Parses the given arguments. Throws an exception on parsing failure.
     */
    OptionParser.prototype.parse = function (argv) {
        var _this = this;
        var result = {}, ptr = 0, len;
        this._prefixes.forEach(function (prefix) { return result[prefix] = {}; });
        argv = argv.map(function (arg) { return arg.trim(); }).filter(function (arg) { return arg !== ''; });
        len = argv.length;
        while (ptr < len) {
            var arg = argv[ptr];
            if (arg[0] === '-') {
                arg = arg.slice(1);
                var opt;
                if (opt = this._parseMap[arg]) {
                    switch (opt.type) {
                        case 0 /* FLAG */:
                        case 2 /* COLON_VALUE_OR_FLAG_SYNTAX */:
                            result[opt.prefix][opt.name] = true;
                            break;
                        case 3 /* NORMAL_VALUE_SYNTAX */:
                        case 1 /* COLON_VALUE_SYNTAX */:
                            ptr++;
                            if (ptr < len) {
                                result[opt.prefix][opt.name] = argv[ptr];
                            }
                            else {
                                throw new Error("-" + arg + " requires an argument.");
                            }
                            break;
                        case 4 /* MAP_SYNTAX */:
                            // NOP.
                            break;
                        default:
                            // Invalid.
                            throw new Error("INTERNAL ERROR: Invalid parse type for -" + arg + ".");
                    }
                }
                else if (this._mapArgs.filter(function (mapArg) {
                    if (arg.slice(0, mapArg.length) === mapArg) {
                        opt = _this._parseMap[mapArg];
                        return true;
                    }
                    return false;
                }).length > 0) {
                    // ASSUMPTION: Map args are mutually exclusive.
                    // Argument is -{mapArg}key=value
                    // If no value, set to ''.
                    var mapping = arg.slice(opt.name.length), map = result[opt.prefix][opt.name];
                    if (!map) {
                        map = result[opt.prefix][opt.name] = {};
                    }
                    var eqIdx = mapping.indexOf('=');
                    if (eqIdx !== -1) {
                        map[mapping.slice(0, eqIdx)] = mapping.slice(eqIdx + 1);
                    }
                    else {
                        map[mapping] = "";
                    }
                }
                else if (arg.indexOf(':') !== -1 && (opt = this._parseMap[arg.slice(0, arg.indexOf(':'))])) {
                    // Colon option.
                    if (opt.type === 1 /* COLON_VALUE_SYNTAX */ || opt.type === 2 /* COLON_VALUE_OR_FLAG_SYNTAX */) {
                        result[opt.prefix][opt.name] = arg.slice(arg.indexOf(':') + 1);
                    }
                    else {
                        // Unrecognized option.
                        throw new Error("Unrecognized option: -" + arg);
                    }
                }
                else {
                    throw new Error("Unrecognized option: -" + arg);
                }
                if (opt.stopParsing) {
                    ptr++;
                    break;
                }
            }
            else {
                break;
            }
            // Advance to next value.
            ptr++;
        }
        // ptr is at raw args to program / JVM.
        var unparsedArgs = argv.slice(ptr), rv = {};
        Object.keys(result).forEach(function (prefix) {
            rv[prefix] = new PrefixParseResult(result[prefix], unparsedArgs);
        });
        return rv;
    };
    /**
     * Generates help text for the given prefixed options.
     */
    OptionParser.prototype.help = function (prefix) {
        return _showHelp(this._rawDesc[prefix], prefix === 'default' ? '' : prefix);
    };
    return OptionParser;
})();
exports.OptionParser = OptionParser;
function printCol(value, width) {
    var rv = value;
    var padding = width - value.length;
    while (padding-- > 0) {
        rv += ' ';
    }
    return rv;
}
function _showHelp(category, prefix) {
    var combinedKeys = {};
    var keyColWidth = 13;
    Object.keys(category).forEach(function (key) {
        var opt = category[key];
        // Ignored in help text.
        if (opt.stopParsing) {
            return;
        }
        var keys = [key];
        if (opt.alias != null) {
            keys.push(opt.alias);
        }
        var ckey;
        if (opt.optDesc) {
            ckey = keys.map(function (key) { return ("-" + prefix + key + opt.optDesc); }).join("\n");
        }
        else {
            ckey = keys.map(function (key) { return ("-" + prefix + key); }).join(' | ');
        }
        combinedKeys[ckey] = opt;
    });
    return Object.keys(combinedKeys).map(function (key) {
        var option = combinedKeys[key];
        if (option.optDesc) {
            var cols = key.split('\n');
            var rv = cols.map(function (row) { return ("    " + row); });
            // Multiline.
            return rv.join('\n') + "\n                  " + option.desc;
        }
        else {
            var colText = printCol(key, keyColWidth);
            if (colText.length === keyColWidth) {
                return "    " + colText + " " + option.desc;
            }
            else {
                return "    " + colText + "\n                  " + option.desc;
            }
        }
    }).join('\n') + '\n';
}

},{}],43:[function(_dereq_,module,exports){
var enums_1 = _dereq_('./enums');
var assert = _dereq_('./assert');
/**
 * Manages parked threads and their callbacks.
 */
var Parker = (function () {
    function Parker() {
        this._parkCounts = {};
        this._parkCallbacks = {};
    }
    Parker.prototype.park = function (thread, cb) {
        var ref = thread.getRef();
        assert(!this._parkCallbacks[ref] && thread.getStatus() !== enums_1.ThreadStatus.PARKED, "Thread " + ref + " is doubly parked? Should be impossible.");
        this._parkCallbacks[ref] = cb;
        this._mutateParkCount(thread, 1);
        // It's possible the thread was instantly unparked due to a previously
        // unbalancing park.
        if (this.isParked(thread)) {
            thread.setStatus(enums_1.ThreadStatus.PARKED);
        }
    };
    Parker.prototype.unpark = function (thread) {
        this._mutateParkCount(thread, -1);
    };
    Parker.prototype.completelyUnpark = function (thread) {
        var ref = thread.getRef(), count = this._parkCounts[ref];
        if (count) {
            this._mutateParkCount(thread, -count);
        }
    };
    Parker.prototype._mutateParkCount = function (thread, delta) {
        var ref = thread.getRef(), cb;
        // Initialize park count.
        if (!this._parkCounts[ref]) {
            this._parkCounts[ref] = 0;
        }
        if (0 === (this._parkCounts[ref] += delta)) {
            assert(!!this._parkCallbacks[ref], "Balancing unpark for thread " + ref + " with no callback? Should be impossible.");
            cb = this._parkCallbacks[ref];
            // Cleanup.
            delete this._parkCounts[ref];
            delete this._parkCallbacks[ref];
            // Avoid situations where a terminated thread's timeout wakes up
            // and tries to revive its thread.
            if (thread.getStatus() === enums_1.ThreadStatus.PARKED) {
                thread.setStatus(enums_1.ThreadStatus.ASYNC_WAITING);
                cb();
            }
        }
    };
    Parker.prototype.isParked = function (thread) {
        return !!this._parkCounts[thread.getRef()];
    };
    return Parker;
})();
module.exports = Parker;

},{"./assert":26,"./enums":31}],44:[function(_dereq_,module,exports){
(function (process){
"use strict";
var JVM = _dereq_('./jvm');
var util = _dereq_('./util');
var difflib = _dereq_('./difflib');
var path = _dereq_('path');
var fs = _dereq_('fs');
function makeTestingError(msg, origErr, fatal) {
    var err = new Error(msg);
    err.originalError = origErr;
    err.fatal = fatal;
    return err;
}
/**
 * Captures stdout/stderr.
 * @todo Do this the proper Node way once BFS is more compliant.
 */
var OutputCapturer = (function () {
    function OutputCapturer() {
        this._stdoutWrite = process.stdout.write;
        this._stderrWrite = process.stderr.write;
        this._data = "";
        this._isCapturing = false;
    }
    OutputCapturer.prototype.debugWrite = function (str) {
        this._stdoutWrite.apply(process.stdout, [str, 'utf8']);
    };
    /**
     * Begin capturing output.
     */
    OutputCapturer.prototype.start = function (clear) {
        var _this = this;
        if (this._isCapturing) {
            throw new Error("Already capturing.");
        }
        this._isCapturing = true;
        if (clear) {
            this._data = "";
        }
        process.stderr.write = process.stdout.write = function (data, arg2, arg3) {
            if (typeof (data) !== 'string') {
                // Buffer.
                data = data.toString();
            }
            _this._data += data;
            return true;
        };
    };
    /**
     * Stop capturing output.
     */
    OutputCapturer.prototype.stop = function () {
        if (!this._isCapturing) {
            // May be called twice when there's a catastrophic error.
            return;
        }
        this._isCapturing = false;
        process.stderr.write = this._stderrWrite;
        process.stdout.write = this._stdoutWrite;
    };
    /**
     * Retrieve the captured output.
     * @param clear Clear the captured output.
     */
    OutputCapturer.prototype.getOutput = function (clear) {
        var data = this._data;
        if (clear) {
            this._data = "";
        }
        return data;
    };
    return OutputCapturer;
})();
/**
 * Represents a single unit test, where we compare Doppio's output to the native
 * JVM.
 */
var DoppioTest = (function () {
    function DoppioTest(opts, cls) {
        /**
         * The output capturer for this test.
         */
        this.outputCapturer = new OutputCapturer();
        this.opts = opts;
        if (cls.indexOf('.') !== -1) {
            // Convert foo.bar.Baz => foo/bar/Baz
            cls = util.descriptor2typestr(util.int_classname(cls));
        }
        this.cls = cls;
        this.outFile = path.resolve(opts.doppioHomePath, cls) + ".runout";
    }
    /**
     * Constructs a new JVM for the test.
     */
    DoppioTest.prototype.constructJVM = function (cb) {
        new JVM(util.merge(JVM.getDefaultOptions(this.opts.doppioHomePath), this.opts, {
            classpath: [this.opts.doppioHomePath],
            enableAssertions: true,
            enableSystemAssertions: true
        }), cb);
    };
    /**
     * Runs the unit test.
     */
    DoppioTest.prototype.run = function (registerGlobalErrorTrap, cb) {
        var _this = this;
        var outputCapturer = this.outputCapturer, _jvm = null, terminated = false, jvmConstructHasFinished = false, hasFinished = false;
        registerGlobalErrorTrap(function (err) {
            if (_jvm) {
                try {
                    _jvm.halt(1);
                }
                catch (e) {
                    err.message += "\n\nAdditionally, test runner received the following error while trying to halt the JVM: " + e + (e.stack ? "\n\n" + e.stack : '') + "\n\nOriginal error's stack trace:";
                }
            }
            outputCapturer.stop();
            cb(makeTestingError("Uncaught error. Aborting further tests.\n\t" + err + (err.stack ? "\n\n" + err.stack : ""), err, true));
        });
        this.constructJVM(function (err, jvm) {
            _jvm = jvm;
            if (terminated) {
                // Already handled.
                return;
            }
            if (jvmConstructHasFinished) {
                return cb(makeTestingError("constructJVM returned twice. Aborting further tests.", null, true));
            }
            jvmConstructHasFinished = true;
            if (err) {
                cb(makeTestingError("Could not construct JVM:\n" + err, err));
            }
            else {
                outputCapturer.start(true);
                jvm.runClass(_this.cls, [], function (status) {
                    if (terminated) {
                        // Already handled.
                        return;
                    }
                    outputCapturer.stop();
                    if (hasFinished) {
                        return cb(makeTestingError("JVM triggered completion callback twice. Aborting further tests.", null, true));
                    }
                    hasFinished = true;
                    var actual = outputCapturer.getOutput(true);
                    fs.readFile(_this.outFile, { encoding: 'utf8' }, function (err, expected) {
                        if (err) {
                            cb(makeTestingError("Could not read runout file:\n" + err, err));
                        }
                        else {
                            var diffText = diff(actual, expected), errMsg = null;
                            if (diffText !== null) {
                                errMsg = "Output does not match native JVM.";
                            }
                            cb(errMsg ? makeTestingError(errMsg) : null, actual, expected, diffText);
                        }
                    });
                });
            }
        });
    };
    return DoppioTest;
})();
exports.DoppioTest = DoppioTest;
/**
 * Locate all of Doppio's test classes, and pass them to the callback.
 */
function findTestClasses(doppioDir, cb) {
    var testDir = path.resolve(doppioDir, path.join('classes', 'test'));
    fs.readdir(testDir, function (err, files) {
        if (err) {
            cb([]);
        }
        else {
            cb(files.filter(function (file) { return path.extname(file) === '.java'; })
                .map(function (file) { return path.join('classes', 'test', path.basename(file, '.java')); }));
        }
    });
}
/**
 * Retrieve all of the unit tests.
 */
function getTests(opts, cb) {
    var testClasses = opts.testClasses, tests;
    if (testClasses == null || testClasses.length === 0) {
        // If no test classes are specified, get ALL the tests!
        findTestClasses(opts.doppioHomePath, function (testClasses) {
            opts.testClasses = testClasses;
            getTests(opts, cb);
        });
    }
    else {
        cb(testClasses.map(function (testClass) {
            return new DoppioTest(opts, testClass);
        }));
    }
}
exports.getTests = getTests;
/**
 * Returns a formatted diff between doppioOut and nativeOut.
 * Returns NULL if the strings are identical.
 */
function diff(doppioOut, nativeOut) {
    // @todo Robust to Windows line breaks!
    var doppioLines = doppioOut.split(/\n/), jvmLines = nativeOut.split(/\n/), diff = difflib.text_diff(doppioLines, jvmLines, 2);
    if (diff.length > 0) {
        return 'Doppio | Java\n' + diff.join('\n');
    }
    return null;
}
exports.diff = diff;
/**
 * Run the specified tests.
 */
function runTests(opts, quiet, continueAfterFailure, hideDiffs, registerGlobalErrorTrap, cb) {
    function print(str) {
        if (!quiet) {
            process.stdout.write(str);
        }
    }
    getTests(opts, function (tests) {
        util.asyncForEach(tests, function (test, nextTest) {
            var hasFinished = false;
            print("[" + test.cls + "]: Running... ");
            test.run(registerGlobalErrorTrap, function (err, actual, expected, diff) {
                if (err && !hideDiffs && diff) {
                    err.message += "\n" + diff;
                }
                if (err) {
                    print("fail.\n\t" + err.message + "\n");
                    if (err.originalError && err.originalError.stack) {
                        print(err.stack + "\n");
                    }
                    if (!continueAfterFailure || err['fatal']) {
                        err.message = "Failed " + test.cls + ": " + err.message;
                        nextTest(err);
                    }
                    else {
                        nextTest();
                    }
                }
                else {
                    print("pass.\n");
                    nextTest();
                }
            });
        }, cb);
    });
}
exports.runTests = runTests;

}).call(this,BrowserFS.BFSRequire('process'))

},{"./difflib":29,"./jvm":38,"./util":47,"fs":13,"path":14}],45:[function(_dereq_,module,exports){
var enums = _dereq_('./enums');
var assert = _dereq_('./assert');
var gLong = _dereq_('./gLong');
var opcodes = _dereq_('./opcodes');
var logging = _dereq_('./logging');
var util = _dereq_('./util');
var ThreadStatus = enums.ThreadStatus;
var global = _dereq_('./global');
if (typeof RELEASE === 'undefined')
    global.RELEASE = false;
var debug = logging.debug, vtrace = logging.vtrace, trace = logging.trace, 
// The number of method resumes we should allow before yielding for
// responsiveness. Updated using a cumulative moving average to ensure
// Doppio is responsive.
maxMethodResumes = 10000, 
// The number of method resumes until Doppio should yield again.
methodResumesLeft = maxMethodResumes, 
// Used for the CMA.
numSamples = 1;
var PreAllocatedStack = (function () {
    function PreAllocatedStack(initialSize) {
        this.curr = 0;
        this.store = new Array(initialSize);
    }
    PreAllocatedStack.prototype.push = function (x) {
        this.store[this.curr++] = x;
    };
    PreAllocatedStack.prototype.pushWithNull = function (x) {
        this.store[this.curr] = x;
        // XXX: Although setting `null` is required in theory, it has no functional impact in practice.
        // Performance is improved when commented.
        // this.store[this.curr + 1] = null;
        this.curr += 2;
    };
    PreAllocatedStack.prototype.push6 = function (x, y, z, z1, z2, z3) {
        this.store[this.curr++] = x;
        this.store[this.curr++] = y;
        this.store[this.curr++] = z;
        this.store[this.curr++] = z1;
        this.store[this.curr++] = z2;
        this.store[this.curr++] = z3;
    };
    PreAllocatedStack.prototype.swap = function () {
        var tmp = this.store[this.curr - 1];
        this.store[this.curr - 1] = this.store[this.curr - 2];
        this.store[this.curr - 2] = tmp;
    };
    PreAllocatedStack.prototype.dup = function () {
        this.store[this.curr] = this.store[this.curr - 1];
        this.curr++;
    };
    PreAllocatedStack.prototype.dup2 = function () {
        this.store[this.curr] = this.store[this.curr - 2];
        this.store[this.curr + 1] = this.store[this.curr - 1];
        this.curr += 2;
    };
    PreAllocatedStack.prototype.dup_x1 = function () {
        var v1 = this.store[this.curr - 1];
        this.store[this.curr - 1] = this.store[this.curr - 2];
        this.store[this.curr] = v1;
        this.store[this.curr - 2] = v1;
        this.curr++;
    };
    PreAllocatedStack.prototype.dup_x2 = function () {
        var v1 = this.store[this.curr - 1];
        this.store[this.curr - 1] = this.store[this.curr - 2];
        this.store[this.curr - 2] = this.store[this.curr - 3];
        this.store[this.curr] = v1;
        this.store[this.curr - 3] = v1;
        this.curr++;
    };
    PreAllocatedStack.prototype.dup2_x1 = function () {
        var v1 = this.store[this.curr - 1];
        var v2 = this.store[this.curr - 2];
        this.store[this.curr] = v2;
        this.store[this.curr + 1] = v1;
        this.store[this.curr - 1] = this.store[this.curr - 3];
        this.store[this.curr - 2] = v1;
        this.store[this.curr - 3] = v2;
        this.curr += 2;
    };
    PreAllocatedStack.prototype.pop = function () {
        return this.store[--this.curr];
    };
    PreAllocatedStack.prototype.pop2 = function () {
        this.curr -= 2;
        return this.store[this.curr];
    };
    PreAllocatedStack.prototype.bottom = function () {
        return this.store[0];
    };
    PreAllocatedStack.prototype.top = function () {
        return this.store[this.curr - 1];
    };
    PreAllocatedStack.prototype.fromTop = function (n) {
        return this.store[this.curr - (n + 1)];
    };
    PreAllocatedStack.prototype.sliceFromBottom = function (n) {
        return this.store.slice(n, this.curr);
    };
    PreAllocatedStack.prototype.sliceFromTop = function (n) {
        return this.store.slice(this.curr - n, this.curr);
    };
    PreAllocatedStack.prototype.dropFromTop = function (n) {
        this.curr -= n;
    };
    PreAllocatedStack.prototype.getRaw = function () {
        return this.store.slice(0, this.curr);
    };
    PreAllocatedStack.prototype.clear = function () {
        this.curr = 0;
    };
    return PreAllocatedStack;
})();
exports.PreAllocatedStack = PreAllocatedStack;
/**
 * Represents a stack frame for a bytecode method.
 */
var BytecodeStackFrame = (function () {
    /**
     * Constructs a bytecode method's stack frame.
     * @param method The bytecode method to run.
     * @param args The arguments to pass to the bytecode method.
     */
    function BytecodeStackFrame(method, args) {
        this.pc = 0;
        this.returnToThreadLoop = false;
        this.lockedMethodLock = false;
        /**
         * Indicates the type of this stack frame.
         */
        this.type = enums.StackFrameType.BYTECODE;
        this.method = method;
        assert(!method.accessFlags.isNative(), 'Cannot run a native method using a BytecodeStackFrame.');
        // @todo This should be a runtime error, since reflection can cause you to
        // try to do this.
        assert(!method.accessFlags.isAbstract(), 'Cannot run an abstract method!');
        this.locals = args;
        this.opStack = new PreAllocatedStack(method.getCodeAttribute().getMaxStack());
    }
    BytecodeStackFrame.prototype.run = function (thread) {
        var _this = this;
        var method = this.method, code = this.method.getCodeAttribute().getCode(), opcodeTable = opcodes.LookupTable;
        if (!RELEASE && logging.log_level >= logging.TRACE) {
            if (this.pc === 0) {
                
            }
            else {
                
            }
            
        }
        if (method.accessFlags.isSynchronized() && !this.lockedMethodLock) {
            // We are starting a synchronized method! These must implicitly enter
            // their respective locks.
            this.lockedMethodLock = method.methodLock(thread, this).enter(thread, function () {
                // Lock succeeded. Set the flag so we don't attempt to reacquire it
                // when this method reruns.
                _this.lockedMethodLock = true;
            });
            if (!this.lockedMethodLock) {
                // Failed. Thread is automatically blocked. Return.
                assert(thread.getStatus() === ThreadStatus.BLOCKED, "Failed to enter a monitor. Thread must be BLOCKED.");
                return;
            }
        }
        // Reset the returnToThreadLoop switch. The current value is leftover
        // from the previous time this method was run, and is meaningless.
        this.returnToThreadLoop = false;
        // Run until we get the signal to return to the thread loop.
        while (!this.returnToThreadLoop) {
            var op = code.readUInt8(this.pc);
            if (!RELEASE && logging.log_level === logging.VTRACE) {
                
            }
            opcodeTable[op](thread, this, code);
            if (!RELEASE && !this.returnToThreadLoop && logging.log_level === logging.VTRACE) {
                
            }
        }
    };
    BytecodeStackFrame.prototype.scheduleResume = function (thread, rv, rv2) {
        // Advance to the next opcode.
        var prevOp = this.method.getCodeAttribute().getCode().readUInt8(this.pc);
        switch (prevOp) {
            case enums.OpCode.INVOKEINTERFACE:
            case enums.OpCode.INVOKEINTERFACE_FAST:
                this.pc += 5;
                break;
            case enums.OpCode.INVOKESPECIAL:
            case enums.OpCode.INVOKESTATIC:
            case enums.OpCode.INVOKEVIRTUAL:
            case enums.OpCode.INVOKESTATIC_FAST:
            case enums.OpCode.INVOKENONVIRTUAL_FAST:
            case enums.OpCode.INVOKEVIRTUAL_FAST:
            case enums.OpCode.INVOKEHANDLE:
            case enums.OpCode.INVOKEBASIC:
            case enums.OpCode.LINKTOSPECIAL:
            case enums.OpCode.LINKTOVIRTUAL:
            case enums.OpCode.INVOKEDYNAMIC:
            case enums.OpCode.INVOKEDYNAMIC_FAST:
                this.pc += 3;
                break;
            default:
                // Should be impossible.
                assert(false, "Resuming from a non-invoke opcode! Opcode: " + enums.OpCode[prevOp] + " [" + prevOp + "]");
                break;
        }
        if (rv !== undefined) {
            this.opStack.push(rv);
        }
        if (rv2 !== undefined) {
            this.opStack.push(rv2);
        }
    };
    /**
     * Checks if this method can handle the specified exception 'e'.
     * Returns true if it can, or if it needs to asynchronously resolve some
     * classes.
     *
     * In the latter case, scheduleException will handle rethrowing the exception
     * in the event that it can't actually handle it.
     */
    BytecodeStackFrame.prototype.scheduleException = function (thread, e) {
        var codeAttr = this.method.getCodeAttribute(), pc = this.pc, method = this.method, 
        // STEP 1: See if we can find an appropriate handler for this exception!
        exceptionHandlers = codeAttr.exceptionHandlers, ecls = e.getClass(), handler;
        for (var i = 0; i < exceptionHandlers.length; i++) {
            var eh = exceptionHandlers[i];
            if (eh.startPC <= pc && pc < eh.endPC) {
                if (eh.catchType === "<any>") {
                    handler = eh;
                    break;
                }
                else {
                    var resolvedCatchType = method.cls.getLoader().getResolvedClass(eh.catchType);
                    if (resolvedCatchType != null) {
                        if (ecls.isCastable(resolvedCatchType)) {
                            handler = eh;
                            break;
                        }
                    }
                    else {
                        // ASYNC PATH: We'll need to asynchronously resolve these handlers.
                        
                        var handlerClasses = [];
                        for (var i_1 = 0; i_1 < exceptionHandlers.length; i_1++) {
                            var handler_1 = exceptionHandlers[i_1];
                            if (handler_1.catchType !== "<any>") {
                                handlerClasses.push(handler_1.catchType);
                            }
                        }
                        
                        thread.setStatus(ThreadStatus.ASYNC_WAITING);
                        method.cls.getLoader().resolveClasses(thread, handlerClasses, function (classes) {
                            if (classes !== null) {
                                
                                // Rethrow the exception to trigger scheduleException again.
                                // @todo If the ClassLoader throws an exception during resolution,
                                // this could result in an infinite loop. Fix would be to sync check
                                // if class failed to load previously.
                                thread.throwException(e);
                            }
                        });
                        // Tell the thread we'll handle it.
                        return true;
                    }
                }
            }
        }
        // STEP 2: Either continue on if we could not find an appropriate handler,
        // or set up the stack for appropriate resumption.
        if (handler != null) {
            // Found the handler.
            
            // clear out anything on the stack; it was made during the try block
            this.opStack.clear();
            this.opStack.push(e);
            this.pc = handler.handlerPC;
            return true;
        }
        else {
            // abrupt method invocation completion
            
            // STEP 3: Synchronized method? Exit from the method's monitor.
            if (method.accessFlags.isSynchronized()) {
                method.methodLock(thread, this).exit(thread);
            }
            return false;
        }
    };
    /**
     * Returns the classloader for the stack frame.
     */
    BytecodeStackFrame.prototype.getLoader = function () {
        return this.method.cls.getLoader();
    };
    BytecodeStackFrame.prototype.getStackTraceFrame = function () {
        return {
            method: this.method,
            pc: this.pc,
            stack: this.opStack.sliceFromBottom(0),
            locals: this.locals.slice(0)
        };
    };
    return BytecodeStackFrame;
})();
exports.BytecodeStackFrame = BytecodeStackFrame;
/**
 * Represents a native method's stack frame.
 */
var NativeStackFrame = (function () {
    /**
     * Constructs a native method's stack frame.
     * @param method The native method to run.
     * @param args The arguments to pass to the native method.
     */
    function NativeStackFrame(method, args) {
        this.type = enums.StackFrameType.NATIVE;
        this.method = method;
        this.args = args;
        assert(method.accessFlags.isNative());
        this.nativeMethod = method.getNativeFunction();
    }
    /**
     * Calls the native method.
     * NOTE: Should only be called once.
     */
    NativeStackFrame.prototype.run = function (thread) {
        
        var rv = this.nativeMethod.apply(null, this.method.convertArgs(thread, this.args));
        // Ensure thread is running, and we are the running method.
        if (thread.getStatus() === ThreadStatus.RUNNABLE && thread.currentMethod() === this.method) {
            // Normal native method exit.
            var returnType = this.method.returnType;
            switch (returnType) {
                case 'J':
                case 'D':
                    // Two stack return values for methods that return a long or a double.
                    thread.asyncReturn(rv, null);
                    break;
                case 'Z':
                    // Convert to a number.
                    thread.asyncReturn(rv ? 1 : 0);
                    break;
                default:
                    thread.asyncReturn(rv);
                    break;
            }
        }
    };
    /**
     * N/A
     */
    NativeStackFrame.prototype.scheduleResume = function (thread, rv, rv2) {
        // NOP
    };
    /**
     * Not relevant; the first execution block of a native method will never
     * receive an exception.
     */
    NativeStackFrame.prototype.scheduleException = function (thread, e) {
        return false;
    };
    NativeStackFrame.prototype.getStackTraceFrame = function () {
        return {
            method: this.method,
            pc: -1,
            stack: [],
            locals: []
        };
    };
    /**
     * Returns the classloader for the stack frame.
     */
    NativeStackFrame.prototype.getLoader = function () {
        return this.method.cls.getLoader();
    };
    return NativeStackFrame;
})();
exports.NativeStackFrame = NativeStackFrame;
/**
 * InternalStackFrames are used by the JVM to launch JVM functions that
 * eventually call back into JavaScript code when they complete or throw a
 * fatal exception.
 */
var InternalStackFrame = (function () {
    /**
     * @param cb Callback function. Called with an exception if one occurs, or
     *   the return value from the called method, if relevant.
     */
    function InternalStackFrame(cb) {
        this.isException = false;
        this.type = enums.StackFrameType.INTERNAL;
        this.cb = cb;
    }
    InternalStackFrame.prototype.run = function (thread) {
        // Pop myself off of the stack.
        thread.framePop();
        // Pause the thread before returning into native JavaScript code.
        thread.setStatus(ThreadStatus.ASYNC_WAITING);
        if (this.isException) {
            this.cb(this.val);
        }
        else {
            this.cb(null, this.val);
        }
    };
    /**
     * Resumes the JavaScript code that created this stack frame.
     */
    InternalStackFrame.prototype.scheduleResume = function (thread, rv) {
        this.isException = false;
        this.val = rv;
    };
    /**
     * Resumes the JavaScript code that created this stack frame with the given
     * exception.
     */
    InternalStackFrame.prototype.scheduleException = function (thread, e) {
        this.isException = true;
        this.val = e;
        return true;
    };
    InternalStackFrame.prototype.getStackTraceFrame = function () {
        // These should not be language visible.
        return null;
    };
    InternalStackFrame.prototype.getLoader = function () {
        throw new Error("Internal stack frames have no loader.");
    };
    return InternalStackFrame;
})();
exports.InternalStackFrame = InternalStackFrame;
/**
 * Represents a single JVM thread.
 */
var JVMThread = (function () {
    /**
     * Initializes a new JVM thread. Starts the thread in the NEW state.
     */
    function JVMThread(jvm, tpool, threadObj) {
        /**
         * The current state of this thread, from the JVM level.
         */
        this.status = ThreadStatus.NEW;
        /**
         * The call stack.
         */
        this.stack = [];
        /**
         * Whether or not this thread has been interrupted. It's a JVM thing.
         */
        this.interrupted = false;
        /**
         * If the thread is WAITING, BLOCKED, or TIMED_WAITING, this field holds the
         * monitor that is involved.
         */
        this.monitor = null;
        this.jvm = jvm;
        this.bsCl = jvm.getBootstrapClassLoader();
        this.tpool = tpool;
        this.jvmThreadObj = threadObj;
    }
    /**
     * Get the JVM thread object that represents this thread.
     */
    JVMThread.prototype.getJVMObject = function () {
        return this.jvmThreadObj;
    };
    /**
     * Is this thread a daemon?
     */
    JVMThread.prototype.isDaemon = function () {
        return this.jvmThreadObj['java/lang/Thread/daemon'] !== 0;
    };
    /**
     * Get the priority of this thread.
     */
    JVMThread.prototype.getPriority = function () {
        return this.jvmThreadObj['java/lang/Thread/priority'];
    };
    /**
     * XXX: Used during bootstrapping to set the first thread's Thread object.
     */
    JVMThread.prototype.setJVMObject = function (obj) {
        obj['java/lang/Thread/threadStatus'] = this.jvmThreadObj['java/lang/Thread/threadStatus'];
        this.jvmThreadObj = obj;
    };
    /**
     * Return the reference number for this thread.
     */
    JVMThread.prototype.getRef = function () {
        return this.jvmThreadObj.ref;
    };
    /**
     * Check if this thread's interrupted flag is set.
     */
    JVMThread.prototype.isInterrupted = function () {
        return this.interrupted;
    };
    /**
     * Returns the currently running method. Returns NULL if stack is empty.
     */
    JVMThread.prototype.currentMethod = function () {
        var stack = this.stack, idx = stack.length, method;
        while (--idx >= 0) {
            method = stack[idx].getStackTraceFrame().method;
            if (method !== null) {
                return method;
            }
        }
        return null;
    };
    /**
     * Set or unset this thread's interrupted flag.
     */
    JVMThread.prototype.setInterrupted = function (interrupted) {
        this.interrupted = interrupted;
    };
    /**
     * Retrieve the bootstrap classloader.
     */
    JVMThread.prototype.getBsCl = function () {
        return this.bsCl;
    };
    /**
     * Get the classloader for the current frame.
     */
    JVMThread.prototype.getLoader = function () {
        var loader = this.stack[this.stack.length - 1].getLoader();
        if (loader) {
            return loader;
        }
        else {
            // Crawl stack until we find one.
            var len = this.stack.length;
            for (var i = 2; i <= len; i++) {
                loader = this.stack[len - i].getLoader();
                if (loader) {
                    return loader;
                }
            }
            throw new Error("Unable to find loader.");
        }
    };
    JVMThread.prototype.import = function (names, cb, explicit) {
        var _this = this;
        if (explicit === void 0) { explicit = true; }
        var loader = this.getLoader();
        this.setStatus(ThreadStatus.ASYNC_WAITING);
        if (Array.isArray(names)) {
            var rv = [];
            util.asyncForEach(names, function (name, nextItem) {
                _this._import(name, loader, function (cons) {
                    rv.push(cons);
                    nextItem();
                }, explicit);
            }, function (e) {
                cb(rv);
            });
        }
        else {
            this._import(names, loader, cb, explicit);
        }
    };
    JVMThread.prototype._import = function (name, loader, cb, explicit) {
        var _this = this;
        var cls = loader.getInitializedClass(this, name);
        if (cls) {
            setImmediate(function () { return cb(cls.getConstructor(_this)); });
        }
        else {
            loader.initializeClass(this, name, function (cdata) {
                if (cdata) {
                    cb(cdata.getConstructor(_this));
                }
            }, explicit);
        }
    };
    /**
     * Retrieve the JVM instantiation that this thread belongs to.
     */
    JVMThread.prototype.getJVM = function () {
        return this.jvm;
    };
    /**
     * Retrieve the thread pool that this thread belongs to.
     */
    JVMThread.prototype.getThreadPool = function () {
        return this.tpool;
    };
    /**
     * Retrieves the current stack trace.
     */
    JVMThread.prototype.getStackTrace = function () {
        var trace = [], i, frame;
        for (i = 0; i < this.stack.length; i++) {
            frame = this.stack[i].getStackTraceFrame();
            if (frame != null) {
                trace.push(frame);
            }
        }
        return trace;
    };
    /**
     * [DEBUG] Return a printable string of the thread's current stack trace.
     */
    JVMThread.prototype.getPrintableStackTrace = function () {
        var rv = "";
        this.getStackTrace().reverse().forEach(function (trace) {
            rv += "\tat " + util.ext_classname(trace.method.cls.getInternalName()) + "::" + trace.method.name + "(";
            if (trace.pc >= 0) {
                // Bytecode method
                var code = trace.method.getCodeAttribute();
                var table = code.getAttribute('LineNumberTable');
                var srcAttr = trace.method.cls.getAttribute('SourceFile');
                if (srcAttr != null) {
                    rv += srcAttr.filename;
                }
                else {
                    rv += 'unknown';
                }
                if (table != null) {
                    var lineNumber = table.getLineNumber(trace.pc);
                    rv += ":" + lineNumber;
                    rv += " Bytecode offset: " + trace.pc;
                }
            }
            else {
                // Native method.
                rv += "native";
            }
            rv += ")\n";
        });
        return rv;
    };
    /**
     * The thread's main execution loop. Everything starts here!
     *
     * SHOULD ONLY BE INVOKED BY THE SCHEDULER.
     */
    JVMThread.prototype.run = function () {
        var stack = this.stack, startTime = (new Date()).getTime();
        // Reset counter. Threads always start from a fresh stack / yield.
        methodResumesLeft = maxMethodResumes;
        while (this.status === ThreadStatus.RUNNABLE && stack.length > 0) {
            var sf = stack[stack.length - 1];
            if (!RELEASE) {
                if (sf.type === enums.StackFrameType.BYTECODE && this.jvm.shouldVtrace(sf.method.fullSignature)) {
                    var oldLevel = logging.log_level;
                    logging.log_level = logging.VTRACE;
                    sf.run(this);
                    logging.log_level = oldLevel;
                }
                else {
                    sf.run(this);
                }
            }
            else {
                sf.run(this);
            }
            if (--methodResumesLeft === 0) {
                var endTime = (new Date()).getTime();
                var duration = endTime - startTime;
                // Estimated number of methods we can resume before needing to yield.
                var estMaxMethodResumes = ((maxMethodResumes / duration) * this.jvm.getResponsiveness()) | 0;
                // Update CMA.
                maxMethodResumes = ((estMaxMethodResumes + numSamples * maxMethodResumes) / (numSamples + 1)) | 0;
                if (maxMethodResumes <= 0) {
                    // Sanity check. Should never really occur.
                    maxMethodResumes = 10;
                }
                
                numSamples++;
                // Tell the scheduler that our quantum is over.
                this.tpool.quantumOver(this);
                // Break out of while loop.
                break;
            }
        }
        if (stack.length === 0) {
            // This thread has finished!
            this.setStatus(ThreadStatus.TERMINATED);
        }
    };
    /**
     * [DEBUG] Performs a sanity check on the thread.
     */
    JVMThread.prototype.sanityCheck = function () {
        switch (this.status) {
            case ThreadStatus.NEW:
                return true;
            case ThreadStatus.RUNNABLE:
                assert(this.stack.length > 0, 'A runnable thread must not have an empty stack.');
                return true;
            case ThreadStatus.TIMED_WAITING:
                assert(this.monitor != null && this.monitor.isTimedWaiting(this), 'A timed waiting thread must be waiting on a monitor.');
                return true;
            case ThreadStatus.WAITING:
                assert(this.monitor != null && this.monitor.isWaiting(this), "A waiting thread must be waiting on a monitor.");
                return true;
            case ThreadStatus.BLOCKED:
            case ThreadStatus.UNINTERRUPTABLY_BLOCKED:
                assert(this.monitor != null && this.monitor.isBlocked(this), "A blocked thread must be blocked on a monitor");
                return true;
            case ThreadStatus.ASYNC_WAITING:
                return true;
            case ThreadStatus.TERMINATED:
                assert(this.stack.length === 0, "A terminated thread must have an empty stack.");
                return true;
            case ThreadStatus.PARKED:
                assert(this.jvm.getParker().isParked(this), "A parked thread must be parked.");
                return true;
            default:
                // Invalid ThreadStatus.
                return false;
        }
    };
    /**
     * Should only be called by setStatus.
     * Updates both the JVMThread object and this object.
     */
    JVMThread.prototype.rawSetStatus = function (newStatus) {
        var jvmNewStatus = 0, oldStatus = this.status;
        if (logging.log_level === logging.VTRACE) {
            
        }
        assert(validateThreadTransition(oldStatus, newStatus), "Invalid thread transition: " + ThreadStatus[oldStatus] + " => " + ThreadStatus[newStatus]);
        this.status = newStatus;
        // Map our status value back to JVM's threadStatus value.
        // Ensures that JVM code can introspect on our threads.
        switch (newStatus) {
            case ThreadStatus.NEW:
                jvmNewStatus |= enums.JVMTIThreadState.ALIVE;
                break;
            case ThreadStatus.RUNNABLE:
                jvmNewStatus |= enums.JVMTIThreadState.RUNNABLE;
                break;
            case ThreadStatus.BLOCKED:
            case ThreadStatus.UNINTERRUPTABLY_BLOCKED:
                jvmNewStatus |= enums.JVMTIThreadState.BLOCKED_ON_MONITOR_ENTER;
                break;
            case ThreadStatus.WAITING:
            case ThreadStatus.ASYNC_WAITING:
            case ThreadStatus.PARKED:
                jvmNewStatus |= enums.JVMTIThreadState.WAITING_INDEFINITELY;
                break;
            case ThreadStatus.TIMED_WAITING:
                jvmNewStatus |= enums.JVMTIThreadState.WAITING_WITH_TIMEOUT;
                break;
            case ThreadStatus.TERMINATED:
                jvmNewStatus |= enums.JVMTIThreadState.TERMINATED;
                break;
            default:
                jvmNewStatus = enums.JVMTIThreadState.RUNNABLE;
                break;
        }
        this.jvmThreadObj['java/lang/Thread/threadStatus'] = jvmNewStatus;
        this.tpool.statusChange(this, oldStatus, this.status);
    };
    /**
     * Transitions the thread from one state to the next.
     * Contains JVM-specific thread logic.
     */
    JVMThread.prototype.setStatus = function (status, monitor) {
        if (monitor === void 0) { monitor = null; }
        if (this.status !== status) {
            var oldStatus = this.status;
            // Update the monitor.
            this.monitor = monitor;
            if (status !== ThreadStatus.TERMINATED) {
                // Actually change state.
                this.rawSetStatus(status);
            }
            else {
                // Call exit() first.
                this.exit();
            }
            // Validate current state (debug builds only)
            assert(this.sanityCheck(), "Invalid thread status.");
        }
    };
    /**
     * Called when a thread finishes executing.
     */
    JVMThread.prototype.exit = function () {
        var _this = this;
        var monitor = this.jvmThreadObj.getMonitor();
        if (monitor.isBlocked(this) || monitor.getOwner() === this || this.status === ThreadStatus.TERMINATED) {
            // Thread is already shutting down.
            return;
        }
        if (this.stack.length === 0) {
            // De-schedule thread.
            this.setStatus(ThreadStatus.ASYNC_WAITING);
            // Only applicable if it's not an early death, e.g. before VM bootup.
            if (this.jvm.hasVMBooted()) {
                
                var phase2 = function () {
                    
                    // Exit.
                    _this.jvmThreadObj["exit()V"](_this, null, function (e) {
                        // Notify everyone.
                        monitor.notifyAll(_this);
                        // Exit monitor.
                        monitor.exit(_this);
                        
                        // Actually become terminated.
                        _this.rawSetStatus(ThreadStatus.TERMINATED);
                    });
                };
                // Acquire the monitor associated with our JavaObject.
                if (monitor.enter(this, phase2)) {
                    phase2();
                }
            }
            else {
                
            }
        }
        else {
            // There are things on the stack. This exit is occuring before the stack has emptied.
            // Clear the stack, set to terminated.
            while (this.stack.length > 0) {
                this.stack.pop();
            }
            
            this.rawSetStatus(ThreadStatus.TERMINATED);
        }
    };
    /**
     * Called when the priority of the thread changes.
     * Should only be called by java.lang.setPriority0.
     */
    JVMThread.prototype.signalPriorityChange = function () {
        this.tpool.priorityChange(this);
    };
    /**
     * Get the monitor that this thread is waiting or blocked on.
     */
    JVMThread.prototype.getMonitorBlock = function () {
        return this.monitor;
    };
    /**
     * Get the thread's current state.
     */
    JVMThread.prototype.getStatus = function () {
        return this.status;
    };
    JVMThread.prototype.asyncReturn = function (rv, rv2) {
        var stack = this.stack;
        assert(this.status === ThreadStatus.RUNNABLE || this.status === ThreadStatus.ASYNC_WAITING);
        assert(typeof (rv) !== 'boolean' && rv2 == null);
        // Pop off the current method.
        var frame = stack.pop();
        if (frame.type != enums.StackFrameType.INTERNAL) {
            var frameCast = frame;
            if (frame.type === enums.StackFrameType.BYTECODE) {
                // This line will be preceded by a line that prints the method, so can be short n' sweet.
                
            }
            
            assert(validateReturnValue(this, frameCast.method, frameCast.method.returnType, this.bsCl, frameCast.method.cls.getLoader(), rv, rv2), "Invalid return value for method " + frameCast.method.getFullSignature());
        }
        // Tell the top of the stack that this RV is waiting for it.
        var idx = stack.length - 1;
        // If idx is 0, then the thread will TERMINATE next time it enters its main
        // loop.
        if (idx >= 0) {
            stack[idx].scheduleResume(this, rv, rv2);
        }
        // Thread state transition.
        this.setStatus(ThreadStatus.RUNNABLE);
    };
    /**
     * Pops the top stackframe off of the call stack.
     * WARNING: SHOULD ONLY BE CALLED BY InternalStackFrame.run()!
     */
    JVMThread.prototype.framePop = function () {
        this.stack.pop();
    };
    /**
     * Throws the given JVM exception. Causes the thread to unwind the stack until
     * it can find a stack frame that can handle the exception.
     *
     * Causes the following state transition:
     * * RUNNING => RUNNABLE
     * * RUNNABLE => RUNNABLE
     * * ASYNC_WAITING => RUNNABLE
     *
     * Or, if the exception is uncaught, one of the following transitions:
     * * RUNNING => TERMINATED
     * * RUNNABLE => TERMINATED
     * * ASYNC_WAITING => TERMINATED
     *
     * It is not valid to call this method if the thread is in any other state.
     */
    JVMThread.prototype.throwException = function (exception) {
        assert(this.status === ThreadStatus.RUNNABLE || this.status === ThreadStatus.ASYNC_WAITING, "Tried to throw exception while thread was in state " + ThreadStatus[this.status]);
        var stack = this.stack, idx = stack.length - 1;
        // Stack may actually be empty, so guard against this.
        if (idx >= 0) {
            // An internal stack frame cannot process its own thrown exception.
            if (stack[idx].type === enums.StackFrameType.INTERNAL) {
                stack.pop();
                idx--;
            }
            // Find a stack frame that can handle the exception.
            // Set our status *before* scheduling the exception. Some exception handlers
            // may want to do something asynchronous before resuming execution.
            this.setStatus(ThreadStatus.RUNNABLE);
            while (stack.length > 0 && !stack[idx].scheduleException(this, exception)) {
                stack.pop();
                idx--;
            }
        }
        if (stack.length === 0) {
            // Uncaught exception!
            this.handleUncaughtException(exception);
        }
    };
    /**
     * Construct a new exception object of the given class with the given message.
     * Convenience function for native JavaScript code.
     * @param clsName Name of the class (e.g. "Ljava/lang/Throwable;")
     * @param msg The message to include with the exception.
     */
    JVMThread.prototype.throwNewException = function (clsName, msg) {
        var _this = this;
        var cls = this.bsCl.getInitializedClass(this, clsName), throwException = function () {
            var eCons = cls.getConstructor(_this), e = new eCons(_this);
            // Construct the exception, and throw it when done.
            e['<init>(Ljava/lang/String;)V'](_this, [util.initString(_this.bsCl, msg)], function (err) {
                if (err) {
                    _this.throwException(err);
                }
                else {
                    _this.throwException(e);
                }
            });
        };
        if (cls != null) {
            // No initialization required.
            throwException();
        }
        else {
            // Initialization required.
            this.setStatus(ThreadStatus.ASYNC_WAITING);
            this.bsCl.initializeClass(this, clsName, function (cdata) {
                if (cdata != null) {
                    cls = cdata;
                    throwException();
                }
            }, false);
        }
    };
    /**
     * Handles an uncaught exception on a thread.
     */
    JVMThread.prototype.handleUncaughtException = function (exception) {
        this.jvmThreadObj['dispatchUncaughtException(Ljava/lang/Throwable;)V'](this, [exception]);
    };
    JVMThread.prototype.close = function () {
        this.jvm = null;
    };
    return JVMThread;
})();
exports.JVMThread = JVMThread;
/**
 * [DEBUG] Stores all of the valid thread transitions.
 * @todo Any way to make this smaller?
 * @todo Move into 'debug' module that we NOP out in release builds.
 */
exports.validTransitions = {};
exports.validTransitions[ThreadStatus.NEW] = {};
exports.validTransitions[ThreadStatus.NEW][ThreadStatus.RUNNABLE] = "RunMethod invoked on new thread";
exports.validTransitions[ThreadStatus.NEW][ThreadStatus.ASYNC_WAITING] = "[JVM bootup only] Internal operation occurs on new thread";
exports.validTransitions[ThreadStatus.NEW][ThreadStatus.TERMINATED] = "[JVM halt0 only] When the JVM shuts down, it terminates all threads, including those that have never been run.";
exports.validTransitions[ThreadStatus.ASYNC_WAITING] = {};
exports.validTransitions[ThreadStatus.ASYNC_WAITING][ThreadStatus.RUNNABLE] = "Async operation completes";
exports.validTransitions[ThreadStatus.ASYNC_WAITING][ThreadStatus.TERMINATED] = "RunMethod completes and callstack is empty";
exports.validTransitions[ThreadStatus.BLOCKED] = {};
exports.validTransitions[ThreadStatus.BLOCKED][ThreadStatus.RUNNABLE] = "Acquires monitor, or is interrupted";
exports.validTransitions[ThreadStatus.BLOCKED][ThreadStatus.TERMINATED] = "Thread is terminated whilst blocked.";
exports.validTransitions[ThreadStatus.PARKED] = {};
exports.validTransitions[ThreadStatus.PARKED][ThreadStatus.ASYNC_WAITING] = "Balancing unpark, or is interrupted";
exports.validTransitions[ThreadStatus.PARKED][ThreadStatus.TERMINATED] = "Thread is terminated whilst parked.";
exports.validTransitions[ThreadStatus.RUNNABLE] = {};
exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.ASYNC_WAITING] = "Thread performs an asynchronous JavaScript operation";
exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.TERMINATED] = "Callstack is empty";
exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.BLOCKED] = "Thread waits to acquire monitor";
exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.WAITING] = "Thread waits on monitor (Object.wait)";
exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.TIMED_WAITING] = "Thread waits on monitor with timeout (Object.wait)";
exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.PARKED] = "Thread parks itself";
exports.validTransitions[ThreadStatus.TERMINATED] = {};
exports.validTransitions[ThreadStatus.TERMINATED][ThreadStatus.NEW] = "Thread is resurrected for re-use";
exports.validTransitions[ThreadStatus.TERMINATED][ThreadStatus.RUNNABLE] = "Thread is resurrected for re-use";
exports.validTransitions[ThreadStatus.TERMINATED][ThreadStatus.ASYNC_WAITING] = "[JVM Bootup] Thread is resurrected for internal operation";
exports.validTransitions[ThreadStatus.TIMED_WAITING] = {};
exports.validTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.RUNNABLE] = "Timer expires, or thread is interrupted, and thread immediately acquires lock";
exports.validTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.UNINTERRUPTABLY_BLOCKED] = "Thread is interrupted or notified, or timer expires, and lock already owned";
exports.validTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.TERMINATED] = "Thread is terminated whilst waiting.";
exports.validTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED] = {};
exports.validTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED][ThreadStatus.RUNNABLE] = "Thread acquires monitor";
exports.validTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED][ThreadStatus.TERMINATED] = "Thread is terminated whilst blocked.";
exports.validTransitions[ThreadStatus.WAITING] = {};
exports.validTransitions[ThreadStatus.WAITING][ThreadStatus.RUNNABLE] = "Thread is interrupted, and immediately acquires lock";
exports.validTransitions[ThreadStatus.WAITING][ThreadStatus.UNINTERRUPTABLY_BLOCKED] = "Thread is notified or interrupted, and does not immediately acquire lock";
exports.validTransitions[ThreadStatus.WAITING][ThreadStatus.TERMINATED] = "Thread is terminated whilst waiting.";
/**
 * [DEBUG] Ensures that a thread transition is legal.
 */
function validateThreadTransition(oldStatus, newStatus) {
    var rv = exports.validTransitions.hasOwnProperty("" + oldStatus) &&
        exports.validTransitions[oldStatus].hasOwnProperty("" + newStatus);
    return rv;
}
/**
 * [DEBUG] Asserts that the return value of the function passes basic sanity
 * checks.
 */
function validateReturnValue(thread, method, returnType, bsCl, cl, rv1, rv2) {
    // invokeBasic is typed with an Object return value, but it can return any
    // damn type it wants, primitive or no.
    if (method.fullSignature === "java/lang/invoke/MethodHandle/invokeBasic([Ljava/lang/Object;)Ljava/lang/Object;") {
        return true;
    }
    var cls;
    if (util.is_primitive_type(returnType)) {
        switch (returnType) {
            case 'Z':
                assert(rv2 === undefined, "Second return value must be undefined for Boolean type.");
                assert(rv1 === 1 || rv1 === 0, "Booleans must be 0 or 1.");
                break;
            case 'B':
                assert(rv2 === undefined, "Second return value must be undefined for Byte type.");
                assert(rv1 <= 127 && rv1 >= -128, "Byte value for method " + method.name + " is out of bounds: " + rv1);
                break;
            case 'C':
                assert(rv2 === undefined, "Second return value must be undefined for Character type.");
                assert(rv1 <= 65535 && rv1 >= 0, "Character value is out of bounds: " + rv1);
                break;
            case 'S':
                assert(rv2 === undefined, "Second return value must be undefined for Short type.");
                assert(rv1 <= 32767 && rv1 >= -32768, "Short value is out of bounds: " + rv1);
                break;
            case 'I':
                assert(rv2 === undefined, "Second return value must be undefined for Int type.");
                assert(rv1 <= 2147483647 && rv1 >= -2147483648, "Int value is out of bounds: " + rv1);
                break;
            case 'J':
                assert(rv2 === null, "Second return value must be NULL for Long type.");
                assert(rv1.lessThanOrEqual(gLong.MAX_VALUE) && rv1.greaterThanOrEqual(gLong.MIN_VALUE), "Long value is out of bounds: " + rv1);
                break;
            case 'F':
                assert(rv2 === undefined, "Second return value must be undefined for Float type.");
                // NaN !== NaN, so we have to have a special case here.
                assert(util.wrapFloat(rv1) === rv1 || (isNaN(rv1) && isNaN(util.wrapFloat(rv1))), "Float value is out of bounds: " + rv1);
                break;
            case 'D':
                assert(rv2 === null, "Second return value must be NULL for Double type.");
                assert(typeof rv1 === 'number', "Invalid double value: " + rv1);
                break;
            case 'V':
                assert(rv1 === undefined && rv2 === undefined, "Return values must be undefined for Void type");
                break;
        }
    }
    else if (util.is_array_type(returnType)) {
        assert(rv2 === undefined, "Second return value must be undefined for array type.");
        assert(rv1 === null || (typeof rv1 === 'object' && typeof rv1['getClass'] === 'function'), "Invalid array object: " + rv1);
        if (rv1 != null) {
            cls = assertClassInitializedOrResolved(thread, cl, returnType, true);
            assert(rv1.getClass().isCastable(cls), "Return value of type " + rv1.getClass().getInternalName() + " unable to be cast to return type " + returnType + ".");
        }
    }
    else {
        assert(util.is_reference_type(returnType), "Invalid reference type: " + returnType);
        assert(rv2 === undefined, "Second return value must be undefined for reference type.");
        // All objects and arrays are instances of java/lang/Object.
        assert(rv1 === null || rv1 instanceof bsCl.getInitializedClass(thread, 'Ljava/lang/Object;').getConstructor(thread), "Reference return type must be an instance of Object; value: " + rv1);
        if (rv1 != null) {
            cls = assertClassInitializedOrResolved(thread, cl, returnType, false);
            if (!cls.accessFlags.isInterface()) {
                // You can return an interface type without initializing it,
                // since they don't need to be initialized until you try to
                // invoke one of their methods.
                // NOTE: We don't check if the class is in the INITIALIZED state,
                // since it is possible that it is currently in the process of being
                // initialized. getInitializedClass handles this subtlety.
                assertClassInitializedOrResolved(thread, cl, returnType, true);
            }
            assert(rv1.getClass().isCastable(cls), "Unable to cast " + rv1.getClass().getInternalName() + " to " + returnType + ".");
        }
    }
    return true;
}
function assertClassInitializedOrResolved(thread, cl, type, initialized) {
    var cls = null;
    // Break out of loop once class is found.
    while (cls === null) {
        cls = initialized ? cl.getInitializedClass(thread, type) : cl.getResolvedClass(type);
        if (cl.getLoaderObject() !== null) {
            if (cl.getLoaderObject()['java/lang/ClassLoader/parent'] === null) {
                cl = thread.getBsCl();
            }
            else {
                cl = cl.getLoaderObject()['java/lang/ClassLoader/parent'].$loader;
            }
        }
        else {
            // We just checked the bootstrap classloader, so we reached the root.
            assert(cls !== null, "Unable to get initialized class for type " + type + ".");
        }
    }
    return cls;
}
function printConstantPoolItem(cpi) {
    switch (cpi.getType()) {
        case enums.ConstantPoolItemType.METHODREF:
            var cpiMR = cpi;
            return util.ext_classname(cpiMR.classInfo.name) + "." + cpiMR.signature;
        case enums.ConstantPoolItemType.INTERFACE_METHODREF:
            var cpiIM = cpi;
            return util.ext_classname(cpiIM.classInfo.name) + "." + cpiIM.signature;
        case enums.ConstantPoolItemType.FIELDREF:
            var cpiFR = cpi;
            return util.ext_classname(cpiFR.classInfo.name) + "." + cpiFR.nameAndTypeInfo.name + ":" + util.ext_classname(cpiFR.nameAndTypeInfo.descriptor);
        case enums.ConstantPoolItemType.NAME_AND_TYPE:
            var cpiNAT = cpi;
            return cpiNAT.name + ":" + cpiNAT.descriptor;
        case enums.ConstantPoolItemType.CLASS:
            var cpiClass = cpi;
            return util.ext_classname(cpiClass.name);
        default:
            return logging.debug_var(cpi.value);
    }
}
// TODO: Prefix behind DEBUG, cache lowercase opcode names.
exports.OpcodeLayoutPrinters = {};
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.OPCODE_ONLY] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase(); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + printConstantPoolItem(frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1))); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL_UINT8] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + printConstantPoolItem(frame.method.cls.constantPool.get(code.readUInt8(pc + 1))); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL_AND_UINT8_VALUE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + printConstantPoolItem(frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1))) + " " + code.readUInt8(pc + 3); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.UINT8_VALUE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + code.readUInt8(pc + 1); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.UINT8_AND_INT8_VALUE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + code.readUInt8(pc + 1) + " " + code.readInt8(pc + 2); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.INT8_VALUE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + code.readInt8(pc + 1); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.INT16_VALUE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + code.readInt16BE(pc + 1); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.INT32_VALUE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + code.readInt32BE(pc + 1); };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.ARRAY_TYPE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase() + " " + opcodes.ArrayTypes[code.readUInt8(pc + 1)]; };
exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.WIDE] = function (frame, code, pc) { return enums.OpCode[code.readUInt8(pc)].toLowerCase(); };
function annotateOpcode(op, frame, code, pc) {
    return exports.OpcodeLayoutPrinters[enums.OpcodeLayouts[op]](frame, code, pc);
}

},{"./assert":26,"./enums":31,"./gLong":32,"./global":33,"./logging":39,"./opcodes":41,"./util":47}],46:[function(_dereq_,module,exports){
var enums_1 = _dereq_('./enums');
var assert = _dereq_('./assert');
/**
 * Checks if the given thread status indicates that the thread is scheduleable.
 */
function isRunnable(status) {
    return status === enums_1.ThreadStatus.RUNNABLE;
}
/**
 * A Weighted Round Robin thread scheduler.
 */
var WeightedRoundRobinScheduler = (function () {
    function WeightedRoundRobinScheduler() {
        // Number of quanta given to the current thread.
        this._count = 0;
        // The queue of threads.
        this._queue = [];
        // Read by runThread. Used as a lock.
        this._threadScheduled = false;
    }
    WeightedRoundRobinScheduler.prototype.scheduleThread = function (thread) {
        this._queue.push(thread);
        if (this._queue.length === 1) {
            // There aren't any threads running. Run this thread.
            this.runThread();
        }
    };
    /**
     * Run the thread at the head of the queue.
     */
    WeightedRoundRobinScheduler.prototype.runThread = function () {
        var _this = this;
        if (this._threadScheduled) {
            return;
        }
        this._threadScheduled = true;
        setImmediate(function () {
            var queue = _this._queue;
            _this._threadScheduled = false;
            if (queue.length > 0) {
                var thread = _this._queue[0];
                assert(thread.getStatus() === enums_1.ThreadStatus.RUNNABLE, "Attempted to run non-runnable thread.");
                thread.run();
            }
        });
    };
    WeightedRoundRobinScheduler.prototype.unscheduleThread = function (thread) {
        var queue = this._queue;
        var isRunningThread = queue[0] === thread;
        assert(queue.indexOf(thread) > -1, "Tried to unschedule thread that was not scheduled.");
        // Remove thread from queue.
        if (isRunningThread) {
            queue.shift();
            this._count = 0;
            // Schedule the next thread.
            this.runThread();
        }
        else {
            queue.splice(queue.indexOf(thread), 1);
        }
    };
    WeightedRoundRobinScheduler.prototype.getRunningThread = function () {
        var queue = this._queue;
        if (queue.length > 0) {
            return queue[0];
        }
        else {
            return null;
        }
    };
    WeightedRoundRobinScheduler.prototype.priorityChange = function (thread) {
        // Not important for the algorithm. We'll pick up the change
        // next time we schedule.
    };
    WeightedRoundRobinScheduler.prototype.quantumOver = function (thread) {
        assert(this._queue[0] === thread, "A non-running thread has an expired quantum?");
        this._count++;
        if (this._count >= thread.getPriority() || thread.getStatus() !== enums_1.ThreadStatus.RUNNABLE) {
            // Move to back of queue, reset count.
            this._count = 0;
            this._queue.push(this._queue.shift());
        }
        // Schedule the next thread.
        this.runThread();
    };
    return WeightedRoundRobinScheduler;
})();
/**
 * Represents a thread pool. Handles scheduling duties.
 */
var ThreadPool = (function () {
    function ThreadPool(emptyCallback) {
        this.threads = [];
        this.scheduler = new WeightedRoundRobinScheduler();
        this.emptyCallback = emptyCallback;
    }
    /**
     * Retrieve all of the threads in the thread pool.
     */
    ThreadPool.prototype.getThreads = function () {
        // Return a copy of our internal array.
        return this.threads.slice(0);
    };
    /**
     * Checks if any remaining threads are non-daemonic and could be runnable.
     * If not, we can terminate execution.
     *
     * This check is invoked each time a thread terminates.
     */
    ThreadPool.prototype.anyNonDaemonicThreads = function () {
        for (var i = 0; i < this.threads.length; i++) {
            var t = this.threads[i];
            if (t.isDaemon()) {
                continue;
            }
            var status_1 = t.getStatus();
            if (status_1 !== enums_1.ThreadStatus.NEW &&
                status_1 !== enums_1.ThreadStatus.TERMINATED) {
                return true;
            }
        }
        return false;
    };
    ThreadPool.prototype.threadTerminated = function (thread) {
        var idx = this.threads.indexOf(thread);
        assert(idx >= 0);
        // Remove the specified thread from the threadpool.
        this.threads.splice(idx, 1);
        if (!this.anyNonDaemonicThreads()) {
            var close_1 = this.emptyCallback();
            if (close_1) {
                this.emptyCallback = null;
            }
        }
    };
    /**
     * Called when a thread's status changes.
     */
    ThreadPool.prototype.statusChange = function (thread, oldStatus, newStatus) {
        var wasRunnable = isRunnable(oldStatus), nowRunnable = isRunnable(newStatus);
        if (oldStatus === enums_1.ThreadStatus.NEW || oldStatus === enums_1.ThreadStatus.TERMINATED) {
            if (this.threads.indexOf(thread) === -1) {
                this.threads.push(thread);
            }
        }
        // Inform scheduling algorithm if thread changes from runnable => unrunnable, or unrunnable => runnable.
        if (wasRunnable !== nowRunnable) {
            if (wasRunnable) {
                this.scheduler.unscheduleThread(thread);
            }
            else {
                this.scheduler.scheduleThread(thread);
            }
        }
        if (newStatus === enums_1.ThreadStatus.TERMINATED) {
            this.threadTerminated(thread);
        }
    };
    /**
     * Called when a thread's priority changes.
     */
    ThreadPool.prototype.priorityChange = function (thread) {
        this.scheduler.priorityChange(thread);
    };
    /**
     * Called when a thread's quantum is over.
     */
    ThreadPool.prototype.quantumOver = function (thread) {
        this.scheduler.quantumOver(thread);
    };
    return ThreadPool;
})();
exports.__esModule = true;
exports["default"] = ThreadPool;

},{"./assert":26,"./enums":31}],47:[function(_dereq_,module,exports){
(function (process,Buffer){
"use strict";
var gLong = _dereq_('./gLong');
var enums = _dereq_('./enums');
/**
 * util contains stateless utility functions that are used around Doppio's
 * codebase.
 * TODO: Separate general JS utility methods from JVM utility methods.
 */
/**
 * Merges object literals together into a new object. Emulates underscore's merge function.
 */
function merge() {
    var literals = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        literals[_i - 0] = arguments[_i];
    }
    var newObject = {};
    literals.forEach(function (literal) {
        Object.keys(literal).forEach(function (key) {
            newObject[key] = literal[key];
        });
    });
    return newObject;
}
exports.merge = merge;
function are_in_browser() {
    return process.platform === 'browser';
}
exports.are_in_browser = are_in_browser;
exports.typedArraysSupported = typeof ArrayBuffer !== "undefined";
/**
 * Converts JVM internal names into JS-safe names. Only for use with reference
 * types.
 * Ljava/lang/Object; => java_lang_Object
 * Lfoo/Bar_baz; => foo_Bar__baz
 *
 * Is NOT meant to be unambiguous!
 *
 * Also handles the special characters described here:
 * https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm
 */
function jvmName2JSName(jvmName) {
    switch (jvmName[0]) {
        case 'L':
            return jvmName.slice(1, jvmName.length - 1).replace(/_/g, '__')
                .replace(/[\/.;$<>\[\]:\\=^-]/g, '_');
        case '[':
            return "ARR_" + jvmName2JSName(jvmName.slice(1));
        default:
            return jvmName;
    }
}
exports.jvmName2JSName = jvmName2JSName;
/**
 * Re-escapes JVM names for eval'd code. Otherwise, JavaScript removes the escapes.
 */
function reescapeJVMName(jvmName) {
    return jvmName.replace(/\\/g, '\\\\');
}
exports.reescapeJVMName = reescapeJVMName;
/**
 * Applies an async function to each element of a list, in order.
 */
function asyncForEach(lst, fn, done_cb) {
    var i = -1;
    function process(err) {
        if (err) {
            done_cb(err);
        }
        else {
            i++;
            if (i < lst.length) {
                fn(lst[i], process);
            }
            else {
                done_cb();
            }
        }
    }
    process();
}
exports.asyncForEach = asyncForEach;
/**
 * Runs the specified tasks in series.
 */
function asyncSeries(tasks, doneCb) {
    var i = -1;
    function process(err) {
        if (err) {
            doneCb(err);
        }
        else {
            i++;
            if (i < tasks.length) {
                tasks[i](process);
            }
            else {
                doneCb();
            }
        }
    }
    process();
}
exports.asyncSeries = asyncSeries;
/**
 * Applies the function to each element of the list in order in series.
 * The first element that returns success halts the process, and triggers
 * done_cb. If no elements return success, done_cb is triggered with no
 * arguments.
 *
 * I wrote this specifically for classloading, but it may have uses elsewhere.
 */
function asyncFind(lst, fn, done_cb) {
    var i = -1;
    function process(success) {
        if (success) {
            done_cb(lst[i]);
        }
        else {
            i++;
            if (i < lst.length) {
                fn(lst[i], process);
            }
            else {
                done_cb();
            }
        }
    }
    process(false);
}
exports.asyncFind = asyncFind;
if (!Math['imul']) {
    Math['imul'] = function (a, b) {
        // polyfill from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/imul
        var ah = (a >>> 16) & 0xffff;
        var al = a & 0xffff;
        var bh = (b >>> 16) & 0xffff;
        var bl = b & 0xffff;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
    };
}
if (!Math['expm1']) {
    Math['expm1'] = function (x) {
        if (Math.abs(x) < 1e-5) {
            return x + 0.5 * x * x;
        }
        else {
            return Math.exp(x) - 1.0;
        }
    };
}
if (!Math['sinh']) {
    Math['sinh'] = function (a) {
        var exp = Math.exp(a);
        return (exp - 1 / exp) / 2;
    };
}
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement, fromIndex) {
        if (this == null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }
        var n = 0;
        if (fromIndex !== undefined) {
            n = Number(fromIndex);
            if (n != n) {
                n = 0;
            }
            else if (n != 0 && n != Infinity && n != -Infinity) {
                n = ((n > 0 ? 1 : 0) || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
}
/**
 * Checks if accessingCls has permission to a field or method with the given
 * flags on owningCls.
 *
 * Modifier    | Class | Package | Subclass | World
 * ————————————+———————+—————————+——————————+———————
 * public      |  y    |    y    |    y     |   y
 * ————————————+———————+—————————+——————————+———————
 * protected   |  y    |    y    |    y     |   n
 * ————————————+———————+—————————+——————————+———————
 * no modifier |  y    |    y    |    n     |   n
 * ————————————+———————+—————————+——————————+———————
 * private     |  y    |    n    |    n     |   n
 *
 * y: accessible
 * n: not accessible
 */
function checkAccess(accessingCls, owningCls, accessFlags) {
    if (accessFlags.isPublic()) {
        return true;
    }
    else if (accessFlags.isProtected()) {
        return accessingCls.getPackageName() === owningCls.getPackageName() || accessingCls.isSubclass(owningCls);
    }
    else if (accessFlags.isPrivate()) {
        return accessingCls === owningCls;
    }
    else {
        return accessingCls.getPackageName() === owningCls.getPackageName();
    }
}
exports.checkAccess = checkAccess;
/**
 * Truncates a floating point into an integer.
 */
function float2int(a) {
    if (a > enums.Constants.INT_MAX) {
        return enums.Constants.INT_MAX;
    }
    else if (a < enums.Constants.INT_MIN) {
        return enums.Constants.INT_MIN;
    }
    else {
        return a | 0;
    }
}
exports.float2int = float2int;
var supportsArrayBuffers = typeof (ArrayBuffer) !== 'undefined';
/**
 * Converts a byte array to a buffer. **Copies.**
 */
function byteArray2Buffer(bytes, offset, len) {
    if (offset === void 0) { offset = 0; }
    if (len === void 0) { len = bytes.length; }
    if (supportsArrayBuffers && ArrayBuffer.isView(bytes)) {
        var offset_1 = bytes.byteOffset;
        return new Buffer(bytes.buffer.slice(offset_1, offset_1 + bytes.length));
    }
    else {
        var buff = new Buffer(len), i;
        for (i = 0; i < len; i++) {
            buff.writeInt8(bytes[offset + i], i);
        }
        return buff;
    }
}
exports.byteArray2Buffer = byteArray2Buffer;
// Call this ONLY on the result of two non-NaN numbers.
function wrapFloat(a) {
    if (a > 3.40282346638528860e+38) {
        return Number.POSITIVE_INFINITY;
    }
    if (0 < a && a < 1.40129846432481707e-45) {
        return 0;
    }
    if (a < -3.40282346638528860e+38) {
        return Number.NEGATIVE_INFINITY;
    }
    if (0 > a && a > -1.40129846432481707e-45) {
        return 0;
    }
    return a;
}
exports.wrapFloat = wrapFloat;
// Convert :count chars starting from :offset in a Java character array into a JS string
function chars2jsStr(jvmCarr, offset, count) {
    if (offset === void 0) { offset = 0; }
    if (count === void 0) { count = jvmCarr.array.length; }
    var i, carrArray = jvmCarr.array, rv = "", endOffset = offset + count;
    for (i = offset; i < endOffset; i++) {
        rv += String.fromCharCode(carrArray[i]);
    }
    return rv;
}
exports.chars2jsStr = chars2jsStr;
// TODO: Is this used anywhere where we are *not* inserting the bytestr into
// a JVMArray object?
// TODO: Could inject this as a static String method...
function bytestr2Array(byteStr) {
    var rv = [];
    for (var i = 0; i < byteStr.length; i++) {
        rv.push(byteStr.charCodeAt(i));
    }
    return rv;
}
exports.bytestr2Array = bytestr2Array;
function array2bytestr(byteArray) {
    // XXX: We'd like to use String.fromCharCode(bytecode_array...)
    //  but that fails on Webkit with arrays longer than 2^31. See issue #129 for details.
    var rv = '';
    for (var i = 0; i < byteArray.length; i++) {
        rv += String.fromCharCode(byteArray[i]);
    }
    return rv;
}
exports.array2bytestr = array2bytestr;
/**
 * Bit masks for the flag byte.
 */
(function (FlagMasks) {
    FlagMasks[FlagMasks["PUBLIC"] = 1] = "PUBLIC";
    FlagMasks[FlagMasks["PRIVATE"] = 2] = "PRIVATE";
    FlagMasks[FlagMasks["PROTECTED"] = 4] = "PROTECTED";
    FlagMasks[FlagMasks["STATIC"] = 8] = "STATIC";
    FlagMasks[FlagMasks["FINAL"] = 16] = "FINAL";
    FlagMasks[FlagMasks["SYNCHRONIZED"] = 32] = "SYNCHRONIZED";
    FlagMasks[FlagMasks["SUPER"] = 32] = "SUPER";
    FlagMasks[FlagMasks["VOLATILE"] = 64] = "VOLATILE";
    FlagMasks[FlagMasks["TRANSIENT"] = 128] = "TRANSIENT";
    FlagMasks[FlagMasks["VARARGS"] = 128] = "VARARGS";
    FlagMasks[FlagMasks["NATIVE"] = 256] = "NATIVE";
    FlagMasks[FlagMasks["INTERFACE"] = 512] = "INTERFACE";
    FlagMasks[FlagMasks["ABSTRACT"] = 1024] = "ABSTRACT";
    FlagMasks[FlagMasks["STRICT"] = 2048] = "STRICT";
})(exports.FlagMasks || (exports.FlagMasks = {}));
var FlagMasks = exports.FlagMasks;
/**
 * Represents a 'flag byte'. See �4 of the JVM spec.
 * @todo Separate METHOD flags and CLASS flags.
 */
var Flags = (function () {
    function Flags(byte) {
        this.byte = byte;
    }
    Flags.prototype.isPublic = function () {
        return (this.byte & FlagMasks.PUBLIC) > 0;
    };
    Flags.prototype.isPrivate = function () {
        return (this.byte & FlagMasks.PRIVATE) > 0;
    };
    Flags.prototype.isProtected = function () {
        return (this.byte & FlagMasks.PROTECTED) > 0;
    };
    Flags.prototype.isStatic = function () {
        return (this.byte & FlagMasks.STATIC) > 0;
    };
    Flags.prototype.isFinal = function () {
        return (this.byte & FlagMasks.FINAL) > 0;
    };
    Flags.prototype.isSynchronized = function () {
        return (this.byte & FlagMasks.SYNCHRONIZED) > 0;
    };
    Flags.prototype.isSuper = function () {
        return (this.byte & FlagMasks.SUPER) > 0;
    };
    Flags.prototype.isVolatile = function () {
        return (this.byte & FlagMasks.VOLATILE) > 0;
    };
    Flags.prototype.isTransient = function () {
        return (this.byte & FlagMasks.TRANSIENT) > 0;
    };
    Flags.prototype.isNative = function () {
        return (this.byte & FlagMasks.NATIVE) > 0;
    };
    Flags.prototype.isInterface = function () {
        return (this.byte & FlagMasks.INTERFACE) > 0;
    };
    Flags.prototype.isAbstract = function () {
        return (this.byte & FlagMasks.ABSTRACT) > 0;
    };
    Flags.prototype.isStrict = function () {
        return (this.byte & FlagMasks.STRICT) > 0;
    };
    /**
     * Changes a function to native. Used for trapped methods.
     */
    Flags.prototype.setNative = function (n) {
        if (n) {
            this.byte = this.byte | FlagMasks.NATIVE;
        }
        else {
            this.byte = this.byte & (~FlagMasks.NATIVE);
        }
    };
    Flags.prototype.isVarArgs = function () {
        return (this.byte & FlagMasks.VARARGS) > 0;
    };
    Flags.prototype.getRawByte = function () {
        return this.byte;
    };
    return Flags;
})();
exports.Flags = Flags;
function initialValue(type_str) {
    if (type_str === 'J')
        return gLong.ZERO;
    var c = type_str[0];
    if (c === '[' || c === 'L')
        return null;
    return 0;
}
exports.initialValue = initialValue;
/**
 * Java classes are represented internally using slashes as delimiters.
 * These helper functions convert between the two representations.
 * Ljava/lang/Class; => java.lang.Class
 */
function ext_classname(str) {
    return descriptor2typestr(str).replace(/\//g, '.');
}
exports.ext_classname = ext_classname;
/**
 * java.lang.Class => Ljava/lang/Class;
 */
function int_classname(str) {
    return typestr2descriptor(str.replace(/\./g, '/'));
}
exports.int_classname = int_classname;
function verify_int_classname(str) {
    var array_nesting = str.match(/^\[*/)[0].length;
    if (array_nesting > 255) {
        return false;
    }
    if (array_nesting > 0) {
        str = str.slice(array_nesting);
    }
    if (str[0] === 'L') {
        if (str[str.length - 1] !== ';') {
            return false;
        }
        str = str.slice(1, -1);
    }
    if (str in exports.internal2external) {
        return true;
    }
    if (str.match(/\/{2,}/)) {
        return false;
    }
    var parts = str.split('/');
    for (var i = 0; i < parts.length; i++) {
        if (parts[i].match(/[^$_a-z0-9]/i)) {
            return false;
        }
    }
    return true;
}
exports.verify_int_classname = verify_int_classname;
exports.internal2external = {
    B: 'byte',
    C: 'char',
    D: 'double',
    F: 'float',
    I: 'int',
    J: 'long',
    S: 'short',
    V: 'void',
    Z: 'boolean'
};
exports.external2internal = {};
for (var k in exports.internal2external) {
    exports.external2internal[exports.internal2external[k]] = k;
}
/**
 * Given a method descriptor, returns the typestrings for the return type
 * and the parameters.
 *
 * e.g. (Ljava/lang/Class;Z)Ljava/lang/String; =>
 *        ["Ljava/lang/Class;", "Z", "Ljava/lang/String;"]
 */
function getTypes(methodDescriptor) {
    var i = 0, types = [], endIdx;
    for (i = 0; i < methodDescriptor.length; i++) {
        switch (methodDescriptor.charAt(i)) {
            case '(':
            case ')':
                //Skip.
                break;
            case 'L':
                // Reference type.
                endIdx = methodDescriptor.indexOf(';', i);
                types.push(methodDescriptor.slice(i, endIdx + 1));
                i = endIdx;
                break;
            case '[':
                endIdx = i + 1;
                // Find the start of the component.
                while (methodDescriptor.charAt(endIdx) === '[') {
                    endIdx++;
                }
                if (methodDescriptor.charAt(endIdx) === 'L') {
                    // Reference component. Read ahead to end.
                    endIdx = methodDescriptor.indexOf(';', endIdx);
                    types.push(methodDescriptor.slice(i, endIdx + 1));
                }
                else {
                    // Primitive component.
                    types.push(methodDescriptor.slice(i, endIdx + 1));
                }
                i = endIdx;
                break;
            default:
                // Primitive type.
                types.push(methodDescriptor.charAt(i));
                break;
        }
    }
    return types;
}
exports.getTypes = getTypes;
// Get the component type of an array type string.
// Cut off the [L and ; for arrays of classes.
function get_component_type(type_str) {
    return type_str.slice(1);
}
exports.get_component_type = get_component_type;
function is_array_type(type_str) {
    return type_str[0] === '[';
}
exports.is_array_type = is_array_type;
function is_primitive_type(type_str) {
    return type_str in exports.internal2external;
}
exports.is_primitive_type = is_primitive_type;
function is_reference_type(type_str) {
    return type_str[0] === 'L';
}
exports.is_reference_type = is_reference_type;
/**
 * Converts type descriptors into standardized internal type strings.
 * Ljava/lang/Class; => java/lang/Class   Reference types
 * [Ljava/lang/Class; is unchanged        Array types
 * C => char                              Primitive types
 */
function descriptor2typestr(type_str) {
    var c = type_str[0];
    if (c in exports.internal2external)
        return exports.internal2external[c];
    if (c === 'L')
        return type_str.slice(1, -1);
    if (c === '[')
        return type_str;
    // no match
    throw new Error("Unrecognized type string: " + type_str);
}
exports.descriptor2typestr = descriptor2typestr;
// Takes a character array of concatenated type descriptors and returns/removes the first one.
function carr2descriptor(carr) {
    var c = carr.shift();
    if (c == null)
        return null;
    if (exports.internal2external[c] !== void 0)
        return c;
    if (c === 'L') {
        var rv = 'L';
        while ((c = carr.shift()) !== ';') {
            rv += c;
        }
        return rv + ';';
    }
    if (c === '[')
        return "[" + carr2descriptor(carr);
    // no match
    carr.unshift(c);
    throw new Error("Unrecognized descriptor: " + carr.join(''));
}
exports.carr2descriptor = carr2descriptor;
// Converts internal type strings into type descriptors. Reverse of descriptor2typestr.
function typestr2descriptor(type_str) {
    if (exports.external2internal[type_str] !== void 0) {
        return exports.external2internal[type_str];
    }
    else if (type_str[0] === '[') {
        return type_str;
    }
    else {
        return "L" + type_str + ";";
    }
}
exports.typestr2descriptor = typestr2descriptor;
/**
 * Java's reflection APIs need to unbox primitive arguments to function calls,
 * as they are boxed in an Object array. This utility function converts
 * an array of arguments into the appropriate form prior to function invocation.
 * Note that this includes padding category 2 primitives, which consume two
 * slots in the array (doubles/longs).
 */
function unboxArguments(thread, paramTypes, args) {
    var rv = [], i, type, arg;
    for (i = 0; i < paramTypes.length; i++) {
        type = paramTypes[i];
        arg = args[i];
        if (is_primitive_type(type)) {
            // Unbox the primitive type.
            // TODO: Precisely type this better. Once TypeScript lets you import
            // union types, we can define a "JVMPrimitive" type...
            rv.push(arg.unbox());
            if (type === 'J' || type === 'D') {
                // 64-bit primitives take up two argument slots. Doppio uses a NULL for the second slot.
                rv.push(null);
            }
        }
        else {
            // Reference type; do not change.
            rv.push(arg);
        }
    }
    return rv;
}
exports.unboxArguments = unboxArguments;
/**
 * Given a method descriptor as a JS string, returns a corresponding MethodType
 * object.
 */
function createMethodType(thread, cl, descriptor, cb) {
    cl.initializeClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;', function (cdata) {
        if (cdata !== null) {
            var jsCons = cdata.getConstructor(thread), classes = getTypes(descriptor);
            classes.push('[Ljava/lang/Class;');
            // Need the return type and parameter types.
            cl.resolveClasses(thread, classes, function (classMap) {
                var types = classes.map(function (cls) { return classMap[cls].getClassObject(thread); });
                types.pop(); // Discard '[Ljava/lang/Class;'
                var rtype = types.pop(), // Return type.
                clsArrCons = classMap['[Ljava/lang/Class;'].getConstructor(thread), ptypes = new clsArrCons(thread, types.length);
                ptypes.array = types;
                jsCons['java/lang/invoke/MethodHandleNatives/findMethodHandleType(Ljava/lang/Class;[Ljava/lang/Class;)Ljava/lang/invoke/MethodType;'](thread, [rtype, ptypes], cb);
            });
        }
    });
}
exports.createMethodType = createMethodType;
/**
 * Given a method descriptor, returns the number of words required to store
 * its arguments.
 * Does not include considerations for e.g. the 'this' argument, since the
 * descriptor does not specify if the method is static or not.
 */
function getMethodDescriptorWordSize(descriptor) {
    var parsedDescriptor = getTypes(descriptor), words = parsedDescriptor.length - 1, i, p;
    // Remove return type.
    parsedDescriptor.pop();
    // Double count doubles / longs.
    for (i = 0; i < parsedDescriptor.length; i++) {
        p = parsedDescriptor[i];
        if (p === 'D' || p === 'J') {
            words++;
        }
    }
    return words;
}
exports.getMethodDescriptorWordSize = getMethodDescriptorWordSize;
/**
 * Given a return type as a Class object, and an array of class objects for
 * parameter types, returns the descriptor string for the method type.
 */
function getDescriptorString(rtype, ptypes) {
    var rv = "(";
    if (ptypes !== undefined && ptypes !== null) {
        ptypes.array.forEach(function (ptype) {
            rv += ptype.$cls.getInternalName();
        });
    }
    rv += ")" + rtype.$cls.getInternalName();
    return rv;
}
exports.getDescriptorString = getDescriptorString;
/**
 * Have a JavaClassLoaderObject and need its ClassLoader object? Use this method!
 * @todo Install on Java ClassLoader objects.
 */
function getLoader(thread, jclo) {
    if ((jclo != null) && (jclo.$loader != null)) {
        return jclo.$loader;
    }
    return thread.getBsCl();
}
exports.getLoader = getLoader;
/**
 * "Fast" array copy; does not have to check every element for illegal
 * assignments. You can do tricks here (if possible) to copy chunks of the array
 * at a time rather than element-by-element.
 * This function *cannot* access any attribute other than 'array' on src due to
 * the special case when src == dest (see code for System.arraycopy below).
 */
function arraycopyNoCheck(src, srcPos, dest, destPos, length) {
    var j = destPos;
    var end = srcPos + length;
    for (var i = srcPos; i < end; i++) {
        dest.array[j++] = src.array[i];
    }
}
exports.arraycopyNoCheck = arraycopyNoCheck;
/**
 * "Slow" array copy; has to check every element for illegal assignments.
 * You cannot do any tricks here; you must copy element by element until you
 * have either copied everything, or encountered an element that cannot be
 * assigned (which causes an exception).
 * Guarantees: src and dest are two different reference types. They cannot be
 *             primitive arrays.
 */
function arraycopyCheck(thread, src, srcPos, dest, destPos, length) {
    var j = destPos;
    var end = srcPos + length;
    var destCompCls = dest.getClass().getComponentClass();
    for (var i = srcPos; i < end; i++) {
        // Check if null or castable.
        if (src.array[i] === null || src.array[i].getClass().isCastable(destCompCls)) {
            dest.array[j] = src.array[i];
        }
        else {
            thread.throwNewException('Ljava/lang/ArrayStoreException;', 'Array element in src cannot be cast to dest array type.');
            return;
        }
        j++;
    }
}
exports.arraycopyCheck = arraycopyCheck;
function initString(cl, str) {
    var carr = initCarr(cl, str);
    var strCons = cl.getResolvedClass('Ljava/lang/String;').getConstructor(null);
    var strObj = new strCons(null);
    strObj['java/lang/String/value'] = carr;
    return strObj;
}
exports.initString = initString;
function initCarr(cl, str) {
    var arrClsCons = cl.getInitializedClass(null, '[C').getConstructor(null), carr = new arrClsCons(null, str.length), carrArray = carr.array;
    for (var i = 0; i < str.length; i++) {
        carrArray[i] = str.charCodeAt(i);
    }
    return carr;
}
exports.initCarr = initCarr;
function newArrayFromClass(thread, clazz, length) {
    return new (clazz.getConstructor(thread))(thread, length);
}
exports.newArrayFromClass = newArrayFromClass;
function newArray(thread, cl, desc, length) {
    var cls = cl.getInitializedClass(thread, desc);
    return newArrayFromClass(thread, cls, length);
}
exports.newArray = newArray;
/**
 * Separate from newArray to avoid programming mistakes where newArray and newArrayFromData are conflated.
 */
function multiNewArray(thread, cl, desc, lengths) {
    var cls = cl.getInitializedClass(thread, desc);
    return new (cls.getConstructor(thread))(thread, lengths);
}
exports.multiNewArray = multiNewArray;
function newObjectFromClass(thread, clazz) {
    return new (clazz.getConstructor(thread))(thread);
}
exports.newObjectFromClass = newObjectFromClass;
function newObject(thread, cl, desc) {
    var cls = cl.getInitializedClass(thread, desc);
    return newObjectFromClass(thread, cls);
}
exports.newObject = newObject;
function getStaticFields(thread, cl, desc) {
    return cl.getInitializedClass(thread, desc).getConstructor(thread);
}
exports.getStaticFields = getStaticFields;
function newArrayFromDataWithClass(thread, cls, data) {
    var arr = newArrayFromClass(thread, cls, 0);
    arr.array = data;
    return arr;
}
exports.newArrayFromDataWithClass = newArrayFromDataWithClass;
function newArrayFromData(thread, cl, desc, data) {
    var arr = newArray(thread, cl, desc, 0);
    arr.array = data;
    return arr;
}
exports.newArrayFromData = newArrayFromData;
/**
 * Returns the boxed class name of the given primitive type.
 */
function boxClassName(primType) {
    switch (primType) {
        case 'B':
            return 'Ljava/lang/Byte;';
        case 'C':
            return 'Ljava/lang/Character;';
        case 'D':
            return 'Ljava/lang/Double;';
        case 'F':
            return 'Ljava/lang/Float;';
        case 'I':
            return 'Ljava/lang/Integer;';
        case 'J':
            return 'Ljava/lang/Long;';
        case 'S':
            return 'Ljava/lang/Short;';
        case 'Z':
            return 'Ljava/lang/Boolean;';
        case 'V':
            return 'Ljava/lang/Void;';
        default:
            throw new Error("Tried to box a non-primitive class: " + this.className);
    }
}
exports.boxClassName = boxClassName;
/**
 * Boxes the given primitive value.
 */
function boxPrimitiveValue(thread, type, val) {
    // XXX: We assume Integer for typing purposes only; avoids a huge union type.
    var primCls = thread.getBsCl().getInitializedClass(thread, boxClassName(type)), primClsCons = primCls.getConstructor(thread);
    return primClsCons.box(val);
}
exports.boxPrimitiveValue = boxPrimitiveValue;
/**
 * Boxes the given arguments into an Object[].
 *
 * @param descriptor The descriptor at the *call site*.
 * @param data The actual arguments for this function call.
 * @param isStatic If false, disregard the first type in the descriptor, as it is the 'this' argument.
 */
function boxArguments(thread, objArrCls, descriptor, data, isStatic, skipArgs) {
    if (skipArgs === void 0) { skipArgs = 0; }
    var paramTypes = getTypes(descriptor), boxedArgs = newArrayFromClass(thread, objArrCls, paramTypes.length - (isStatic ? 1 : 2) - skipArgs), i, j = 0, boxedArgsArr = boxedArgs.array, type;
    // Ignore return value.
    paramTypes.pop();
    if (!isStatic) {
        // Ignore 'this' argument.
        paramTypes.shift();
    }
    if (skipArgs > 0) {
        // Ignore regular arguments
        paramTypes = paramTypes.slice(skipArgs);
        data = data.slice(skipArgs);
    }
    for (i = 0; i < paramTypes.length; i++) {
        type = paramTypes[i];
        switch (type[0]) {
            case '[':
            case 'L':
                // Single argument slot, no boxing required.
                boxedArgsArr[i] = data[j];
                break;
            case 'J':
            case 'D':
                boxedArgsArr[i] = boxPrimitiveValue(thread, type, data[j]);
                j++;
                break;
            default:
                boxedArgsArr[i] = boxPrimitiveValue(thread, type, data[j]);
                break;
        }
        j++;
    }
    return boxedArgs;
}
exports.boxArguments = boxArguments;
function forwardResult(thread) {
    return function (e, rv) {
        if (e) {
            thread.throwException(e);
        }
        else {
            thread.asyncReturn(rv);
        }
    };
}
exports.forwardResult = forwardResult;

}).call(this,BrowserFS.BFSRequire('process'),BrowserFS.BFSRequire('buffer').Buffer)

},{"./enums":31,"./gLong":32}],48:[function(_dereq_,module,exports){
module.exports={"url":"https://github.com/plasma-umass/doppio_jcl/releases/download/v3.2/java_home.tar.gz","classpath":["lib/rt.jar","lib/charsets.jar","lib/doppio.jar","lib/dt.jar","lib/jce.jar","lib/jconsole.jar","lib/jsse.jar","lib/management-agent.jar","lib/resources.jar","lib/sa-jdi.jar","lib/tools.jar"]}
},{}]},{},[35])(35)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsInBhY2thZ2UuanNvbiIsInNoaW1zL2J1ZmZlci5qcyIsInNoaW1zL2ZzLmpzIiwic2hpbXMvcGF0aC5qcyIsInNyYy9CeXRlU3RyZWFtLnRzIiwic3JjL0NsYXNzRGF0YS50cyIsInNyYy9DbGFzc0ZpbGUudHMiLCJzcmMvQ2xhc3NMb2FkZXIudHMiLCJzcmMvQ2xhc3NMb2NrLnRzIiwic3JjL0NvbnN0YW50UG9vbC50cyIsInNyYy9EZWJ1Zy50cyIsInNyYy9Nb25pdG9yLnRzIiwic3JjL1NhZmVNYXAudHMiLCJzcmMvU3RyaW5nT3V0cHV0U3RyZWFtLnRzIiwic3JjL1ZNLnRzIiwic3JjL2Fzc2VydC50cyIsInNyYy9hdHRyaWJ1dGVzLnRzIiwic3JjL2NsYXNzcGF0aC50cyIsInNyYy9kaWZmbGliLnRzIiwic3JjL2RvcHBpb2p2bS50cyIsInNyYy9lbnVtcy50cyIsInNyYy9nTG9uZy50cyIsInNyYy9nbG9iYWwudHMiLCJzcmMvaGVhcC50cyIsInNyYy9pbmRleC50cyIsInNyYy9pbnRlcmZhY2VzLnRzIiwic3JjL2phdmFfY2xpLnRzIiwic3JjL2p2bS50cyIsInNyYy9sb2dnaW5nLnRzIiwic3JjL21ldGhvZHMudHMiLCJzcmMvb3Bjb2Rlcy50cyIsInNyYy9vcHRpb25fcGFyc2VyLnRzIiwic3JjL3Bhcmtlci50cyIsInNyYy90ZXN0aW5nLnRzIiwic3JjL3RocmVhZGluZy50cyIsInNyYy90aHJlYWRwb29sLnRzIiwic3JjL3V0aWwudHMiLCJ2ZW5kb3IvamF2YV9ob21lL2pkay5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUN2QyxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixHQUFHLElBQUksR0FBRyxLQUFLLEVBQUUsQ0FBQztRQUNsQixHQUFHLElBQUksTUFBTSxDQUFDO1FBQ2QsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDakIsR0FBRyxJQUFJLEdBQUcsS0FBSyxFQUFFLENBQUM7UUFDbEIsR0FBRyxJQUFJLE1BQU0sQ0FBQztRQUNkLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLEdBQUcsSUFBSSxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQ2xCLEdBQUcsSUFBSSxNQUFNLENBQUM7UUFDZCxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixHQUFHLElBQUksR0FBRyxLQUFLLEVBQUUsQ0FBQztRQUNsQixHQUFHLElBQUksTUFBTSxDQUFDO1FBQ2QsR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDakIsR0FBRyxJQUFJLEdBQUcsS0FBSyxFQUFFLENBQUM7UUFDbEIsR0FBRyxJQUFJLE1BQU0sQ0FBQztRQUNkLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLEdBQUcsSUFBSSxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQ2xCLEdBQUcsSUFBSSxNQUFNLENBQUM7UUFDZCxHQUFHLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNyRCxHQUFHLElBQUksTUFBTSxDQUFDO1FBQ2QsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7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LEtBQW1DLEVBQUUsSUFBWTtRQUMvRixJQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3BCLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixLQUFLLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2hCLENBQUM7SUFDSCxDQUFDO0lBRWEsWUFBSSxHQUFsQixVQUFtQixNQUEyQixFQUFFLEtBQW1DLEVBQUUsSUFBWTtRQUMvRixJQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3BCLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixLQUFLLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2hCLENBQUM7SUFDSCxDQUFDO0lBRWEsWUFBSSxHQUFsQixVQUFtQixNQUEyQixFQUFFLEtBQW1DLEVBQUUsSUFBWTtRQUMvRixJQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3BCLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixLQUFLLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUssQ0FBQyxF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QUFDO1FBQzVCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRCxnQ0FBSSxHQUFKO1FBQ0UsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsK0JBQUcsR0FBSDtRQUNFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRUQsZ0NBQUksR0FBSjtRQUNFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxrQ0FBTSxHQUFOO1FBQ0UsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRXJDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFL0IsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELGtDQUFNLEdBQU47UUFDRSxJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFckMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRS9CLElBQUksQ0FBQyxJ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QyxDQUFDLENBQUMsQ0FBQztnQkFDMUIsS0FBSyxDQUFDO1lBQ1IsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLEdBQUc7Z0JBQ04sWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzNELENBQUMsRUFBRSxDQUFDO2dCQUNKLEtBQUssQ0FBQztZQUNSO2dCQUNFLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzRCxLQUFLLENBQUM7UUFDVixDQUFDO1FBQ0QsQ0FBQyxFQUFFLENBQUM7SUFDTixDQUFDO0lBRUQsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBdkNlLG9CQUFZLGVBdUMzQixDQUFBO0FBRUQsdUJBQW1FLE1BQTJCO0lBQzVGLE1BQU0sQ0FBQyxVQUFDLENBQWdDLEVBQUUsRUFBTTtRQUM5QyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ04sTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCLENBQUM7SUFDSCxDQUFDLENBQUM7QUFDSixDQUFDO0FBUmUscUJBQWEsZ0JBUTVCLENBQUE7Ozs7O0FDdDNCRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBkb2Vzbid0IHdvcnRoIHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25hIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIHMuZF9idWYgPSBzLmxpdF9idWZzaXplID4+IDE7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB0aGUgc291cmNlIHN0YXRlIHRvIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZVxuICovXG4vL2Z1bmN0aW9uIGRlZmxhdGVDb3B5KGRlc3QsIHNvdXJjZSkge1xuLy9cbi8vfVxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgY2FzZSBIRUFEOlxuICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbiAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRkxBR1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRJTUU6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgLy89PT1cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgT1M6XG4gICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhMRU46XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYVFJBOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW5kIHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTkFNRTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBIQ1JDOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJQ1RJRDpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElDVDpcbiAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFOlxuICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRURPOlxuICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgYml0cyAtPSAxO1xuICAgICAgLy8tLS0vL1xuXG4gICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICBiaXRzIC09IDI7XG4gICAgICAvLy0tLS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUT1JFRDpcbiAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgIC8vLS0tLy9cbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFlfOlxuICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZOlxuICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVEFCTEU6XG4gICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPREVMRU5TOlxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTl86XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOOlxuICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgLy8tLS1cblxuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVORVhUOlxuICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNUOlxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVEVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTUFUQ0g6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICB9XG4gICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgIGRvIHtcbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIExJVDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGxlZnQtLTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICBicmVhaztcbiAgICBjYXNlIENIRUNLOlxuICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIC8vIFVzZSAnfCcgaW5zZGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICB9XG4gICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5HVEg6XG4gICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBET05FOlxuICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgQkFEOlxuICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgTUVNOlxuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIGNhc2UgU1lOQzpcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBpID0gMDtcbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnNkZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkBocmovZG9wcGlvanZtLXNuYXBzaG90XCIsXG4gIFwidmVyc2lvblwiOiBcIjAuNC4xMFwiLFxuICBcImVuZ2luZVwiOiBcIm5vZGUgPj0gNC4wLjBcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImRpc3QvcmVsZWFzZS9kb3BwaW8uanNcIixcbiAgXCJ0eXBpbmdzXCI6IFwiZGlzdC90eXBpbmdzL3NyYy9kb3BwaW9qdm1cIixcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYXN5bmNcIjogXCJeMS41LjJcIixcbiAgICBcImJyb3dzZXJmc1wiOiBcIl4wLjUuMTJcIixcbiAgICBcImdsb2JcIjogXCJeNy4wLjBcIixcbiAgICBcImd1bnppcC1tYXliZVwiOiBcIl4xLjMuMVwiLFxuICAgIFwib3B0aW1pc3RcIjogXCJ+MC42XCIsXG4gICAgXCJwYWtvXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJyaW1yYWZcIjogXCJeMi41LjJcIixcbiAgICBcInNvdXJjZS1tYXAtc3VwcG9ydFwiOiBcIl4wLjQuMFwiLFxuICAgIFwidGFyLWZzXCI6IFwiXjEuMTAuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJmcy1idWZmZXJcIjogXCJeMC4xLjFcIixcbiAgICBcImJmcy1wYXRoXCI6IFwiXjAuMS4xXCIsXG4gICAgXCJiZnMtcHJvY2Vzc1wiOiBcIl4wLjEuNVwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICBcImJyb3dzZXJpZnktZGVyZXF1aXJlXCI6IFwiXjAuOS40XCIsXG4gICAgXCJicm93c2VyaWZ5LXNoaW1cIjogXCJeMy44LjEyXCIsXG4gICAgXCJjcHJcIjogXCJeMS4wLjBcIixcbiAgICBcImVzY29kZWdlblwiOiBcIl4xLjguMFwiLFxuICAgIFwiZXNwcmltYVwiOiBcIl4yLjcuMlwiLFxuICAgIFwiZXN0cmF2ZXJzZVwiOiBcIl40LjEuMFwiLFxuICAgIFwiZ3J1bnRcIjogXCJeMC40LjVcIixcbiAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJeNC4wLjFcIixcbiAgICBcImdydW50LWNsaVwiOiBcIl4wLjEuMTNcIixcbiAgICBcImdydW50LWNvbnRyaWItY29ubmVjdFwiOiBcIl4wLjExLjJcIixcbiAgICBcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4wLjguMVwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMC4xMS4xXCIsXG4gICAgXCJncnVudC1leG9yY2lzZVwiOiBcIl4yLjEuMVwiLFxuICAgIFwiZ3J1bnQta2FybWFcIjogXCJeMC4xMi4xXCIsXG4gICAgXCJncnVudC1saW5lZW5kaW5nXCI6IFwiXjAuMi40XCIsXG4gICAgXCJncnVudC1tZXJnZS1zb3VyY2UtbWFwc1wiOiBcIl4wLjEuMFwiLFxuICAgIFwiZ3J1bnQtdHNcIjogXCJeNS4zLjJcIixcbiAgICBcImphc21pbmUtY29yZVwiOiBcIl4yLjMuNFwiLFxuICAgIFwia2FybWFcIjogXCJeMC4xMy4yMVwiLFxuICAgIFwia2FybWEtYnJvd3NlcmlmeVwiOiBcIl41LjAuMlwiLFxuICAgIFwia2FybWEtY2hyb21lLWxhdW5jaGVyXCI6IFwiXjAuMi4xXCIsXG4gICAgXCJrYXJtYS1maXJlZm94LWxhdW5jaGVyXCI6IFwiXjAuMS42XCIsXG4gICAgXCJrYXJtYS1pZS1sYXVuY2hlclwiOiBcIl4wLjIuMFwiLFxuICAgIFwia2FybWEtamFzbWluZVwiOiBcIl4wLjMuN1wiLFxuICAgIFwia2FybWEtb3BlcmEtbGF1bmNoZXJcIjogXCJeMC4zLjBcIixcbiAgICBcImthcm1hLXNhZmFyaS1sYXVuY2hlclwiOiBcIl4wLjEuMVwiLFxuICAgIFwibG9jYXRlLWphdmEtaG9tZVwiOiBcIl4wLjEuNFwiLFxuICAgIFwic2VtdmVyXCI6IFwiXjUuMS4wXCIsXG4gICAgXCJ0c2lmeVwiOiBcIl4wLjEzLjJcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCJeMS44LjJcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcIl4yLjYuMlwiLFxuICAgIFwidW5kZWJ1Z2lmeVwiOiBcIl4wLjEuMFwiLFxuICAgIFwidW5kZXJzY29yZVwiOiBcIl4xLjguM1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3J1bnQgdGVzdFwiLFxuICAgIFwicHJlcHVibGlzaFwiOiBcIm5vZGUgLi9wcmVwdWJsaXNoLmpzXCIsXG4gICAgXCJpbnN0YWxsXCI6IFwibm9kZSAuL2luc3RhbGwuanNcIixcbiAgICBcImFwcHZleW9yLXRlc3RcIjogXCJncnVudCB0ZXN0LWJyb3dzZXItYXBwdmV5b3JcIlxuICB9LFxuICBcImJyb3dzZXJpZnktc2hpbVwiOiB7XG4gICAgXCJicm93c2VyZnNcIjogXCJnbG9iYWw6QnJvd3NlckZTXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHA6Ly9naXRodWIuY29tL3BsYXNtYS11bWFzcy9kb3BwaW8uZ2l0XCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwiZG9wcGlvXCI6IFwiLi9iaW4vZG9wcGlvXCIsXG4gICAgXCJkb3BwaW9oXCI6IFwiLi9iaW4vZG9wcGlvaFwiLFxuICAgIFwiZG9wcGlvLWRldlwiOiBcIi4vYmluL2RvcHBpby1kZXZcIixcbiAgICBcImRvcHBpby1mYXN0LWRldlwiOiBcIi4vYmluL2RvcHBpby1mYXN0LWRldlwiXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPUJyb3dzZXJGUy5CRlNSZXF1aXJlKCdidWZmZXInKTtcbiIsIm1vZHVsZS5leHBvcnRzPUJyb3dzZXJGUy5CRlNSZXF1aXJlKCdmcycpO1xuIiwibW9kdWxlLmV4cG9ydHM9QnJvd3NlckZTLkJGU1JlcXVpcmUoJ3BhdGgnKTtcbiIsIu+7v1widXNlIHN0cmljdFwiO1xuaW1wb3J0IGdMb25nID0gcmVxdWlyZSgnLi9nTG9uZycpO1xuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cbi8qKlxuICogQSBCeXRlU3RyZWFtLCBpbXBsZW1lbnRlZCB1c2luZyBhIE5vZGVCdWZmZXIuXG4gKi9cbmNsYXNzIEJ5dGVTdHJlYW0ge1xuICBwcml2YXRlIF9pbmRleDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJ1ZmZlcjogTm9kZUJ1ZmZlcikge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZWFkIGluZGV4LCBhbmQgaW5jcmVtZW50cyB0aGUgaW5kZXggYnkgdGhlIGluZGljYXRlZFxuICAgKiBhbW91bnQuXG4gICAqL1xuICBwcml2YXRlIGluY0luZGV4KGluYzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICB2YXIgcmVhZEluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgdGhpcy5faW5kZXggKz0gaW5jO1xuICAgIHJldHVybiByZWFkSW5kZXg7XG4gIH1cblxuICBwdWJsaWMgcmV3aW5kKCk6IHZvaWQge1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBzZWVrKGlkeDogbnVtYmVyKSB7XG4gICAgYXNzZXJ0KGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuYnVmZmVyLmxlbmd0aCwgXCJJbnZhbGlkIHNlZWsgcG9zaXRpb24uXCIpO1xuICAgIHRoaXMuX2luZGV4ID0gaWR4O1xuICB9XG5cbiAgcHVibGljIHBvcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgfVxuXG4gIHB1YmxpYyBza2lwKGJ5dGVzQ291bnQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2luZGV4ICs9IGJ5dGVzQ291bnQ7XG4gIH1cblxuICBwdWJsaWMgaGFzQnl0ZXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldEZsb2F0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJlYWRGbG9hdEJFKHRoaXMuaW5jSW5kZXgoNCkpO1xuICB9XG5cbiAgcHVibGljIGdldERvdWJsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkRG91YmxlQkUodGhpcy5pbmNJbmRleCg4KSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0VWludChieXRlQ291bnQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgc3dpdGNoIChieXRlQ291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VWludDgoKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VWludDE2KCk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVpbnQzMigpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIGNvdW50IGZvciBnZXRVaW50OiBcIiArIGJ5dGVDb3VudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldEludChieXRlQ291bnQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgc3dpdGNoIChieXRlQ291bnQpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50OCgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnQxNigpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnQzMigpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIGNvdW50IGZvciBnZXRVaW50OiBcIiArIGJ5dGVDb3VudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFVpbnQ4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLmluY0luZGV4KDEpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRVaW50MTYoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIucmVhZFVJbnQxNkJFKHRoaXMuaW5jSW5kZXgoMikpO1xuICB9XG5cbiAgcHVibGljIGdldFVpbnQzMigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkVUludDMyQkUodGhpcy5pbmNJbmRleCg0KSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SW50OCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkSW50OCh0aGlzLmluY0luZGV4KDEpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnQxNigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkSW50MTZCRSh0aGlzLmluY0luZGV4KDIpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnQzMigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZWFkSW50MzJCRSh0aGlzLmluY0luZGV4KDQpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnQ2NCgpOiBnTG9uZyB7XG4gICAgdmFyIGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuICAgIHZhciBsb3cgPSB0aGlzLmdldFVpbnQzMigpO1xuICAgIHJldHVybiBnTG9uZy5mcm9tQml0cyhsb3csIGhpZ2gpO1xuICB9XG5cbiAgcHVibGljIHJlYWQoYnl0ZXNDb3VudDogbnVtYmVyKTogQnVmZmVyIHtcbiAgICB2YXIgcnYgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLl9pbmRleCwgdGhpcy5faW5kZXggKyBieXRlc0NvdW50KTtcbiAgICB0aGlzLl9pbmRleCArPSBieXRlc0NvdW50O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIHB1YmxpYyBwZWVrKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLl9pbmRleCk7XG4gIH1cblxuICBwdWJsaWMgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLl9pbmRleDtcbiAgfVxuXG4gIHB1YmxpYyBzbGljZShsZW46IG51bWJlcik6IEJ5dGVTdHJlYW0ge1xuICAgIHZhciBhcnIgPSBuZXcgQnl0ZVN0cmVhbSh0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLl9pbmRleCwgdGhpcy5faW5kZXggKyBsZW4pKTtcbiAgICB0aGlzLl9pbmRleCArPSBsZW47XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRCdWZmZXIoKTogTm9kZUJ1ZmZlciB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICB9XG59XG5cbmV4cG9ydCA9IEJ5dGVTdHJlYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5pbXBvcnQgQnl0ZVN0cmVhbSA9IHJlcXVpcmUoJy4vQnl0ZVN0cmVhbScpO1xuaW1wb3J0IENvbnN0YW50UG9vbCA9IHJlcXVpcmUoJy4vQ29uc3RhbnRQb29sJyk7XG5pbXBvcnQgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xuaW1wb3J0IHtKVk1UaHJlYWQsIEludGVybmFsU3RhY2tGcmFtZSwgTmF0aXZlU3RhY2tGcmFtZSwgQnl0ZWNvZGVTdGFja0ZyYW1lfSBmcm9tICcuL3RocmVhZGluZyc7XG5pbXBvcnQgbG9nZ2luZyA9IHJlcXVpcmUoJy4vbG9nZ2luZycpO1xuaW1wb3J0IG1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcbmltcG9ydCBDbGFzc0xvYWRlciA9IHJlcXVpcmUoJy4vQ2xhc3NMb2FkZXInKTtcbmltcG9ydCBlbnVtcyA9IHJlcXVpcmUoJy4vZW51bXMnKTtcbmltcG9ydCBDbGFzc0xvY2sgPSByZXF1aXJlKCcuL0NsYXNzTG9jaycpO1xuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5pbXBvcnQgZ0xvbmcgPSByZXF1aXJlKCcuL2dMb25nJyk7XG5pbXBvcnQgSlZNID0gcmVxdWlyZSgnLi9qdm0nKTtcbmltcG9ydCBTdHJpbmdPdXRwdXRTdHJlYW0gPSByZXF1aXJlKCcuL1N0cmluZ091dHB1dFN0cmVhbScpO1xuaW1wb3J0IEpWTVR5cGVzID0gcmVxdWlyZSgnLi4vaW5jbHVkZXMvSlZNVHlwZXMnKTtcbmltcG9ydCBDbGFzc1N0YXRlID0gZW51bXMuQ2xhc3NTdGF0ZTtcblxuaW1wb3J0IHRyYWNlID0gbG9nZ2luZy50cmFjZTtcbmltcG9ydCBkZWJ1ZyA9IGxvZ2dpbmcuZGVidWc7XG5cbmltcG9ydCBnbG9iYWwgPSByZXF1aXJlKCcuL2dsb2JhbCcpO1xuXG5kZWNsYXJlIHZhciBSRUxFQVNFOiBib29sZWFuO1xuaWYgKHR5cGVvZiBSRUxFQVNFID09PSAndW5kZWZpbmVkJykgZ2xvYmFsLlJFTEVBU0UgPSBmYWxzZTtcblxuLyoqXG4gKiBBdXRvLWluY3JlbWVudGluZyByZWZlcmVuY2UgbnVtYmVyLiBVbmlxdWVseSBpZGVudGlmaWVzIGVhY2ggb2JqZWN0IGFsbG9jYXRlZFxuICogYnkgdGhlIEpWTS4gU3RhcnRlZCBhdCAxIGJlY2F1c2Ugd2UgdXNlIDAgdG8gaWRlbnRpZnkgTlVMTC5cbiAqL1xudmFyIHJlZjogbnVtYmVyID0gMTtcblxuLyoqXG4gKiBEZWZpbmVzIHNwZWNpYWwgSlZNLWluamVjdGVkIGZpZWxkcy4gVGhlIG1hcCBzdG9yZXMgdGhlIFR5cGVTY3JpcHQgdHlwZSBvZlxuICogdGhlIGZpZWxkIGFuZCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGZpZWxkLCB3aGljaCB3aWxsIGJlIGFzc2lnbmVkIGluIHRoZVxuICogSmF2YVNjcmlwdCBjb25zdHJ1Y3RvciBmb3IgdGhlIGNsYXNzLlxuICovXG52YXIgaW5qZWN0ZWRGaWVsZHM6IHtbY2xhc3NOYW1lOiBzdHJpbmddOiB7W2ZpZWxkTmFtZTogc3RyaW5nXTogW3N0cmluZywgc3RyaW5nXX19ID0ge1xuICAnTGphdmEvbGFuZy9pbnZva2UvTWVtYmVyTmFtZTsnOiB7XG4gICAgdm10YXJnZXQ6IFtcIih0aHJlYWQ6IEpWTVRocmVhZCwgZGVzY3JpcHRvcjogc3RyaW5nLCBhcmdzOiBhbnlbXSwgY2I/OiAoZT86IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIHJ2PzogYW55KSA9PiB2b2lkKSA9PiB2b2lkXCIsIFwibnVsbFwiXSxcbiAgICB2bWluZGV4OiBbXCJudW1iZXJcIiwgXCItMVwiXVxuICB9LFxuICAnTGphdmEvbGFuZy9PYmplY3Q7Jzoge1xuICAgICdyZWYnOiBbXCJudW1iZXJcIiwgXCJyZWYrK1wiXSxcbiAgICAnJG1vbml0b3InOiBbXCJNb25pdG9yXCIsIFwibnVsbFwiXVxuICB9LFxuICAnTGphdmEvbmV0L1BsYWluU29ja2V0SW1wbDsnOiB7XG4gICAgJyRpc19zaHV0ZG93bic6IFsnYm9vbGVhbicsICdmYWxzZSddLFxuICAgICckd3MnOiBbJ0ludGVyZmFjZXMuSVdlYnNvY2snLCAnbnVsbCddXG4gIH0sXG4gICdMamF2YS9pby9GaWxlRGVzY3JpcHRvcjsnOiB7XG4gICAgJyRwb3MnOiBbJ251bWJlcicsICctMSddXG4gIH0sXG4gICdMamF2YS9sYW5nL0NsYXNzOyc6IHtcbiAgICAnJGNscyc6IFsnQ2xhc3NEYXRhJywgJ251bGwnXVxuICB9LFxuICAnTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsnOiB7XG4gICAgJyRsb2FkZXInOiBbJ0NsYXNzTG9hZGVyJywgJ25ldyBDbGFzc0xvYWRlci5DdXN0b21DbGFzc0xvYWRlcih0aHJlYWQuZ2V0QnNDbCgpLCB0aGlzKTsnXVxuICB9LFxuICAnTGphdmEvbGFuZy9UaHJlYWQ7Jzoge1xuICAgIC8vIE5vdGU6IE5lZWQgdG8gaGFuZGxlIGluaXRpYWwgY2FzZSB3aGVuIHRocmVhZCBpcyBOVUxMLlxuICAgICckdGhyZWFkJzogWydKVk1UaHJlYWQnLCAndGhyZWFkID8gbmV3IHRocmVhZC5jb25zdHJ1Y3Rvcih0aHJlYWQuZ2V0SlZNKCksIHRocmVhZC5nZXRUaHJlYWRQb29sKCksIHRoaXMpIDogbnVsbCddXG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBzcGVjaWFsIEpWTS1pbmplY3RlZCBtZXRob2QuIFRoZSBtYXAgc3RvcmVzIHRoZSBUeXBlU2NyaXB0IHR5cGVcbiAqIHNpZ25hdHVyZSBvZiB0aGUgbWV0aG9kIGFuZCB0aGUgSmF2YVNjcmlwdCBib2R5IG9mIHRoZSBtZXRob2QsIGtleWVkIG9uIHRoZVxuICogbWV0aG9kJ3MgbmFtZS4gVGhlc2UgYXJlIGFsbCBpbnN0YW5jZSBtZXRob2RzIChlLmcuIG5vbi1zdGF0aWMpLlxuICovXG52YXIgaW5qZWN0ZWRNZXRob2RzOiB7W2NsYXNzTmFtZTogc3RyaW5nXToge1ttZXRob2ROYW1lOiBzdHJpbmddOiBzdHJpbmdbXX19ID0ge1xuICAnTGphdmEvbGFuZy9PYmplY3Q7Jzoge1xuICAgICdnZXRDbGFzcyc6IFtcIigpOiBDbGFzc0RhdGFcIiwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jbHMgfWBdLFxuICAgICdnZXRNb25pdG9yJzogW1wiKCk6IE1vbml0b3JcIiwgYGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy4kbW9uaXRvciA9PT0gbnVsbCkge1xuICAgIHRoaXMuJG1vbml0b3IgPSBuZXcgTW9uaXRvcigpO1xuICB9XG4gIHJldHVybiB0aGlzLiRtb25pdG9yO1xufWBdXG4gIH0sXG4gICdMamF2YS9sYW5nL1N0cmluZzsnOiB7XG4gICAgJ3RvU3RyaW5nJzogW1wiKCk6IHN0cmluZ1wiLCBgZnVuY3Rpb24oKSB7IHJldHVybiB1dGlsLmNoYXJzMmpzU3RyKHRoaXNbJ2phdmEvbGFuZy9TdHJpbmcvdmFsdWUnXSk7IH1gXVxuICB9LFxuICAnTGphdmEvbGFuZy9CeXRlOyc6IHtcbiAgICAndW5ib3gnOiBbXCIoKTogbnVtYmVyXCIsIGBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXNbJ2phdmEvbGFuZy9CeXRlL3ZhbHVlJ107IH1gXVxuICB9LFxuICAnTGphdmEvbGFuZy9DaGFyYWN0ZXI7Jzoge1xuICAgICd1bmJveCc6IFtcIigpOiBudW1iZXJcIiwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpc1snamF2YS9sYW5nL0NoYXJhY3Rlci92YWx1ZSddOyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvRG91YmxlOyc6IHtcbiAgICAndW5ib3gnOiBbXCIoKTogbnVtYmVyXCIsIGBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXNbJ2phdmEvbGFuZy9Eb3VibGUvdmFsdWUnXTsgfWBdXG4gIH0sXG4gICdMamF2YS9sYW5nL0Zsb2F0Oyc6IHtcbiAgICAndW5ib3gnOiBbXCIoKTogbnVtYmVyXCIsIGBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXNbJ2phdmEvbGFuZy9GbG9hdC92YWx1ZSddOyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvSW50ZWdlcjsnOiB7XG4gICAgJ3VuYm94JzogW1wiKCk6IG51bWJlclwiLCBgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzWydqYXZhL2xhbmcvSW50ZWdlci92YWx1ZSddOyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvTG9uZzsnOiB7XG4gICAgJ3VuYm94JzogW1wiKCk6IExvbmdcIiwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpc1snamF2YS9sYW5nL0xvbmcvdmFsdWUnXTsgfWBdXG4gIH0sXG4gICdMamF2YS9sYW5nL1Nob3J0Oyc6IHtcbiAgICAndW5ib3gnOiBbXCIoKTogbnVtYmVyXCIsIGBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXNbJ2phdmEvbGFuZy9TaG9ydC92YWx1ZSddOyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvQm9vbGVhbjsnOiB7XG4gICAgJ3VuYm94JzogW1wiKCk6IG51bWJlclwiLCBgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzWydqYXZhL2xhbmcvQm9vbGVhbi92YWx1ZSddOyB9YF1cbiAgfSxcbiAgLy8gVG8gY2F0Y2ggYW55IGVycm9ycy4gU2hvdWxkIG5ldmVyIGFjdHVhbGx5IGhhcHBlbjsgVm9pZHMgZG9uJ3Qgc2hvdyB1cCBpbiBhcmcgbGlzdHMuXG4gICdMamF2YS9sYW5nL1ZvaWQ7Jzoge1xuICAgICd1bmJveCc6IFtcIigpOiBudW1iZXJcIiwgYGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdW5ib3ggYSBWb2lkIHR5cGUuXCIpOyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvaW52b2tlL01ldGhvZFR5cGU7Jzoge1xuICAgICd0b1N0cmluZyc6IFtcIigpOiBzdHJpbmdcIiwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIoXCIgKyB0aGlzWydqYXZhL2xhbmcvaW52b2tlL01ldGhvZFR5cGUvcHR5cGVzJ10uYXJyYXkubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLiRjbHMuZ2V0SW50ZXJuYWxOYW1lKCk7IH0pLmpvaW4oXCJcIikgKyBcIilcIiArIHRoaXNbJ2phdmEvbGFuZy9pbnZva2UvTWV0aG9kVHlwZS9ydHlwZSddLiRjbHMuZ2V0SW50ZXJuYWxOYW1lKCk7IH1gXVxuICB9XG59O1xuXG4vKipcbiAqIFNhbWUgYXMgaW5qZWN0ZWQgbWV0aG9kcywgYnV0IHRoZXNlIGFyZSBzdGF0aWMuXG4gKi9cbnZhciBpbmplY3RlZFN0YXRpY01ldGhvZHM6IHtbY2xhc3NOYW1lOiBzdHJpbmddOiB7W21ldGhvZE5hbWU6IHN0cmluZ106IFtzdHJpbmcsIHN0cmluZ119fSA9IHtcbiAgJ0xqYXZhL2xhbmcvQnl0ZTsnOiB7XG4gICAgJ2JveCc6IFtcIih2YWw6IG51bWJlcik6IGphdmFfbGFuZ19CeXRlXCIsIGBmdW5jdGlvbih2YWwpIHsgdmFyIHJ2ID0gbmV3IHRoaXMobnVsbCk7IHJ2WydqYXZhL2xhbmcvQnl0ZS92YWx1ZSddID0gdmFsOyByZXR1cm4gcnY7IH1gXVxuICB9LFxuICAnTGphdmEvbGFuZy9DaGFyYWN0ZXI7Jzoge1xuICAgICdib3gnOiBbXCIodmFsOiBudW1iZXIpOiBqYXZhX2xhbmdfQ2hhcmFjdGVyXCIsIGBmdW5jdGlvbih2YWwpIHsgdmFyIHJ2ID0gbmV3IHRoaXMobnVsbCk7IHJ2WydqYXZhL2xhbmcvQ2hhcmFjdGVyL3ZhbHVlJ10gPSB2YWw7IHJldHVybiBydjsgfWBdXG4gIH0sXG4gICdMamF2YS9sYW5nL0RvdWJsZTsnOiB7XG4gICAgJ2JveCc6IFtcIih2YWw6IG51bWJlcik6IGphdmFfbGFuZ19Eb3VibGVcIiwgYGZ1bmN0aW9uKHZhbCkgeyB2YXIgcnYgPSBuZXcgdGhpcyhudWxsKTsgcnZbJ2phdmEvbGFuZy9Eb3VibGUvdmFsdWUnXSA9IHZhbDsgcmV0dXJuIHJ2OyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvRmxvYXQ7Jzoge1xuICAgICdib3gnOiBbXCIodmFsOiBudW1iZXIpOiBqYXZhX2xhbmdfRmxvYXRcIiwgYGZ1bmN0aW9uKHZhbCkgeyB2YXIgcnYgPSBuZXcgdGhpcyhudWxsKTsgcnZbJ2phdmEvbGFuZy9GbG9hdC92YWx1ZSddID0gdmFsOyByZXR1cm4gcnY7IH1gXVxuICB9LFxuICAnTGphdmEvbGFuZy9JbnRlZ2VyOyc6IHtcbiAgICAnYm94JzogW1wiKHZhbDogbnVtYmVyKTogamF2YV9sYW5nX0ludGVnZXJcIiwgYGZ1bmN0aW9uKHZhbCkgeyB2YXIgcnYgPSBuZXcgdGhpcyhudWxsKTsgcnZbJ2phdmEvbGFuZy9JbnRlZ2VyL3ZhbHVlJ10gPSB2YWw7IHJldHVybiBydjsgfWBdXG4gIH0sXG4gICdMamF2YS9sYW5nL0xvbmc7Jzoge1xuICAgICdib3gnOiBbXCIodmFsOiBMb25nKTogamF2YV9sYW5nX0xvbmdcIiwgYGZ1bmN0aW9uKHZhbCkgeyB2YXIgcnYgPSBuZXcgdGhpcyhudWxsKTsgcnZbJ2phdmEvbGFuZy9Mb25nL3ZhbHVlJ10gPSB2YWw7IHJldHVybiBydjsgfWBdXG4gIH0sXG4gICdMamF2YS9sYW5nL1Nob3J0Oyc6IHtcbiAgICAnYm94JzogW1wiKHZhbDogbnVtYmVyKTogamF2YV9sYW5nX1Nob3J0XCIsIGBmdW5jdGlvbih2YWwpIHsgdmFyIHJ2ID0gbmV3IHRoaXMobnVsbCk7IHJ2WydqYXZhL2xhbmcvU2hvcnQvdmFsdWUnXSA9IHZhbDsgcmV0dXJuIHJ2OyB9YF1cbiAgfSxcbiAgJ0xqYXZhL2xhbmcvQm9vbGVhbjsnOiB7XG4gICAgJ2JveCc6IFtcIih2YWw6IG51bWJlcik6IGphdmFfbGFuZ19Cb29sZWFuXCIsIGBmdW5jdGlvbih2YWwpIHsgdmFyIHJ2ID0gbmV3IHRoaXMobnVsbCk7IHJ2WydqYXZhL2xhbmcvQm9vbGVhbi92YWx1ZSddID0gdmFsOyByZXR1cm4gcnY7IH1gXVxuICB9LFxuICAnTGphdmEvbGFuZy9Wb2lkOyc6IHtcbiAgICAnYm94JzogW1wiKCk6IGphdmFfbGFuZ19Wb2lkXCIsIGBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyB0aGlzKG51bGwpOyB9YF1cbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBJSlZNQ29uc3RydWN0b3I8VCBleHRlbmRzIEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgb2JqZWN0IGluIHRoZSBzYW1lIG1hbm5lciBhcyB0aGUgSlZNJ3MgXCJuZXdcIiBvcGNvZGUuXG4gICAqIERvZXMgKk5PVCogcnVuIHRoZSBKVk0gY29uc3RydWN0b3IhXG4gICAqIEBwYXJhbSBqdm0gVGhlIHRocmVhZCB0aGF0IGlzIGNvbnN0cnVjdGluZyB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gbGVuZ3Rocy4uLiBJZiB0aGlzIGlzIGFuIGFycmF5IHR5cGUsIHRoZSBsZW5ndGggb2YgZWFjaCBkaW1lbnNpb24gb2YgdGhlIGFycmF5LiAoUmVxdWlyZWQgaWYgYW4gYXJyYXkgdHlwZS4pXG4gICAqL1xuICBuZXcodGhyZWFkOiBKVk1UaHJlYWQsIGxlbmd0aHM/OiBudW1iZXJbXSB8IG51bWJlcik6IFQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBhIEpWTSBjbGFzcyBieSBtYWtpbmcgaXRzIHByb3RvdHlwZSBhIGJsYW5rIGluc3RhbnRpYXRpb24gb2YgYW5cbiAqIG9iamVjdCB3aXRoIHRoZSBzdXBlciBjbGFzcydzIHByb3RvdHlwZSBhcyBpdHMgcHJvdG90eXBlLiBJbnNwaXJlZCBmcm9tXG4gKiBUeXBlU2NyaXB0J3MgX19leHRlbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZENsYXNzKGNsczogYW55LCBzdXBlckNsczogYW55KSB7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2xzOyB9XG4gIF9fLnByb3RvdHlwZSA9IHN1cGVyQ2xzLnByb3RvdHlwZTtcbiAgY2xzLnByb3RvdHlwZSA9IG5ldyAoPGFueT4gX18pKCk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBjbGFzcyBpbiB0aGUgSlZNLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xhc3NEYXRhIHtcbiAgcHJvdGVjdGVkIGxvYWRlcjogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXI7XG4gIHB1YmxpYyBhY2Nlc3NGbGFnczogdXRpbC5GbGFncyA9IG51bGw7XG4gIC8qKlxuICAgKiBXZSBtYWtlIHRoaXMgcHJpdmF0ZSB0byAqZW5mb3JjZSogY2FsbCBzaXRlcyB0byB1c2Ugb3VyIGdldHRlciBmdW5jdGlvbnMuXG4gICAqIFRoZSBhY3R1YWwgc3RhdGUgb2YgdGhpcyBjbGFzcyBkZXBlbmRzIG9uIHRoZSBzdGF0ZSBvZiBpdHMgcGFyZW50cywgYW5kXG4gICAqIHBhcmVudHMgZG8gbm90IGluZm9ybSB0aGVpciBjaGlsZHJlbiB3aGVuIHRoZXkgY2hhbmdlIHN0YXRlLlxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0ZTogZW51bXMuQ2xhc3NTdGF0ZSA9IGVudW1zLkNsYXNzU3RhdGUuTE9BREVEO1xuICBwcml2YXRlIGpjbzogSlZNVHlwZXMuamF2YV9sYW5nX0NsYXNzID0gbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBjbGFzcydzIGNhbm9uaWNhbCBuYW1lLCBpbiBpbnRlcm5hbCBmb3JtLlxuICAgKiBMamF2YS9sYW5nL0ZvbztcbiAgICovXG4gIHByb3RlY3RlZCBjbGFzc05hbWU6IHN0cmluZztcbiAgcHJvdGVjdGVkIHN1cGVyQ2xhc3M6IFJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlc3BvbnNpYmxlIGZvciBzZXR0aW5nIHVwIGFsbCBvZiB0aGUgZmllbGRzIHRoYXQgYXJlIGd1YXJhbnRlZWQgdG8gYmVcbiAgICogcHJlc2VudCBvbiBhbnkgQ2xhc3NEYXRhIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvYWRlcjogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIpIHtcbiAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVybmFsIGZvcm0gb2YgdGhpcyBjbGFzcydzIG5hbWUgKGUuZy4gamF2YS5sYW5nLlN0cmluZykuXG4gICAqL1xuICBwdWJsaWMgZ2V0RXh0ZXJuYWxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHV0aWwuZXh0X2NsYXNzbmFtZSh0aGlzLmNsYXNzTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcm5hbCBmb3JtIG9mIHRoaXMgY2xhc3MncyBuYW1lIChlLmcuIExqYXZhL2xhbmcvU3RyaW5nOykuXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJuYWxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0aGF0IHRoaXMgY2xhc3MgYmVsb25ncyB0byAoZS5nLiBqYXZhLmxhbmcpLlxuICAgKi9cbiAgcHVibGljIGdldFBhY2thZ2VOYW1lKCk6IHN0cmluZyB7XG4gICAgdmFyIGV4dE5hbWUgPSB0aGlzLmdldEV4dGVybmFsTmFtZSgpLCBpOiBudW1iZXI7XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgJy4nIGluIHRoZSBuYW1lLlxuICAgIGZvciAoaSA9IGV4dE5hbWUubGVuZ3RoIC0gMTsgaSA+PSAwICYmIGV4dE5hbWVbaV0gIT09ICcuJzsgaS0tKSB7fVxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHJldHVybiBleHROYW1lLnNsaWNlKDAsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ2xhc3NMb2FkZXIgb2JqZWN0IG9mIHRoZSBjbGFzc2xvYWRlciB0aGF0IGluaXRpYWxpemVkIHRoaXNcbiAgICogY2xhc3MuIFJldHVybnMgbnVsbCBmb3IgdGhlIGRlZmF1bHQgY2xhc3Nsb2FkZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9hZGVyKCk6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjbGFzcydzIHN1cGVyIGNsYXNzLCB3aGljaCBpcyBhbHdheXMgZ29pbmcgdG8gYmUgYSByZWZlcmVuY2VcbiAgICogY2xhc3MuXG4gICAqL1xuICBwdWJsaWMgZ2V0U3VwZXJDbGFzcygpOiBSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4ge1xuICAgIHJldHVybiB0aGlzLnN1cGVyQ2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBvZiB0aGUgaW50ZXJmYWNlcyB0aGF0IHRoZSBjbGFzcyBpbXBsZW1lbnRzLlxuICAgKi9cbiAgcHVibGljIGdldEludGVyZmFjZXMoKTogUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+W10ge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIG9mIHRoZSBpbmplY3RlZCBmaWVsZHMgZm9yIHRoaXMgY2xhc3MuIFRoZSB2YWx1ZSBmb3IgZWFjaCBmaWVsZFxuICAgKiBpbiB0aGUgcmV0dXJuZWQgbWFwIGlzIGl0cyB0eXBlLlxuICAgKi9cbiAgcHVibGljIGdldEluamVjdGVkRmllbGRzKCk6IHsgW2ZpZWxkTmFtZTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgIHZhciBydjogeyBbZmllbGROYW1lOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgIGlmIChpbmplY3RlZEZpZWxkc1t0aGlzLmdldEludGVybmFsTmFtZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmllbGRzID0gaW5qZWN0ZWRGaWVsZHNbdGhpcy5nZXRJbnRlcm5hbE5hbWUoKV07XG4gICAgICBPYmplY3Qua2V5cyhmaWVsZHMpLmZvckVhY2goKGZpZWxkTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJ2W2ZpZWxkTmFtZV0gPSBmaWVsZHNbZmllbGROYW1lXVswXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBvZiB0aGUgaW5qZWN0ZWQgbWV0aG9kcyBmb3IgdGhpcyBjbGFzcy4gVGhlIHZhbHVlIGZvciBlYWNoIG1ldGhvZFxuICAgKiBpbiB0aGUgcmV0dXJuZWQgbWFwIGlzIGl0cyB0eXBlLlxuICAgKi9cbiAgcHVibGljIGdldEluamVjdGVkTWV0aG9kcygpOiB7IFttZXRob2ROYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgdmFyIHJ2OiB7IFttZXRob2ROYW1lOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LFxuICAgICAgbG9va3VwTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxOYW1lKCk7XG4gICAgLy8gQWxsIGFycmF5IGNsYXNzZXMgc2hhcmUgdGhlIHNhbWUgaW5qZWN0ZWQgbWV0aG9kcy5cbiAgICBpZiAobG9va3VwTmFtZVswXSA9PT0gJ1snKSB7XG4gICAgICBsb29rdXBOYW1lID0gJ1snO1xuICAgIH1cblxuICAgIGlmIChpbmplY3RlZE1ldGhvZHNbbG9va3VwTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIG1ldGhvZHMgPSBpbmplY3RlZE1ldGhvZHNbbG9va3VwTmFtZV07XG4gICAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKChtZXRob2ROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcnZbbWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdWzBdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIG9mIHRoZSBpbmplY3RlZCBzdGF0aWMgbWV0aG9kcyBmb3IgdGhpcyBjbGFzcy4gVGhlIHZhbHVlIGZvciBlYWNoXG4gICAqIG1ldGhvZCBpbiB0aGUgcmV0dXJuZWQgbWFwIGlzIGl0cyB0eXBlLlxuICAgKi9cbiAgcHVibGljIGdldEluamVjdGVkU3RhdGljTWV0aG9kcygpOiB7IFttZXRob2ROYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB7XG4gICAgdmFyIHJ2OiB7IFttZXRob2ROYW1lOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9LFxuICAgICAgbG9va3VwTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxOYW1lKCk7XG4gICAgLy8gQWxsIGFycmF5IGNsYXNzZXMgc2hhcmUgdGhlIHNhbWUgaW5qZWN0ZWQgbWV0aG9kcy5cbiAgICBpZiAobG9va3VwTmFtZVswXSA9PT0gJ1snKSB7XG4gICAgICBsb29rdXBOYW1lID0gJ1snO1xuICAgIH1cblxuICAgIGlmIChpbmplY3RlZFN0YXRpY01ldGhvZHNbbG9va3VwTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIG1ldGhvZHMgPSBpbmplY3RlZFN0YXRpY01ldGhvZHNbbG9va3VwTmFtZV07XG4gICAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKChtZXRob2ROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcnZbbWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdWzBdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBqYXZhLmxhbmcuQ2xhc3Mgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyBnZXRDbGFzc09iamVjdCh0aHJlYWQ6IEpWTVRocmVhZCk6IEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzcyB7XG4gICAgaWYgKHRoaXMuamNvID09PSBudWxsKSB7XG4gICAgICB0aGlzLmpjbyA9IG5ldyAoKDxSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX0NsYXNzPj4gdGhyZWFkLmdldEJzQ2woKS5nZXRSZXNvbHZlZENsYXNzKCdMamF2YS9sYW5nL0NsYXNzOycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKSh0aHJlYWQpO1xuICAgICAgdGhpcy5qY28uJGNscyA9IHRoaXM7XG4gICAgICB0aGlzLmpjb1snamF2YS9sYW5nL0NsYXNzL2NsYXNzTG9hZGVyJ10gPSB0aGlzLmdldExvYWRlcigpLmdldExvYWRlck9iamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5qY287XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcm90ZWN0aW9uIGRvbWFpbiBvZiB0aGlzIGNsYXNzLlxuICAgKiBUaGlzIHZhbHVlIGlzIE5VTEwgZm9yIGFsbCBidXQgcmVmZXJlbmNlIGNsYXNzZXMgbG9hZGVkIGJ5IGFwcCBjbGFzc2xvYWRlcnMuXG4gICAqL1xuICBwdWJsaWMgZ2V0UHJvdGVjdGlvbkRvbWFpbigpOiBKVk1UeXBlcy5qYXZhX3NlY3VyaXR5X1Byb3RlY3Rpb25Eb21haW4ge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbWV0aG9kIGRlZmluZWQgaW4gdGhpcyBwYXJ0aWN1bGFyIGNsYXNzIGJ5IHRoZSBnaXZlbiBtZXRob2RcbiAgICogc2lnbmF0dXJlICp3aXRob3V0KiBpbnZva2luZyBtZXRob2QgbG9va3VwLlxuICAgKiBAcGFyYW0gbWV0aG9kU2lnbmF0dXJlIFRoZSBtZXRob2QncyBmdWxsIHNpZ25hdHVyZSwgZS5nLiA8Y2xpbml0PigpVlxuICAgKi9cbiAgcHVibGljIGdldE1ldGhvZChtZXRob2RTaWduYXR1cmU6IHN0cmluZyk6IG1ldGhvZHMuTWV0aG9kIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhbGwgb2YgdGhlIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGlzIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIGdldE1ldGhvZHMoKTogbWV0aG9kcy5NZXRob2RbXSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBzZXQgb2YgZmllbGRzIGRlZmluZWQgb24gdGhpcyBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyBnZXRGaWVsZHMoKTogbWV0aG9kcy5GaWVsZFtdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBzeW5jaHJvbm91c2x5IHJlc29sdmUgdGhpcyBjbGFzcyB1c2luZyBpdHMgbG9hZGVyLiBTaG91bGQgb25seVxuICAgKiBiZSBjYWxsZWQgb24gQ2xhc3NEYXRhIGluIHRoZSBMT0FERUQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgdHJ5VG9SZXNvbHZlKCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc3luY2hyb25vdXNseSBpbml0aWFsaXplIHRoaXMgY2xhc3MuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgdHJ5VG9Jbml0aWFsaXplKCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgdGhpcyBwYXJ0aWN1bGFyIGNsYXNzIHRvIExPQURFRC9SRVNPTFZFRC9JTklUSUFMSVpFRC5cbiAgICovXG4gIHB1YmxpYyBzZXRTdGF0ZShzdGF0ZTogZW51bXMuQ2xhc3NTdGF0ZSk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY2xhc3MuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0U3RhdGUoKTogZW51bXMuQ2xhc3NTdGF0ZSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENsYXNzU3RhdGUuUkVTT0xWRUQgJiYgdGhpcy5nZXRNZXRob2QoJzxjbGluaXQ+KClWJykgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIGNhbiBwcm9tb3RlIHRvIElOSVRJQUxJWkVEIGlmIHRoaXMgY2xhc3MgaGFzIG5vIHN0YXRpYyBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIGFuZCBpdHMgcGFyZW50IGNsYXNzIGlzIGluaXRpYWxpemVkLlxuICAgICAgdmFyIHNjbHMgPSB0aGlzLmdldFN1cGVyQ2xhc3MoKTtcbiAgICAgIGlmIChzY2xzICE9PSBudWxsICYmIHNjbHMuZ2V0U3RhdGUoKSA9PT0gQ2xhc3NTdGF0ZS5JTklUSUFMSVpFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gQ2xhc3NTdGF0ZS5JTklUSUFMSVpFRDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGNsYXNzIGlzIGluaXRpYWxpemVkLlxuICAgKiBAcGFyYW0gdGhyZWFkIFRoZSB0aHJlYWQgdGhhdCBpcyBwZXJmb3JtaW5nIHRoZSBjaGVjay4gSWYgaW5pdGlhbGl6YXRpb25cbiAgICogICBpcyBpbiBwcm9ncmVzcyBvbiB0aGF0IHRocmVhZCwgdGhlbiB0aGUgY2xhc3MgaXMsIGZvciBhbGwgaW50ZW50cyBhbmRcbiAgICogICBwdXJwb3NlcywgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBwdWJsaWMgaXNJbml0aWFsaXplZCh0aHJlYWQ6IEpWTVRocmVhZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCkgPT09IENsYXNzU3RhdGUuSU5JVElBTElaRUQ7XG4gIH1cbiAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24uXG4gIHB1YmxpYyBpc1Jlc29sdmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpICE9PSBDbGFzc1N0YXRlLkxPQURFRDsgfVxuXG4gIHB1YmxpYyBpc1N1YmludGVyZmFjZSh0YXJnZXQ6IENsYXNzRGF0YSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBpc1N1YmNsYXNzKHRhcmdldDogQ2xhc3NEYXRhKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldFN1cGVyQ2xhc3MoKSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdXBlckNsYXNzKCkuaXNTdWJjbGFzcyh0YXJnZXQpO1xuICB9XG5cbiAgcHVibGljIGFic3RyYWN0IGlzQ2FzdGFibGUodGFyZ2V0OiBDbGFzc0RhdGEpOiBib29sZWFuO1xuXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogSlZNVGhyZWFkLCBjYjogKGNkYXRhOiBDbGFzc0RhdGEpID0+IHZvaWQsIGV4cGxpY2l0OiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuaW1wbGVtZW50ZWQuXCIpO1xuICB9XG5cbiAgcHVibGljIGluaXRpYWxpemUodGhyZWFkOiBKVk1UaHJlYWQsIGNiOiAoY2RhdGE6IENsYXNzRGF0YSkgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZC5cIik7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3V0cHV0SW5qZWN0ZWRNZXRob2RzKGpzQ2xhc3NOYW1lOiBzdHJpbmcsIG91dHB1dFN0cmVhbTogU3RyaW5nT3V0cHV0U3RyZWFtKSB7XG4gICAgdmFyIGxvb2t1cE5hbWUgPSB0aGlzLmdldEludGVybmFsTmFtZSgpO1xuICAgIGlmIChsb29rdXBOYW1lWzBdID09PSAnWycpIHtcbiAgICAgIGxvb2t1cE5hbWUgPSAnWyc7XG4gICAgfVxuICAgIGlmIChpbmplY3RlZE1ldGhvZHNbbG9va3VwTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIG1ldGhvZHMgPSBpbmplY3RlZE1ldGhvZHNbbG9va3VwTmFtZV07XG4gICAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKChtZXRob2ROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKGAgICR7anNDbGFzc05hbWV9LnByb3RvdHlwZS4ke21ldGhvZE5hbWV9ID0gJHttZXRob2RzW21ldGhvZE5hbWVdWzFdfTtcXG5gKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpbmplY3RlZFN0YXRpY01ldGhvZHNbbG9va3VwTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHN0YXRpY01ldGhvZHMgPSBpbmplY3RlZFN0YXRpY01ldGhvZHNbbG9va3VwTmFtZV07XG4gICAgICBPYmplY3Qua2V5cyhzdGF0aWNNZXRob2RzKS5mb3JFYWNoKChtZXRob2ROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKGAgICR7anNDbGFzc05hbWV9LiR7bWV0aG9kTmFtZX0gPSAke3N0YXRpY01ldGhvZHNbbWV0aG9kTmFtZV1bMV19O1xcbmApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcmltaXRpdmVDbGFzc0RhdGEgZXh0ZW5kcyBDbGFzc0RhdGEge1xuICBjb25zdHJ1Y3RvcihjbGFzc05hbWU6IHN0cmluZywgbG9hZGVyOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlcikge1xuICAgIHN1cGVyKGxvYWRlcik7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgLy8gUHJpbWl0aXZlQ2xhc3NEYXRhIG9iamVjdHMgYXJlIEFCU1RSQUNULCBGSU5BTCwgYW5kIFBVQkxJQy5cbiAgICB0aGlzLmFjY2Vzc0ZsYWdzID0gbmV3IHV0aWwuRmxhZ3MoMHg0MTEpO1xuICAgIHRoaXMuc2V0U3RhdGUoQ2xhc3NTdGF0ZS5JTklUSUFMSVpFRCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGNsYXNzIGlzIGFuIGluc3RhbmNlIG9mIHRoZSB0YXJnZXQgY2xhc3MuXG4gICAqIFwidGFyZ2V0XCIgaXMgYSBDbGFzc0RhdGEgb2JqZWN0LlxuICAgKiBUaGUgQ2xhc3NEYXRhIG9iamVjdHMgZG8gbm90IG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQ7IGp1c3QgbG9hZGVkLlxuICAgKi9cbiAgcHVibGljIGlzQ2FzdGFibGUodGFyZ2V0OiBDbGFzc0RhdGEpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgPT09IHRhcmdldC5nZXRJbnRlcm5hbE5hbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbGFzcyBuYW1lIGZvciB0aGUgY29ycmVzcG9uZGluZyBib3hlZCB0eXBlLlxuICAgKi9cbiAgcHVibGljIGJveENsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB1dGlsLmJveENsYXNzTmFtZSh0aGlzLmNsYXNzTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJveGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHByaW1pdGl2ZS5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVXcmFwcGVyT2JqZWN0KHRocmVhZDogSlZNVGhyZWFkLCB2YWx1ZTogYW55KTogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCB7XG4gICAgdmFyIGJveE5hbWUgPSB0aGlzLmJveENsYXNzTmFtZSgpO1xuICAgIHZhciBib3hDbHMgPSA8UmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiB0aHJlYWQuZ2V0QnNDbCgpLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCBib3hOYW1lKTtcbiAgICAvLyB0aGVzZSBhcmUgYWxsIGluaXRpYWxpemVkIGluIHByZWluaXQgKGZvciB0aGUgQlNDTCwgYXQgbGVhc3QpXG4gICAgdmFyIGJveENvbnMgPSBib3hDbHMuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcbiAgICB2YXIgd3JhcHBlZCA9IG5ldyBib3hDb25zKHRocmVhZCk7XG4gICAgaWYgKGJveE5hbWUgIT09ICdWJykge1xuICAgICAgLy8gWFhYOiBhbGwgcHJpbWl0aXZlIHdyYXBwZXJzIHN0b3JlIHRoZWlyIHZhbHVlIGluIGEgcHJpdmF0ZSBzdGF0aWMgZmluYWwgZmllbGQgbmFtZWQgJ3ZhbHVlJ1xuICAgICAgKDxhbnk+IHdyYXBwZWQpW3V0aWwuZGVzY3JpcHRvcjJ0eXBlc3RyKGJveE5hbWUpICsgJy92YWx1ZSddID0gdmFsdWU7XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHZhbHVlLmxvd18gPT09IFwibnVtYmVyXCIsIGBJbnZhbGlkIHByaW1pdGl2ZSB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG4gIH1cblxuICBwdWJsaWMgdHJ5VG9SZXNvbHZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHRyeVRvSW5pdGlhbGl6ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmltaXRpdmUgY2xhc3NlcyBhcmUgYWxyZWFkeSByZXNvbHZlZC5cbiAgICovXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogSlZNVGhyZWFkLCBjYjogKGNkYXRhOiBDbGFzc0RhdGEpID0+IHZvaWQsIGV4cGxpY2l0OiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiBjYih0aGlzKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFycmF5Q2xhc3NEYXRhPFQ+IGV4dGVuZHMgQ2xhc3NEYXRhIHtcbiAgcHJpdmF0ZSBjb21wb25lbnRDbGFzc05hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSBjb21wb25lbnRDbGFzczogQ2xhc3NEYXRhO1xuICBwcml2YXRlIF9jb25zdHJ1Y3RvcjogSUpWTUNvbnN0cnVjdG9yPEpWTVR5cGVzLkpWTUFycmF5PFQ+PiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29tcG9uZW50VHlwZTogc3RyaW5nLCBsb2FkZXI6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyKSB7XG4gICAgc3VwZXIobG9hZGVyKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGBbJHtjb21wb25lbnRUeXBlfWA7XG4gICAgLy8gQXJyYXlDbGFzc0RhdGEgb2JqZWN0cyBhcmUgQUJTVFJBQ1QsIEZJTkFMLCBhbmQgUFVCTElDLlxuICAgIHRoaXMuYWNjZXNzRmxhZ3MgPSBuZXcgdXRpbC5GbGFncygweDQxMSk7XG4gICAgdGhpcy5jb21wb25lbnRDbGFzc05hbWUgPSBjb21wb25lbnRUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIHNpZ25hdHVyZS4gUmV0dXJucyBudWxsIGlmIG5vIG1ldGhvZFxuICAgKiBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyBtZXRob2RMb29rdXAoc2lnbmF0dXJlOiBzdHJpbmcpOiBtZXRob2RzLk1ldGhvZCB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzcy5tZXRob2RMb29rdXAoc2lnbmF0dXJlKTtcbiAgfVxuXG4gIHB1YmxpYyBmaWVsZExvb2t1cChuYW1lOiBzdHJpbmcpOiBtZXRob2RzLkZpZWxkIHtcbiAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLmZpZWxkTG9va3VwKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgdGhlIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIHJlc29sdmUodGhyZWFkOiBKVk1UaHJlYWQsIGNiOiAoY2RhdGE6IENsYXNzRGF0YSkgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSZXNvbHZlZCgpKSB7XG4gICAgICAvLyBTaG9ydCBjaXJjdWl0LlxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNiKHRoaXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXRpbC5hc3luY0ZvckVhY2goW1wiTGphdmEvbGFuZy9PYmplY3Q7XCIsIHRoaXMuY29tcG9uZW50Q2xhc3NOYW1lXSwgKGNsczogc3RyaW5nLCBuZXh0SXRlbTogKGVycj86IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgdGhpcy5sb2FkZXIucmVzb2x2ZUNsYXNzKHRocmVhZCwgY2xzLCAoY2RhdGE6IENsYXNzRGF0YSkgPT4ge1xuICAgICAgICBpZiAoY2RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0SXRlbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRJdGVtKFwiRmFpbGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgKGVycj86IGFueSkgPT4ge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvbHZlZCg8UmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiB0aGlzLmxvYWRlci5nZXRSZXNvbHZlZENsYXNzKFwiTGphdmEvbGFuZy9PYmplY3Q7XCIpLCB0aGlzLmxvYWRlci5nZXRSZXNvbHZlZENsYXNzKHRoaXMuY29tcG9uZW50Q2xhc3NOYW1lKSk7XG4gICAgICAgIGNiKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29tcG9uZW50Q2xhc3MoKTogQ2xhc3NEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRDbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlZCBhbmQgaW5pdGlhbGl6ZWQgYXJlIHRoZSBzYW1lIGZvciBhcnJheSB0eXBlcy5cbiAgICovXG4gIHB1YmxpYyBzZXRSZXNvbHZlZDxUIGV4dGVuZHMgSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4oc3VwZXJfY2xhc3NfY2RhdGE6IFJlZmVyZW5jZUNsYXNzRGF0YTxUPiwgY29tcG9uZW50X2NsYXNzX2NkYXRhOiBDbGFzc0RhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlcl9jbGFzc19jZGF0YTtcbiAgICB0aGlzLmNvbXBvbmVudENsYXNzID0gY29tcG9uZW50X2NsYXNzX2NkYXRhO1xuICAgIHRoaXMuc2V0U3RhdGUoQ2xhc3NTdGF0ZS5JTklUSUFMSVpFRCk7XG4gIH1cblxuICBwdWJsaWMgdHJ5VG9SZXNvbHZlKCk6IGJvb2xlYW4ge1xuICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcixcbiAgICAgIHN1cGVyQ2xhc3NDZGF0YSA9IDxSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4+IGxvYWRlci5nZXRSZXNvbHZlZENsYXNzKFwiTGphdmEvbGFuZy9PYmplY3Q7XCIpLFxuICAgICAgY29tcG9uZW50Q2xhc3NDZGF0YSA9IGxvYWRlci5nZXRSZXNvbHZlZENsYXNzKHRoaXMuY29tcG9uZW50Q2xhc3NOYW1lKTtcblxuICAgIGlmIChzdXBlckNsYXNzQ2RhdGEgPT09IG51bGwgfHwgY29tcG9uZW50Q2xhc3NDZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJlc29sdmVkKHN1cGVyQ2xhc3NDZGF0YSwgY29tcG9uZW50Q2xhc3NDZGF0YSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJ5VG9Jbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIC8vIEFycmF5cyBhcmUgaW5pdGlhbGl6ZWQgb25jZSByZXNvbHZlZC5cbiAgICByZXR1cm4gdGhpcy50cnlUb1Jlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgY2xhc3MgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRhcmdldCBjbGFzcy5cbiAgICogXCJ0YXJnZXRcIiBpcyBhIENsYXNzRGF0YSBvYmplY3QuXG4gICAqIFRoZSBDbGFzc0RhdGEgb2JqZWN0cyBkbyBub3QgbmVlZCB0byBiZSBpbml0aWFsaXplZDsganVzdCBsb2FkZWQuXG4gICAqIFNlZSDCpzIuNi43IGZvciBjYXN0aW5nIHJ1bGVzLlxuICAgKi9cbiAgcHVibGljIGlzQ2FzdGFibGUodGFyZ2V0OiBDbGFzc0RhdGEpOiBib29sZWFuIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheUNsYXNzRGF0YSkpIHtcbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBQcmltaXRpdmVDbGFzc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gTXVzdCBiZSBhIHJlZmVyZW5jZSB0eXBlLlxuICAgICAgaWYgKHRhcmdldC5hY2Nlc3NGbGFncy5pc0ludGVyZmFjZSgpKSB7XG4gICAgICAgIC8vIEludGVyZmFjZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICB2YXIgdHlwZSA9IHRhcmdldC5nZXRJbnRlcm5hbE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdMamF2YS9sYW5nL0Nsb25lYWJsZTsnIHx8IHR5cGUgPT09ICdMamF2YS9pby9TZXJpYWxpemFibGU7JztcbiAgICAgIH1cbiAgICAgIC8vIE5vbi1pbnRlcmZhY2UgcmVmZXJlbmNlIHR5cGVcbiAgICAgIHJldHVybiB0YXJnZXQuZ2V0SW50ZXJuYWxOYW1lKCkgPT09ICdMamF2YS9sYW5nL09iamVjdDsnO1xuICAgIH1cbiAgICAvLyBXZSBhcmUgYm90aCBhcnJheSB0eXBlcywgc28gaXQgb25seSBtYXR0ZXJzIGlmIG15IGNvbXBvbmVudCB0eXBlIGNhbiBiZVxuICAgIC8vIGNhc3QgdG8gaXRzIGNvbXBvbmVudCB0eXBlLlxuICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudENsYXNzKCkuaXNDYXN0YWJsZSgoPEFycmF5Q2xhc3NEYXRhPGFueT4+IHRhcmdldCkuZ2V0Q29tcG9uZW50Q2xhc3MoKSk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZSh0aHJlYWQ6IEpWTVRocmVhZCwgY2I6IChjZGF0YTogQ2xhc3NEYXRhKSA9PiB2b2lkLCBleHBsaWNpdDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLnJlc29sdmUodGhyZWFkLCBjYiwgZXhwbGljaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXJyYXkgY29uc3RydWN0b3IgZm9yIHRoaXMgcGFydGljdWxhciBKVk0gYXJyYXkgY2xhc3MuXG4gICAqIFVzZXMgdHlwZWQgYXJyYXlzIHdoZW4gYXZhaWxhYmxlIGZvciBwcmltaXRpdmUgYXJyYXlzLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRKU0FycmF5Q29uc3RydWN0b3IoKTogc3RyaW5nIHtcbiAgICBpZiAoIXV0aWwudHlwZWRBcnJheXNTdXBwb3J0ZWQpIHtcbiAgICAgIHJldHVybiAnQXJyYXknO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuY29tcG9uZW50Q2xhc3NOYW1lKSB7XG4gICAgICBjYXNlICdCJzpcbiAgICAgICAgcmV0dXJuICdJbnQ4QXJyYXknO1xuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIHJldHVybiAnVWludDE2QXJyYXknO1xuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIHJldHVybiAnSW50MTZBcnJheSc7XG4gICAgICBjYXNlICdJJzpcbiAgICAgICAgcmV0dXJuICdJbnQzMkFycmF5JztcbiAgICAgIGNhc2UgJ0YnOlxuICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgcmV0dXJuICdGbG9hdDY0QXJyYXknO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5pdGlhbCB2YWx1ZSBwbGFjZWQgaW50byBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIGdldEpTRGVmYXVsdEFycmF5RWxlbWVudCgpOiBzdHJpbmcge1xuICAgIHN3aXRjaCh0aGlzLmNvbXBvbmVudENsYXNzTmFtZVswXSkge1xuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBgbmV3IChjbHMuZ2V0Q29tcG9uZW50Q2xhc3MoKS5nZXRDb25zdHJ1Y3RvcigpKSh0aHJlYWQsIG90aGVyTGVuZ3RocylgO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgIGNhc2UgJ0onOlxuICAgICAgICByZXR1cm4gXCJnTG9uZ1plcm9cIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIjBcIjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNwZWNpYWxpemVkIGBzbGljZWAgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHNoYWxsb3cgc2xpY2Ugb2YgdGhpc1xuICAgKiBhcnJheS4gU3BlY2lhbGl6ZWQgdG8gdGhlIHR5cGUgb2YgYXJyYXkgKEpTIG9yIFR5cGVkKS5cbiAgICovXG4gIHByaXZhdGUgX2dldFNsaWNlTWV0aG9kKCk6IHN0cmluZyB7XG4gICAgdmFyIG91dHB1dCA9IG5ldyBTdHJpbmdPdXRwdXRTdHJlYW0oKSxcbiAgICAgIGpzQXJyQ29ucyA9IHRoaXMuZ2V0SlNBcnJheUNvbnN0cnVjdG9yKCk7XG4gICAgb3V0cHV0LndyaXRlKGBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIG5ld09iaiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG51bGwsIDApO1xcbmApO1xuICAgIGlmIChqc0FyckNvbnMgPT09ICdBcnJheScpIHtcbiAgICAgIG91dHB1dC53cml0ZShgICAgIG5ld09iai5hcnJheSA9IHRoaXMuYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCk7XFxuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbGVtZW50U2l6ZTogbnVtYmVyO1xuICAgICAgc3dpdGNoIChqc0FyckNvbnMpIHtcbiAgICAgICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICAgICAgICBlbGVtZW50U2l6ZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgICAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgICAgICAgZWxlbWVudFNpemUgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICAgICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICAgICAgICBlbGVtZW50U2l6ZSA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgICAgICAgZWxlbWVudFNpemUgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJJbGxlZ2FsIGFycmF5IHR5cGUgcmV0dXJuZWQ/P1wiKTtcbiAgICAgIH1cbiAgICAgIC8vIEFsdGhvdWdoIEFycmF5QnVmZmVyLnNsaWNlIGhhcyBhbiBvcHRpb25hbCBlbmQgYXJndW1lbnQsIHdlIG5lZWQgdG9cbiAgICAgIC8vIG11bHRpcGx5IGl0IGlmIGl0IGRvZXMgZXhpc3QuXG4gICAgICBvdXRwdXQud3JpdGUoYCAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMuYXJyYXkubGVuZ3RoO1xuICAgICAgJHtlbGVtZW50U2l6ZSA+IDEgPyBgc3RhcnQgKj0gJHtlbGVtZW50U2l6ZX07XFxuZW5kICo9ICR7ZWxlbWVudFNpemV9O2AgOiAnJ31cbiAgICAgIG5ld09iai5hcnJheSA9IG5ldyAke2pzQXJyQ29uc30odGhpcy5hcnJheS5idWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCkpO1xcbmApO1xuICAgIH1cbiAgICBvdXRwdXQud3JpdGUoYCAgICByZXR1cm4gbmV3T2JqO1xuICB9YCk7XG4gICAgcmV0dXJuIG91dHB1dC5mbHVzaCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29uc3RydWN0Q29uc3RydWN0b3IodGhyZWFkOiBKVk1UaHJlYWQpOiBJSlZNQ29uc3RydWN0b3I8SlZNVHlwZXMuSlZNQXJyYXk8VD4+IHtcbiAgICBhc3NlcnQodGhpcy5fY29uc3RydWN0b3IgPT09IG51bGwsIGBUcmllZCB0byBjb25zdHJ1Y3QgY29uc3RydWN0b3IgdHdpY2UgZm9yICR7dGhpcy5nZXRFeHRlcm5hbE5hbWUoKX0hYCk7XG4gICAgdmFyIG91dHB1dFN0cmVhbSA9IG5ldyBTdHJpbmdPdXRwdXRTdHJlYW0oKSxcbiAgICAgIGpzQ2xhc3NOYW1lID0gdXRpbC5qdm1OYW1lMkpTTmFtZSh0aGlzLmdldEludGVybmFsTmFtZSgpKTtcbiAgICBvdXRwdXRTdHJlYW0ud3JpdGUoYGZ1bmN0aW9uIF9jcmVhdGUoZXh0ZW5kQ2xhc3MsIGNscywgc3VwZXJDbHMsIGdMb25nWmVybywgdGhyZWFkKSB7XG4gIGV4dGVuZENsYXNzKCR7anNDbGFzc05hbWV9LCBzdXBlckNscy5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKTtcbiAgZnVuY3Rpb24gJHtqc0NsYXNzTmFtZX0odGhyZWFkLCBsZW5ndGhzKSB7XFxuYCk7XG4gICAgdGhpcy5zdXBlckNsYXNzLm91dHB1dEluamVjdGVkRmllbGRzKG91dHB1dFN0cmVhbSk7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcnJheS5cbiAgICBpZiAodGhpcy5jb21wb25lbnRDbGFzc05hbWVbMF0gIT09ICdbJykge1xuICAgICAgLy8gQXJyYXkgZWxlbWVudHMgYXJlIGEgbm9uLWFycmF5IHR5cGUuXG4gICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoYCAgICB0aGlzLmFycmF5ID0gbmV3ICR7dGhpcy5nZXRKU0FycmF5Q29uc3RydWN0b3IoKX0obGVuZ3Rocyk7XFxuYClcbiAgICAgIGlmICh0aGlzLmdldEpTQXJyYXlDb25zdHJ1Y3RvcigpID09PSAnQXJyYXknKSB7XG4gICAgICAgIC8vIFR5cGVkQXJyYXlzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkIHRvIDAsIHNvIHRoaXMgY2hlY2sgc2tpcHMgYXJyYXlcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gaW4gdGhhdCBjYXNlLlxuICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoYCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aHM7IGkrKykge1xuICAgICAgdGhpcy5hcnJheVtpXSA9ICR7dGhpcy5nZXRKU0RlZmF1bHRBcnJheUVsZW1lbnQoKX07XG4gICAgfVxcbmApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE11bHRpLWRpbWVuc2lvbmFsIGFycmF5LlxuICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKGAgICAgaWYgKHR5cGVvZiBsZW5ndGhzID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3ICR7dGhpcy5nZXRKU0FycmF5Q29uc3RydWN0b3IoKX0obGVuZ3Rocyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFycmF5W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxlbmd0aHNbMF0sIG90aGVyTGVuZ3RocyA9IGxlbmd0aHMubGVuZ3RoID4gMiA/IGxlbmd0aHMuc2xpY2UoMSkgOiBsZW5ndGhzWzFdO1xuICAgICAgICB0aGlzLmFycmF5ID0gbmV3ICR7dGhpcy5nZXRKU0FycmF5Q29uc3RydWN0b3IoKX0obGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXJyYXlbaV0gPSAke3RoaXMuZ2V0SlNEZWZhdWx0QXJyYXlFbGVtZW50KCl9O1xuICAgICAgICB9XG4gICAgICB9XFxuYClcbiAgICB9XG4gICAgb3V0cHV0U3RyZWFtLndyaXRlKGAgIH1cblxuICAke2pzQ2xhc3NOYW1lfS5wcm90b3R5cGUuc2xpY2UgPSAke3RoaXMuX2dldFNsaWNlTWV0aG9kKCl9O1xuICAke2pzQ2xhc3NOYW1lfS5jbHMgPSBjbHM7XFxuYCk7XG4gICAgdGhpcy5vdXRwdXRJbmplY3RlZE1ldGhvZHMoanNDbGFzc05hbWUsIG91dHB1dFN0cmVhbSk7XG4gICAgb3V0cHV0U3RyZWFtLndyaXRlKGBcbiAgcmV0dXJuICR7anNDbGFzc05hbWV9O1xufVxuLy8gTGFzdCBzdGF0ZW1lbnQgaXMgcmV0dXJuIHZhbHVlIG9mIGV2YWwuXG5fY3JlYXRlYCk7XG4gICAgLy8gQWxsIGFycmF5cyBleHRlbmQgamF2YS9sYW5nL09iamVjdFxuICAgIHJldHVybiBldmFsKG91dHB1dFN0cmVhbS5mbHVzaCgpKShleHRlbmRDbGFzcywgdGhpcywgdGhpcy5zdXBlckNsYXNzLCBnTG9uZy5aRVJPLCB0aHJlYWQpO1xuICB9XG5cbiAgcHVibGljIGdldENvbnN0cnVjdG9yKHRocmVhZDogSlZNVGhyZWFkKTogSUpWTUNvbnN0cnVjdG9yPEpWTVR5cGVzLkpWTUFycmF5PFQ+PiB7XG4gICAgYXNzZXJ0KHRoaXMuaXNSZXNvbHZlZCgpLCBgVHJpZWQgdG8gZ2V0IGNvbnN0cnVjdG9yIGZvciBjbGFzcyAke3RoaXMuZ2V0SW50ZXJuYWxOYW1lKCl9IGJlZm9yZSBpdCB3YXMgcmVzb2x2ZWQuYCk7XG4gICAgaWYgKHRoaXMuX2NvbnN0cnVjdG9yID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9jb25zdHJ1Y3RvciA9IHRoaXMuX2NvbnN0cnVjdENvbnN0cnVjdG9yKHRocmVhZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RvcjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBcInJlZmVyZW5jZVwiIENsYXNzIC0tIHRoYXQgaXMsIGEgY2xhc3MgdGhhdCBuZWl0aGVyIHJlcHJlc2VudHMgYVxuICogcHJpbWl0aXZlIG5vciBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlZmVyZW5jZUNsYXNzRGF0YTxUIGV4dGVuZHMgSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4gZXh0ZW5kcyBDbGFzc0RhdGEge1xuICBwcml2YXRlIG1pbm9yVmVyc2lvbjogbnVtYmVyO1xuICBwdWJsaWMgbWFqb3JWZXJzaW9uOiBudW1iZXI7XG4gIHB1YmxpYyBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2w7XG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGZpZWxkcyBkaXJlY3RseSBkZWZpbmVkIGJ5IHRoaXMgY2xhc3MuXG4gICAqL1xuICBwcml2YXRlIGZpZWxkczogbWV0aG9kcy5GaWVsZFtdO1xuICAvKipcbiAgICogQWxsIG9mIHRoZSBtZXRob2RzIGRpcmVjdGx5IGRlZmluZWQgYnkgdGhpcyBjbGFzcy5cbiAgICovXG4gIHByaXZhdGUgbWV0aG9kczogbWV0aG9kcy5NZXRob2RbXTtcbiAgcHJpdmF0ZSBhdHRyczogYXR0cmlidXRlcy5JQXR0cmlidXRlW107XG4gIHByaXZhdGUgaW50ZXJmYWNlQ2xhc3NlczogUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+W10gPSBudWxsO1xuICBwcml2YXRlIHN1cGVyQ2xhc3NSZWY6IENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZSA9IG51bGw7XG4gIHByaXZhdGUgaW50ZXJmYWNlUmVmczogQ29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlW107XG4gIC8qKlxuICAgKiBJbml0aWFsaXphdGlvbiBsb2NrLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0TG9jazogQ2xhc3NMb2NrID0gbmV3IENsYXNzTG9jaygpO1xuICAvKipcbiAgICogU3RvcmVzIHRoZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIGZvciB0aGlzIGNsYXNzLlxuICAgKi9cbiAgcHJpdmF0ZSBfY29uc3RydWN0b3I6IElKVk1Db25zdHJ1Y3RvcjxUPiA9IG51bGw7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIGZpZWxkIHRhYmxlXG4gICAqL1xuICBwcml2YXRlIF9maWVsZExvb2t1cDogeyBbbmFtZTogc3RyaW5nXTogbWV0aG9kcy5GaWVsZCB9ID0ge307XG4gIC8qKlxuICAgKiBBbGwgZmllbGRzIGluIG9iamVjdCBpbnN0YW50aWF0aW9ucy4gRmllbGRzIGZyb20gc3VwZXIgY2xhc3NlcyBhcmUgaW4gZnJvbnRcbiAgICogb2YgZmllbGRzIGZyb20gdGhpcyBjbGFzcy4gQSBmaWVsZCdzIG9mZnNldCBpbiB0aGUgYXJyYXkgaXMgaXRzICp2bWluZGV4Ki5cbiAgICovXG4gIHByb3RlY3RlZCBfb2JqZWN0RmllbGRzOiBtZXRob2RzLkZpZWxkW10gPSBbXTtcbiAgLyoqXG4gICAqIEFsbCBzdGF0aWMgZmllbGRzIGluIHRoaXMgcGFydGljdWxhciBjbGFzcy4gVGhlIGZpZWxkJ3Mgb2Zmc2V0IGluIHRoaXNcbiAgICogYXJyYXkgaXMgaXRzICp2bWluZGV4Ki5cbiAgICovXG4gIHByb3RlY3RlZCBfc3RhdGljRmllbGRzOiBtZXRob2RzLkZpZWxkW10gPSBbXTtcbiAgLyoqXG4gICAqIFZpcnR1YWwgbWV0aG9kIHRhYmxlLCBrZXllZCBieSBtZXRob2Qgc2lnbmF0dXJlLiBVbmxpa2UgX3ZtVGFibGUsXG4gICAqIF9tZXRob2RMb29rdXAgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgYW5kIGNvbnN0cnVjdG9ycywgdG9vLlxuICAgKi9cbiAgcHJpdmF0ZSBfbWV0aG9kTG9va3VwOiB7IFtzaWduYXR1cmU6IHN0cmluZ106IG1ldGhvZHMuTWV0aG9kIH0gPSB7fTtcbiAgLyoqXG4gICAqIFZpcnR1YWwgbWV0aG9kIHRhYmxlLCBrZXllZCBieSB2bWluZGV4LiBNZXRob2RzIG9yaWdpbmFsbHkgZGVmaW5lZCBieVxuICAgKiBzdXBlciBjbGFzc2VzIGFyZSBpbiBmcm9udCBvZiBtZXRob2RzIGRlZmluZWQgaW4gdGhpcyBjbGFzcy4gT3ZlcnJpZGluZ1xuICAgKiBtZXRob2RzIGFyZSBwbGFjZWQgaW50byB0aGUgdm1pbmRleCBvZiB0aGUgb3JpZ2luYXRpbmcgbWV0aG9kLlxuICAgKi9cbiAgcHJvdGVjdGVkIF92bVRhYmxlOiBtZXRob2RzLk1ldGhvZFtdID0gW107XG4gIC8qKlxuICAgKiBEZWZhdWx0IG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMgdGhhdCB0aGlzIGNsYXNzIGRpZCAqbm90KiBpbmhlcml0LCBidXQgYXJlXG4gICAqIHN0aWxsIGludm9jYWJsZSBpbiB0aGUgY2xhc3MgdmlhIHRoZWlyIGZ1bGwgbmFtZSAoZS5nLiB0aHJvdWdoIGFuXG4gICAqIGludm9rZXNwZWNpYWwgYnl0ZWNvZGUpLlxuICAgKi9cbiAgcHJvdGVjdGVkIF91bmluaGVyaXRlZERlZmF1bHRNZXRob2RzOiBtZXRob2RzLk1ldGhvZFtdID0gW107XG4gIC8qKlxuICAgKiBUaGUgUHJvdGVjdGlvbkRvbWFpbiBmb3IgdGhpcyBjbGFzcywgc3BlY2lmaWVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBjbGFzc1xuICAgKiBsb2FkZXIuIE5VTEwgZm9yIGJvb3RzdHJhcCBjbGFzc2xvYWRlZCBpdGVtcy5cbiAgICovXG4gIHByb3RlY3RlZCBfcHJvdGVjdGlvbkRvbWFpbjogSlZNVHlwZXMuamF2YV9zZWN1cml0eV9Qcm90ZWN0aW9uRG9tYWluO1xuXG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcjogQnVmZmVyLCBwcm90ZWN0aW9uRG9tYWluPzogSlZNVHlwZXMuamF2YV9zZWN1cml0eV9Qcm90ZWN0aW9uRG9tYWluLCBsb2FkZXI/OiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY3BQYXRjaGVzPzogSlZNVHlwZXMuSlZNQXJyYXk8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4pIHtcbiAgICBzdXBlcihsb2FkZXIpO1xuICAgIHRoaXMuX3Byb3RlY3Rpb25Eb21haW4gPSBwcm90ZWN0aW9uRG9tYWluID8gcHJvdGVjdGlvbkRvbWFpbiA6IG51bGw7XG4gICAgdmFyIGJ5dGVTdHJlYW0gPSBuZXcgQnl0ZVN0cmVhbShidWZmZXIpLFxuICAgICAgaTogbnVtYmVyID0gMDtcbiAgICBpZiAoKGJ5dGVTdHJlYW0uZ2V0VWludDMyKCkpICE9PSAweENBRkVCQUJFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWdpYyBudW1iZXIgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgdGhpcy5taW5vclZlcnNpb24gPSBieXRlU3RyZWFtLmdldFVpbnQxNigpO1xuICAgIHRoaXMubWFqb3JWZXJzaW9uID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgICBpZiAoISg0NSA8PSB0aGlzLm1ham9yVmVyc2lvbiAmJiB0aGlzLm1ham9yVmVyc2lvbiA8PSA1MikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ham9yIHZlcnNpb24gaW52YWxpZFwiKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdGFudFBvb2wgPSBuZXcgQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCgpO1xuICAgIHRoaXMuY29uc3RhbnRQb29sLnBhcnNlKGJ5dGVTdHJlYW0sIGNwUGF0Y2hlcyk7XG4gICAgLy8gYml0bWFzayBmb3Ige3B1YmxpYyxmaW5hbCxzdXBlcixpbnRlcmZhY2UsYWJzdHJhY3R9IGNsYXNzIG1vZGlmaWVyXG4gICAgdGhpcy5hY2Nlc3NGbGFncyA9IG5ldyB1dGlsLkZsYWdzKGJ5dGVTdHJlYW0uZ2V0VWludDE2KCkpO1xuXG4gICAgdGhpcy5jbGFzc05hbWUgPSAoPENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZT4gdGhpcy5jb25zdGFudFBvb2wuZ2V0KGJ5dGVTdHJlYW0uZ2V0VWludDE2KCkpKS5uYW1lO1xuICAgIC8vIHN1cGVyIHJlZmVyZW5jZSBpcyAwIHdoZW4gdGhlcmUncyBubyBzdXBlciAoYmFzaWNhbGx5IGp1c3QgamF2YS5sYW5nLk9iamVjdClcbiAgICB2YXIgc3VwZXJSZWYgPSBieXRlU3RyZWFtLmdldFVpbnQxNigpO1xuICAgIGlmIChzdXBlclJlZiAhPT0gMCkge1xuICAgICAgdGhpcy5zdXBlckNsYXNzUmVmID0gKDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IHRoaXMuY29uc3RhbnRQb29sLmdldChzdXBlclJlZikpO1xuICAgIH1cbiAgICAvLyBkaXJlY3QgaW50ZXJmYWNlcyBvZiB0aGlzIGNsYXNzXG4gICAgdmFyIGlzaXplID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgICB0aGlzLmludGVyZmFjZVJlZnMgPSBuZXcgQXJyYXk8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPihpc2l6ZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGlzaXplOyArK2kpIHtcbiAgICAgIHRoaXMuaW50ZXJmYWNlUmVmc1tpXSA9IDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IHRoaXMuY29uc3RhbnRQb29sLmdldChieXRlU3RyZWFtLmdldFVpbnQxNigpKTtcbiAgICB9XG4gICAgLy8gZmllbGRzIG9mIHRoaXMgY2xhc3NcbiAgICB2YXIgbnVtRmllbGRzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgICB0aGlzLmZpZWxkcyA9IG5ldyBBcnJheTxtZXRob2RzLkZpZWxkPihudW1GaWVsZHMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1GaWVsZHM7ICsraSkge1xuICAgICAgdGhpcy5maWVsZHNbaV0gPSBuZXcgbWV0aG9kcy5GaWVsZCh0aGlzLCB0aGlzLmNvbnN0YW50UG9vbCwgaSwgYnl0ZVN0cmVhbSk7XG4gICAgfVxuICAgIC8vIGNsYXNzIG1ldGhvZHNcbiAgICB2YXIgbnVtTWV0aG9kcyA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCk7XG4gICAgdGhpcy5tZXRob2RzID0gbmV3IEFycmF5PG1ldGhvZHMuTWV0aG9kPihudW1NZXRob2RzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTWV0aG9kczsgaSsrKSB7XG4gICAgICB2YXIgbSA9IG5ldyBtZXRob2RzLk1ldGhvZCh0aGlzLCB0aGlzLmNvbnN0YW50UG9vbCwgaSwgYnl0ZVN0cmVhbSk7XG4gICAgICB0aGlzLm1ldGhvZHNbaV0gPSBtO1xuICAgIH1cbiAgICAvLyBjbGFzcyBhdHRyaWJ1dGVzXG4gICAgdGhpcy5hdHRycyA9IGF0dHJpYnV0ZXMubWFrZUF0dHJpYnV0ZXMoYnl0ZVN0cmVhbSwgdGhpcy5jb25zdGFudFBvb2wpO1xuICAgIGlmIChieXRlU3RyZWFtLmhhc0J5dGVzKCkpIHtcbiAgICAgIHRocm93IGBMZWZ0b3ZlciBieXRlcyBpbiBjbGFzc2ZpbGU6ICR7Ynl0ZVN0cmVhbX1gO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRTdXBlckNsYXNzUmVmZXJlbmNlKCk6IENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwZXJDbGFzc1JlZjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnRlcmZhY2VDbGFzc1JlZmVyZW5jZXMoKTogQ29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlW10ge1xuICAgIHJldHVybiB0aGlzLmludGVyZmFjZVJlZnMuc2xpY2UoMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHNldCBvZiBpbnRlcmZhY2VzIHRoYXQgdGhpcyBjbGFzcyBpbXBsZW1lbnRzLlxuICAgKiBETyBOT1QgTVVUQVRFIVxuICAgKi9cbiAgcHVibGljIGdldEludGVyZmFjZXMoKTogUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+W10ge1xuICAgIHJldHVybiB0aGlzLmludGVyZmFjZUNsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHNldCBvZiBmaWVsZHMgdGhhdCB0aGlzIGNsYXNzIGhhcy5cbiAgICogRE8gTk9UIE1VVEFURSFcbiAgICovXG4gIHB1YmxpYyBnZXRGaWVsZHMoKTogbWV0aG9kcy5GaWVsZFtdIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBWaXJ0dWFsIE1ldGhvZCB0YWJsZSBmb3IgdGhpcyBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyBnZXRWTVRhYmxlKCk6IG1ldGhvZHMuTWV0aG9kW10ge1xuICAgIHJldHVybiB0aGlzLl92bVRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFZNIGluZGV4IGZvciB0aGUgZ2l2ZW4gbWV0aG9kLiBSZXR1cm5zIC0xIGlmIG5vdCBwcmVzZW50IGluIHRoZVxuICAgKiB2aXJ0dWFsIG1ldGhvZCB0YWJsZSAoZS5nLiBpcyBzdGF0aWMgb3IgYSBjb25zdHJ1Y3RvcikuXG4gICAqL1xuICBwdWJsaWMgZ2V0Vk1JbmRleEZvck1ldGhvZChtOiBtZXRob2RzLk1ldGhvZCk6IG51bWJlciB7XG4gICAgLy8gVXNlIE0ncyBzaWduYXR1cmUsIGFzIHdlIG1pZ2h0IG92ZXJyaWRlIHRoZSBtZXRob2QgYW5kIHVzZSBhIGRpZmZlcmVudFxuICAgIC8vIG1ldGhvZCBvYmplY3QgaW4gdGhlIHRhYmxlIGZvciBpdHMgdm1pbmRleC5cbiAgICByZXR1cm4gdGhpcy5fdm1UYWJsZS5pbmRleE9mKHRoaXMubWV0aG9kTG9va3VwKG0uc2lnbmF0dXJlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWV0aG9kIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIFZNSW5kZXguXG4gICAqL1xuICBwdWJsaWMgZ2V0TWV0aG9kRnJvbVZNSW5kZXgoaTogbnVtYmVyKTogbWV0aG9kcy5NZXRob2Qge1xuICAgIGlmICh0aGlzLl92bVRhYmxlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl92bVRhYmxlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFZNIGluZGV4IGZvciB0aGUgZ2l2ZW4gZmllbGRcbiAgICogTk9URTogQSBzdGF0aWMgYW5kIG5vbi1zdGF0aWMgZmllbGQgY2FuIGhhdmUgdGhlIHNhbWUgdm1pbmRleCEgQ2FsbGVyIG11c3RcbiAgICogYmUgYWJsZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gc3RhdGljIGFuZCBub24tc3RhdGljIGJlaGF2aW9yIVxuICAgKi9cbiAgcHVibGljIGdldFZNSW5kZXhGb3JGaWVsZChmOiBtZXRob2RzLkZpZWxkKTogbnVtYmVyIHtcbiAgICBpZiAoZi5hY2Nlc3NGbGFncy5pc1N0YXRpYygpKSB7XG4gICAgICBhc3NlcnQoZi5jbHMgPT09IHRoaXMsIFwiTG9va3MgbGlrZSB3ZSBhY3R1YWxseSBuZWVkIHRvIHN1cHBvcnQgc3RhdGljIGZpZWxkIGxvb2t1cHMhXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY0ZpZWxkcy5pbmRleE9mKGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0RmllbGRzLmluZGV4T2YoZik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFN0YXRpY0ZpZWxkRnJvbVZNSW5kZXgoaW5kZXg6IG51bWJlcik6IG1ldGhvZHMuRmllbGQge1xuICAgIHZhciBmID0gdGhpcy5fc3RhdGljRmllbGRzW2luZGV4XTtcbiAgICBpZiAoZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgZ2V0T2JqZWN0RmllbGRGcm9tVk1JbmRleChpbmRleDogbnVtYmVyKTogbWV0aG9kcy5GaWVsZCB7XG4gICAgdmFyIGYgPSB0aGlzLl9vYmplY3RGaWVsZHNbaW5kZXhdO1xuICAgIGlmIChmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBmaWVsZCBmcm9tIGl0cyBcInNsb3RcIi4gQSBcInNsb3RcIiBpcyBqdXN0IHRoZSBmaWVsZCdzIGluZGV4IGluIGl0c1xuICAgKiBkZWZpbmluZyBjbGFzcydzIGZpZWxkIGFycmF5LlxuICAgKi9cbiAgcHVibGljIGdldEZpZWxkRnJvbVNsb3Qoc2xvdDogbnVtYmVyKTogbWV0aG9kcy5GaWVsZCB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW3Nsb3RdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIG1ldGhvZCBmcm9tIGl0cyBcInNsb3RcIi4gQSBcInNsb3RcIiBpcyBqdXN0IHRoZSBtZXRob2QncyBpbmRleCBpbiBpdHNcbiAgICogZGVmaW5pbmcgY2xhc3MncyBtZXRob2QgYXJyYXkuXG4gICAqL1xuICBwdWJsaWMgZ2V0TWV0aG9kRnJvbVNsb3Qoc2xvdDogbnVtYmVyKTogbWV0aG9kcy5NZXRob2Qge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZHNbc2xvdF07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGZyb20gdGhpcyBwYXJ0aWN1bGFyIGNsYXNzLlxuICAgKiBEb2VzIG5vdCBzZWFyY2ggc3VwZXJjbGFzc2VzIC8gaW50ZXJmYWNlcy5cbiAgICovXG4gIHB1YmxpYyBnZXRNZXRob2Qoc2lnOiBzdHJpbmcpOiBtZXRob2RzLk1ldGhvZCB7XG4gICAgdmFyIG0gPSB0aGlzLl9tZXRob2RMb29rdXBbc2lnXTtcbiAgICBpZiAobS5jbHMgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRTcGVjaWZpY01ldGhvZChkZWZpbmluZ0Nsczogc3RyaW5nLCBzaWc6IHN0cmluZyk6IG1ldGhvZHMuTWV0aG9kIHtcbiAgICBpZiAodGhpcy5nZXRJbnRlcm5hbE5hbWUoKSA9PT0gZGVmaW5pbmdDbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1ldGhvZChzaWcpO1xuICAgIH1cbiAgICB2YXIgc2VhcmNoQ2xhc3NlcyA9IHRoaXMuaW50ZXJmYWNlQ2xhc3Nlcy5zbGljZSgwKSwgbTogbWV0aG9kcy5NZXRob2Q7XG4gICAgaWYgKHRoaXMuc3VwZXJDbGFzcykge1xuICAgICAgc2VhcmNoQ2xhc3Nlcy5wdXNoKHRoaXMuc3VwZXJDbGFzcyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG51bGwgIT09IChtID0gc2VhcmNoQ2xhc3Nlc1tpXS5nZXRTcGVjaWZpY01ldGhvZChkZWZpbmluZ0Nscywgc2lnKSkpIHtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWV0aG9kcyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGNsYXNzLlxuICAgKiBETyBOT1QgTVVUQVRFIVxuICAgKi9cbiAgcHVibGljIGdldE1ldGhvZHMoKTogbWV0aG9kcy5NZXRob2RbXSB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNldCBvZiBkZWZhdWx0IG1ldGhvZHMgdGhhdCBhcmUgaW52b2NhYmxlIG9uIHRoaXMgb2JqZWN0LCBidXQgd2VyZVxuICAgKiBub3QgaW5oZXJpdGVkIGluIHRoZSB2aXJ0dWFsIG1ldGhvZCB0YWJsZS5cbiAgICogRE8gTk9UIE1VVEFURSFcbiAgICovXG4gIHB1YmxpYyBnZXRVbmluaGVyaXRlZERlZmF1bHRNZXRob2RzKCk6IG1ldGhvZHMuTWV0aG9kW10ge1xuICAgIHJldHVybiB0aGlzLl91bmluaGVyaXRlZERlZmF1bHRNZXRob2RzO1xuICB9XG5cbiAgcHVibGljIGdldFByb3RlY3Rpb25Eb21haW4oKTogSlZNVHlwZXMuamF2YV9zZWN1cml0eV9Qcm90ZWN0aW9uRG9tYWluIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdGVjdGlvbkRvbWFpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGlzIGNsYXNzJ3MgdmlydHVhbCBtZXRob2QgdGFibGUgYWNjb3JkaW5nIHRvIHRoZSBKVk1cbiAgICogc3BlY2lmaWNhdGlvbjpcbiAgICogaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvanZtcy9zZTgvaHRtbC9qdm1zLTUuaHRtbCNqdm1zLTUuNC4zLjNcbiAgICovXG4gIHByaXZhdGUgX3Jlc29sdmVNZXRob2RzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIC8vIFN0YXJ0IG9mZiB3aXRoIG15IHBhcmVudHMnIG1ldGhvZCB0YWJsZS5cbiAgICAgIHRoaXMuX3ZtVGFibGUgPSB0aGlzLl92bVRhYmxlLmNvbmNhdCh0aGlzLnN1cGVyQ2xhc3MuX3ZtVGFibGUpO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5zdXBlckNsYXNzLl9tZXRob2RMb29rdXApLmZvckVhY2goKG06IHN0cmluZykgPT4ge1xuICAgICAgICB0aGlzLl9tZXRob2RMb29rdXBbbV0gPSB0aGlzLnN1cGVyQ2xhc3MuX21ldGhvZExvb2t1cFttXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE15IG1ldGhvZHMgb3ZlcnJpZGUgbXkgc3VwZXIgY2xhc3MnLlxuICAgIHRoaXMubWV0aG9kcy5mb3JFYWNoKChtOiBtZXRob2RzLk1ldGhvZCkgPT4ge1xuICAgICAgdmFyIHN1cGVyTSA9IHRoaXMuX21ldGhvZExvb2t1cFttLnNpZ25hdHVyZV07XG4gICAgICBpZiAoIW0uYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSAmJiBtLm5hbWUgIT09IFwiPGluaXQ+XCIpIHtcbiAgICAgICAgLy8gT25seSBub24tc3RhdGljIG5vbi1jb25zdHJ1Y3RvciBtZXRob2RzIGFyZSBwbGFjZWQgaW50byB0aGUgdmlydHVhbFxuICAgICAgICAvLyBtZXRob2QgdGFibGUuXG4gICAgICAgIGlmIChzdXBlck0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIE5ldyB2bWluZGV4LlxuICAgICAgICAgIHRoaXMuX3ZtVGFibGUucHVzaChtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPbGQgdm1pbmRleC4gSW5oZXJpdCB0aGUgc3VwZXIgY2xhc3MgbWV0aG9kJ3Mgdm1pbmRleC5cbiAgICAgICAgICB0aGlzLl92bVRhYmxlW3RoaXMuX3ZtVGFibGUuaW5kZXhPZihzdXBlck0pXSA9IG07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21ldGhvZExvb2t1cFttLnNpZ25hdHVyZV0gPSBtO1xuICAgIH0pO1xuXG4gICAgLy8gUm9vdCBvdXQgYW55IG1pcmFuZGEgLyBkZWZhdWx0IC8gc3RhdGljIGludGVyZmFjZSBtZXRob2RzLiBPbmx5IGluc3RhbGxcbiAgICAvLyB0aGVtIGlmIHRoZXJlIGFyZSBubyBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBpbiB0aGUgdGFibGUuXG4gICAgdGhpcy5pbnRlcmZhY2VDbGFzc2VzLmZvckVhY2goKGlmYWNlOiBSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4pID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGlmYWNlLl9tZXRob2RMb29rdXApLmZvckVhY2goKGlmYWNlTWV0aG9kU2lnOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdmFyIGlmYWNlTSA9IGlmYWNlLl9tZXRob2RMb29rdXBbaWZhY2VNZXRob2RTaWddO1xuICAgICAgICBpZiAodGhpcy5fbWV0aG9kTG9va3VwW2lmYWNlTWV0aG9kU2lnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCFpZmFjZU0uYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgLy8gTmV3IHZtaW5kZXguXG4gICAgICAgICAgICB0aGlzLl92bVRhYmxlLnB1c2goaWZhY2VNKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbWV0aG9kTG9va3VwW2lmYWNlTWV0aG9kU2lnXSA9IGlmYWNlTTtcbiAgICAgICAgfSBlbHNlIGlmIChpZmFjZU0uaXNEZWZhdWx0KCkpIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IG1ldGhvZDsgdW5pbmhlcml0ZWQsIGJ1dCBzdGlsbCBjYWxsYWJsZSB2aWEgZnVsbCBzaWduYXR1cmUuXG4gICAgICAgICAgdGhpcy5fdW5pbmhlcml0ZWREZWZhdWx0TWV0aG9kcy5wdXNoKGlmYWNlTSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFsbCBvZiB0aGUgZmllbGRzIGZvciB0aGlzIGNsYXNzIGFjY29yZGluZyB0byB0aGUgSlZNXG4gICAqIHNwZWNpZmljYXRpb246XG4gICAqIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy01Lmh0bWwjanZtcy01LjQuMy4yXG4gICAqL1xuICBwcml2YXRlIF9yZXNvbHZlRmllbGRzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIC8vIFN0YXJ0IG9mZiB3LyBteSBwYXJlbnQgY2xhc3MnIGZpZWxkcy5cbiAgICAgIHRoaXMuX29iamVjdEZpZWxkcyA9IHRoaXMuX29iamVjdEZpZWxkcy5jb25jYXQodGhpcy5zdXBlckNsYXNzLl9vYmplY3RGaWVsZHMpO1xuICAgICAgT2JqZWN0LmtleXModGhpcy5zdXBlckNsYXNzLl9maWVsZExvb2t1cCkuZm9yRWFjaCgoZjogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRoaXMuX2ZpZWxkTG9va3VwW2ZdID0gdGhpcy5zdXBlckNsYXNzLl9maWVsZExvb2t1cFtmXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN1cGVyaW50ZXJmYWNlIGZpZWxkcyB0cnVtcCBzdXBlcmNsYXNzIGZpZWxkcy5cbiAgICB0aGlzLmludGVyZmFjZUNsYXNzZXMuZm9yRWFjaCgoaWZhY2U6IFJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PikgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoaWZhY2UuX2ZpZWxkTG9va3VwKS5mb3JFYWNoKChpZmFjZUZpZWxkTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHZhciBpZmFjZUYgPSBpZmFjZS5fZmllbGRMb29rdXBbaWZhY2VGaWVsZE5hbWVdO1xuICAgICAgICBhc3NlcnQoaWZhY2VGLmFjY2Vzc0ZsYWdzLmlzU3RhdGljKCksIFwiSW50ZXJmYWNlIGZpZWxkcyBtdXN0IGJlIHN0YXRpYy5cIik7XG4gICAgICAgIHRoaXMuX2ZpZWxkTG9va3VwW2lmYWNlRmllbGROYW1lXSA9IGlmYWNlRjtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gTXkgZmllbGRzIG92ZXJyaWRlIGFsbCBvdGhlciBmaWVsZHMuXG4gICAgdGhpcy5maWVsZHMuZm9yRWFjaCgoZjogbWV0aG9kcy5GaWVsZCkgPT4ge1xuICAgICAgdGhpcy5fZmllbGRMb29rdXBbZi5uYW1lXSA9IGY7XG4gICAgICBpZiAoZi5hY2Nlc3NGbGFncy5pc1N0YXRpYygpKSB7XG4gICAgICAgIHRoaXMuX3N0YXRpY0ZpZWxkcy5wdXNoKGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0RmllbGRzLnB1c2goZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdXAgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gc2lnbmF0dXJlLiBSZXR1cm5zIG51bGwgaWYgbm8gbWV0aG9kXG4gICAqIGZvdW5kLlxuICAgKi9cbiAgcHVibGljIG1ldGhvZExvb2t1cChzaWduYXR1cmU6IHN0cmluZyk6IG1ldGhvZHMuTWV0aG9kIHtcbiAgICB2YXIgbSA9IHRoaXMuX21ldGhvZExvb2t1cFtzaWduYXR1cmVdO1xuICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgbWV0aG9kIGxvb2t1cCwgYW5kIGluY2x1ZGVzIHNpZ25hdHVyZSBwb2x5bW9ycGhpYyByZXN1bHRzIGlmXG4gICAqIHRoZSBtZXRob2QgaXMgc2lnbmF0dXJlIHBvbHltb3JwaGljLlxuICAgKi9cbiAgcHVibGljIHNpZ25hdHVyZVBvbHltb3JwaGljQXdhcmVNZXRob2RMb29rdXAoc2lnbmF0dXJlOiBzdHJpbmcpOiBtZXRob2RzLk1ldGhvZCB7XG4gICAgdmFyIG06IG1ldGhvZHMuTWV0aG9kO1xuICAgIGlmIChudWxsICE9PSAobSA9IHRoaXMubWV0aG9kTG9va3VwKHNpZ25hdHVyZSkpKSB7XG4gICAgICByZXR1cm4gbTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2xhc3NOYW1lID09PSAnTGphdmEvbGFuZy9pbnZva2UvTWV0aG9kSGFuZGxlOycpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBzaWduYXR1cmUgcG9seW1vcnBoaWMgbWV0aG9kLlxuICAgICAgLy8gRnJvbSBTMi45OlxuICAgICAgLy8gQSBtZXRob2QgaXMgc2lnbmF0dXJlIHBvbHltb3JwaGljIGlmIGFuZCBvbmx5IGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgaG9sZCA6XG4gICAgICAvLyAqIEl0IGlzIGRlY2xhcmVkIGluIHRoZSBqYXZhLmxhbmcuaW52b2tlLk1ldGhvZEhhbmRsZSBjbGFzcy5cbiAgICAgIC8vICogSXQgaGFzIGEgc2luZ2xlIGZvcm1hbCBwYXJhbWV0ZXIgb2YgdHlwZSBPYmplY3RbXS5cbiAgICAgIC8vICogSXQgaGFzIGEgcmV0dXJuIHR5cGUgb2YgT2JqZWN0LlxuICAgICAgLy8gKiBJdCBoYXMgdGhlIEFDQ19WQVJBUkdTIGFuZCBBQ0NfTkFUSVZFIGZsYWdzIHNldC5cbiAgICAgIHZhciBwb2x5U2lnID0gYCR7c2lnbmF0dXJlLnNsaWNlKDAsIHNpZ25hdHVyZS5pbmRleE9mKCcoJykpfShbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0O2AsXG4gICAgICAgIG0gPSB0aGlzLl9tZXRob2RMb29rdXBbcG9seVNpZ107XG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkICYmIG0uYWNjZXNzRmxhZ3MuaXNOYXRpdmUoKSAmJiBtLmFjY2Vzc0ZsYWdzLmlzVmFyQXJncygpICYmIG0uY2xzID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBlckNsYXNzLnNpZ25hdHVyZVBvbHltb3JwaGljQXdhcmVNZXRob2RMb29rdXAoc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdXAgYSBmaWVsZCB3aXRoIHRoZSBnaXZlbiBuYW1lLiBSZXR1cm5zIG51bGwgaWYgbm8gbWV0aG9kIGZvdW5kLlxuICAgKi9cbiAgcHVibGljIGZpZWxkTG9va3VwKG5hbWU6IHN0cmluZyk6IG1ldGhvZHMuRmllbGQge1xuICAgIHZhciBmID0gdGhpcy5fZmllbGRMb29rdXBbbmFtZV07XG4gICAgaWYgKGYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nKTogYXR0cmlidXRlcy5JQXR0cmlidXRlIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICBpZiAoYXR0ci5nZXROYW1lKCkgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGdldEF0dHJpYnV0ZXMobmFtZTogc3RyaW5nKTogYXR0cmlidXRlcy5JQXR0cmlidXRlW10ge1xuICAgIHZhciBhdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgdmFyIHJlc3VsdHMgOiBhdHRyaWJ1dGVzLklBdHRyaWJ1dGVbXSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICBpZiAoYXR0ci5nZXROYW1lKCkgPT09IG5hbWUpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJvb3RzdHJhcCBtZXRob2QgaW5mb3JtYXRpb24gZm9yIGFuIEludm9rZUR5bmFtaWMgb3Bjb2RlLlxuICAgKi9cbiAgcHVibGljIGdldEJvb3RzdHJhcE1ldGhvZChpZHg6IG51bWJlcik6IFtDb25zdGFudFBvb2wuTWV0aG9kSGFuZGxlLCBDb25zdGFudFBvb2wuSUNvbnN0YW50UG9vbEl0ZW1bXV0ge1xuICAgIHZhciBibXMgPSA8YXR0cmlidXRlcy5Cb290c3RyYXBNZXRob2RzPiB0aGlzLmdldEF0dHJpYnV0ZSgnQm9vdHN0cmFwTWV0aG9kcycpO1xuICAgIHJldHVybiBibXMuYm9vdHN0cmFwTWV0aG9kc1tpZHhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgdmFsdWUgZm9yIGEgZ2l2ZW4gc3RhdGljIGZpZWxkIGluIHRoZSBjbGFzcy4gU2hvdWxkXG4gICAqIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnN0cnVjdG9yIGlzIGNyZWF0ZWQuXG4gICAqL1xuICBwcml2YXRlIF9nZXRJbml0aWFsU3RhdGljRmllbGRWYWx1ZSh0aHJlYWQ6IEpWTVRocmVhZCwgbmFtZTogc3RyaW5nKTogYW55IHtcbiAgICB2YXIgZjogbWV0aG9kcy5GaWVsZCA9IHRoaXMuZmllbGRMb29rdXAobmFtZSk7XG4gICAgaWYgKGYgIT09IG51bGwgJiYgZi5hY2Nlc3NGbGFncy5pc1N0YXRpYygpKSB7XG4gICAgICB2YXIgY3ZhID0gPGF0dHJpYnV0ZXMuQ29uc3RhbnRWYWx1ZT4gZi5nZXRBdHRyaWJ1dGUoJ0NvbnN0YW50VmFsdWUnKTtcbiAgICAgIGlmIChjdmEgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChjdmEudmFsdWUuZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICB2YXIgc3RyaW5nQ1BJID0gPENvbnN0YW50UG9vbC5Db25zdFN0cmluZz4gY3ZhLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0cmluZ0NQSS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHJpbmdDUEkudmFsdWUgPSB0aHJlYWQuZ2V0SlZNKCkuaW50ZXJuU3RyaW5nKHN0cmluZ0NQSS5zdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nQ1BJLnZhbHVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIGJldHRlci5cbiAgICAgICAgICAgIHJldHVybiAoPGFueT4gY3ZhLnZhbHVlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaW5pdGlhbFZhbHVlKGYucmF3RGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2VydChmYWxzZSwgYFRyaWVkIHRvIGNvbnN0cnVjdCBhIHN0YXRpYyBmaWVsZCB2YWx1ZSB0aGF0ICR7ZiAhPT0gbnVsbCA/IFwiaXNuJ3Qgc3RhdGljXCIgOiBcImRvZXNuJ3QgZXhpc3RcIn06ICR7ZiAhPT0gbnVsbCA/IGYuY2xzLmdldEludGVybmFsTmFtZSgpIDogdGhpcy5nZXRJbnRlcm5hbE5hbWUoKX0gJHtuYW1lfWApO1xuICB9XG5cbiAgcHVibGljIHNldFJlc29sdmVkKHN1cGVyQ2xheno6IFJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiwgaW50ZXJmYWNlQ2xhenplczogUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+W10pOiB2b2lkIHtcbiAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXp6O1xuICAgIHRyYWNlKGBDbGFzcyAke3RoaXMuZ2V0SW50ZXJuYWxOYW1lKCl9IGlzIG5vdyByZXNvbHZlZC5gKTtcbiAgICB0aGlzLmludGVyZmFjZUNsYXNzZXMgPSBpbnRlcmZhY2VDbGF6emVzO1xuICAgIC8vIFRPRE86IEFzc2VydCB3ZSBhcmUgbm90IGFscmVhZHkgcmVzb2x2ZWQgb3IgaW5pdGlhbGl6ZWQ/XG4gICAgdGhpcy5fcmVzb2x2ZU1ldGhvZHMoKTtcbiAgICB0aGlzLl9yZXNvbHZlRmllbGRzKCk7XG4gICAgdGhpcy5zZXRTdGF0ZShDbGFzc1N0YXRlLlJFU09MVkVEKTtcbiAgfVxuXG4gIHB1YmxpYyB0cnlUb1Jlc29sdmUoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuZ2V0U3RhdGUoKSA9PT0gQ2xhc3NTdGF0ZS5MT0FERUQpIHtcbiAgICAgIC8vIE5lZWQgdG8gZ3JhYiB0aGUgc3VwZXIgY2xhc3MsIGFuZCBpbnRlcmZhY2VzLlxuICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyLFxuICAgICAgICB0b1Jlc29sdmUgPSB0aGlzLnN1cGVyQ2xhc3NSZWYgIT09IG51bGwgPyB0aGlzLmludGVyZmFjZVJlZnMuY29uY2F0KHRoaXMuc3VwZXJDbGFzc1JlZikgOiB0aGlzLmludGVyZmFjZVJlZnMsXG4gICAgICAgIGFsbEdvb2QgPSB0cnVlLFxuICAgICAgICByZXNvbHZlZEl0ZW1zOiBSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD5bXSA9IFtdLCBpOiBudW1iZXIsXG4gICAgICAgIGl0ZW06IENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b1Jlc29sdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHRvUmVzb2x2ZVtpXTtcbiAgICAgICAgaWYgKGl0ZW0udHJ5UmVzb2x2ZShsb2FkZXIpKSB7XG4gICAgICAgICAgcmVzb2x2ZWRJdGVtcy5wdXNoKDxSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4+IGl0ZW0uY2xzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXQgd29ya2VkIVxuICAgICAgdGhpcy5zZXRSZXNvbHZlZCh0aGlzLnN1cGVyQ2xhc3NSZWYgIT09IG51bGwgPyByZXNvbHZlZEl0ZW1zLnBvcCgpIDogbnVsbCwgcmVzb2x2ZWRJdGVtcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc3luY2hyb25vdXNseSBpbml0aWFsaXplLiBUaGlzIGlzIHBvc3NpYmxlIGlmIHRoZXJlIGlzIG5vXG4gICAqIHN0YXRpYyBpbml0aWFsaXplciwgYW5kIHRoZSBwYXJlbnQgY2xhc3NlcyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBwdWJsaWMgdHJ5VG9Jbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmdldFN0YXRlKCkgPT09IENsYXNzU3RhdGUuSU5JVElBTElaRUQpIHtcbiAgICAgIC8vIEFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRTdGF0ZSgpID09PSBDbGFzc1N0YXRlLlJFU09MVkVEIHx8IHRoaXMudHJ5VG9SZXNvbHZlKCkpIHtcbiAgICAgIC8vIEVuc3VyZSBwYXJlbnQgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICBpZiAodGhpcy5zdXBlckNsYXNzICE9PSBudWxsICYmICF0aGlzLnN1cGVyQ2xhc3MudHJ5VG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgLy8gUGFyZW50IGZhaWxlZCB0byBpbml0aWFsaXplLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2xhc3MgaGFzIGEgc3RhdGljIGluaXRpYWxpemVyLlxuICAgICAgdmFyIGNsaW5pdCA9IHRoaXMuZ2V0TWV0aG9kKCc8Y2xpbml0PigpVicpO1xuICAgICAgaWYgKGNsaW5pdCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBOb3BlOyB0aGlzIGNsYXNzIG5lZWRzIHRvIGRvIHRoZSBmdWxsIGluaXRpYWxpemF0aW9uIHNvbmctYW5kLWRhbmNlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBzdGF0aWMgaW5pdGlhbGl6ZXIhIFRoaXMgY2xhc3MgaXMgaW5pdGlhbGl6ZWQhXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoQ2xhc3NTdGF0ZS5JTklUSUFMSVpFRCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgY2xhc3MgaXMgbm90IHJlc29sdmVkLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgY2xhc3MgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRhcmdldCBjbGFzcy5cbiAgICogXCJ0YXJnZXRcIiBpcyBhIENsYXNzRGF0YSBvYmplY3QuXG4gICAqIFRoZSBDbGFzc0RhdGEgb2JqZWN0cyBkbyBub3QgbmVlZCB0byBiZSBpbml0aWFsaXplZDsganVzdCBsb2FkZWQuXG4gICAqIFNlZSDCpzIuNi43IGZvciBjYXN0aW5nIHJ1bGVzLlxuICAgKiBAdG9kbyBEZXRlcm1pbmUgdGhpcyBzdGF0aWNhbGx5IHRvIG1ha2UgdGhpcyBhIGNvbnN0YW50IHRpbWUgb3BlcmF0aW9uLlxuICAgKi9cbiAgcHVibGljIGlzQ2FzdGFibGUodGFyZ2V0OiBDbGFzc0RhdGEpOiBib29sZWFuIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBSZWZlcmVuY2VDbGFzc0RhdGEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjY2Vzc0ZsYWdzLmlzSW50ZXJmYWNlKCkpIHtcbiAgICAgIC8vIFdlIGFyZSBib3RoIGludGVyZmFjZXNcbiAgICAgIGlmICh0YXJnZXQuYWNjZXNzRmxhZ3MuaXNJbnRlcmZhY2UoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N1YmludGVyZmFjZSh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgLy8gT25seSBJIGFtIGFuIGludGVyZmFjZVxuICAgICAgaWYgKCF0YXJnZXQuYWNjZXNzRmxhZ3MuaXNJbnRlcmZhY2UoKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEludGVybmFsTmFtZSgpID09PSAnTGphdmEvbGFuZy9PYmplY3Q7JztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSSBhbSBhIHJlZ3VsYXIgY2xhc3MsIHRhcmdldCBpcyBhbiBpbnRlcmZhY2VcbiAgICAgIGlmICh0YXJnZXQuYWNjZXNzRmxhZ3MuaXNJbnRlcmZhY2UoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N1YmludGVyZmFjZSh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgLy8gV2UgYXJlIGJvdGggcmVndWxhciBjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy5pc1N1YmNsYXNzKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgJ3RydWUnIGlmIEkgaW1wbGVtZW50IHRoZSB0YXJnZXQgaW50ZXJmYWNlLlxuICAgKi9cbiAgcHVibGljIGlzU3ViaW50ZXJmYWNlKHRhcmdldDogQ2xhc3NEYXRhKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY2xhc3NOYW1lID09PSB0YXJnZXQuZ2V0SW50ZXJuYWxOYW1lKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaWZhY2VzID0gdGhpcy5nZXRJbnRlcmZhY2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZmFjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdXBlcklmYWNlID0gaWZhY2VzW2ldO1xuICAgICAgaWYgKHN1cGVySWZhY2UuaXNTdWJpbnRlcmZhY2UodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0U3VwZXJDbGFzcygpID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VwZXJDbGFzcygpLmlzU3ViaW50ZXJmYWNlKHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgKmluaXRpYWxpemVzKiB0aGUgY2xhc3MgYW5kIGl0cyBzdXBlciBjbGFzc2VzLlxuICAgKiBUaHJvd3MgYSBKYXZhIGV4Y2VwdGlvbiBvbiB0aGUgdGhyZWFkIGlmIGluaXRpYWxpemF0aW9uIGZhaWxzLlxuICAgKiBAcGFyYW0gdGhyZWFkIFRoZSB0aHJlYWQgdGhhdCBpcyBwZXJmb3JtaW5nIHRoZSBpbml0aWFsaXphdGlvbi5cbiAgICogQHBhcmFtIGNiIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGNvbXBsZXRlZC4gQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlXG4gICAqICAgY2xhc3MgaWYgaXQgc3VjY2VlZHMsIG9yIE5VTEwgaWYgYSBmYWlsdXJlIG9jY3Vycy5cbiAgICogQHBhcmFtIFtleHBsaWNpdF0gRGVmYXVsdHMgdG8gdHJ1ZS4gSWYgdHJ1ZSwgdGhpcyBjbGFzcyBpcyBiZWluZ1xuICAgKiAgICpleHBsaWNpdGx5KiBpbml0aWFsaXplZCBieSBhIHVzZXIuIElmIGZhbHNlLCB0aGUgSlZNIGlzIGltcGxpY2l0bHlcbiAgICogICBpbml0aWFsaXppbmcgdGhlIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIGluaXRpYWxpemUodGhyZWFkOiBKVk1UaHJlYWQsIGNiOiAoY2RhdGE6IENsYXNzRGF0YSkgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSZXNvbHZlZCgpKSB7XG4gICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKHRocmVhZCkpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkbyEgRWl0aGVyIHJlc29sdXRpb24gZmFpbGVkIGFuZCBhbiBleGNlcHRpb24gaGFzIGFscmVhZHlcbiAgICAgICAgLy8gYmVlbiB0aHJvd24sIGNkYXRhIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9yIHRoZSBjdXJyZW50IHRocmVhZCBpc1xuICAgICAgICAvLyBpbml0aWFsaXppbmcgdGhlIGNsYXNzLlxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIGNiKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbml0TG9jay50cnlMb2NrKHRocmVhZCwgY2IpKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHN1cGVyIGNsYXNzLCBhbmQgdGhlbiB0aGlzIGNsYXNzLlxuICAgICAgICBpZiAodGhpcy5zdXBlckNsYXNzICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN1cGVyQ2xhc3MuaW5pdGlhbGl6ZSh0aHJlYWQsIChjZGF0YTogQ2xhc3NEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2RhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvLiBJbml0aWFsaXppbmcgdGhlIHN1cGVyIGNsYXNzIGZhaWxlZC5cbiAgICAgICAgICAgICAgdGhpcy5pbml0TG9jay51bmxvY2sobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIG15c2VsZi5cbiAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSh0aHJlYWQsIChjZGF0YTogQ2xhc3NEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0TG9jay51bmxvY2soY2RhdGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBleHBsaWNpdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gamF2YS9sYW5nL09iamVjdCdzIHBhcmVudCBpcyBOVUxMLlxuICAgICAgICAgIC8vIENvbnRpbnVlIGluaXRpYWxpemluZyB0aGlzIGNsYXNzLlxuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemUodGhyZWFkLCAoY2RhdGE6IENsYXNzRGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0TG9jay51bmxvY2soY2RhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc29sdmUgZmlyc3QsIHRoZW4gaW5pdGlhbGl6ZS5cbiAgICAgIHRoaXMucmVzb2x2ZSh0aHJlYWQsIChjZGF0YTogQ2xhc3NEYXRhKSA9PiB7XG4gICAgICAgIGlmIChjZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSh0aHJlYWQsIGNiLCBleHBsaWNpdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRWxzZTogQW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gICAgICAgICAgY2IoY2RhdGEpO1xuICAgICAgICB9XG4gICAgICB9LCBleHBsaWNpdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbi4gSW5pdGlhbGl6ZXMgdGhpcyBjbGFzcyBhbG9uZS4gQXNzdW1lcyBzdXBlciBjbGFzcyBpc1xuICAgKiBhbHJlYWR5IGluaXRpYWxpemVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZSh0aHJlYWQ6IEpWTVRocmVhZCwgY2I6IChjZGF0YTogQ2xhc3NEYXRhKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdmFyIGNvbnMgPSA8dHlwZW9mIEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+IDxhbnk+IHRoaXMuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcbiAgICBpZiAoY29uc1snPGNsaW5pdD4oKVYnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWJ1ZyhgVCR7dGhyZWFkLmdldFJlZigpfSBSdW5uaW5nIHN0YXRpYyBpbml0aWFsaXphdGlvbiBmb3IgY2xhc3MgJHt0aGlzLmNsYXNzTmFtZX0uLi5gKTtcbiAgICAgIGNvbnNbJzxjbGluaXQ+KClWJ10odGhyZWFkLCBudWxsLCAoZT86IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUpID0+IHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBkZWJ1ZyhgSW5pdGlhbGl6YXRpb24gb2YgY2xhc3MgJHt0aGlzLmNsYXNzTmFtZX0gZmFpbGVkLmApO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZW51bXMuQ2xhc3NTdGF0ZS5SRVNPTFZFRCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogXCJUaGUgY2xhc3Mgb3IgaW50ZXJmYWNlIGluaXRpYWxpemF0aW9uIG1ldGhvZCBtdXN0IGhhdmUgY29tcGxldGVkXG4gICAgICAgICAgICogIGFicnVwdGx5IGJ5IHRocm93aW5nIHNvbWUgZXhjZXB0aW9uIEUuIElmIHRoZSBjbGFzcyBvZiBFIGlzIG5vdFxuICAgICAgICAgICAqICBFcnJvciBvciBvbmUgb2YgaXRzIHN1YmNsYXNzZXMsIHRoZW4gY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZVxuICAgICAgICAgICAqICBjbGFzcyBFeGNlcHRpb25JbkluaXRpYWxpemVyRXJyb3Igd2l0aCBFIGFzIHRoZSBhcmd1bWVudCwgYW5kIHVzZVxuICAgICAgICAgICAqICB0aGlzIG9iamVjdCBpbiBwbGFjZSBvZiBFLlwiXG4gICAgICAgICAgICogQHVybCBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qdm1zL3NlNy9odG1sL2p2bXMtNS5odG1sI2p2bXMtNS41XG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGUuZ2V0Q2xhc3MoKS5pc0Nhc3RhYmxlKHRocmVhZC5nZXRCc0NsKCkuZ2V0UmVzb2x2ZWRDbGFzcygnTGphdmEvbGFuZy9FcnJvcjsnKSkpIHtcbiAgICAgICAgICAgIC8vICdlJyBpcyAnRXJyb3Igb3Igb25lIG9mIGl0cyBzdWJjbGFzc2VzJy5cbiAgICAgICAgICAgIHRocmVhZC50aHJvd0V4Y2VwdGlvbihlKTtcbiAgICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXcmFwIHRoZSBlcnJvci5cbiAgICAgICAgICAgIHRocmVhZC5nZXRCc0NsKCkuaW5pdGlhbGl6ZUNsYXNzKHRocmVhZCwgJ0xqYXZhL2xhbmcvRXhjZXB0aW9uSW5Jbml0aWFsaXplckVycm9yOycsIChjZGF0YTogUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19FeGNlcHRpb25JbkluaXRpYWxpemVyRXJyb3I+KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9uYWwgZmFpbHVyZSByaWdodCBoZXJlOiAqV2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBFeGNlcHRpb25JbkluaXRpYWxpemVyRXJyb3IqIVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemVDbGFzcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBvbiBvdXIgYmVoYWxmO1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBvYmplY3QhXG4gICAgICAgICAgICAgICAgdmFyIGVDb25zID0gY2RhdGEuZ2V0Q29uc3RydWN0b3IodGhyZWFkKSxcbiAgICAgICAgICAgICAgICAgIGUyID0gbmV3IGVDb25zKHRocmVhZCk7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBFeGNlcHRpb25JbkluaXRpYWxpemVyRXJyb3IhXG4gICAgICAgICAgICAgICAgZTJbXCI8aW5pdD4oTGphdmEvbGFuZy9UaHJvd2FibGU7KVZcIl0odGhyZWFkLCBbZV0sIChlPzogSlZNVHlwZXMuamF2YV9sYW5nX1Rocm93YWJsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgdGhlIG5ld2x5LWNvbnN0cnVjdGVkIGVycm9yIVxuICAgICAgICAgICAgICAgICAgdGhyZWFkLnRocm93RXhjZXB0aW9uKGUyKTtcbiAgICAgICAgICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShlbnVtcy5DbGFzc1N0YXRlLklOSVRJQUxJWkVEKTtcbiAgICAgICAgICBkZWJ1ZyhgSW5pdGlhbGl6YXRpb24gb2YgY2xhc3MgJHt0aGlzLmNsYXNzTmFtZX0gc3VjY2VlZGVkLmApO1xuICAgICAgICAgIC8vIE5vcm1hbCBjYXNlISBJbml0aWFsaXphdGlvbiBzdWNjZWVkZWQuXG4gICAgICAgICAgY2IodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGFzcyBkb2Vzbid0IGhhdmUgYSBzdGF0aWMgaW5pdGlhbGl6ZXIuXG4gICAgICB0aGlzLnNldFN0YXRlKGVudW1zLkNsYXNzU3RhdGUuSU5JVElBTElaRUQpO1xuICAgICAgY2IodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIGNsYXNzIGNhbiBiZSB0cmVhdGVkIGFzIGluaXRpYWxpemVkIGluIGEgdGhyZWFkIGlmIHRoYXQgdGhyZWFkXG4gICAqIGlzIGluIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBpdC5cbiAgICovXG4gIHB1YmxpYyBpc0luaXRpYWxpemVkKHRocmVhZDogSlZNVGhyZWFkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PT0gQ2xhc3NTdGF0ZS5JTklUSUFMSVpFRCB8fCB0aGlzLmluaXRMb2NrLmdldE93bmVyKCkgPT09IHRocmVhZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIHRoZSBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogSlZNVGhyZWFkLCBjYjogKGNkYXRhOiBDbGFzc0RhdGEpID0+IHZvaWQsIGV4cGxpY2l0OiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIHZhciB0b1Jlc29sdmU6IENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZVtdID0gdGhpcy5pbnRlcmZhY2VSZWZzLnNsaWNlKDApO1xuICAgIGlmICh0aGlzLnN1cGVyQ2xhc3NSZWYgIT09IG51bGwpIHtcbiAgICAgIHRvUmVzb2x2ZS5wdXNoKHRoaXMuc3VwZXJDbGFzc1JlZik7XG4gICAgfVxuICAgIHRvUmVzb2x2ZSA9IHRvUmVzb2x2ZS5maWx0ZXIoKGl0ZW06IENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZSkgPT4gIWl0ZW0uaXNSZXNvbHZlZCgpKTtcbiAgICB1dGlsLmFzeW5jRm9yRWFjaCh0b1Jlc29sdmUsIChjbHNSZWY6IENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZSwgbmV4dEl0ZW06IChlcnI/OiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgIGNsc1JlZi5yZXNvbHZlKHRocmVhZCwgdGhpcy5sb2FkZXIsIHRoaXMsIChzdGF0dXM6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgICAgICBuZXh0SXRlbShcIkZhaWxlZC5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEl0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwbGljaXQpO1xuICAgIH0sIChlcnI/OiBhbnkpID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRoaXMuc2V0UmVzb2x2ZWQodGhpcy5zdXBlckNsYXNzUmVmICE9PSBudWxsID8gPFJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0Pj4gdGhpcy5zdXBlckNsYXNzUmVmLmNscyA6IG51bGwsIHRoaXMuaW50ZXJmYWNlUmVmcy5tYXAoKHJlZjogQ29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlKSA9PiA8UmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiByZWYuY2xzKSk7XG4gICAgICAgIGNiKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBNaXJhbmRhIGFuZCBkZWZhdWx0IGludGVyZmFjZSBtZXRob2RzIGluIHRoaXMgY2xhc3MuIFRoZXNlXG4gICAqIG1ldGhvZHMgbWFuaWZlc3QgYXMgbmV3IHZtaW5kaWNlcyBpbiB0aGUgdmlydHVhbCBtZXRob2QgdGFibGUgY29tcGFyZWQgd2l0aFxuICAgKiB0aGUgc3VwZXJjbGFzcywgYW5kIGFyZSBub3QgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIGl0c2VsZi5cbiAgICovXG4gIHB1YmxpYyBnZXRNaXJhbmRhQW5kRGVmYXVsdE1ldGhvZHMoKTogbWV0aG9kcy5NZXRob2RbXSB7XG4gICAgdmFyIHN1cGVyQ2xzTWV0aG9kVGFibGU6IG1ldGhvZHMuTWV0aG9kW10gPSB0aGlzLnN1cGVyQ2xhc3MgIT09IG51bGwgPyB0aGlzLnN1cGVyQ2xhc3MuZ2V0Vk1UYWJsZSgpIDogW107XG4gICAgcmV0dXJuIHRoaXMuZ2V0Vk1UYWJsZSgpLnNsaWNlKHN1cGVyQ2xzTWV0aG9kVGFibGUubGVuZ3RoKS5maWx0ZXIoKG1ldGhvZDogbWV0aG9kcy5NZXRob2QpID0+IG1ldGhvZC5jbHMgIT09IHRoaXMpO1xuICB9XG5cbiAgcHVibGljIG91dHB1dEluamVjdGVkRmllbGRzKG91dHB1dFN0cmVhbTogU3RyaW5nT3V0cHV0U3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zdXBlckNsYXNzLm91dHB1dEluamVjdGVkRmllbGRzKG91dHB1dFN0cmVhbSk7XG4gICAgfVxuICAgIHZhciBpbmplY3RlZCA9IGluamVjdGVkRmllbGRzW3RoaXMuZ2V0SW50ZXJuYWxOYW1lKCldO1xuICAgIGlmIChpbmplY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBPYmplY3Qua2V5cyhpbmplY3RlZCkuZm9yRWFjaCgoZmllbGROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKGB0aGlzLiR7ZmllbGROYW1lfSA9ICR7aW5qZWN0ZWRbZmllbGROYW1lXVsxXX07XFxuYCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbnN0cnVjdENvbnN0cnVjdG9yKHRocmVhZDogSlZNVGhyZWFkKTogSUpWTUNvbnN0cnVjdG9yPFQ+IHtcbiAgICBhc3NlcnQodGhpcy5fY29uc3RydWN0b3IgPT09IG51bGwsIGBBdHRlbXB0ZWQgdG8gY29uc3RydWN0IGNvbnN0cnVjdG9yIHR3aWNlIGZvciBjbGFzcyAke3RoaXMuZ2V0RXh0ZXJuYWxOYW1lKCl9IWApO1xuXG4gICAgdmFyIGpzQ2xhc3NOYW1lID0gdXRpbC5qdm1OYW1lMkpTTmFtZSh0aGlzLmdldEludGVybmFsTmFtZSgpKSxcbiAgICAgIG91dHB1dFN0cmVhbSA9IG5ldyBTdHJpbmdPdXRwdXRTdHJlYW0oKTtcblxuICAgIG91dHB1dFN0cmVhbS53cml0ZShgZnVuY3Rpb24gX2NyZWF0ZShleHRlbmRDbGFzcywgY2xzLCBJbnRlcm5hbFN0YWNrRnJhbWUsIE5hdGl2ZVN0YWNrRnJhbWUsIEJ5dGVjb2RlU3RhY2tGcmFtZSwgZ0xvbmdaZXJvLCBDbGFzc0xvYWRlciwgTW9uaXRvciwgdGhyZWFkKSB7XG4gIGlmIChjbHMuc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIGV4dGVuZENsYXNzKCR7anNDbGFzc05hbWV9LCBjbHMuc3VwZXJDbGFzcy5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKTtcbiAgfVxuICBmdW5jdGlvbiAke2pzQ2xhc3NOYW1lfSh0aHJlYWQpIHtcXG5gKTtcbiAgICAvLyBJbmplY3RlZCBmaWVsZHMuXG4gICAgdGhpcy5vdXRwdXRJbmplY3RlZEZpZWxkcyhvdXRwdXRTdHJlYW0pO1xuXG4gICAgLy8gT3V0cHV0IGluc3RhbmNlIGZpZWxkIGFzc2lnbm1lbnRzLlxuICAgIHRoaXMuX29iamVjdEZpZWxkcy5mb3JFYWNoKChmOiBtZXRob2RzLkZpZWxkKSA9PiBmLm91dHB1dEphdmFTY3JpcHRGaWVsZChqc0NsYXNzTmFtZSwgb3V0cHV0U3RyZWFtKSk7XG4gICAgb3V0cHV0U3RyZWFtLndyaXRlKGAgIH1cbiAgJHtqc0NsYXNzTmFtZX0uY2xzID0gY2xzO1xcbmApO1xuXG4gICAgLy8gSW5qZWN0ZWQgbWV0aG9kcy5cbiAgICB0aGlzLm91dHB1dEluamVjdGVkTWV0aG9kcyhqc0NsYXNzTmFtZSwgb3V0cHV0U3RyZWFtKTtcblxuICAgIC8vIFN0YXRpYyBmaWVsZHMuXG4gICAgdGhpcy5fc3RhdGljRmllbGRzLmZvckVhY2goKGY6IG1ldGhvZHMuRmllbGQpID0+IGYub3V0cHV0SmF2YVNjcmlwdEZpZWxkKGpzQ2xhc3NOYW1lLCBvdXRwdXRTdHJlYW0pKTtcblxuICAgIC8vIFN0YXRpYyBhbmQgaW5zdGFuY2UgbWV0aG9kcy5cbiAgICB0aGlzLmdldE1ldGhvZHMoKS5mb3JFYWNoKChtOiBtZXRob2RzLk1ldGhvZCkgPT4gbS5vdXRwdXRKYXZhU2NyaXB0RnVuY3Rpb24oanNDbGFzc05hbWUsIG91dHB1dFN0cmVhbSkpO1xuXG4gICAgLy8gTWlyYW5kYSBhbmQgZGVmYXVsdCBpbnRlcmZhY2UgbWV0aG9kcy5cbiAgICB0aGlzLmdldE1pcmFuZGFBbmREZWZhdWx0TWV0aG9kcygpLmZvckVhY2goKG06IG1ldGhvZHMuTWV0aG9kKSA9PiBtLm91dHB1dEphdmFTY3JpcHRGdW5jdGlvbihqc0NsYXNzTmFtZSwgb3V0cHV0U3RyZWFtKSk7XG5cbiAgICAvLyBVbmluaGVyaXRlZCBkZWZhdWx0IG1ldGhvZHMuXG4gICAgdGhpcy5nZXRVbmluaGVyaXRlZERlZmF1bHRNZXRob2RzKCkuZm9yRWFjaCgobTogbWV0aG9kcy5NZXRob2QpID0+IG0ub3V0cHV0SmF2YVNjcmlwdEZ1bmN0aW9uKGpzQ2xhc3NOYW1lLCBvdXRwdXRTdHJlYW0sIHRydWUpKTtcblxuICAgIG91dHB1dFN0cmVhbS53cml0ZShgICByZXR1cm4gJHtqc0NsYXNzTmFtZX07XG59XG5fY3JlYXRlYCk7XG5cbiAgICB2YXIgZXZhbFRleHQgPSBvdXRwdXRTdHJlYW0uZmx1c2goKTtcbiAgICAvLyBOT1RFOiBUaHJlYWQgd2lsbCBiZSBudWxsIGR1cmluZyBzeXN0ZW0gYm9vdHN0cmFwcGluZy5cbiAgICBpZiAodHlwZW9mIFJFTEVBU0UgPT09ICd1bmRlZmluZWQnICYmIHRocmVhZCAhPT0gbnVsbCAmJiB0aHJlYWQuZ2V0SlZNKCkuc2hvdWxkRHVtcENvbXBpbGVkQ29kZSgpKSB7XG4gICAgICB0aHJlYWQuZ2V0SlZNKCkuZHVtcE9iamVjdERlZmluaXRpb24odGhpcywgZXZhbFRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbChldmFsVGV4dCkoZXh0ZW5kQ2xhc3MsIHRoaXMsIEludGVybmFsU3RhY2tGcmFtZSwgTmF0aXZlU3RhY2tGcmFtZSwgQnl0ZWNvZGVTdGFja0ZyYW1lLCBnTG9uZy5aRVJPLCByZXF1aXJlKCcuL0NsYXNzTG9hZGVyJyksIHJlcXVpcmUoJy4vTW9uaXRvcicpLCB0aHJlYWQpO1xuICB9XG5cbiAgcHVibGljIGdldENvbnN0cnVjdG9yKHRocmVhZDogSlZNVGhyZWFkKTogSUpWTUNvbnN0cnVjdG9yPFQ+IHtcbiAgICBpZiAodGhpcy5fY29uc3RydWN0b3IgPT0gbnVsbCkge1xuICAgICAgYXNzZXJ0KHRoaXMuaXNSZXNvbHZlZCgpLCBgQ2Fubm90IGNvbnN0cnVjdCAke3RoaXMuZ2V0SW50ZXJuYWxOYW1lKCl9J3MgY29uc3RydWN0b3IgdW50aWwgaXQgaXMgcmVzb2x2ZWQuYCk7XG4gICAgICB0aGlzLl9jb25zdHJ1Y3RvciA9IHRoaXMuX2NvbnN0cnVjdENvbnN0cnVjdG9yKHRocmVhZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RvcjtcbiAgfVxufVxuIiwiLyoqXG4gKiBBZ2dyZWdhdGVzIC5jbGFzcyBmaWxlLXJlbGF0ZWQgQVBJcyB1bmRlciBhIHNpbmdsZSBpbnRlcmZhY2UgKERvcHBpby5WTS5DbGFzc0ZpbGUpXG4gKi9cblxuaW1wb3J0ICogYXMgQ29uc3RhbnRQb29sIGZyb20gJy4vQ29uc3RhbnRQb29sJztcbmltcG9ydCAqIGFzIEF0dHJpYnV0ZXMgZnJvbSAnLi9hdHRyaWJ1dGVzJztcblxuZXhwb3J0ICogZnJvbSAnLi9DbGFzc0RhdGEnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXRob2RzJztcbmV4cG9ydCAqIGZyb20gJy4vQ2xhc3NMb2FkZXInO1xuZXhwb3J0ICogZnJvbSAnLi9jbGFzc3BhdGgnO1xuZXhwb3J0IHtDb25zdGFudFBvb2wsIEF0dHJpYnV0ZXN9O1xuIiwiaW1wb3J0IHtDbGFzc0RhdGEsIFJlZmVyZW5jZUNsYXNzRGF0YSwgQXJyYXlDbGFzc0RhdGEsIFByaW1pdGl2ZUNsYXNzRGF0YX0gZnJvbSAnLi9DbGFzc0RhdGEnO1xuaW1wb3J0IHRocmVhZGluZyA9IHJlcXVpcmUoJy4vdGhyZWFkaW5nJyk7XG5pbXBvcnQgQ2xhc3NMb2NrID0gcmVxdWlyZSgnLi9DbGFzc0xvY2snKTtcbmltcG9ydCB7SUNsYXNzcGF0aEl0ZW0sIENsYXNzcGF0aEZhY3Rvcnl9IGZyb20gJy4vY2xhc3NwYXRoJztcbmltcG9ydCB7VHJpU3RhdGV9IGZyb20gJy4vZW51bXMnO1xuaW1wb3J0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmltcG9ydCBtZXRob2RzID0gcmVxdWlyZSgnLi9tZXRob2RzJyk7XG5pbXBvcnQgbG9nZ2luZyA9IHJlcXVpcmUoJy4vbG9nZ2luZycpO1xuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5pbXBvcnQgSkFSID0gcmVxdWlyZSgnLi9qYXInKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmltcG9ydCBKVk1UeXBlcyA9IHJlcXVpcmUoJy4uL2luY2x1ZGVzL0pWTVR5cGVzJyk7XG52YXIgZGVidWcgPSBsb2dnaW5nLmRlYnVnO1xuXG4vKipcbiAqIFVzZWQgdG8gbG9jayBjbGFzc2VzIGZvciBsb2FkaW5nLlxuICovXG5jbGFzcyBDbGFzc0xvY2tzIHtcbiAgLyoqXG4gICAqIHR5cHJTdHIgPT4gYXJyYXkgb2YgY2FsbGJhY2tzIHRvIHRyaWdnZXIgd2hlbiBvcGVyYXRpb24gY29tcGxldGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBsb2NrczogeyBbdHlwZVN0cjogc3RyaW5nXTogQ2xhc3NMb2NrIH0gPSB7fTtcblxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbG9jayBmb3IgdGhlIGdpdmVuIGNsYXNzIGlzIGFscmVhZHkgdGFrZW4uIElmIG5vdCwgaXQgdGFrZXNcbiAgICogdGhlIGxvY2suIElmIGl0IGlzIHRha2VuLCB3ZSBlbnF1ZXVlIHRoZSBjYWxsYmFjay5cbiAgICogTk9URTogRm9yIGNvbnZlbmllbmNlLCB3aWxsIGhhbmRsZSB0cmlnZ2VyaW5nIHRoZSBvd25lcidzIGNhbGxiYWNrIGFzIHdlbGwuXG4gICAqL1xuICBwdWJsaWMgdHJ5TG9jayh0eXBlU3RyOiBzdHJpbmcsIHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2I6IChjZGF0YTogQ2xhc3NEYXRhKSA9PiB2b2lkKTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxvY2tzW3R5cGVTdHJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sb2Nrc1t0eXBlU3RyXSA9IG5ldyBDbGFzc0xvY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9ja3NbdHlwZVN0cl0udHJ5TG9jayh0aHJlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgbG9jayBvbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgKi9cbiAgcHVibGljIHVubG9jayh0eXBlU3RyOiBzdHJpbmcsIGNkYXRhOiBDbGFzc0RhdGEpOiB2b2lkIHtcbiAgICB0aGlzLmxvY2tzW3R5cGVTdHJdLnVubG9jayhjZGF0YSk7XG4gICAgLy8gTm8gbmVlZCBmb3IgdGhpcyBsb2NrIHRvIHJlbWFpbi5cbiAgICBkZWxldGUgdGhpcy5sb2Nrc1t0eXBlU3RyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvd25pbmcgdGhyZWFkIG9mIGEgZ2l2ZW4gbG9jay4gUmV0dXJucyBudWxsIGlmIHRoZSBzcGVjaWZpZWRcbiAgICogdHlwZSBzdHJpbmcgaXMgbm90IGxvY2tlZC5cbiAgICovXG4gIHB1YmxpYyBnZXRPd25lcih0eXBlU3RyOiBzdHJpbmcpOiB0aHJlYWRpbmcuSlZNVGhyZWFkIHtcbiAgICBpZiAodGhpcy5sb2Nrc1t0eXBlU3RyXSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9ja3NbdHlwZVN0cl0uZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzbG9hZGVyIGNsYXNzLiBDb250YWlucyBjb21tb24gY2xhc3MgcmVzb2x1dGlvbiBhbmQgaW5zdGFudGlhdGlvblxuICogbG9naWMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDbGFzc0xvYWRlciB7XG4gIC8qKlxuICAgKiBTdG9yZXMgbG9hZGVkICpyZWZlcmVuY2UqIGFuZCAqYXJyYXkqIGNsYXNzZXMuXG4gICAqL1xuICBwcml2YXRlIGxvYWRlZENsYXNzZXM6IHsgW3R5cGVTdHI6IHN0cmluZ106IENsYXNzRGF0YSB9ID0ge307XG4gIC8qKlxuICAgKiBTdG9yZXMgY2FsbGJhY2tzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIGFub3RoZXIgdGhyZWFkIHRvIGZpbmlzaCBsb2FkaW5nXG4gICAqIHRoZSBzcGVjaWZpZWQgY2xhc3MuXG4gICAqL1xuICBwcml2YXRlIGxvYWRDbGFzc0xvY2tzOiBDbGFzc0xvY2tzID0gbmV3IENsYXNzTG9ja3MoKTtcblxuICAvKipcbiAgICogQHBhcmFtIGJvb3RzdHJhcCBUaGUgSlZNJ3MgYm9vdHN0cmFwIGNsYXNzbG9hZGVyLiBDbGFzc0xvYWRlcnMgdXNlIGl0XG4gICAqICAgdG8gcmV0cmlldmUgcHJpbWl0aXZlIHR5cGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIGJvb3RzdHJhcDogQm9vdHN0cmFwQ2xhc3NMb2FkZXIpIHsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIGxpc3Rpbmcgb2YgY2xhc3NlcyB0aGF0IGFyZSBsb2FkZWQgaW4gdGhpcyBjbGFzcyBsb2FkZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9hZGVkQ2xhc3NOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubG9hZGVkQ2xhc3Nlcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIGNsYXNzIHRvIHRoZSBjbGFzc2xvYWRlci4gQXMgb3Bwb3NlZCB0byBkZWZpbmVDbGFzcyxcbiAgICogd2hpY2ggZGVmaW5lcyBhIG5ldyBjbGFzcyBmcm9tIGJ5dGVzIHdpdGggdGhlIGNsYXNzbG9hZGVyLlxuICAgKlxuICAgKiBXaGF0J3MgdGhlIGRpZmZlcmVuY2U/XG4gICAqICogQ2xhc3NlcyBjcmVhdGVkIHdpdGggZGVmaW5lQ2xhc3MgYXJlIGRlZmluZWQgYnkgdGhpcyBjbGFzc2xvYWRlci5cbiAgICogKiBDbGFzc2VzIGFkZGVkIHdpdGggYWRkQ2xhc3MgbWF5IGhhdmUgYmVlbiBkZWZpbmVkIGJ5IGEgZGlmZmVyZW50XG4gICAqICAgY2xhc3Nsb2FkZXIuIFRoaXMgaGFwcGVucyB3aGVuIGEgY3VzdG9tIGNsYXNzIGxvYWRlcidzIGxvYWRDbGFzc1xuICAgKiAgIGZ1bmN0aW9uIHByb3hpZXMgY2xhc3Nsb2FkaW5nIHRvIGEgZGlmZmVyZW50IGNsYXNzbG9hZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZVN0ciBUaGUgdHlwZSBzdHJpbmcgb2YgdGhlIGNsYXNzLlxuICAgKiBAcGFyYW0gY2xhc3NEYXRhIFRoZSBjbGFzcyBkYXRhIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIGFkZENsYXNzKHR5cGVTdHI6IHN0cmluZywgY2xhc3NEYXRhOiBDbGFzc0RhdGEpOiB2b2lkIHtcbiAgICAvLyBJZiB0aGUgY2xhc3MgaXMgYWxyZWFkeSBhZGRlZCwgZW5zdXJlIGl0IGlzIHRoZSBzYW1lIGNsYXNzIHdlIGFyZSBhZGRpbmcgYWdhaW4uXG4gICAgYXNzZXJ0KHRoaXMubG9hZGVkQ2xhc3Nlc1t0eXBlU3RyXSAhPSBudWxsID8gdGhpcy5sb2FkZWRDbGFzc2VzW3R5cGVTdHJdID09PSBjbGFzc0RhdGEgOiB0cnVlKTtcbiAgICB0aGlzLmxvYWRlZENsYXNzZXNbdHlwZVN0cl0gPSBjbGFzc0RhdGE7XG4gIH1cblxuICAvKipcbiAgICogTm8tZnJpbGxzLiBHZXQgdGhlIGNsYXNzIGlmIGl0J3MgZGVmaW5lZCBpbiB0aGUgY2xhc3MgbG9hZGVyLCBubyBtYXR0ZXJcbiAgICogd2hhdCBzaGFwZSBpdCBpcyBpbi5cbiAgICpcbiAgICogU2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5IGJ5IENsYXNzTG9hZGVyIHN1YmNsYXNzZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0Q2xhc3ModHlwZVN0cjogc3RyaW5nKTogQ2xhc3NEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZWRDbGFzc2VzW3R5cGVTdHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBuZXcgY2xhc3Mgd2l0aCB0aGUgY2xhc3MgbG9hZGVyIGZyb20gYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAqIEBwYXJhbSB0aHJlYWQgVGhlIHRocmVhZCB0aGF0IGlzIGN1cnJlbnRseSBpbiBjb250cm9sIHdoZW4gdGhpcyBjbGFzcyBpc1xuICAgKiAgIGJlaW5nIGRlZmluZWQuIEFuIGV4Y2VwdGlvbiBtYXkgYmUgdGhyb3duIGlmIHRoZXJlIGlzIGFuIGlzc3VlIHBhcnNpbmdcbiAgICogICB0aGUgY2xhc3MgZmlsZS5cbiAgICogQHBhcmFtIHR5cGVTdHIgVGhlIHR5cGUgc3RyaW5nIG9mIHRoZSBjbGFzcyAoZS5nLiBcIkxqYXZhL2xhbmcvT2JqZWN0O1wiKVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGNsYXNzIGFzIGEgYmluYXJ5IGJsb2IuXG4gICAqIEBwYXJhbSBwcm90ZWN0aW9uRG9tYWluIFRoZSBwcm90ZWN0aW9uIGRvbWFpbiBmb3IgdGhlIGNsYXNzIChjYW4gYmUgTlVMTCkuXG4gICAqIEByZXR1cm4gVGhlIGRlZmluZWQgY2xhc3MsIG9yIG51bGwgaWYgdGhlcmUgd2FzIGFuIGlzc3VlLlxuICAgKi9cbiAgcHVibGljIGRlZmluZUNsYXNzPFQgZXh0ZW5kcyBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0Pih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHR5cGVTdHI6IHN0cmluZywgZGF0YTogQnVmZmVyLCBwcm90ZWN0aW9uRG9tYWluOiBKVk1UeXBlcy5qYXZhX3NlY3VyaXR5X1Byb3RlY3Rpb25Eb21haW4pOiBSZWZlcmVuY2VDbGFzc0RhdGE8VD4ge1xuICAgIHRyeSB7XG4gICAgICB2YXIgY2xhc3NEYXRhID0gbmV3IFJlZmVyZW5jZUNsYXNzRGF0YTxUPihkYXRhLCBwcm90ZWN0aW9uRG9tYWluLCB0aGlzKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3ModHlwZVN0ciwgY2xhc3NEYXRhKTtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQm9vdHN0cmFwQ2xhc3NMb2FkZXIpIHtcbiAgICAgICAgZGVidWcoYFtCT09UU1RSQVBdIERlZmluaW5nIGNsYXNzICR7dHlwZVN0cn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKGBbQ1VTVE9NXSBEZWZpbmluZyBjbGFzcyAke3R5cGVTdHJ9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhc3NEYXRhO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aHJlYWQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIG9ubHkgaGFwcGVuIHdoZW4gd2UncmUgbG9hZGluZyBqYXZhL2xhbmcvVGhyZWFkIGZvclxuICAgICAgICAvLyB0aGUgdmVyeSBmaXJzdCB0aW1lLlxuICAgICAgICBsb2dnaW5nLmVycm9yKGBKVk0gaW5pdGlhbGl6YXRpb24gZmFpbGVkOiAke2V9YCk7XG4gICAgICAgIGxvZ2dpbmcuZXJyb3IoZS5zdGFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvQ2xhc3NGb3JtYXRFcnJvcjsnLCBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgbmV3IGFycmF5IGNsYXNzIHdpdGggdGhpcyBsb2FkZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgZGVmaW5lQXJyYXlDbGFzczxUPih0eXBlU3RyOiBzdHJpbmcpOiBBcnJheUNsYXNzRGF0YTxUPiB7XG4gICAgYXNzZXJ0KHRoaXMuZ2V0TG9hZGVkQ2xhc3ModXRpbC5nZXRfY29tcG9uZW50X3R5cGUodHlwZVN0cikpICE9IG51bGwpO1xuICAgIHZhciBhcnJheUNsYXNzID0gbmV3IEFycmF5Q2xhc3NEYXRhPFQ+KHV0aWwuZ2V0X2NvbXBvbmVudF90eXBlKHR5cGVTdHIpLCB0aGlzKTtcbiAgICB0aGlzLmFkZENsYXNzKHR5cGVTdHIsIGFycmF5Q2xhc3MpO1xuICAgIHJldHVybiBhcnJheUNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJldHJpZXZlIHRoZSBnaXZlbiBsb2FkZWQgY2xhc3MuXG4gICAqIEBwYXJhbSB0eXBlU3RyIFRoZSBuYW1lIG9mIHRoZSBjbGFzcy5cbiAgICogQHJldHVybiBSZXR1cm5zIHRoZSBsb2FkZWQgY2xhc3MsIG9yIG51bGwgaWYgbm8gc3VjaCBjbGFzcyBpcyBjdXJyZW50bHlcbiAgICogICBsb2FkZWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9hZGVkQ2xhc3ModHlwZVN0cjogc3RyaW5nKTogQ2xhc3NEYXRhIHtcbiAgICB2YXIgY2xzID0gdGhpcy5sb2FkZWRDbGFzc2VzW3R5cGVTdHJdO1xuICAgIGlmIChjbHMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNscztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHV0aWwuaXNfcHJpbWl0aXZlX3R5cGUodHlwZVN0cikpIHtcbiAgICAgICAgLy8gUHJpbWl0aXZlIGNsYXNzZXMgbXVzdCBiZSBmZXRjaGVkIGZyb20gdGhlIGJvb3RzdHJhcCBjbGFzc2xvYWRlci5cbiAgICAgICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwLmdldFByaW1pdGl2ZUNsYXNzKHR5cGVTdHIpO1xuICAgICAgfSBlbHNlIGlmICh1dGlsLmlzX2FycmF5X3R5cGUodHlwZVN0cikpIHtcbiAgICAgICAgLy8gV2UgbWlnaHQgYmUgYWJsZSB0byBsb2FkIHRoaXMgYXJyYXkgY2xhc3Mgc3luY2hyb25vdXNseS5cbiAgICAgICAgLy8gQ29tcG9uZW50IGNsYXNzIG11c3QgYmUgbG9hZGVkLiBBbmQgd2UgbXVzdCBkZWZpbmUgdGhlIGFycmF5IGNsYXNzXG4gICAgICAgIC8vIHdpdGggdGhlIGNvbXBvbmVudCBjbGFzcydzIGxvYWRlci5cbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuZ2V0TG9hZGVkQ2xhc3ModXRpbC5nZXRfY29tcG9uZW50X3R5cGUodHlwZVN0cikpO1xuICAgICAgICBpZiAoY29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50Q2wgPSBjb21wb25lbnQuZ2V0TG9hZGVyKCk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudENsID09PSB0aGlzKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSByZXNwb25zaWJsZSBmb3IgZGVmaW5pbmcgdGhlIGFycmF5IGNsYXNzLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lQXJyYXlDbGFzcyh0eXBlU3RyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVsZWdhdGUgdG8gdGhlIG90aGVyIGxvYWRlciwgdGhlbiBhZGQgdGhlIGNsYXNzIHRvIG91ciBsb2FkZWRcbiAgICAgICAgICAgIC8vIHJvc3Rlci5cbiAgICAgICAgICAgIGNscyA9IGNvbXBvbmVudENsLmdldExvYWRlZENsYXNzKHR5cGVTdHIpO1xuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcyh0eXBlU3RyLCBjbHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byByZXRyaWV2ZSB0aGUgZ2l2ZW4gcmVzb2x2ZWQgY2xhc3MuXG4gICAqIEBwYXJhbSB0eXBlU3RyIFRoZSBuYW1lIG9mIHRoZSBjbGFzcy5cbiAgICogQHJldHVybiBSZXR1cm5zIHRoZSBjbGFzcyBpZiBpdCBpcyBib3RoIGxvYWRlZCBhbmQgcmVzb2x2ZWQuIFJldHVybnMgbnVsbFxuICAgKiAgIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuICAgKi9cbiAgcHVibGljIGdldFJlc29sdmVkQ2xhc3ModHlwZVN0cjogc3RyaW5nKTogQ2xhc3NEYXRhIHtcbiAgICB2YXIgY2xzID0gdGhpcy5nZXRMb2FkZWRDbGFzcyh0eXBlU3RyKTtcbiAgICBpZiAoY2xzICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2xzLmlzUmVzb2x2ZWQoKSB8fCBjbHMudHJ5VG9SZXNvbHZlKCkpIHtcbiAgICAgICAgcmV0dXJuIGNscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmV0cmlldmUgdGhlIGdpdmVuIGluaXRpYWxpemVkIGNsYXNzLlxuICAgKiBAcGFyYW0gdHlwZVN0ciBUaGUgbmFtZSBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm4gUmV0dXJucyB0aGUgY2xhc3MgaWYgaXQgaXMgaW5pdGlhbGl6ZWQuIFJldHVybnMgbnVsbCBpZiB0aGlzIGlzXG4gICAqICAgbm90IHRoZSBjYXNlLlxuICAgKi9cbiAgcHVibGljIGdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCB0eXBlU3RyOiBzdHJpbmcpOiBDbGFzc0RhdGEge1xuICAgIHZhciBjbHMgPSB0aGlzLmdldExvYWRlZENsYXNzKHR5cGVTdHIpO1xuICAgIGlmIChjbHMgIT09IG51bGwpIHtcbiAgICAgIGlmIChjbHMuaXNJbml0aWFsaXplZCh0aHJlYWQpIHx8IGNscy50cnlUb0luaXRpYWxpemUoKSkge1xuICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGxvYWRzIHRoZSBnaXZlbiBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyBsb2FkQ2xhc3ModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCB0eXBlU3RyOiBzdHJpbmcsIGNiOiAoY2RhdGE6IENsYXNzRGF0YSkgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgLy8gU2VlIGlmIHdlIGNhbiBncmFiIHRoaXMgc3luY2hyb25vdXNseSBmaXJzdC5cbiAgICB2YXIgY2RhdGEgPSB0aGlzLmdldExvYWRlZENsYXNzKHR5cGVTdHIpO1xuICAgIGlmIChjZGF0YSkge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgY2IoY2RhdGEpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENoZWNrIHRoZSBsb2FkQ2xhc3MgbG9jayBmb3IgdGhpcyBjbGFzcy5cbiAgICAgIGlmICh0aGlzLmxvYWRDbGFzc0xvY2tzLnRyeUxvY2sodHlwZVN0ciwgdGhyZWFkLCBjYikpIHtcbiAgICAgICAgLy8gQXN5bmMgaXQgaXMhXG4gICAgICAgIGlmICh1dGlsLmlzX3JlZmVyZW5jZV90eXBlKHR5cGVTdHIpKSB7XG4gICAgICAgICAgdGhpcy5fbG9hZENsYXNzKHRocmVhZCwgdHlwZVN0ciwgKGNkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRDbGFzc0xvY2tzLnVubG9jayh0eXBlU3RyLCBjZGF0YSk7XG4gICAgICAgICAgfSwgZXhwbGljaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFycmF5XG4gICAgICAgICAgdGhpcy5sb2FkQ2xhc3ModGhyZWFkLCB1dGlsLmdldF9jb21wb25lbnRfdHlwZSh0eXBlU3RyKSwgKGNkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBTeW5jaHJvbm91c2x5IHdpbGwgd29yayBub3cuXG4gICAgICAgICAgICAgIHRoaXMubG9hZENsYXNzTG9ja3MudW5sb2NrKHR5cGVTdHIsIHRoaXMuZ2V0TG9hZGVkQ2xhc3ModHlwZVN0cikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGV4cGxpY2l0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBsb2FkcyB0aGUgZ2l2ZW4gY2xhc3MuIFdvcmtzIGRpZmZlcmVudGx5IGZvciBib290c3RyYXAgYW5kXG4gICAqIGN1c3RvbSBjbGFzcyBsb2FkZXJzLlxuICAgKlxuICAgKiBTaG91bGQgbmV2ZXIgYmUgaW52b2tlZCBkaXJlY3RseSEgVXNlIGxvYWRDbGFzcy5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfbG9hZENsYXNzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgdHlwZVN0cjogc3RyaW5nLCBjYjogKGNkYXRhOiBDbGFzc0RhdGEpID0+IHZvaWQsIGV4cGxpY2l0PzogYm9vbGVhbik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uOiBSZXNvbHZlIG1hbnkgY2xhc3Nlcy4gQ2FsbHMgY2Igd2l0aCBudWxsIHNob3VsZFxuICAgKiBhbiBlcnJvciBvY2N1ci5cbiAgICovXG4gIHB1YmxpYyByZXNvbHZlQ2xhc3Nlcyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHR5cGVTdHJzOiBzdHJpbmdbXSwgY2I6IChjbGFzc2VzOiB7IFt0eXBlU3RyOiBzdHJpbmddOiBDbGFzc0RhdGEgfSkgPT4gdm9pZCkge1xuICAgIHZhciBjbGFzc2VzOiB7IFt0eXBlU3RyOiBzdHJpbmddOiBDbGFzc0RhdGEgfSA9IHt9O1xuICAgIHV0aWwuYXN5bmNGb3JFYWNoPHN0cmluZz4odHlwZVN0cnMsICh0eXBlU3RyOiBzdHJpbmcsIG5leHRfaXRlbTogKGVycj86IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlQ2xhc3ModGhyZWFkLCB0eXBlU3RyLCAoY2RhdGEpID0+IHtcbiAgICAgICAgaWYgKGNkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dF9pdGVtKGBFcnJvciByZXNvbHZpbmcgY2xhc3M6ICR7dHlwZVN0cn1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGFzc2VzW3R5cGVTdHJdID0gY2RhdGE7XG4gICAgICAgICAgbmV4dF9pdGVtKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIChlcnI/OiBhbnkpOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihjbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSAqcmVzb2x2ZXMqIHRoZSBnaXZlbiBjbGFzcyBieSBsb2FkaW5nIHRoZSBjbGFzcyBhbmRcbiAgICogcmVzb2x2aW5nIGl0cyBzdXBlciBjbGFzcywgaW50ZXJmYWNlcywgYW5kL29yIGNvbXBvbmVudCBjbGFzc2VzLlxuICAgKi9cbiAgcHVibGljIHJlc29sdmVDbGFzcyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHR5cGVTdHI6IHN0cmluZywgY2I6IChjZGF0YTogQ2xhc3NEYXRhKSA9PiB2b2lkLCBleHBsaWNpdDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWRDbGFzcyh0aHJlYWQsIHR5cGVTdHIsIChjZGF0YTogQ2xhc3NEYXRhKSA9PiB7XG4gICAgICBpZiAoY2RhdGEgPT09IG51bGwgfHwgY2RhdGEuaXNSZXNvbHZlZCgpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8hIEVpdGhlciBjZGF0YSBpcyBudWxsLCBhbiBleGNlcHRpb24gdHJpZ2dlcmVkLCBhbmQgd2VcbiAgICAgICAgLy8gZmFpbGVkLCBvciBjZGF0YSBpcyBhbHJlYWR5IHJlc29sdmVkLlxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4geyBjYihjZGF0YSk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2RhdGEucmVzb2x2ZSh0aHJlYWQsIGNiLCBleHBsaWNpdCk7XG4gICAgICB9XG4gICAgfSwgZXhwbGljaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5ICppbml0aWFsaXplcyogdGhlIGdpdmVuIGNsYXNzIGFuZCBpdHMgc3VwZXIgY2xhc3Nlcy5cbiAgICovXG4gIHB1YmxpYyBpbml0aWFsaXplQ2xhc3ModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCB0eXBlU3RyOiBzdHJpbmcsIGNiOiAoY2RhdGE6IENsYXNzRGF0YSkgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgLy8gR2V0IHRoZSByZXNvbHZlZCBjbGFzcy5cbiAgICB0aGlzLnJlc29sdmVDbGFzcyh0aHJlYWQsIHR5cGVTdHIsIChjZGF0YTogQ2xhc3NEYXRhKSA9PiB7XG4gICAgICBpZiAoY2RhdGEgPT09IG51bGwgfHwgY2RhdGEuaXNJbml0aWFsaXplZCh0aHJlYWQpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8hIEVpdGhlciByZXNvbHV0aW9uIGZhaWxlZCBhbmQgYW4gZXhjZXB0aW9uIGhhcyBhbHJlYWR5XG4gICAgICAgIC8vIGJlZW4gdGhyb3duLCBjZGF0YSBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCBvciB0aGUgY3VycmVudCB0aHJlYWQgaXNcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSBjbGFzcy5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICBjYihjZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHV0aWwuaXNfcmVmZXJlbmNlX3R5cGUodHlwZVN0cikpO1xuICAgICAgICAoPFJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0Pj4gY2RhdGEpLmluaXRpYWxpemUodGhyZWFkLCBjYiwgZXhwbGljaXQpO1xuICAgICAgfVxuICAgIH0sIGV4cGxpY2l0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgdGhlIGFwcHJvcHJpYXRlIGV4Y2VwdGlvbi9lcnJvciBmb3IgYSBjbGFzcyBub3QgYmVpbmcgZm91bmQuXG4gICAqIElmIGxvYWRpbmcgd2FzIGltcGxpY2l0bHkgdHJpZ2dlcmVkIGJ5IHRoZSBKVk0sIHdlIGNhbGwgTm9DbGFzc0RlZkZvdW5kRXJyb3IuXG4gICAqIElmIHRoZSBwcm9ncmFtIGV4cGxpY2l0bHkgY2FsbGVkIGxvYWRDbGFzcywgdGhlbiB3ZSB0aHJvdyB0aGUgQ2xhc3NOb3RGb3VuZEV4Y2VwdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCB0aHJvd0NsYXNzTm90Rm91bmRFeGNlcHRpb24odGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCB0eXBlU3RyOiBzdHJpbmcsIGV4cGxpY2l0OiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhyZWFkLnRocm93TmV3RXhjZXB0aW9uKGV4cGxpY2l0ID8gJ0xqYXZhL2xhbmcvQ2xhc3NOb3RGb3VuZEV4Y2VwdGlvbjsnIDogJ0xqYXZhL2xhbmcvTm9DbGFzc0RlZkZvdW5kRXJyb3I7JywgYENhbm5vdCBsb2FkIGNsYXNzOiAke3V0aWwuZXh0X2NsYXNzbmFtZSh0eXBlU3RyKX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBKVk0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBDbGFzc0xvYWRlci5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBnZXRMb2FkZXJPYmplY3QoKTogSlZNVHlwZXMuamF2YV9sYW5nX0NsYXNzTG9hZGVyO1xufVxuXG4vKipcbiAqIFRoZSBKVk0ncyBib290c3RyYXAgY2xhc3MgbG9hZGVyLiBMb2FkcyBjbGFzc2VzIGRpcmVjdGx5IGZyb20gZmlsZXMgb24gdGhlXG4gKiBmaWxlIHN5c3RlbS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcENsYXNzTG9hZGVyIGV4dGVuZHMgQ2xhc3NMb2FkZXIge1xuICAvKipcbiAgICogVGhlIGNsYXNzcGF0aC4gVGhlIGZpcnN0IHBhdGggaW4gdGhlIGFycmF5IGlzIHRoZSBmaXJzdCBzZWFyY2hlZC5cbiAgICogTWVhbmluZzogVGhlICplbmQqIG9mIHRoaXMgYXJyYXkgaXMgdGhlIGJvb3RzdHJhcCBjbGFzcyBsb2FkZXIsIGFuZCB0aGVcbiAgICogICAqYmVnaW5uaW5nKiBvZiB0aGUgYXJyYXkgaXMgdGhlIGNsYXNzcGF0aCBpdGVtIGFkZGVkIGxhc3QuXG4gICAqL1xuICBwcml2YXRlIGNsYXNzcGF0aDogSUNsYXNzcGF0aEl0ZW1bXTtcbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIGFsbCBsb2FkZWQgcGFja2FnZXMsIGFuZCB0aGUgY2xhc3NwYXRoIGl0ZW0ocykgZnJvbVxuICAgKiB3aGVuY2UgdGhlaXIgcGFja2FnZXMgY2FtZS5cbiAgICpcbiAgICogTm90ZTogUGFja2FnZSBzZXBhcmF0b3JzIGFyZSBzcGVjaWZpZWQgd2l0aCBzbGFzaGVzICgnLycpLCBub3QgcGVyaW9kcyAoJy4nKS5cbiAgICovXG4gIHByaXZhdGUgbG9hZGVkUGFja2FnZXM6IHtbcGtnU3RyaW5nOiBzdHJpbmddOiBJQ2xhc3NwYXRoSXRlbVtdfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgYm9vdHN0cmFwIGNsYXNzbG9hZGVyIHdpdGggdGhlIGdpdmVuIGNsYXNzcGF0aC5cbiAgICogQHBhcmFtIGNsYXNzUGF0aCBUaGUgY2xhc3NwYXRoLCB3aGVyZSB0aGUgKmZpcnN0KiBpdGVtIGlzIHRoZSAqbGFzdCpcbiAgICogICBjbGFzc3BhdGggc2VhcmNoZWQuIE1lYW5pbmcsIHRoZSBjbGFzc1BhdGhbMF0gc2hvdWxkIGJlIHRoZSBib290c3RyYXBcbiAgICogICBjbGFzcyBwYXRoLlxuICAgKiBAcGFyYW0gZXh0cmFjdGlvblBhdGggVGhlIHBhdGggd2hlcmUgamFyIGZpbGVzIHNob3VsZCBiZSBleHRyYWN0ZWQuXG4gICAqIEBwYXJhbSBjYiBDYWxsZWQgb25jZSBhbGwgb2YgdGhlIGNsYXNzcGF0aCBpdGVtcyBoYXZlIGJlZW4gY2hlY2tlZC5cbiAgICogICBQYXNzZXMgYW4gZXJyb3IgaWYgb25lIG9jY3Vycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGphdmFIb21lOiBzdHJpbmcsIGNsYXNzcGF0aDogc3RyaW5nW10sIGNiOiAoZT86IGFueSkgPT4gdm9pZCkge1xuICAgIC8vIFRoZSBjb3JyZWN0IHdheSB0byBkbyB0aGlzIHdvdWxkIGJlIHN1cGVyKHRoaXMpLCBidXQgd2UgY2Fubm90IHJlZmVyZW5jZSB0aGlzIGJlZm9yZSBjYWxsaW5nIHN1cGVyKClcbiAgICBzdXBlcihudWxsKTtcbiAgICB0aGlzLmJvb3RzdHJhcCA9IHRoaXM7XG5cbiAgICB0aGlzLmNsYXNzcGF0aCA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRQYWNrYWdlcyA9IHt9O1xuXG4gICAgQ2xhc3NwYXRoRmFjdG9yeShqYXZhSG9tZSwgY2xhc3NwYXRoLCAoaXRlbXMpID0+IHtcbiAgICAgIHRoaXMuY2xhc3NwYXRoID0gaXRlbXMucmV2ZXJzZSgpO1xuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgdGhhdCBhIGdpdmVuIGNsYXNzIGhhcyBzdWNjZXNzZnVsbHkgYmVlbiBsb2FkZWQgZnJvbSB0aGUgc3BlY2lmaWVkXG4gICAqIGNsYXNzcGF0aCBpdGVtLlxuICAgKi9cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJMb2FkZWRDbGFzcyhjbHNUeXBlOiBzdHJpbmcsIGNwSXRlbTogSUNsYXNzcGF0aEl0ZW0pOiB2b2lkIHtcbiAgICBsZXQgcGtnTmFtZSA9IGNsc1R5cGUuc2xpY2UoMCwgY2xzVHlwZS5sYXN0SW5kZXhPZignLycpKSxcbiAgICAgIGl0ZW1Mb2FkZXIgPSB0aGlzLmxvYWRlZFBhY2thZ2VzW3BrZ05hbWVdO1xuICAgIGlmICghaXRlbUxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZWRQYWNrYWdlc1twa2dOYW1lXSA9IFtjcEl0ZW1dO1xuICAgIH0gZWxzZSBpZiAoaXRlbUxvYWRlclswXSAhPT0gY3BJdGVtICYmIGl0ZW1Mb2FkZXIuaW5kZXhPZihjcEl0ZW0pID09PSAtMSkge1xuICAgICAgLy8gQ29tbW9uIGNhc2Ugb3B0aW1pemF0aW9uOiBTaW1wbHkgY2hlY2sgdGhlIGZpcnN0IGFycmF5IGVsZW1lbnQuXG4gICAgICBpdGVtTG9hZGVyLnB1c2goY3BJdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Rpbmcgb2YgdHVwbGVzIGNvbnRhaW5pbmc6XG4gICAqICogVGhlIHBhY2thZ2UgbmFtZSAoZS5nLiBqYXZhL2xhbmcpXG4gICAqICogQ2xhc3NwYXRoIGxvY2F0aW9ucyB3aGVyZSBjbGFzc2VzIGluIHRoZSBwYWNrYWdlIHdlcmUgbG9hZGVkLlxuICAgKi9cbiAgcHVibGljIGdldFBhY2thZ2VzKCk6IFtzdHJpbmcsIHN0cmluZ1tdXVtdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sb2FkZWRQYWNrYWdlcykubWFwKChwa2dOYW1lOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmdbXV0gPT4ge1xuICAgICAgcmV0dXJuIFtwa2dOYW1lLCB0aGlzLmxvYWRlZFBhY2thZ2VzW3BrZ05hbWVdLm1hcCgoaXRlbSkgPT4gaXRlbS5nZXRQYXRoKCkpXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgb3IgZGVmaW5lcyB0aGUgc3BlY2lmaWVkIHByaW1pdGl2ZSBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyBnZXRQcmltaXRpdmVDbGFzcyh0eXBlU3RyOiBzdHJpbmcpOiBQcmltaXRpdmVDbGFzc0RhdGEge1xuICAgIHZhciBjZGF0YSA9IDxQcmltaXRpdmVDbGFzc0RhdGE+IHRoaXMuZ2V0Q2xhc3ModHlwZVN0cik7XG4gICAgaWYgKGNkYXRhID09IG51bGwpIHtcbiAgICAgIGNkYXRhID0gbmV3IFByaW1pdGl2ZUNsYXNzRGF0YSh0eXBlU3RyLCB0aGlzKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3ModHlwZVN0ciwgY2RhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2RhdGE7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZ2l2ZW4gY2xhc3MgZnJvbSB0aGUgY2xhc3NwYXRoLlxuICAgKlxuICAgKiBTSE9VTEQgT05MWSBCRSBJTlZPS0VEIElOVEVSTkFMTFkgQlkgVEhFIENMQVNTTE9BREVSLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sb2FkQ2xhc3ModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCB0eXBlU3RyOiBzdHJpbmcsIGNiOiAoY2RhdGE6IENsYXNzRGF0YSkgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgZGVidWcoYFtCT09UU1RSQVBdIExvYWRpbmcgY2xhc3MgJHt0eXBlU3RyfWApO1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIG9ubHkgdmFsaWQgZm9yIHJlZmVyZW5jZSB0eXBlcyFcbiAgICBhc3NlcnQodXRpbC5pc19yZWZlcmVuY2VfdHlwZSh0eXBlU3RyKSk7XG4gICAgLy8gU2VhcmNoIHRoZSBjbGFzcyBwYXRoIGZvciB0aGUgY2xhc3MuXG4gICAgbGV0IGNsc0ZpbGVQYXRoID0gdXRpbC5kZXNjcmlwdG9yMnR5cGVzdHIodHlwZVN0ciksXG4gICAgICBjUGF0aExlbiA9IHRoaXMuY2xhc3NwYXRoLmxlbmd0aCxcbiAgICAgIHRvU2VhcmNoOiBJQ2xhc3NwYXRoSXRlbVtdID0gW10sXG4gICAgICBjbHNEYXRhOiBCdWZmZXI7XG5cbiAgICBzZWFyY2hMb29wOlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY1BhdGhMZW47IGkrKykge1xuICAgICAgbGV0IGl0ZW0gPSB0aGlzLmNsYXNzcGF0aFtpXTtcbiAgICAgIHN3aXRjaCAoaXRlbS5oYXNDbGFzcyhjbHNGaWxlUGF0aCkpIHtcbiAgICAgICAgY2FzZSBUcmlTdGF0ZS5JTkRFVEVSTUlOQVRFOlxuICAgICAgICAgIHRvU2VhcmNoLnB1c2goaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVHJpU3RhdGUuVFJVRTpcbiAgICAgICAgICAvLyBCcmVhayBvdXQgb2YgdGhlIGxvb3A7IFRSVUUgcGF0aHMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgY2xhc3MuXG4gICAgICAgICAgdG9TZWFyY2gucHVzaChpdGVtKTtcbiAgICAgICAgICBicmVhayBzZWFyY2hMb29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWwuYXN5bmNGaW5kPElDbGFzc3BhdGhJdGVtPih0b1NlYXJjaCwgKHBJdGVtOiBJQ2xhc3NwYXRoSXRlbSwgY2FsbGJhY2s6IChzdWNjZXNzOiBib29sZWFuKSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICBwSXRlbS5sb2FkQ2xhc3MoY2xzRmlsZVBhdGgsIChlcnI6IEVycm9yLCBkYXRhPzogQnVmZmVyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xzRGF0YSA9IGRhdGE7XG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIChwSXRlbT86IElDbGFzc3BhdGhJdGVtKSA9PiB7XG4gICAgICBpZiAocEl0ZW0pIHtcbiAgICAgICAgbGV0IGNscyA9IHRoaXMuZGVmaW5lQ2xhc3ModGhyZWFkLCB0eXBlU3RyLCBjbHNEYXRhLCBudWxsKTtcbiAgICAgICAgaWYgKGNscyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyTG9hZGVkQ2xhc3MoY2xzRmlsZVBhdGgsIHBJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjYihjbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gc3VjaCBjbGFzcy5cbiAgICAgICAgZGVidWcoYENvdWxkIG5vdCBmaW5kIGNsYXNzICR7dHlwZVN0cn1gKTtcbiAgICAgICAgdGhpcy50aHJvd0NsYXNzTm90Rm91bmRFeGNlcHRpb24odGhyZWFkLCB0eXBlU3RyLCBleHBsaWNpdCk7XG4gICAgICAgIGNiKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0aW5nIG9mIHJlZmVyZW5jZSBjbGFzc2VzIGxvYWRlZCBpbiB0aGUgYm9vdHN0cmFwIGxvYWRlci5cbiAgICovXG4gIHB1YmxpYyBnZXRMb2FkZWRDbGFzc0ZpbGVzKCk6IHN0cmluZ1tdIHtcbiAgICB2YXIgbG9hZGVkQ2xhc3NlcyA9IHRoaXMuZ2V0TG9hZGVkQ2xhc3NOYW1lcygpO1xuICAgIHJldHVybiBsb2FkZWRDbGFzc2VzLmZpbHRlcigoY2xzTmFtZTogc3RyaW5nKSA9PiB1dGlsLmlzX3JlZmVyZW5jZV90eXBlKGNsc05hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBKVk0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBDbGFzc0xvYWRlci5cbiAgICogQHRvZG8gUmVwcmVzZW50IHRoZSBib290c3RyYXAgYnkgc29tZXRoaW5nIG90aGVyIHRoYW4gJ251bGwnLlxuICAgKiBAdG9kbyBUaGVzZSBzaG91bGQgYmUgb25lLWluLXRoZS1zYW1lLlxuICAgKi9cbiAgcHVibGljIGdldExvYWRlck9iamVjdCgpOiBKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3NMb2FkZXIge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY2xhc3NwYXRoLlxuICAgKi9cbiAgcHVibGljIGdldENsYXNzUGF0aCgpOiBzdHJpbmdbXSB7XG4gICAgbGV0IGNwTGVuID0gdGhpcy5jbGFzc3BhdGgubGVuZ3RoLFxuICAgICAgY3BTdHJpbmdzOiBzdHJpbmdbXSA9IG5ldyBBcnJheTxzdHJpbmc+KGNwTGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNwTGVuOyBpKyspIHtcbiAgICAgIC8vIFJldmVyc2UgaXQgc28gaXQgaXMgdGhlIGV4cGVjdGVkIG9yZGVyIChsYXN0IGl0ZW0gaXMgZmlyc3Qgc2VhcmNoIHRhcmdldClcbiAgICAgIGNwU3RyaW5nc1tpXSA9IHRoaXMuY2xhc3NwYXRoW2NwTGVuIC0gaSAtIDFdLmdldFBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNwU3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGFzc3BhdGggaXRlbSBvYmplY3RzIGluIHRoZSBjbGFzc3BhdGguXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2xhc3NQYXRoSXRlbXMoKTogSUNsYXNzcGF0aEl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NwYXRoLnNsaWNlKDApO1xuICB9XG59XG5cbi8qKlxuICogQSBDdXN0b20gQ2xhc3NMb2FkZXIuIExvYWRzIGNsYXNzZXMgYnkgY2FsbGluZyBsb2FkQ2xhc3Mgb24gdGhlIHVzZXItZGVmaW5lZFxuICogbG9hZGVyLlxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQ2xhc3NMb2FkZXIgZXh0ZW5kcyBDbGFzc0xvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGJvb3RzdHJhcDogQm9vdHN0cmFwQ2xhc3NMb2FkZXIsXG4gICAgcHJpdmF0ZSBsb2FkZXJPYmo6IEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzc0xvYWRlcikge1xuICAgIHN1cGVyKGJvb3RzdHJhcCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZ2l2ZW4gY2xhc3MgZnJvbSB0aGUgY2xhc3NwYXRoLiBDYWxscyB0aGVcbiAgICogY2xhc3Nsb2FkZXIncyBsb2FkQ2xhc3MgbWV0aG9kLlxuICAgKlxuICAgKiBTSE9VTEQgT05MWSBCRSBJTlZPS0VEIEJZIFRIRSBDTEFTUyBMT0FERVIuXG4gICAqXG4gICAqIEBwYXJhbSB0aHJlYWQgVGhlIHRocmVhZCB0aGF0IHRyaWdnZXJlZCB0aGUgbG9hZGluZy5cbiAgICogQHBhcmFtIHR5cGVTdHIgVGhlIHR5cGUgc3RyaW5nIG9mIHRoZSBjbGFzcy5cbiAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBjbGFzcy4gSXQgd2lsbFxuICAgKiAgIGJlIHBhc3NlZCBhIG51bGwgaWYgdGhlcmUgaXMgYW4gZXJyb3IgLS0gd2hpY2ggYWxzbyBpbmRpY2F0ZXMgdGhhdCBpdFxuICAgKiAgIHRocmV3IGFuIGV4Y2VwdGlvbiBvbiB0aGUgSlZNIHRocmVhZC5cbiAgICogQHBhcmFtIGV4cGxpY2l0ICdUcnVlJyBpZiBsb2FkQ2xhc3Mgd2FzIGV4cGxpY2l0bHkgaW52b2tlZCBieSB0aGUgcHJvZ3JhbSxcbiAgICogICBmYWxzZSBvdGhlcndpc2UuIFRoaXMgY2hhbmdlcyB0aGUgZXhjZXB0aW9uL2Vycm9yIHRoYXQgd2UgdGhyb3cuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xvYWRDbGFzcyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHR5cGVTdHI6IHN0cmluZywgY2I6IChjZGF0YTogQ2xhc3NEYXRhKSA9PiB2b2lkLCBleHBsaWNpdDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICBkZWJ1ZyhgW0NVU1RPTV0gTG9hZGluZyBjbGFzcyAke3R5cGVTdHJ9YCk7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgb25seSB2YWxpZCBmb3IgcmVmZXJlbmNlIHR5cGVzIVxuICAgIGFzc2VydCh1dGlsLmlzX3JlZmVyZW5jZV90eXBlKHR5cGVTdHIpKTtcbiAgICAvLyBJbnZva2UgdGhlIGN1c3RvbSBjbGFzcyBsb2FkZXIuXG4gICAgdGhpcy5sb2FkZXJPYmpbJ2xvYWRDbGFzcyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9DbGFzczsnXSh0aHJlYWQsIFt1dGlsLmluaXRTdHJpbmcodGhpcy5ib290c3RyYXAsIHV0aWwuZXh0X2NsYXNzbmFtZSh0eXBlU3RyKSldLCAoZT86IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIGpjbz86IEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzcykgPT4ge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgLy8gRXhjZXB0aW9uISBUaGVyZSB3YXMgYW4gaXNzdWUgZGVmaW5pbmcgdGhlIGNsYXNzLlxuICAgICAgICB0aGlzLnRocm93Q2xhc3NOb3RGb3VuZEV4Y2VwdGlvbih0aHJlYWQsIHR5cGVTdHIsIGV4cGxpY2l0KTtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgdGhlIGNsYXNzIHJldHVybmVkIGJ5IGxvYWRDbGFzcywgaW4gY2FzZSB0aGUgY2xhc3Nsb2FkZXJcbiAgICAgICAgLy8gcHJveGllZCBsb2FkaW5nIHRvIGFub3RoZXIgY2xhc3Nsb2FkZXIuXG4gICAgICAgIHZhciBjbHMgPSBqY28uJGNscztcbiAgICAgICAgdGhpcy5hZGRDbGFzcyh0eXBlU3RyLCBjbHMpO1xuICAgICAgICBjYihjbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEpWTSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGlzIENsYXNzTG9hZGVyLlxuICAgKiBAdG9kbyBUaGVzZSBzaG91bGQgYmUgb25lLWluLXRoZS1zYW1lLlxuICAgKi9cbiAgcHVibGljIGdldExvYWRlck9iamVjdCgpOiBKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3NMb2FkZXIge1xuICAgIHJldHVybiB0aGlzLmxvYWRlck9iajtcbiAgfVxufVxuIiwiaW1wb3J0IHRocmVhZGluZyA9IHJlcXVpcmUoJy4vdGhyZWFkaW5nJyk7XG5pbXBvcnQgQ2xhc3NEYXRhID0gcmVxdWlyZSgnLi9DbGFzc0RhdGEnKTtcblxuLyoqXG4gKiBBIHNpbmdsZSBjbGFzcyBsb2NrLCB1c2VkIGZvciBsb2FkL2luaXRpYWxpemF0aW9uIGxvY2tzLlxuICovXG5jbGFzcyBDbGFzc0xvY2sge1xuICBwcml2YXRlIHF1ZXVlOiB7IHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZDsgY2I6IChjZGF0YTogQ2xhc3NEYXRhLkNsYXNzRGF0YSkgPT4gdm9pZDsgfVtdID0gW107XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbG9jayBpcyB0YWtlbi4gSWYgc28sIGl0IGVucXVldWVzIHRoZSBjYWxsYmFjay4gT3RoZXJ3aXNlLFxuICAgKiBpdCB0YWtlcyB0aGUgbG9jayBhbmQgcmV0dXJucyB0cnVlLlxuICAgKi9cbiAgcHVibGljIHRyeUxvY2sodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjYjogKGNkYXRhOiBDbGFzc0RhdGEuQ2xhc3NEYXRhKSA9PiB2b2lkKTogYm9vbGVhbiB7XG4gICAgLy8gV2UncmUgdGhlIG93bmVyIGlmIHRoZSBxdWV1ZSB3YXMgcHJldmlvdXNseSBlbXB0eS5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5wdXNoKHsgdGhyZWFkOiB0aHJlYWQsIGNiOiBjYiB9KSA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgbG9jayBvbiB0aGUgY2xhc3MsIGFuZCBwYXNzZXMgdGhlIG9iamVjdCB0byBhbGwgZW5xdWV1ZWRcbiAgICogY2FsbGJhY2tzLlxuICAgKi9cbiAgcHVibGljIHVubG9jayhjZGF0YTogQ2xhc3NEYXRhLkNsYXNzRGF0YSk6IHZvaWQge1xuICAgIHZhciBpOiBudW1iZXIsIG51bSA9IHRoaXMucXVldWUubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgdGhpcy5xdWV1ZVtpXS5jYihjZGF0YSk7XG4gICAgfVxuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG93bmVyIG9mIHRoaXMgbG9jay5cbiAgICovXG4gIHB1YmxpYyBnZXRPd25lcigpOiB0aHJlYWRpbmcuSlZNVGhyZWFkIHtcbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZVswXS50aHJlYWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCA9IENsYXNzTG9jaztcbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGdMb25nID0gcmVxdWlyZSgnLi9nTG9uZycpO1xuaW1wb3J0IEJ5dGVTdHJlYW0gPSByZXF1aXJlKCcuL0J5dGVTdHJlYW0nKTtcbmltcG9ydCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5pbXBvcnQgZW51bXMgPSByZXF1aXJlKCcuL2VudW1zJyk7XG5pbXBvcnQgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmltcG9ydCBDbGFzc0RhdGEgPSByZXF1aXJlKCcuL0NsYXNzRGF0YScpO1xuaW1wb3J0IG1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcbmltcG9ydCBDbGFzc0xvYWRlciA9IHJlcXVpcmUoJy4vQ2xhc3NMb2FkZXInKTtcbi8vIEZvciB0eXBlIGluZm9ybWF0aW9uLlxuaW1wb3J0IHRocmVhZGluZyA9IHJlcXVpcmUoJy4vdGhyZWFkaW5nJyk7XG5pbXBvcnQgSlZNVHlwZXMgPSByZXF1aXJlKCcuLi9pbmNsdWRlcy9KVk1UeXBlcycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb25zdGFudCBwb29sIGl0ZW0uIFVzZSB0aGUgaXRlbSdzIHR5cGUgdG8gZGlzY3JpbWluYXRlIGFtb25nIHRoZW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlO1xuICAvKipcbiAgICogSXMgdGhpcyBjb25zdGFudCBwb29sIGl0ZW0gcmVzb2x2ZWQ/IFVzZSB0byBkaXNjcmltaW5hdGUgYW1vbmcgcmVzb2x2ZWRcbiAgICogYW5kIHVucmVzb2x2ZWQgcmVmZXJlbmNlIHR5cGVzLlxuICAgKi9cbiAgaXNSZXNvbHZlZCgpOiBib29sZWFuO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29uc3RhbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25zdGFudCBwb29sIGl0ZW0uIFRoZSBpdGVtICptdXN0KlxuICAgKiBiZSByZXNvbHZlZC5cbiAgICogT25seSBkZWZpbmVkIG9uIGNvbnN0YW50IHBvb2wgaXRlbXMgdGhhdCByZXR1cm4gdmFsdWVzIHRocm91Z2ggTERDLlxuICAgKi9cbiAgZ2V0Q29uc3RhbnQ/KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCk6IGFueTtcbiAgLyoqXG4gICAqIFJlc29sdmVzIGFuIHVucmVzb2x2ZWQgY29uc3RhbnQgcG9vbCBpdGVtLiBDYW4gb25seSBiZSBjYWxsZWQgaWZcbiAgICogaXNSZXNvbHZlZCgpIHJldHVybnMgZmFsc2UuXG4gICAqL1xuICByZXNvbHZlPyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2FsbGVyOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjYjogKHN0YXR1czogYm9vbGVhbikgPT4gdm9pZCwgZXhwbGljaXQ/OiBib29sZWFuKTogdm9pZDtcbn1cblxuLyoqXG4gKiBBbGwgY29uc3RhbnQgcG9vbCBpdGVtcyBoYXZlIGEgc3RhdGljIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDb25zdGFudFBvb2xUeXBlIHtcbiAgZnJvbUJ5dGVzKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sKTogSUNvbnN0YW50UG9vbEl0ZW07XG4gIC8qKlxuICAgKiBUaGUgcmVzdWx0aW5nIHNpemUgaW4gdGhlIGNvbnN0YW50IHBvb2wsIGluIG1hY2hpbmUgd29yZHMuXG4gICAqL1xuICBzaXplOiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaGUgYnl0ZXNpemUgb24gZGlzayBvZiB0aGUgaXRlbSdzIGluZm9ybWF0aW9uIHBhc3QgdGhlIHRhZyBieXRlLlxuICAgKi9cbiAgaW5mb0J5dGVTaXplOiBudW1iZXI7XG59XG4vKipcbiAqIFN0b3JlcyBhbGwgb2YgdGhlIGNvbnN0YW50IHBvb2wgY2xhc3Nlcywga2V5ZWQgb24gdGhlaXIgZW51bSB2YWx1ZS5cbiAqL1xudmFyIENQX0NMQVNTRVM6IHsgW246IG51bWJlcl06IElDb25zdGFudFBvb2xUeXBlIH0gPSB7fTtcblxuLy8gI3JlZ2lvbiBUaWVyIDBcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29uc3RhbnQgVVRGLTggc3RyaW5nLlxuICogYGBgXG4gKiBDT05TVEFOVF9VdGY4X2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHUyIGxlbmd0aDtcbiAqICAgdTEgYnl0ZXNbbGVuZ3RoXTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ29uc3RVVEY4IGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwdWJsaWMgdmFsdWU6IHN0cmluZztcbiAgY29uc3RydWN0b3IocmF3Qnl0ZXM6IEJ1ZmZlcikge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmJ5dGVzMnN0cihyYXdCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgSmF2YSdzIHBzZXVkby1VVEYtOCBzdHJpbmdzIGludG8gdmFsaWQgVVRGLTE2IGNvZGVwb2ludHMgKHNwZWMgNC40LjcpXG4gICAqIE5vdGUgdGhhdCBKYXZhIHVzZXMgVVRGLTE2IGludGVybmFsbHkgYnkgZGVmYXVsdCBmb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uLFxuICAgKiBhbmQgdGhlIHBzZXVkby1VVEYtOCBzdHJpbmdzIGFyZSAqb25seSogdXNlZCBmb3Igc2VyaWFsaXphdGlvbiBwdXJwb3Nlcy5cbiAgICogVGh1cywgdGhlcmUgaXMgbm8gcmVhc29uIGZvciBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZSB0byBjYWxsIHRoaXMgcm91dGluZSFcbiAgICogVE9ETzogVG8gYXZvaWQgY29weWluZywgY3JlYXRlIGEgY2hhcmFjdGVyIGFycmF5IGZvciB0aGlzIGRhdGEuXG4gICAqIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy00Lmh0bWwjanZtcy00LjQuN1xuICAgKi9cbiAgcHJpdmF0ZSBieXRlczJzdHIoYnl0ZXM6IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgdmFyIHk6IG51bWJlciwgejogbnVtYmVyLCB2OiBudW1iZXIsIHc6IG51bWJlciwgeDogbnVtYmVyLCBjaGFyQ29kZTogbnVtYmVyLCBpZHggPSAwLCBydiA9ICcnO1xuICAgIHdoaWxlIChpZHggPCBieXRlcy5sZW5ndGgpIHtcbiAgICAgIHggPSBieXRlcy5yZWFkVUludDgoaWR4KyspICYgMHhmZjtcbiAgICAgIC8vIFdoaWxlIHRoZSBzdGFuZGFyZCBzcGVjaWZpZXMgdGhhdCBzdXJyb2dhdGUgcGFpcnMgc2hvdWxkIGJlIGhhbmRsZWQsIGl0IHNlZW1zIGxpa2VcbiAgICAgIC8vIHRoZXkgYXJlIGJ5IGRlZmF1bHQgd2l0aCB0aGUgdGhyZWUgYnl0ZSBmb3JtYXQuIFNlZSBwYXJzaW5nIGNvZGUgaGVyZTpcbiAgICAgIC8vIGh0dHA6Ly9oZy5vcGVuamRrLmphdmEubmV0L2pkazh1L2pkazh1LWRldi9qZGsvZmlsZS8zNjIzZjFiMjliNTgvc3JjL3NoYXJlL2NsYXNzZXMvamF2YS9pby9EYXRhSW5wdXRTdHJlYW0uamF2YSNsNjE4XG5cbiAgICAgIC8vIE9uZSBVVEYtMTYgY2hhcmFjdGVyLlxuICAgICAgaWYgKHggPD0gMHg3Zikge1xuICAgICAgICAvLyBPbmUgY2hhcmFjdGVyLCBvbmUgYnl0ZS5cbiAgICAgICAgY2hhckNvZGUgPSB4O1xuICAgICAgfSBlbHNlIGlmICh4IDw9IDB4ZGYpIHtcbiAgICAgICAgLy8gT25lIGNoYXJhY3RlciwgdHdvIGJ5dGVzLlxuICAgICAgICB5ID0gYnl0ZXMucmVhZFVJbnQ4KGlkeCsrKTtcbiAgICAgICAgY2hhckNvZGUgPSAoKHggJiAweDFmKSA8PCA2KSArICh5ICYgMHgzZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmUgY2hhcmFjdGVyLCB0aHJlZSBieXRlcy5cbiAgICAgICAgeSA9IGJ5dGVzLnJlYWRVSW50OChpZHgrKyk7XG4gICAgICAgIHogPSBieXRlcy5yZWFkVUludDgoaWR4KyspO1xuICAgICAgICBjaGFyQ29kZSA9ICgoeCAmIDB4ZikgPDwgMTIpICsgKCh5ICYgMHgzZikgPDwgNikgKyAoeiAmIDB4M2YpO1xuICAgICAgfVxuICAgICAgcnYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgcHVibGljIGdldFR5cGUoKTogZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUge1xuICAgIHJldHVybiBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5VVEY4O1xuICB9XG5cbiAgcHVibGljIGdldENvbnN0YW50KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfVxuXG4gIHB1YmxpYyBpc1Jlc29sdmVkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgc2l6ZTogbnVtYmVyID0gMTtcbiAgLy8gVmFyaWFibGUtc2l6ZS5cbiAgcHVibGljIHN0YXRpYyBpbmZvQnl0ZVNpemU6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sKTogSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAgIHZhciBzdHJsZW4gPSBieXRlU3RyZWFtLmdldFVpbnQxNigpO1xuICAgIHJldHVybiBuZXcgdGhpcyhieXRlU3RyZWFtLnJlYWQoc3RybGVuKSk7XG4gIH1cbn1cbkNQX0NMQVNTRVNbZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuVVRGOF0gPSBDb25zdFVURjg7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnN0YW50IDMyLWJpdCBpbnRlZ2VyLlxuICogYGBgXG4gKiBDT05TVEFOVF9JbnRlZ2VyX2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHU0IGJ5dGVzO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdEludDMyIGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwdWJsaWMgdmFsdWU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuSU5URUdFUjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb25zdGFudCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpIHsgcmV0dXJuIHRoaXMudmFsdWU7IH1cblxuICBwdWJsaWMgaXNSZXNvbHZlZCgpIHsgcmV0dXJuIHRydWU7IH1cblxuICBwdWJsaWMgc3RhdGljIHNpemU6IG51bWJlciA9IDE7XG4gIHB1YmxpYyBzdGF0aWMgaW5mb0J5dGVTaXplOiBudW1iZXIgPSA0O1xuICBwdWJsaWMgc3RhdGljIGZyb21CeXRlcyhieXRlU3RyZWFtOiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbCk6IElDb25zdGFudFBvb2xJdGVtIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoYnl0ZVN0cmVhbS5nZXRJbnQzMigpKTtcbiAgfVxufVxuQ1BfQ0xBU1NFU1tlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5JTlRFR0VSXSA9IENvbnN0SW50MzI7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnN0YW50IDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXG4gKiBgYGBcbiAqIENPTlNUQU5UX0Zsb2F0X2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHU0IGJ5dGVzO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdEZsb2F0IGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwdWJsaWMgdmFsdWU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRkxPQVQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29uc3RhbnQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9XG5cbiAgcHVibGljIGlzUmVzb2x2ZWQoKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gNDtcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGJ5dGVTdHJlYW0uZ2V0RmxvYXQoKSk7XG4gIH1cbn1cbkNQX0NMQVNTRVNbZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRkxPQVRdID0gQ29uc3RGbG9hdDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29uc3RhbnQgNjQtYml0IGludGVnZXIuXG4gKiBgYGBcbiAqIENPTlNUQU5UX0xvbmdfaW5mbyB7XG4gKiAgIHUxIHRhZztcbiAqICAgdTQgaGlnaF9ieXRlcztcbiAqICAgdTQgbG93X2J5dGVzO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdExvbmcgaW1wbGVtZW50cyBJQ29uc3RhbnRQb29sSXRlbSB7XG4gIHB1YmxpYyB2YWx1ZTogZ0xvbmc7XG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBnTG9uZykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTE9ORztcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb25zdGFudCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpIHsgcmV0dXJuIHRoaXMudmFsdWU7IH1cblxuICBwdWJsaWMgaXNSZXNvbHZlZCgpIHsgcmV0dXJuIHRydWU7IH1cblxuICBwdWJsaWMgc3RhdGljIHNpemU6IG51bWJlciA9IDI7XG4gIHB1YmxpYyBzdGF0aWMgaW5mb0J5dGVTaXplOiBudW1iZXIgPSA4O1xuICBwdWJsaWMgc3RhdGljIGZyb21CeXRlcyhieXRlU3RyZWFtOiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbCk6IElDb25zdGFudFBvb2xJdGVtIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoYnl0ZVN0cmVhbS5nZXRJbnQ2NCgpKTtcbiAgfVxufVxuQ1BfQ0xBU1NFU1tlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5MT05HXSA9IENvbnN0TG9uZztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29uc3RhbnQgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAqIGBgYFxuICogQ09OU1RBTlRfRG91YmxlX2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHU0IGhpZ2hfYnl0ZXM7XG4gKiAgIHU0IGxvd19ieXRlcztcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ29uc3REb3VibGUgaW1wbGVtZW50cyBJQ29uc3RhbnRQb29sSXRlbSB7XG4gIHB1YmxpYyB2YWx1ZTogbnVtYmVyO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGdldFR5cGUoKTogZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUge1xuICAgIHJldHVybiBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5ET1VCTEU7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29uc3RhbnQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9XG5cbiAgcHVibGljIGlzUmVzb2x2ZWQoKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAyO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gODtcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGJ5dGVTdHJlYW0uZ2V0RG91YmxlKCkpO1xuICB9XG59XG5DUF9DTEFTU0VTW2VudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkRPVUJMRV0gPSBDb25zdERvdWJsZTtcblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIFRpZXIgMVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGFzcyBvciBpbnRlcmZhY2UuXG4gKiBgYGBcbiAqIENPTlNUQU5UX0NsYXNzX2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHUyIG5hbWVfaW5kZXg7XG4gKiB9XG4gKiBgYGBcbiAqIEB0b2RvIEhhdmUgYSBjbGFzc2xvYWRlci1sb2NhbCBjYWNoZSBvZiBjbGFzcyByZWZlcmVuY2Ugb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENsYXNzUmVmZXJlbmNlIGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGNsYXNzLCBpbiBmdWxsIGRlc2NyaXB0b3IgZm9ybSwgZS5nLjpcbiAgICogTGZvby9iYXIvQmF6O1xuICAgKi9cbiAgcHVibGljIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCBjbGFzcyByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgY2xzOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+IHwgQ2xhc3NEYXRhLkFycmF5Q2xhc3NEYXRhPGFueT4gPSBudWxsO1xuICAvKipcbiAgICogVGhlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgZm9yIHRoZSByZWZlcmVuY2VkIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIGNsc0NvbnN0cnVjdG9yOiBDbGFzc0RhdGEuSUpWTUNvbnN0cnVjdG9yPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+ID0gbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBhcnJheSBjbGFzcyBmb3IgdGhlIHJlc29sdmVkIGNsYXNzIHJlZmVyZW5jZS5cbiAgICovXG4gIHB1YmxpYyBhcnJheUNsYXNzOiBDbGFzc0RhdGEuQXJyYXlDbGFzc0RhdGE8YW55PiA9IG51bGw7XG4gIC8qKlxuICAgKiBUaGUgSmF2YVNjcmlwdCBjb25zdHJ1Y3RvciBmb3IgdGhlIGFycmF5IGNsYXNzLlxuICAgKi9cbiAgcHVibGljIGFycmF5Q2xhc3NDb25zdHJ1Y3RvcjogQ2xhc3NEYXRhLklKVk1Db25zdHJ1Y3RvcjxKVk1UeXBlcy5KVk1BcnJheTxhbnk+PiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBzeW5jaHJvbm91c2x5IHJlc29sdmUuXG4gICAqL1xuICBwdWJsaWMgdHJ5UmVzb2x2ZShsb2FkZXI6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY2xzID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNscyA9IDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiBsb2FkZXIuZ2V0UmVzb2x2ZWRDbGFzcyh0aGlzLm5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbHMgIT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIGNsYXNzIHJlZmVyZW5jZSBieSByZXNvbHZpbmcgdGhlIGNsYXNzLiBEb2VzIG5vdCBydW5cbiAgICogY2xhc3MgaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGxvYWRlcjogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIGNhbGxlcjogQ2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiwgY2I6IChzdGF0dXM6IGJvb2xlYW4pID0+IHZvaWQsIGV4cGxpY2l0OiBib29sZWFuID0gdHJ1ZSkge1xuICAgIC8vIEJlY2F1c2Ugb2YgSmF2YSA4IGFub255bW91cyBjbGFzc2VzLCBUSElTIENIRUNLIElTIFJFUVVJUkVEIEZPUiBDT1JSRUNUTkVTUy5cbiAgICAvLyAoQ2xhc3NMb2FkZXJzIGRvIG5vdCBrbm93IGFib3V0IGFub255bW91cyBjbGFzc2VzLCBoZW5jZSB0aGV5IGFyZVxuICAgIC8vICAnYW5vbnltb3VzJylcbiAgICAvLyAoQW5vbnltb3VzIGNsYXNzZXMgYXJlIGFuICdVbnNhZmUnIGZlYXR1cmUsIGFuZCBhcmUgbm90IHBhcnQgb2YgdGhlIHN0YW5kYXJkLFxuICAgIC8vICBidXQgdGhleSBhcmUgZW1wbG95ZWQgZm9yIGxhbWJkYXMgYW5kIHN1Y2guKVxuICAgIC8vIE5PVEU6IFRocmVhZCBpcyAnbnVsbCcgZHVyaW5nIEpWTSBib290c3RyYXBwaW5nLlxuICAgIGlmICh0aHJlYWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50TWV0aG9kID0gdGhyZWFkLmN1cnJlbnRNZXRob2QoKTtcbiAgICAgIC8vIFRoZSBzdGFjayBtaWdodCBiZSBlbXB0eSBkdXJpbmcgcmVzb2x1dGlvbiwgd2hpY2ggb2NjdXJzIGR1cmluZyBKVk0gYm9vdHVwLlxuICAgICAgaWYgKGN1cnJlbnRNZXRob2QgIT09IG51bGwgJiYgdGhpcy5uYW1lID09PSBjdXJyZW50TWV0aG9kLmNscy5nZXRJbnRlcm5hbE5hbWUoKSkge1xuICAgICAgICB0aGlzLnNldFJlc29sdmVkKHRocmVhZCwgdGhyZWFkLmN1cnJlbnRNZXRob2QoKS5jbHMpO1xuICAgICAgICByZXR1cm4gY2IodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9hZGVyLnJlc29sdmVDbGFzcyh0aHJlYWQsIHRoaXMubmFtZSwgKGNkYXRhOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+KSA9PiB7XG4gICAgICB0aGlzLnNldFJlc29sdmVkKHRocmVhZCwgY2RhdGEpO1xuICAgICAgY2IoY2RhdGEgIT09IG51bGwpO1xuICAgIH0sIGV4cGxpY2l0KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0UmVzb2x2ZWQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjbHM6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4pIHtcbiAgICB0aGlzLmNscyA9IGNscztcbiAgICBpZiAoY2xzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNsc0NvbnN0cnVjdG9yID0gY2xzLmdldENvbnN0cnVjdG9yKHRocmVhZCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFR5cGUoKTogZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUge1xuICAgIHJldHVybiBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5DTEFTUztcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb25zdGFudCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpIHsgcmV0dXJuIHRoaXMuY2xzLmdldENsYXNzT2JqZWN0KHRocmVhZCk7IH1cblxuICBwdWJsaWMgaXNSZXNvbHZlZCgpIHsgcmV0dXJuIHRoaXMuY2xzICE9PSBudWxsOyB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gMjtcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgdmFyIG5hbWVJbmRleCA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBjcEl0ZW0gPSBjb25zdGFudFBvb2wuZ2V0KG5hbWVJbmRleCk7XG4gICAgYXNzZXJ0KGNwSXRlbS5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLlVURjgsXG4gICAgICAnQ29uc3RhbnRQb29sIENsYXNzUmVmZXJlbmNlIHR5cGUgIT0gVVRGOCcpO1xuICAgIC8vIFRoZSBDb25zdGFudFBvb2wgc3RvcmVzIGNsYXNzIG5hbWVzIHdpdGhvdXQgdGhlIEwuLi47IGRlc2NyaXB0b3Igc3R1ZmZcbiAgICByZXR1cm4gbmV3IHRoaXModXRpbC50eXBlc3RyMmRlc2NyaXB0b3IoKDxDb25zdFVURjg+IGNwSXRlbSkudmFsdWUpKTtcbiAgfVxufVxuQ1BfQ0xBU1NFU1tlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5DTEFTU10gPSBDbGFzc1JlZmVyZW5jZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZmllbGQgb3IgbWV0aG9kIHdpdGhvdXQgaW5kaWNhdGluZyB3aGljaCBjbGFzcyBvciBpbnRlcmZhY2VcbiAqIHR5cGUgaXQgYmVsb25ncyB0by5cbiAqIGBgYFxuICogQ09OU1RBTlRfTmFtZUFuZFR5cGVfaW5mbyB7XG4gKiAgIHUxIHRhZztcbiAqICAgdTIgbmFtZV9pbmRleDtcbiAqICAgdTIgZGVzY3JpcHRvcl9pbmRleDtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTmFtZUFuZFR5cGVJbmZvIGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuICBwdWJsaWMgZGVzY3JpcHRvcjogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIGRlc2NyaXB0b3I6IHN0cmluZykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTkFNRV9BTkRfVFlQRTtcbiAgfVxuXG4gIHB1YmxpYyBpc1Jlc29sdmVkKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgc2l6ZTogbnVtYmVyID0gMTtcbiAgcHVibGljIHN0YXRpYyBpbmZvQnl0ZVNpemU6IG51bWJlciA9IDQ7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sKTogSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAgIHZhciBuYW1lSW5kZXggPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgZGVzY3JpcHRvckluZGV4ID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIG5hbWVDb25zdCA9IDxDb25zdFVURjg+IGNvbnN0YW50UG9vbC5nZXQobmFtZUluZGV4KSxcbiAgICAgIGRlc2NyaXB0b3JDb25zdCA9IDxDb25zdFVURjg+IGNvbnN0YW50UG9vbC5nZXQoZGVzY3JpcHRvckluZGV4KTtcbiAgICBhc3NlcnQobmFtZUNvbnN0LmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuVVRGOCAmJlxuICAgICAgZGVzY3JpcHRvckNvbnN0LmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuVVRGOCxcbiAgICAgICdDb25zdGFudFBvb2wgTmFtZUFuZFR5cGVJbmZvIHR5cGVzICE9IFVURjgnKTtcbiAgICByZXR1cm4gbmV3IHRoaXMobmFtZUNvbnN0LnZhbHVlLCBkZXNjcmlwdG9yQ29uc3QudmFsdWUpO1xuICB9XG59XG5DUF9DTEFTU0VTW2VudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk5BTUVfQU5EX1RZUEVdID0gTmFtZUFuZFR5cGVJbmZvO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgY29uc3RhbnQgb2JqZWN0cyBvZiB0aGUgdHlwZSBqYXZhLmxhbmcuU3RyaW5nLlxuICogYGBgXG4gKiBDT05TVEFOVF9TdHJpbmdfaW5mbyB7XG4gKiAgIHUxIHRhZztcbiAqICAgdTIgc3RyaW5nX2luZGV4O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zdFN0cmluZyBpbXBsZW1lbnRzIElDb25zdGFudFBvb2xJdGVtIHtcbiAgcHVibGljIHN0cmluZ1ZhbHVlOiBzdHJpbmc7XG4gIHB1YmxpYyB2YWx1ZTogSlZNVHlwZXMuamF2YV9sYW5nX1N0cmluZyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHN0cmluZ1ZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0VHlwZSgpOiBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZSB7XG4gICAgcmV0dXJuIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLlNUUklORztcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgbG9hZGVyOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2FsbGVyOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjYjogKHN0YXR1czogYm9vbGVhbikgPT4gdm9pZCkge1xuICAgIHRoaXMudmFsdWUgPSB0aHJlYWQuZ2V0SlZNKCkuaW50ZXJuU3RyaW5nKHRoaXMuc3RyaW5nVmFsdWUpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiBjYih0cnVlKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29uc3RhbnQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9XG5cbiAgcHVibGljIGlzUmVzb2x2ZWQoKSB7IHJldHVybiB0aGlzLnZhbHVlICE9PSBudWxsOyB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gMjtcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIHV0ZjhJbmZvID0gPENvbnN0VVRGOD4gY29uc3RhbnRQb29sLmdldChzdHJpbmdJbmRleCk7XG4gICAgYXNzZXJ0KHV0ZjhJbmZvLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuVVRGOCxcbiAgICAgICdDb25zdGFudFBvb2wgQ29uc3RTdHJpbmcgdHlwZSAhPSBVVEY4Jyk7XG4gICAgcmV0dXJuIG5ldyB0aGlzKHV0ZjhJbmZvLnZhbHVlKTtcbiAgfVxufVxuQ1BfQ0xBU1NFU1tlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5TVFJJTkddID0gQ29uc3RTdHJpbmc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGdpdmVuIG1ldGhvZCB0eXBlLlxuICogYGBgXG4gKiBDT05TVEFOVF9NZXRob2RUeXBlX2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHUyIGRlc2NyaXB0b3JfaW5kZXg7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE1ldGhvZFR5cGUgaW1wbGVtZW50cyBJQ29uc3RhbnRQb29sSXRlbSB7XG4gIHByaXZhdGUgZGVzY3JpcHRvcjogc3RyaW5nO1xuICBwdWJsaWMgbWV0aG9kVHlwZTogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RUeXBlID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZGVzY3JpcHRvcjogc3RyaW5nKSB7XG4gICAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2w6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyLCBjYWxsZXI6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIGNiOiAoc3RhdHVzOiBib29sZWFuKSA9PiB2b2lkKSB7XG4gICAgdXRpbC5jcmVhdGVNZXRob2RUeXBlKHRocmVhZCwgY2wsIHRoaXMuZGVzY3JpcHRvciwgKGU6IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIHR5cGU6IEpWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWV0aG9kVHlwZSkgPT4ge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdGhyZWFkLnRocm93RXhjZXB0aW9uKGUpO1xuICAgICAgICBjYihmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGhvZFR5cGUgPSB0eXBlO1xuICAgICAgICBjYih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb25zdGFudCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpIHsgcmV0dXJuIHRoaXMubWV0aG9kVHlwZTsgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX1RZUEU7XG4gIH1cblxuICBwdWJsaWMgaXNSZXNvbHZlZCgpIHsgcmV0dXJuIHRoaXMubWV0aG9kVHlwZSAhPT0gbnVsbDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgc2l6ZTogbnVtYmVyID0gMTtcbiAgcHVibGljIHN0YXRpYyBpbmZvQnl0ZVNpemU6IG51bWJlciA9IDI7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sKTogSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAgIHZhciBkZXNjcmlwdG9ySW5kZXggPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgdXRmOEluZm8gPSA8Q29uc3RVVEY4PiBjb25zdGFudFBvb2wuZ2V0KGRlc2NyaXB0b3JJbmRleCk7XG4gICAgYXNzZXJ0KHV0ZjhJbmZvLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuVVRGOCxcbiAgICAgICdDb25zdGFudFBvb2wgTWV0aG9kVHlwZSB0eXBlICE9IFVURjgnKTtcbiAgICByZXR1cm4gbmV3IHRoaXModXRmOEluZm8udmFsdWUpO1xuICB9XG59XG5DUF9DTEFTU0VTW2VudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk1FVEhPRF9UWVBFXSA9IE1ldGhvZFR5cGU7XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBUaWVyIDJcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcGFydGljdWxhciBtZXRob2QuXG4gKiBgYGBcbiAqIENPTlNUQU5UX01ldGhvZHJlZl9pbmZvIHtcbiAqICAgdTEgdGFnO1xuICogICB1MiBjbGFzc19pbmRleDtcbiAqICAgdTIgbmFtZV9hbmRfdHlwZV9pbmRleDtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTWV0aG9kUmVmZXJlbmNlIGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwdWJsaWMgY2xhc3NJbmZvOiBDbGFzc1JlZmVyZW5jZTtcbiAgcHVibGljIG5hbWVBbmRUeXBlSW5mbzogTmFtZUFuZFR5cGVJbmZvO1xuICBwdWJsaWMgbWV0aG9kOiBtZXRob2RzLk1ldGhvZCA9IG51bGw7XG4gIC8qKlxuICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBtZXRob2QsIHdpdGhvdXQgdGhlIG93bmluZyBjbGFzcy5cbiAgICogZS5nLiBmb28oSUopVlxuICAgKi9cbiAgcHVibGljIHNpZ25hdHVyZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHNpZ25hdHVyZSBvZiB0aGUgbWV0aG9kLCBpbmNsdWRpbmcgdGhlIG93bmluZyBjbGFzcy5cbiAgICogZS5nLiBiYXIvQmF6L2ZvbyhJSilWXG4gICAqL1xuICBwdWJsaWMgZnVsbFNpZ25hdHVyZTogc3RyaW5nID0gbnVsbDtcbiAgcHVibGljIHBhcmFtV29yZFNpemU6IG51bWJlciA9IC0xO1xuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIE1lbWJlck5hbWUgb2JqZWN0IGZvciB0aGUgbWV0aG9kIHRoYXQgaW52b2tlc1xuICAgKiB0aGUgZGVzaXJlZCBmdW5jdGlvbi5cbiAgICovXG4gIHB1YmxpYyBtZW1iZXJOYW1lOiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01lbWJlck5hbWUgPSBudWxsO1xuICAvKipcbiAgICogQ29udGFpbnMgYW4gb2JqZWN0IHRoYXQgbmVlZHMgdG8gYmUgcHVzaGVkIG9udG8gdGhlIHN0YWNrIGJlZm9yZSBpbnZva2luZ1xuICAgKiBtZW1iZXJOYW1lLlxuICAgKi9cbiAgcHVibGljIGFwcGVuZGl4OiBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0ID0gbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIGZvciB0aGUgY2xhc3MgdGhhdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAqL1xuICBwdWJsaWMganNDb25zdHJ1Y3RvcjogYW55ID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihjbGFzc0luZm86IENsYXNzUmVmZXJlbmNlLCBuYW1lQW5kVHlwZUluZm86IE5hbWVBbmRUeXBlSW5mbykge1xuICAgIHRoaXMuY2xhc3NJbmZvID0gY2xhc3NJbmZvO1xuICAgIHRoaXMubmFtZUFuZFR5cGVJbmZvID0gbmFtZUFuZFR5cGVJbmZvO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdGhpcy5uYW1lQW5kVHlwZUluZm8ubmFtZSArIHRoaXMubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3I7XG4gIH1cblxuICBwdWJsaWMgZ2V0VHlwZSgpOiBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZSB7XG4gICAgcmV0dXJuIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk1FVEhPRFJFRjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIG1ldGhvZCByZWZlcmVuY2VkIGJ5IHRoaXMgY29uc3RhbnQgcG9vbCBpdGVtIGluIHRoZSBzcGVjaWZpZWRcbiAgICogYnl0ZWNvZGUgY29udGV4dC5cbiAgICogUmV0dXJucyBudWxsIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICogLSBUaHJvd3MgYSBOb1N1Y2hGaWVsZEVycm9yIGlmIG1pc3NpbmcuXG4gICAqIC0gVGhyb3dzIGFuIElsbGVnYWxBY2Nlc3NFcnJvciBpZiBmaWVsZCBpcyBpbmFjY2Vzc2libGUuXG4gICAqIC0gVGhyb3dzIGFuIEluY29tcGF0aWJsZUNsYXNzQ2hhbmdlRXJyb3IgaWYgdGhlIGZpZWxkIGlzIGFuIGluY29ycmVjdCB0eXBlXG4gICAqICAgZm9yIHRoZSBmaWVsZCBhY2Nlc3MuXG4gICAqL1xuICBwdWJsaWMgaGFzQWNjZXNzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGlzU3RhdGljOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMubWV0aG9kLCBhY2Nlc3NpbmdDbHMgPSBmcmFtZS5tZXRob2QuY2xzO1xuICAgIGlmIChtZXRob2QuYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSAhPT0gaXNTdGF0aWMpIHtcbiAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9JbmNvbXBhdGlibGVDbGFzc0NoYW5nZUVycm9yOycsIGBNZXRob2QgJHttZXRob2QubmFtZX0gZnJvbSBjbGFzcyAke21ldGhvZC5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9IGlzICR7aXNTdGF0aWMgPyAnbm90ICcgOiAnJ31zdGF0aWMuYCk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIXV0aWwuY2hlY2tBY2Nlc3MoYWNjZXNzaW5nQ2xzLCBtZXRob2QuY2xzLCBtZXRob2QuYWNjZXNzRmxhZ3MpKSB7XG4gICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvSWxsZWdhbEFjY2Vzc0Vycm9yOycsIGAke2FjY2Vzc2luZ0Nscy5nZXRFeHRlcm5hbE5hbWUoKX0gY2Fubm90IGFjY2VzcyAke21ldGhvZC5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9LiR7bWV0aG9kLm5hbWV9YCk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZU1lbWJlck5hbWUobWV0aG9kOiBtZXRob2RzLk1ldGhvZCwgdGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjbDogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIGNhbGxlcjogQ2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiwgY2I6IChzdGF0dXM6IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB2YXIgbWVtYmVySGFuZGxlTmF0aXZlcyA9IDx0eXBlb2YgSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RIYW5kbGVOYXRpdmVzPiAgKDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWV0aG9kSGFuZGxlTmF0aXZlcz4+IHRocmVhZC5nZXRCc0NsKCkuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsICdMamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGVOYXRpdmVzOycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpLFxuICAgICAgYXBwZW5kaXggPSBuZXcgKCg8Q2xhc3NEYXRhLkFycmF5Q2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiB0aHJlYWQuZ2V0QnNDbCgpLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnW0xqYXZhL2xhbmcvT2JqZWN0OycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKSh0aHJlYWQsIDEpO1xuXG4gICAgdXRpbC5jcmVhdGVNZXRob2RUeXBlKHRocmVhZCwgY2wsIHRoaXMubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3IsIChlOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlLCB0eXBlOiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01ldGhvZFR5cGUpID0+IHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHRocmVhZC50aHJvd0V4Y2VwdGlvbihlKTtcbiAgICAgICAgY2IoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogTWVtYmVyTmFtZSBsaW5rTWV0aG9kKCBpbnQgcmVmS2luZCwgQ2xhc3M8Pz4gZGVmYyxcbiAgICAgICAgICAgU3RyaW5nIG5hbWUsIE9iamVjdCB0eXBlLFxuICAgICAgICAgICBPYmplY3RbXSBhcHBlbmRpeFJlc3VsdCkgKi9cbiAgICAgICAgbWVtYmVySGFuZGxlTmF0aXZlc1snamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGVOYXRpdmVzL2xpbmtNZXRob2QoTGphdmEvbGFuZy9DbGFzcztJTGphdmEvbGFuZy9DbGFzcztMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvaW52b2tlL01lbWJlck5hbWU7J10oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIC8vIENsYXNzIGNhbGxlckNsYXNzXG4gICAgICAgICAgW2NhbGxlci5nZXRDbGFzc09iamVjdCh0aHJlYWQpLFxuICAgICAgICAgIC8vIGludCByZWZLaW5kXG4gICAgICAgICAgIGVudW1zLk1ldGhvZEhhbmRsZVJlZmVyZW5jZUtpbmQuSU5WT0tFVklSVFVBTCxcbiAgICAgICAgICAvLyBDbGFzcyBkZWZjXG4gICAgICAgICAgIHRoaXMuY2xhc3NJbmZvLmNscy5nZXRDbGFzc09iamVjdCh0aHJlYWQpLFxuICAgICAgICAgIC8vIFN0cmluZyBuYW1lXG4gICAgICAgICAgIHRocmVhZC5nZXRKVk0oKS5pbnRlcm5TdHJpbmcodGhpcy5uYW1lQW5kVHlwZUluZm8ubmFtZSksXG4gICAgICAgICAgLy8gT2JqZWN0IHR5cGUsIE9iamVjdFtdIGFwcGVuZGl4UmVzdWx0XG4gICAgICAgICAgIHR5cGUsIGFwcGVuZGl4XSxcbiAgICAgICAgKGU/OiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlLCBydj86IEpWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWVtYmVyTmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJlYWQudGhyb3dFeGNlcHRpb24oZSk7XG4gICAgICAgICAgICBjYihmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kaXggPSBhcHBlbmRpeC5hcnJheVswXTtcbiAgICAgICAgICAgIHRoaXMubWVtYmVyTmFtZSA9IHJ2O1xuICAgICAgICAgICAgY2IodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgbG9hZGVyOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2FsbGVyOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjYjogKHN0YXR1czogYm9vbGVhbikgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLmNsYXNzSW5mby5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHRoaXMuY2xhc3NJbmZvLnJlc29sdmUodGhyZWFkLCBsb2FkZXIsIGNhbGxlciwgKHN0YXR1czogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgIGNiKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlc29sdmUodGhyZWFkLCBsb2FkZXIsIGNhbGxlciwgY2IsIGV4cGxpY2l0KTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwbGljaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2xzID0gdGhpcy5jbGFzc0luZm8uY2xzLFxuICAgICAgICBtZXRob2QgPSBjbHMubWV0aG9kTG9va3VwKHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgIGlmIChtZXRob2QgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNfcmVmZXJlbmNlX3R5cGUoY2xzLmdldEludGVybmFsTmFtZSgpKSkge1xuICAgICAgICAgIC8vIFNpZ25hdHVyZSBwb2x5bW9ycGhpYyBsb29rdXAuXG4gICAgICAgICAgbWV0aG9kID0gKDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiBjbHMpLnNpZ25hdHVyZVBvbHltb3JwaGljQXdhcmVNZXRob2RMb29rdXAodGhpcy5zaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChtZXRob2QgIT09IG51bGwgJiYgKG1ldGhvZC5uYW1lID09PSAnaW52b2tlJyB8fCBtZXRob2QubmFtZSA9PT0gJ2ludm9rZUV4YWN0JykpIHtcbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGNvbXBsZXRlbHkgcmVzb2x2ZSB0aGUgc2lnbmF0dXJlIHBvbHltb3JwaGljIGZ1bmN0aW9uLFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIGl0cyBNZW1iZXJOYW1lIG9iamVjdCBhbmQgQXBwZW5kaXguXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlTWVtYmVyTmFtZShtZXRob2QsIHRocmVhZCwgbG9hZGVyLCBjYWxsZXIsIChzdGF0dXM6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVzb2x2ZWQodGhyZWFkLCBtZXRob2QpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9Ob1N1Y2hNZXRob2RFcnJvcjsnLCBgTWV0aG9kICR7dGhpcy5zaWduYXR1cmV9IGRvZXMgbm90IGV4aXN0IGluIGNsYXNzICR7dGhpcy5jbGFzc0luZm8uY2xzLmdldEV4dGVybmFsTmFtZSgpfS5gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYihzdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0UmVzb2x2ZWQodGhyZWFkLCBtZXRob2QpO1xuICAgICAgICBjYih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9Ob1N1Y2hNZXRob2RFcnJvcjsnLCBgTWV0aG9kICR7dGhpcy5zaWduYXR1cmV9IGRvZXMgbm90IGV4aXN0IGluIGNsYXNzICR7dGhpcy5jbGFzc0luZm8uY2xzLmdldEV4dGVybmFsTmFtZSgpfS5gKTtcbiAgICAgICAgY2IoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRSZXNvbHZlZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIG1ldGhvZDogbWV0aG9kcy5NZXRob2QpOiB2b2lkIHtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLnBhcmFtV29yZFNpemUgPSB1dGlsLmdldE1ldGhvZERlc2NyaXB0b3JXb3JkU2l6ZSh0aGlzLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yKTtcbiAgICB0aGlzLmZ1bGxTaWduYXR1cmUgPSB0aGlzLm1ldGhvZC5mdWxsU2lnbmF0dXJlO1xuICAgIHRoaXMuanNDb25zdHJ1Y3RvciA9IHRoaXMubWV0aG9kLmNscy5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpO1xuICB9XG5cbiAgcHVibGljIGlzUmVzb2x2ZWQoKSB7IHJldHVybiB0aGlzLm1ldGhvZCAhPT0gbnVsbDsgfVxuICBwdWJsaWMgZ2V0UGFyYW1Xb3JkU2l6ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnBhcmFtV29yZFNpemUgPT09IC0xKSB7XG4gICAgICB0aGlzLnBhcmFtV29yZFNpemUgPSB1dGlsLmdldE1ldGhvZERlc2NyaXB0b3JXb3JkU2l6ZSh0aGlzLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyYW1Xb3JkU2l6ZTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgc2l6ZTogbnVtYmVyID0gMTtcbiAgcHVibGljIHN0YXRpYyBpbmZvQnl0ZVNpemU6IG51bWJlciA9IDQ7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sKTogSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAgIHZhciBjbGFzc0luZGV4ID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIG5hbWVBbmRUeXBlSW5kZXggPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgY2xhc3NJbmZvID0gPENsYXNzUmVmZXJlbmNlPiBjb25zdGFudFBvb2wuZ2V0KGNsYXNzSW5kZXgpLFxuICAgICAgbmFtZUFuZFR5cGVJbmZvID0gPE5hbWVBbmRUeXBlSW5mbz4gY29uc3RhbnRQb29sLmdldChuYW1lQW5kVHlwZUluZGV4KTtcbiAgICBhc3NlcnQoY2xhc3NJbmZvLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuQ0xBU1MgJiZcbiAgICAgIG5hbWVBbmRUeXBlSW5mby5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk5BTUVfQU5EX1RZUEUsXG4gICAgICAnQ29uc3RhbnRQb29sIE1ldGhvZFJlZmVyZW5jZSB0eXBlcyBtaXNtYXRjaCcpO1xuICAgIHJldHVybiBuZXcgdGhpcyhjbGFzc0luZm8sIG5hbWVBbmRUeXBlSW5mbyk7XG4gIH1cbn1cbkNQX0NMQVNTRVNbZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EUkVGXSA9IE1ldGhvZFJlZmVyZW5jZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcGFydGljdWxhciBpbnRlcmZhY2UgbWV0aG9kLlxuICogYGBgXG4gKiBDT05TVEFOVF9JbnRlcmZhY2VNZXRob2RyZWZfaW5mbyB7XG4gKiAgIHUxIHRhZztcbiAqICAgdTIgY2xhc3NfaW5kZXg7XG4gKiAgIHUyIG5hbWVfYW5kX3R5cGVfaW5kZXg7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZU1ldGhvZFJlZmVyZW5jZSBpbXBsZW1lbnRzIElDb25zdGFudFBvb2xJdGVtIHtcbiAgcHVibGljIGNsYXNzSW5mbzogQ2xhc3NSZWZlcmVuY2U7XG4gIHB1YmxpYyBuYW1lQW5kVHlwZUluZm86IE5hbWVBbmRUeXBlSW5mbztcbiAgLyoqXG4gICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIG1ldGhvZCwgd2l0aG91dCB0aGUgb3duaW5nIGNsYXNzLlxuICAgKiBlLmcuIGZvbyhJSilWXG4gICAqL1xuICBwdWJsaWMgc2lnbmF0dXJlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgc2lnbmF0dXJlIG9mIHRoZSBtZXRob2QsIGluY2x1ZGluZyB0aGUgb3duaW5nIGNsYXNzLlxuICAgKiBlLmcuIGJhci9CYXovZm9vKElKKVZcbiAgICovXG4gIHB1YmxpYyBmdWxsU2lnbmF0dXJlOiBzdHJpbmcgPSBudWxsO1xuICBwdWJsaWMgbWV0aG9kOiBtZXRob2RzLk1ldGhvZCA9IG51bGw7XG4gIHB1YmxpYyBwYXJhbVdvcmRTaXplOiBudW1iZXIgPSAtMTtcbiAgcHVibGljIGpzQ29uc3RydWN0b3I6IGFueSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGNsYXNzSW5mbzogQ2xhc3NSZWZlcmVuY2UsIG5hbWVBbmRUeXBlSW5mbzogTmFtZUFuZFR5cGVJbmZvKSB7XG4gICAgdGhpcy5jbGFzc0luZm8gPSBjbGFzc0luZm87XG4gICAgdGhpcy5uYW1lQW5kVHlwZUluZm8gPSBuYW1lQW5kVHlwZUluZm87XG4gICAgdGhpcy5zaWduYXR1cmUgPSB0aGlzLm5hbWVBbmRUeXBlSW5mby5uYW1lICsgdGhpcy5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvcjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuSU5URVJGQUNFX01FVEhPRFJFRjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIG1ldGhvZCByZWZlcmVuY2VkIGJ5IHRoaXMgY29uc3RhbnQgcG9vbCBpdGVtIGluIHRoZSBzcGVjaWZpZWRcbiAgICogYnl0ZWNvZGUgY29udGV4dC5cbiAgICogUmV0dXJucyBudWxsIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICogLSBUaHJvd3MgYSBOb1N1Y2hGaWVsZEVycm9yIGlmIG1pc3NpbmcuXG4gICAqIC0gVGhyb3dzIGFuIElsbGVnYWxBY2Nlc3NFcnJvciBpZiBmaWVsZCBpcyBpbmFjY2Vzc2libGUuXG4gICAqIC0gVGhyb3dzIGFuIEluY29tcGF0aWJsZUNsYXNzQ2hhbmdlRXJyb3IgaWYgdGhlIGZpZWxkIGlzIGFuIGluY29ycmVjdCB0eXBlXG4gICAqICAgZm9yIHRoZSBmaWVsZCBhY2Nlc3MuXG4gICAqL1xuICBwdWJsaWMgaGFzQWNjZXNzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGlzU3RhdGljOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMubWV0aG9kLCBhY2Nlc3NpbmdDbHMgPSBmcmFtZS5tZXRob2QuY2xzO1xuICAgIGlmIChtZXRob2QuYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSAhPT0gaXNTdGF0aWMpIHtcbiAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9JbmNvbXBhdGlibGVDbGFzc0NoYW5nZUVycm9yOycsIGBNZXRob2QgJHttZXRob2QubmFtZX0gZnJvbSBjbGFzcyAke21ldGhvZC5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9IGlzICR7aXNTdGF0aWMgPyAnbm90ICcgOiAnJ31zdGF0aWMuYCk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIXV0aWwuY2hlY2tBY2Nlc3MoYWNjZXNzaW5nQ2xzLCBtZXRob2QuY2xzLCBtZXRob2QuYWNjZXNzRmxhZ3MpKSB7XG4gICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvSWxsZWdhbEFjY2Vzc0Vycm9yOycsIGAke2FjY2Vzc2luZ0Nscy5nZXRFeHRlcm5hbE5hbWUoKX0gY2Fubm90IGFjY2VzcyAke21ldGhvZC5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9LiR7bWV0aG9kLm5hbWV9YCk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgbG9hZGVyOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2FsbGVyOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjYjogKHN0YXR1czogYm9vbGVhbikgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLmNsYXNzSW5mby5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHRoaXMuY2xhc3NJbmZvLnJlc29sdmUodGhyZWFkLCBsb2FkZXIsIGNhbGxlciwgKHN0YXR1czogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgIGNiKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlc29sdmUodGhyZWFkLCBsb2FkZXIsIGNhbGxlciwgY2IsIGV4cGxpY2l0KTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwbGljaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2xzID0gdGhpcy5jbGFzc0luZm8uY2xzLFxuICAgICAgICBtZXRob2QgPSBjbHMubWV0aG9kTG9va3VwKHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgIHRoaXMucGFyYW1Xb3JkU2l6ZSA9IHV0aWwuZ2V0TWV0aG9kRGVzY3JpcHRvcldvcmRTaXplKHRoaXMubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3IpO1xuICAgICAgaWYgKG1ldGhvZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldFJlc29sdmVkKHRocmVhZCwgbWV0aG9kKTtcbiAgICAgICAgY2IodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvTm9TdWNoTWV0aG9kRXJyb3I7JywgYE1ldGhvZCAke3RoaXMuc2lnbmF0dXJlfSBkb2VzIG5vdCBleGlzdCBpbiBjbGFzcyAke3RoaXMuY2xhc3NJbmZvLmNscy5nZXRFeHRlcm5hbE5hbWUoKX0uYCk7XG4gICAgICAgIGNiKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0UmVzb2x2ZWQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBtZXRob2Q6IG1ldGhvZHMuTWV0aG9kKTogdm9pZCB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5wYXJhbVdvcmRTaXplID0gdXRpbC5nZXRNZXRob2REZXNjcmlwdG9yV29yZFNpemUodGhpcy5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvcik7XG4gICAgdGhpcy5mdWxsU2lnbmF0dXJlID0gdGhpcy5tZXRob2QuZnVsbFNpZ25hdHVyZTtcbiAgICB0aGlzLmpzQ29uc3RydWN0b3IgPSB0aGlzLm1ldGhvZC5jbHMuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQYXJhbVdvcmRTaXplKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMucGFyYW1Xb3JkU2l6ZSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGFyYW1Xb3JkU2l6ZSA9IHV0aWwuZ2V0TWV0aG9kRGVzY3JpcHRvcldvcmRTaXplKHRoaXMubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJhbVdvcmRTaXplO1xuICB9XG5cbiAgcHVibGljIGlzUmVzb2x2ZWQoKSB7IHJldHVybiB0aGlzLm1ldGhvZCAhPT0gbnVsbDsgfVxuXG4gIHB1YmxpYyBzdGF0aWMgc2l6ZTogbnVtYmVyID0gMTtcbiAgcHVibGljIHN0YXRpYyBpbmZvQnl0ZVNpemU6IG51bWJlciA9IDQ7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sKTogSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAgIHZhciBjbGFzc0luZGV4ID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIG5hbWVBbmRUeXBlSW5kZXggPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgY2xhc3NJbmZvID0gPENsYXNzUmVmZXJlbmNlPiBjb25zdGFudFBvb2wuZ2V0KGNsYXNzSW5kZXgpLFxuICAgICAgbmFtZUFuZFR5cGVJbmZvID0gPE5hbWVBbmRUeXBlSW5mbz4gY29uc3RhbnRQb29sLmdldChuYW1lQW5kVHlwZUluZGV4KTtcbiAgICBhc3NlcnQoY2xhc3NJbmZvLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuQ0xBU1MgJiZcbiAgICAgIG5hbWVBbmRUeXBlSW5mby5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk5BTUVfQU5EX1RZUEUsXG4gICAgICAnQ29uc3RhbnRQb29sIEludGVyZmFjZU1ldGhvZFJlZmVyZW5jZSB0eXBlcyBtaXNtYXRjaCcpO1xuICAgIHJldHVybiBuZXcgdGhpcyhjbGFzc0luZm8sIG5hbWVBbmRUeXBlSW5mbyk7XG4gIH1cbn1cbkNQX0NMQVNTRVNbZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuSU5URVJGQUNFX01FVEhPRFJFRl0gPSBJbnRlcmZhY2VNZXRob2RSZWZlcmVuY2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBhcnRpY3VsYXIgZmllbGQuXG4gKiBgYGBcbiAqIENPTlNUQU5UX0ZpZWxkcmVmX2luZm8ge1xuICogICB1MSB0YWc7XG4gKiAgIHUyIGNsYXNzX2luZGV4O1xuICogICB1MiBuYW1lX2FuZF90eXBlX2luZGV4O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWVsZFJlZmVyZW5jZSBpbXBsZW1lbnRzIElDb25zdGFudFBvb2xJdGVtIHtcbiAgcHVibGljIGNsYXNzSW5mbzogQ2xhc3NSZWZlcmVuY2U7XG4gIHB1YmxpYyBuYW1lQW5kVHlwZUluZm86IE5hbWVBbmRUeXBlSW5mbztcbiAgcHVibGljIGZpZWxkOiBtZXRob2RzLkZpZWxkID0gbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBmdWxsIG5hbWUgb2YgdGhlIGZpZWxkLCBpbmNsdWRpbmcgdGhlIG93bmluZyBjbGFzcy5cbiAgICogZS5nLiBqYXZhL2xhbmcvU3RyaW5nL3ZhbHVlXG4gICAqL1xuICBwdWJsaWMgZnVsbEZpZWxkTmFtZTogc3RyaW5nID0gbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIGZpZWxkIG93bmVyLiBVc2VkIGZvciBzdGF0aWMgZmllbGRzLlxuICAgKi9cbiAgcHVibGljIGZpZWxkT3duZXJDb25zdHJ1Y3RvcjogYW55ID0gbnVsbDtcbiAgY29uc3RydWN0b3IoY2xhc3NJbmZvOiBDbGFzc1JlZmVyZW5jZSwgbmFtZUFuZFR5cGVJbmZvOiBOYW1lQW5kVHlwZUluZm8pIHtcbiAgICB0aGlzLmNsYXNzSW5mbyA9IGNsYXNzSW5mbztcbiAgICB0aGlzLm5hbWVBbmRUeXBlSW5mbyA9IG5hbWVBbmRUeXBlSW5mbztcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRklFTERSRUY7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBmaWVsZCByZWZlcmVuY2VkIGJ5IHRoaXMgY29uc3RhbnQgcG9vbCBpdGVtIGluIHRoZSBzcGVjaWZpZWRcbiAgICogYnl0ZWNvZGUgY29udGV4dC5cbiAgICogUmV0dXJucyBudWxsIGlmIGFuIGVycm9yIG9jY3Vycy5cbiAgICogLSBUaHJvd3MgYSBOb1N1Y2hGaWVsZEVycm9yIGlmIG1pc3NpbmcuXG4gICAqIC0gVGhyb3dzIGFuIElsbGVnYWxBY2Nlc3NFcnJvciBpZiBmaWVsZCBpcyBpbmFjY2Vzc2libGUuXG4gICAqIC0gVGhyb3dzIGFuIEluY29tcGF0aWJsZUNsYXNzQ2hhbmdlRXJyb3IgaWYgdGhlIGZpZWxkIGlzIGFuIGluY29ycmVjdCB0eXBlXG4gICAqICAgZm9yIHRoZSBmaWVsZCBhY2Nlc3MuXG4gICAqL1xuICBwdWJsaWMgaGFzQWNjZXNzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGlzU3RhdGljOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZCwgYWNjZXNzaW5nQ2xzID0gZnJhbWUubWV0aG9kLmNscztcbiAgICBpZiAoZmllbGQuYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSAhPT0gaXNTdGF0aWMpIHtcbiAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9JbmNvbXBhdGlibGVDbGFzc0NoYW5nZUVycm9yOycsIGBGaWVsZCAke25hbWV9IGZyb20gY2xhc3MgJHtmaWVsZC5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9IGlzICR7aXNTdGF0aWMgPyAnbm90ICcgOiAnJ31zdGF0aWMuYCk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIXV0aWwuY2hlY2tBY2Nlc3MoYWNjZXNzaW5nQ2xzLCBmaWVsZC5jbHMsIGZpZWxkLmFjY2Vzc0ZsYWdzKSkge1xuICAgICAgdGhyZWFkLnRocm93TmV3RXhjZXB0aW9uKCdMamF2YS9sYW5nL0lsbGVnYWxBY2Nlc3NFcnJvcjsnLCBgJHthY2Nlc3NpbmdDbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9IGNhbm5vdCBhY2Nlc3MgJHtmaWVsZC5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9LiR7bmFtZX1gKTtcbiAgICAgIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHJlc29sdmUodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBsb2FkZXI6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyLCBjYWxsZXI6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIGNiOiAoc3RhdHVzOiBib29sZWFuKSA9PiB2b2lkLCBleHBsaWNpdDogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuY2xhc3NJbmZvLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgdGhpcy5jbGFzc0luZm8ucmVzb2x2ZSh0aHJlYWQsIGxvYWRlciwgY2FsbGVyLCAoc3RhdHVzOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmICghc3RhdHVzKSB7XG4gICAgICAgICAgY2IoZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZSh0aHJlYWQsIGxvYWRlciwgY2FsbGVyLCBjYiwgZXhwbGljaXQpO1xuICAgICAgICB9XG4gICAgICB9LCBleHBsaWNpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbHMgPSB0aGlzLmNsYXNzSW5mby5jbHMsXG4gICAgICAgIGZpZWxkID0gY2xzLmZpZWxkTG9va3VwKHRoaXMubmFtZUFuZFR5cGVJbmZvLm5hbWUpO1xuICAgICAgaWYgKGZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnVsbEZpZWxkTmFtZSA9IGAke3V0aWwuZGVzY3JpcHRvcjJ0eXBlc3RyKGZpZWxkLmNscy5nZXRJbnRlcm5hbE5hbWUoKSl9LyR7ZmllbGQubmFtZX1gO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIGNiKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyZWFkLnRocm93TmV3RXhjZXB0aW9uKCdMamF2YS9sYW5nL05vU3VjaEZpZWxkRXJyb3I7JywgYEZpZWxkICR7dGhpcy5uYW1lQW5kVHlwZUluZm8ubmFtZX0gZG9lcyBub3QgZXhpc3QgaW4gY2xhc3MgJHt0aGlzLmNsYXNzSW5mby5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9LmApO1xuICAgICAgICBjYihmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzUmVzb2x2ZWQoKSB7IHJldHVybiB0aGlzLmZpZWxkICE9PSBudWxsOyB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gNDtcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgdmFyIGNsYXNzSW5kZXggPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgbmFtZUFuZFR5cGVJbmRleCA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBjbGFzc0luZm8gPSA8Q2xhc3NSZWZlcmVuY2U+IGNvbnN0YW50UG9vbC5nZXQoY2xhc3NJbmRleCksXG4gICAgICBuYW1lQW5kVHlwZUluZm8gPSA8TmFtZUFuZFR5cGVJbmZvPiBjb25zdGFudFBvb2wuZ2V0KG5hbWVBbmRUeXBlSW5kZXgpO1xuICAgIGFzc2VydChjbGFzc0luZm8uZ2V0VHlwZSgpID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5DTEFTUyAmJlxuICAgICAgbmFtZUFuZFR5cGVJbmZvLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTkFNRV9BTkRfVFlQRSxcbiAgICAgICdDb25zdGFudFBvb2wgRmllbGRSZWZlcmVuY2UgdHlwZXMgbWlzbWF0Y2gnKTtcbiAgICByZXR1cm4gbmV3IHRoaXMoY2xhc3NJbmZvLCBuYW1lQW5kVHlwZUluZm8pO1xuICB9XG59XG5DUF9DTEFTU0VTW2VudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkZJRUxEUkVGXSA9IEZpZWxkUmVmZXJlbmNlO1xuXG4vKipcbiAqIFVzZWQgYnkgYW4gaW52b2tlZHluYW1pYyBpbnN0cnVjdGlvbiB0byBzcGVjaWZ5IGEgYm9vdHN0cmFwIG1ldGhvZCxcbiAqIHRoZSBkeW5hbWljIGludm9jYXRpb24gbmFtZSwgdGhlIGFyZ3VtZW50IGFuZCByZXR1cm4gdHlwZXMgb2YgdGhlIGNhbGwsXG4gKiBhbmQgb3B0aW9uYWxseSwgYSBzZXF1ZW5jZSBvZiBhZGRpdGlvbmFsIGNvbnN0YW50cyBjYWxsZWQgc3RhdGljIGFyZ3VtZW50c1xuICogdG8gdGhlIGJvb3RzdHJhcCBtZXRob2QuXG4gKiBgYGBcbiAqIENPTlNUQU5UX0ludm9rZUR5bmFtaWNfaW5mbyB7XG4gKiAgIHUxIHRhZztcbiAqICAgdTIgYm9vdHN0cmFwX21ldGhvZF9hdHRyX2luZGV4O1xuICogICB1MiBuYW1lX2FuZF90eXBlX2luZGV4O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZva2VEeW5hbWljIGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwdWJsaWMgYm9vdHN0cmFwTWV0aG9kQXR0ckluZGV4OiBudW1iZXI7XG4gIHB1YmxpYyBuYW1lQW5kVHlwZUluZm86IE5hbWVBbmRUeXBlSW5mbztcbiAgLyoqXG4gICAqIFRoZSBwYXJhbWV0ZXIgd29yZCBzaXplIG9mIHRoZSBuYW1lQW5kVHlwZUluZm8ncyBkZXNjcmlwdG9yLlxuICAgKiBEb2VzIG5vdCB0YWtlIGFwcGVuZGl4IGludG8gYWNjb3VudDsgdGhpcyBpcyB0aGUgc3RhdGljIHBhcmFtV29yZFNpemUuXG4gICAqL1xuICBwdWJsaWMgcGFyYW1Xb3JkU2l6ZTogbnVtYmVyO1xuICAvKipcbiAgICogT25jZSBhIENhbGxTaXRlIGlzIGRlZmluZWQgZm9yIGEgcGFydGljdWxhciBsZXhpY2FsIG9jY3VycmVuY2Ugb2ZcbiAgICogSW52b2tlRHluYW1pYywgdGhlIENhbGxTaXRlIHdpbGwgYmUgcmV1c2VkIGZvciBlYWNoIGZ1dHVyZSBleGVjdXRpb25cbiAgICogb2YgdGhhdCBwYXJ0aWN1bGFyIG9jY3VycmVuY2UuXG4gICAqXG4gICAqIFdlIHN0b3JlIHRoZSBDYWxsU2l0ZSBvYmplY3RzIGhlcmUgZm9yIGZ1dHVyZSByZXRyaWV2YWwsIGFsb25nIHdpdGggYW5cbiAgICogb3B0aW9uYWwgJ2FwcGVuZGl4JyBhcmd1bWVudC5cbiAgICovXG4gIHByaXZhdGUgY2FsbFNpdGVPYmplY3RzOiB7IFtwYzogbnVtYmVyXTogW0pWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWVtYmVyTmFtZSwgSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdF0gfSA9IHt9O1xuICAvKipcbiAgICogQSBNZXRob2RUeXBlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgSW52b2tlRHluYW1pYyBjYWxsJ3NcbiAgICogbWV0aG9kIGRlc2NyaXB0b3IuXG4gICAqL1xuICBwcml2YXRlIG1ldGhvZFR5cGU6IEpWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWV0aG9kVHlwZSA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoYm9vdHN0cmFwTWV0aG9kQXR0ckluZGV4OiBudW1iZXIsIG5hbWVBbmRUeXBlSW5mbzogTmFtZUFuZFR5cGVJbmZvKSB7XG4gICAgdGhpcy5ib290c3RyYXBNZXRob2RBdHRySW5kZXggPSBib290c3RyYXBNZXRob2RBdHRySW5kZXg7XG4gICAgdGhpcy5uYW1lQW5kVHlwZUluZm8gPSBuYW1lQW5kVHlwZUluZm87XG4gICAgdGhpcy5wYXJhbVdvcmRTaXplID0gdXRpbC5nZXRNZXRob2REZXNjcmlwdG9yV29yZFNpemUodGhpcy5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0VHlwZSgpOiBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZSB7XG4gICAgcmV0dXJuIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLklOVk9LRV9EWU5BTUlDO1xuICB9XG4gIHB1YmxpYyBpc1Jlc29sdmVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5tZXRob2RUeXBlICE9PSBudWxsOyB9XG4gIHB1YmxpYyByZXNvbHZlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgbG9hZGVyOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2FsbGVyOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjYjogKHN0YXR1czogYm9vbGVhbikgPT4gdm9pZCkge1xuICAgIHV0aWwuY3JlYXRlTWV0aG9kVHlwZSh0aHJlYWQsIGxvYWRlciwgdGhpcy5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvciwgKGU6IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIHJ2OiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01ldGhvZFR5cGUpID0+IHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHRocmVhZC50aHJvd0V4Y2VwdGlvbihlKTtcbiAgICAgICAgY2IoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZXRob2RUeXBlID0gcnY7XG4gICAgICAgIGNiKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGdldENhbGxTaXRlT2JqZWN0KHBjOiBudW1iZXIpOiBbSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZW1iZXJOYW1lLCBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0XSB7XG4gICAgdmFyIGNzbyA9IHRoaXMuY2FsbFNpdGVPYmplY3RzW3BjXVxuICAgIGlmIChjc28pIHtcbiAgICAgIHJldHVybiBjc287XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RDYWxsU2l0ZU9iamVjdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2xheno6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIHBjOiBudW1iZXIsIGNiOiAoc3RhdHVzOiBib29sZWFuKSA9PiB2b2lkLCBleHBsaWNpdDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAvKipcbiAgICAgKiBBIGNhbGwgc2l0ZSBzcGVjaWZpZXIgZ2l2ZXMgYSBzeW1ib2xpYyByZWZlcmVuY2UgdG8gYSBtZXRob2QgaGFuZGxlIHdoaWNoXG4gICAgICogaXMgdG8gc2VydmUgYXMgdGhlIGJvb3RzdHJhcCBtZXRob2QgZm9yIGEgZHluYW1pYyBjYWxsIHNpdGUgKMKnNC43LjIzKS5cbiAgICAgKiBUaGUgbWV0aG9kIGhhbmRsZSBpcyByZXNvbHZlZCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBqYXZhLmxhbmcuaW52b2tlLk1ldGhvZEhhbmRsZSAowqc1LjQuMy41KS5cbiAgICAgKi9cbiAgICB2YXIgYm9vdHN0cmFwTWV0aG9kID0gY2xhenouZ2V0Qm9vdHN0cmFwTWV0aG9kKHRoaXMuYm9vdHN0cmFwTWV0aG9kQXR0ckluZGV4KSxcbiAgICAgIHVucmVzb2x2ZWRJdGVtczogSUNvbnN0YW50UG9vbEl0ZW1bXSA9IGJvb3RzdHJhcE1ldGhvZFsxXS5jb25jYXQoYm9vdHN0cmFwTWV0aG9kWzBdLCB0aGlzKS5maWx0ZXIoKGl0ZW06IElDb25zdGFudFBvb2xJdGVtKSA9PiAhaXRlbS5pc1Jlc29sdmVkKCkpO1xuXG4gICAgaWYgKHVucmVzb2x2ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBSZXNvbHZlIGFsbCBuZWVkZWQgY29uc3RhbnQgcG9vbCBpdGVtcyAoaW5jbHVkaW5nIHRoaXMgb25lKS5cbiAgICAgIHJldHVybiB1dGlsLmFzeW5jRm9yRWFjaCh1bnJlc29sdmVkSXRlbXMsIChjcEl0ZW06IElDb25zdGFudFBvb2xJdGVtLCBuZXh0SXRlbTogKGVycj86IGFueSkgPT4gdm9pZCkgPT4ge1xuICAgICAgICBjcEl0ZW0ucmVzb2x2ZSh0aHJlYWQsIGNsLCBjbGF6eiwgKHN0YXR1czogYm9vbGVhbikgPT4ge1xuICAgICAgICAgIGlmICghc3RhdHVzKSB7XG4gICAgICAgICAgICBuZXh0SXRlbShcIkZhaWxlZC5cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRJdGVtKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBleHBsaWNpdCk7XG4gICAgICB9LCAoZXJyPzogYW55KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYihmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVydW4uIFRoaXMgdGltZSwgYWxsIGl0ZW1zIGFyZSByZXNvbHZlZC5cbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdENhbGxTaXRlT2JqZWN0KHRocmVhZCwgY2wsIGNsYXp6LCBwYywgY2IsIGV4cGxpY2l0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjYWxsIHNpdGUgc3BlY2lmaWVyIGdpdmVzIHplcm8gb3IgbW9yZSBzdGF0aWMgYXJndW1lbnRzLCB3aGljaFxuICAgICAqIGNvbW11bmljYXRlIGFwcGxpY2F0aW9uLXNwZWNpZmljIG1ldGFkYXRhIHRvIHRoZSBib290c3RyYXAgbWV0aG9kLiBBbnlcbiAgICAgKiBzdGF0aWMgYXJndW1lbnRzIHdoaWNoIGFyZSBzeW1ib2xpYyByZWZlcmVuY2VzIHRvIGNsYXNzZXMsIG1ldGhvZFxuICAgICAqIGhhbmRsZXMsIG9yIG1ldGhvZCB0eXBlcyBhcmUgcmVzb2x2ZWQsIGFzIGlmIGJ5IGludm9jYXRpb24gb2YgdGhlIGxkY1xuICAgICAqIGluc3RydWN0aW9uICjCp2xkYyksIHRvIG9idGFpbiByZWZlcmVuY2VzIHRvIENsYXNzIG9iamVjdHMsXG4gICAgICogamF2YS5sYW5nLmludm9rZS5NZXRob2RIYW5kbGUgb2JqZWN0cywgYW5kIGphdmEubGFuZy5pbnZva2UuTWV0aG9kVHlwZVxuICAgICAqIG9iamVjdHMgcmVzcGVjdGl2ZWx5LiBBbnkgc3RhdGljIGFyZ3VtZW50cyB0aGF0IGFyZSBzdHJpbmcgbGl0ZXJhbHMgYXJlXG4gICAgICogdXNlZCB0byBvYnRhaW4gcmVmZXJlbmNlcyB0byBTdHJpbmcgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBcmd1bWVudHMoKTogSlZNVHlwZXMuSlZNQXJyYXk8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4ge1xuICAgICAgdmFyIGNwSXRlbXMgPSBib290c3RyYXBNZXRob2RbMV0sXG4gICAgICAgIGk6IG51bWJlciwgY3BJdGVtOiBJQ29uc3RhbnRQb29sSXRlbSxcbiAgICAgICAgcnZPYmogPSBuZXcgKCg8Q2xhc3NEYXRhLkFycmF5Q2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiB0aHJlYWQuZ2V0QnNDbCgpLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnW0xqYXZhL2xhbmcvT2JqZWN0OycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKSh0aHJlYWQsIGNwSXRlbXMubGVuZ3RoKSxcbiAgICAgICAgcnYgPSBydk9iai5hcnJheTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjcEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNwSXRlbSA9IGNwSXRlbXNbaV07XG4gICAgICAgIHN3aXRjaCAoY3BJdGVtLmdldFR5cGUoKSkge1xuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuQ0xBU1M6XG4gICAgICAgICAgICBydltpXSA9ICg8Q2xhc3NSZWZlcmVuY2U+IGNwSXRlbSkuY2xzLmdldENsYXNzT2JqZWN0KHRocmVhZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk1FVEhPRF9IQU5ETEU6XG4gICAgICAgICAgICBydltpXSA9ICg8TWV0aG9kSGFuZGxlPiBjcEl0ZW0pLm1ldGhvZEhhbmRsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX1RZUEU6XG4gICAgICAgICAgICBydltpXSA9ICg8TWV0aG9kVHlwZT4gY3BJdGVtKS5tZXRob2RUeXBlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICBydltpXSA9ICg8Q29uc3RTdHJpbmc+IGNwSXRlbSkudmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLlVURjg6XG4gICAgICAgICAgICBydltpXSA9IHRocmVhZC5nZXRKVk0oKS5pbnRlcm5TdHJpbmcoKDxDb25zdFVURjg+IGNwSXRlbSkudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5JTlRFR0VSOlxuICAgICAgICAgICAgcnZbaV0gPSAoPENsYXNzRGF0YS5QcmltaXRpdmVDbGFzc0RhdGE+IGNsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnSScpKS5jcmVhdGVXcmFwcGVyT2JqZWN0KHRocmVhZCwgKDxDb25zdEludDMyPiBjcEl0ZW0pLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTE9ORzpcbiAgICAgICAgICAgIHJ2W2ldID0gKDxDbGFzc0RhdGEuUHJpbWl0aXZlQ2xhc3NEYXRhPiBjbC5nZXRJbml0aWFsaXplZENsYXNzKHRocmVhZCwgJ0onKSkuY3JlYXRlV3JhcHBlck9iamVjdCh0aHJlYWQsICg8Q29uc3RMb25nPiBjcEl0ZW0pLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRkxPQVQ6XG4gICAgICAgICAgICBydltpXSA9ICg8Q2xhc3NEYXRhLlByaW1pdGl2ZUNsYXNzRGF0YT4gY2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsICdGJykpLmNyZWF0ZVdyYXBwZXJPYmplY3QodGhyZWFkLCAoPENvbnN0RmxvYXQ+IGNwSXRlbSkudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5ET1VCTEU6XG4gICAgICAgICAgICBydltpXSA9ICg8Q2xhc3NEYXRhLlByaW1pdGl2ZUNsYXNzRGF0YT4gY2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsICdEJykpLmNyZWF0ZVdyYXBwZXJPYmplY3QodGhyZWFkLCAoPENvbnN0RG91YmxlPiBjcEl0ZW0pLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiSW52YWxpZCBDUEl0ZW0gZm9yIHN0YXRpYyBhcmdzOiBcIiArIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlW2NwSXRlbS5nZXRUeXBlKCldKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NlcnQoKCgpID0+IHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHRydWU7XG4gICAgICAgIGNwSXRlbXMuZm9yRWFjaCgoY3BJdGVtOiBJQ29uc3RhbnRQb29sSXRlbSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgaWYgKHJ2W2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5kZWZpbmVkIGl0ZW0gYXQgYXJnIFwiICsgaSArIFwiOiBcIiArIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlW2NwSXRlbS5nZXRUeXBlKCldKTtcbiAgICAgICAgICAgIHN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocnZbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTnVsbCBpdGVtIGF0IGFyZyBcIiArIGkgKyBcIjogXCIgKyBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZVtjcEl0ZW0uZ2V0VHlwZSgpXSk7XG4gICAgICAgICAgICBzdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgfSkoKSwgXCJBcmd1bWVudHMgY2Fubm90IGJlIHVuZGVmaW5lZCBvciBudWxsLlwiKTtcblxuICAgICAgcmV0dXJuIHJ2T2JqO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgY2FsbCBzaXRlIHNwZWNpZmllciBnaXZlcyBhIG1ldGhvZCBkZXNjcmlwdG9yLCBURC4gQSByZWZlcmVuY2UgdG8gYW5cbiAgICAgKiBpbnN0YW5jZSBvZiBqYXZhLmxhbmcuaW52b2tlLk1ldGhvZFR5cGUgaXMgb2J0YWluZWQgYXMgaWYgYnkgcmVzb2x1dGlvblxuICAgICAqIG9mIGEgc3ltYm9saWMgcmVmZXJlbmNlIHRvIGEgbWV0aG9kIHR5cGUgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXIgYW5kXG4gICAgICogcmV0dXJuIHR5cGVzIGFzIFREICjCpzUuNC4zLjUpLlxuICAgICAqXG4gICAgICogRG8gd2hhdCBhbGwgT3BlbkpESy1iYXNlZCBKVk1zIGRvOiBDYWxsXG4gICAgICogTWV0aG9kSGFuZGxlTmF0aXZlcy5saW5rQ2FsbFNpdGUgd2l0aDpcbiAgICAgKiAtIFRoZSBjbGFzcyB3LyB0aGUgaW52b2tlZHluYW1pYyBpbnN0cnVjdGlvblxuICAgICAqIC0gVGhlIGJvb3RzdHJhcCBtZXRob2RcbiAgICAgKiAtIFRoZSBuYW1lIHN0cmluZyBmcm9tIHRoZSBuYW1lQW5kVHlwZUluZm9cbiAgICAgKiAtIFRoZSBtZXRob2RUeXBlIG9iamVjdCBmcm9tIHRoZSBuYW1lQW5kVHlwZUluZm9cbiAgICAgKiAtIFRoZSBzdGF0aWMgYXJndW1lbnRzIGZyb20gdGhlIGJvb3RzdHJhcCBtZXRob2QuXG4gICAgICogLSBBIDEtbGVuZ3RoIGFwcGVuZGl4IGJveC5cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRocmVhZC5nZXRKVk0oKS5pbnRlcm5TdHJpbmcodGhpcy5uYW1lQW5kVHlwZUluZm8ubmFtZSksXG4gICAgICBhcHBlbmRpeEFyciA9IG5ldyAoKDxDbGFzc0RhdGEuQXJyYXlDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4+IGNsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnW0xqYXZhL2xhbmcvT2JqZWN0OycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKSh0aHJlYWQsIDEpLFxuICAgICAgc3RhdGljQXJncyA9IGdldEFyZ3VtZW50cygpLFxuICAgICAgbWhuID0gPHR5cGVvZiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01ldGhvZEhhbmRsZU5hdGl2ZXM+ICg8Q2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01ldGhvZEhhbmRsZU5hdGl2ZXM+PiBjbC5nZXRJbml0aWFsaXplZENsYXNzKHRocmVhZCwgJ0xqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZU5hdGl2ZXM7JykpLmdldENvbnN0cnVjdG9yKHRocmVhZCk7XG5cblxuICAgIG1oblsnamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGVOYXRpdmVzL2xpbmtDYWxsU2l0ZShMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL09iamVjdDtMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvaW52b2tlL01lbWJlck5hbWU7J10odGhyZWFkLFxuICAgICAgW2NsYXp6LmdldENsYXNzT2JqZWN0KHRocmVhZCksIGJvb3RzdHJhcE1ldGhvZFswXS5tZXRob2RIYW5kbGUsIG1ldGhvZE5hbWUsIHRoaXMubWV0aG9kVHlwZSwgc3RhdGljQXJncywgYXBwZW5kaXhBcnJdLCAoZT86IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIHJ2PzogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZW1iZXJOYW1lKSA9PiB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB0aHJlYWQudGhyb3dFeGNlcHRpb24oZSk7XG4gICAgICAgIGNiKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0UmVzb2x2ZWQocGMsIFtydiwgYXBwZW5kaXhBcnIuYXJyYXlbMF1dKTtcbiAgICAgICAgY2IodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNldFJlc29sdmVkKHBjOiBudW1iZXIsIGNzbzogW0pWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWVtYmVyTmFtZSwgSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdF0pIHtcbiAgICAvLyBQcmV2ZW50IHJlc29sdXRpb24gcmFjZXMuIEl0J3MgT0sgdG8gY3JlYXRlIG11bHRpcGxlIENTT3MsIGJ1dCBvbmx5IG9uZVxuICAgIC8vIHNob3VsZCBldmVyIGJlIHVzZWQhXG4gICAgaWYgKHRoaXMuY2FsbFNpdGVPYmplY3RzW3BjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGxTaXRlT2JqZWN0c1twY10gPSBjc287XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gNDtcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgdmFyIGJvb3RzdHJhcE1ldGhvZEF0dHJJbmRleCA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBuYW1lQW5kVHlwZUluZGV4ID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIG5hbWVBbmRUeXBlSW5mbyA9IDxOYW1lQW5kVHlwZUluZm8+IGNvbnN0YW50UG9vbC5nZXQobmFtZUFuZFR5cGVJbmRleCk7XG4gICAgYXNzZXJ0KG5hbWVBbmRUeXBlSW5mby5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk5BTUVfQU5EX1RZUEUsXG4gICAgICAnQ29uc3RhbnRQb29sIEludm9rZUR5bmFtaWMgdHlwZXMgbWlzbWF0Y2gnKTtcbiAgICByZXR1cm4gbmV3IHRoaXMoYm9vdHN0cmFwTWV0aG9kQXR0ckluZGV4LCBuYW1lQW5kVHlwZUluZm8pO1xuICB9XG59XG5DUF9DTEFTU0VTW2VudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLklOVk9LRV9EWU5BTUlDXSA9IEludm9rZUR5bmFtaWM7XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBUaWVyIDNcblxuZXhwb3J0IGludGVyZmFjZSBJQ29uc3RhbnRQb29sUmVmZXJlbmNlIGV4dGVuZHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBjbGFzc0luZm86IENsYXNzUmVmZXJlbmNlO1xuICBuYW1lQW5kVHlwZUluZm86IE5hbWVBbmRUeXBlSW5mbztcbiAgZ2V0TWV0aG9kSGFuZGxlVHlwZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2I6IChlOiBhbnksIHR5cGU6IEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3QpID0+IHZvaWQpOiB2b2lkO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBnaXZlbiBtZXRob2QgaGFuZGxlLlxuICogYGBgXG4gKiBDT05TVEFOVF9NZXRob2RIYW5kbGVfaW5mbyB7XG4gKiAgIHUxIHRhZztcbiAqICAgdTEgcmVmZXJlbmNlX2tpbmQ7XG4gKiAgIHUyIHJlZmVyZW5jZV9pbmRleDtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTWV0aG9kSGFuZGxlIGltcGxlbWVudHMgSUNvbnN0YW50UG9vbEl0ZW0ge1xuICBwcml2YXRlIHJlZmVyZW5jZTogRmllbGRSZWZlcmVuY2UgfCBNZXRob2RSZWZlcmVuY2UgfCBJbnRlcmZhY2VNZXRob2RSZWZlcmVuY2U7XG4gIHByaXZhdGUgcmVmZXJlbmNlVHlwZTogZW51bXMuTWV0aG9kSGFuZGxlUmVmZXJlbmNlS2luZDtcbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCBNZXRob2RIYW5kbGUgb2JqZWN0LlxuICAgKi9cbiAgcHVibGljIG1ldGhvZEhhbmRsZTogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RIYW5kbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihyZWZlcmVuY2U6IEZpZWxkUmVmZXJlbmNlIHwgTWV0aG9kUmVmZXJlbmNlIHwgSW50ZXJmYWNlTWV0aG9kUmVmZXJlbmNlLCByZWZlcmVuY2VUeXBlOiBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kKSB7XG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XG4gICAgdGhpcy5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRUeXBlKCk6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX0hBTkRMRTtcbiAgfVxuICBwdWJsaWMgaXNSZXNvbHZlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMubWV0aG9kSGFuZGxlICE9PSBudWxsOyB9XG4gIHB1YmxpYyBnZXRDb25zdGFudCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpIHsgcmV0dXJuIHRoaXMubWV0aG9kSGFuZGxlOyB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGNvbnN0cnVjdHMgYSBKVk0tdmlzaWJsZSBNZXRob2RIYW5kbGUgb2JqZWN0IGZvciB0aGlzXG4gICAqIE1ldGhvZEhhbmRsZS5cbiAgICpcbiAgICogUmVxdWlyZXMgcHJvZHVjaW5nIHRoZSBmb2xsb3dpbmcsIGFuZCBwYXNzaW5nIGl0IHRvIGEgTWV0aG9kSGFuZGxlXG4gICAqIGNvbnN0cnVjdG9yOlxuICAgKiAqIFtqYXZhLmxhbmcuQ2xhc3NdIFRoZSBkZWZpbmluZyBjbGFzcy5cbiAgICogKiBbamF2YS5sYW5nLlN0cmluZ10gVGhlIG5hbWUgb2YgdGhlIGZpZWxkL21ldGhvZC9ldGMuXG4gICAqICogW2phdmEubGFuZy5pbnZva2UuTWV0aG9kVHlwZSB8IGphdmEubGFuZy5DbGFzc10gVGhlIHR5cGUgb2YgdGhlIGZpZWxkIE9SLFxuICAgKiAgIGlmIGEgbWV0aG9kLCB0aGUgdHlwZSBvZiB0aGUgbWV0aG9kIGRlc2NyaXB0b3IuXG4gICAqXG4gICAqIElmIG5lZWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgbmVlZGVkIGNsYXNzZXMuXG4gICAqL1xuICBwdWJsaWMgcmVzb2x2ZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2FsbGVyOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjYjogKHN0YXR1czogYm9vbGVhbikgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoIXRoaXMucmVmZXJlbmNlLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlLnJlc29sdmUodGhyZWFkLCBjbCwgY2FsbGVyLCAoc3RhdHVzOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmICghc3RhdHVzKSB7XG4gICAgICAgICAgY2IoZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZSh0aHJlYWQsIGNsLCBjYWxsZXIsIGNiLCBleHBsaWNpdCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGV4cGxpY2l0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnN0cnVjdE1ldGhvZEhhbmRsZVR5cGUodGhyZWFkLCBjbCwgKHR5cGU6IEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3QpID0+IHtcbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIGNiKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtZXRob2RIYW5kbGVOYXRpdmVzID0gPHR5cGVvZiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01ldGhvZEhhbmRsZU5hdGl2ZXM+ICg8Q2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01ldGhvZEhhbmRsZU5hdGl2ZXM+PiBjbC5nZXRJbml0aWFsaXplZENsYXNzKHRocmVhZCwgJ0xqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZU5hdGl2ZXM7JykpLmdldENvbnN0cnVjdG9yKHRocmVhZCk7XG4gICAgICAgIG1ldGhvZEhhbmRsZU5hdGl2ZXNbJ2xpbmtNZXRob2RIYW5kbGVDb25zdGFudChMamF2YS9sYW5nL0NsYXNzO0lMamF2YS9sYW5nL0NsYXNzO0xqYXZhL2xhbmcvU3RyaW5nO0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGU7J10oXG4gICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgIFtjYWxsZXIuZ2V0Q2xhc3NPYmplY3QodGhyZWFkKSwgdGhpcy5yZWZlcmVuY2VUeXBlLCB0aGlzLmdldERlZmluaW5nQ2xhc3NPYmoodGhyZWFkKSwgdGhyZWFkLmdldEpWTSgpLmludGVyblN0cmluZyh0aGlzLnJlZmVyZW5jZS5uYW1lQW5kVHlwZUluZm8ubmFtZSksIHR5cGVdLCAoZT86IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIG1ldGhvZEhhbmRsZT86IEpWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWV0aG9kSGFuZGxlKSA9PiB7XG4gICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHRocmVhZC50aHJvd0V4Y2VwdGlvbihlKTtcbiAgICAgICAgICAgIGNiKGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXRob2RIYW5kbGUgPSBtZXRob2RIYW5kbGU7XG4gICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWZpbmluZ0NsYXNzT2JqKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCk6IEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzcyB7XG4gICAgaWYgKHRoaXMucmVmZXJlbmNlLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRklFTERSRUYpIHtcbiAgICAgIHJldHVybiAoPEZpZWxkUmVmZXJlbmNlPiB0aGlzLnJlZmVyZW5jZSkuZmllbGQuY2xzLmdldENsYXNzT2JqZWN0KHRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoPE1ldGhvZFJlZmVyZW5jZT4gdGhpcy5yZWZlcmVuY2UpLm1ldGhvZC5jbHMuZ2V0Q2xhc3NPYmplY3QodGhyZWFkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdE1ldGhvZEhhbmRsZVR5cGUodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjbDogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIGNiOiAodHlwZTogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlZmVyZW5jZS5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkZJRUxEUkVGKSB7XG4gICAgICB2YXIgcmVzb2x2ZU9iajogc3RyaW5nID0gdGhpcy5yZWZlcmVuY2UubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3I7XG4gICAgICBjbC5yZXNvbHZlQ2xhc3ModGhyZWFkLCByZXNvbHZlT2JqLCAoY2RhdGE6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4pID0+IHtcbiAgICAgICAgaWYgKGNkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY2IoY2RhdGEuZ2V0Q2xhc3NPYmplY3QodGhyZWFkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmNyZWF0ZU1ldGhvZFR5cGUodGhyZWFkLCBjbCwgdGhpcy5yZWZlcmVuY2UubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3IsIChlOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlLCBydjogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RUeXBlKSA9PiB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgdGhyZWFkLnRocm93RXhjZXB0aW9uKGUpO1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKHJ2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBzaXplOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIGluZm9CeXRlU2l6ZTogbnVtYmVyID0gMztcbiAgcHVibGljIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wpOiBJQ29uc3RhbnRQb29sSXRlbSB7XG4gICAgdmFyIHJlZmVyZW5jZUtpbmQ6IGVudW1zLk1ldGhvZEhhbmRsZVJlZmVyZW5jZUtpbmQgPSBieXRlU3RyZWFtLmdldFVpbnQ4KCksXG4gICAgICByZWZlcmVuY2VJbmRleCA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICByZWZlcmVuY2U6IEZpZWxkUmVmZXJlbmNlIHwgTWV0aG9kUmVmZXJlbmNlIHwgSW50ZXJmYWNlTWV0aG9kUmVmZXJlbmNlID0gPGFueT4gY29uc3RhbnRQb29sLmdldChyZWZlcmVuY2VJbmRleCk7XG5cbiAgICBhc3NlcnQoMCA8IHJlZmVyZW5jZUtpbmQgJiYgcmVmZXJlbmNlS2luZCA8IDEwLFxuICAgICAgJ0NvbnN0YW50UG9vbCBNZXRob2RIYW5kbGUgaW52YWxpZCByZWZlcmVuY2VLaW5kOiAnICsgcmVmZXJlbmNlS2luZCk7XG4gICAgLy8gU2FuaXR5IGNoZWNrLlxuICAgIGFzc2VydCgoKCkgPT4ge1xuICAgICAgc3dpdGNoIChyZWZlcmVuY2VLaW5kKSB7XG4gICAgICAgIGNhc2UgZW51bXMuTWV0aG9kSGFuZGxlUmVmZXJlbmNlS2luZC5HRVRGSUVMRDpcbiAgICAgICAgY2FzZSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLkdFVFNUQVRJQzpcbiAgICAgICAgY2FzZSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLlBVVEZJRUxEOlxuICAgICAgICBjYXNlIGVudW1zLk1ldGhvZEhhbmRsZVJlZmVyZW5jZUtpbmQuUFVUU1RBVElDOlxuICAgICAgICAgIHJldHVybiByZWZlcmVuY2UuZ2V0VHlwZSgpID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5GSUVMRFJFRjtcbiAgICAgICAgY2FzZSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLklOVk9LRUlOVEVSRkFDRTpcbiAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuSU5URVJGQUNFX01FVEhPRFJFRlxuICAgICAgICAgICAgJiYgKDxNZXRob2RSZWZlcmVuY2U+cmVmZXJlbmNlKS5uYW1lQW5kVHlwZUluZm8ubmFtZVswXSAhPT0gJzwnO1xuICAgICAgICBjYXNlIGVudW1zLk1ldGhvZEhhbmRsZVJlZmVyZW5jZUtpbmQuSU5WT0tFVklSVFVBTDpcbiAgICAgICAgY2FzZSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLklOVk9LRVNUQVRJQzpcbiAgICAgICAgY2FzZSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLklOVk9LRVNQRUNJQUw6XG4gICAgICAgICAgLy8gTk9URTogU3BlYyBzYXlzIE1FVEhPRFJFRiwgYnV0IEkndmUgZm91bmQgaW5zdGFuY2VzIHdoZXJlXG4gICAgICAgICAgLy8gSU5WT0tFU1BFQ0lBTCBpcyB1c2VkIG9uIGFuIElOVEVSRkFDRV9NRVRIT0RSRUYuXG4gICAgICAgICAgcmV0dXJuIChyZWZlcmVuY2UuZ2V0VHlwZSgpID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5NRVRIT0RSRUZcbiAgICAgICAgICAgIHx8IHJlZmVyZW5jZS5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLklOVEVSRkFDRV9NRVRIT0RSRUYpXG4gICAgICAgICAgICAmJiAoPE1ldGhvZFJlZmVyZW5jZT5yZWZlcmVuY2UpLm5hbWVBbmRUeXBlSW5mby5uYW1lWzBdICE9PSAnPCc7XG4gICAgICAgIGNhc2UgZW51bXMuTWV0aG9kSGFuZGxlUmVmZXJlbmNlS2luZC5ORVdJTlZPS0VTUEVDSUFMOlxuICAgICAgICAgIHJldHVybiByZWZlcmVuY2UuZ2V0VHlwZSgpID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5NRVRIT0RSRUZcbiAgICAgICAgICAgICYmICg8TWV0aG9kUmVmZXJlbmNlPnJlZmVyZW5jZSkubmFtZUFuZFR5cGVJbmZvLm5hbWUgPT09ICc8aW5pdD4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkoKSwgXCJJbnZhbGlkIGNvbnN0YW50IHBvb2wgcmVmZXJlbmNlIGZvciBtZXRob2QgaGFuZGxlIHJlZmVyZW5jZSB0eXBlOiBcIiArIGVudW1zLk1ldGhvZEhhbmRsZVJlZmVyZW5jZUtpbmRbcmVmZXJlbmNlS2luZF0pO1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHJlZmVyZW5jZSwgcmVmZXJlbmNlS2luZCk7XG4gIH1cbn1cbkNQX0NMQVNTRVNbZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX0hBTkRMRV0gPSBNZXRob2RIYW5kbGU7XG5cbi8vICNlbmRyZWdpb25cblxuLyoqXG4gKiBDb25zdGFudCBwb29sIHR5cGUgKnJlc29sdXRpb24gdGllcnMqLiBWYWx1ZSBpcyB0aGUgdGllciwga2V5IGlzIHRoZVxuICogY29uc3RhbnQgcG9vbCB0eXBlLlxuICogVGllciAwIGhhcyBubyByZWZlcmVuY2VzIHRvIG90aGVyIGNvbnN0YW50IHBvb2wgaXRlbXMsIGFuZCBjYW4gYmUgcmVzb2x2ZWRcbiAqIGZpcnN0LlxuICogVGllciAxIHJlZmVycyB0byB0aWVyIDAgaXRlbXMuXG4gKiBUaWVyIG4gcmVmZXJzIHRvIHRpZXIgbi0xIGl0ZW1zIGFuZCBiZWxvdy5cbiAqIEluaXRpYWxpemVkIGluIHRoZSBnaXZlbiBmYXNoaW9uIHRvIGdpdmUgdGhlIEpTIGVuZ2luZSBhIHRhc3R5IHR5cGUgaGludC5cbiAqL1xudmFyIENPTlNUQU5UX1BPT0xfVElFUjogbnVtYmVyW10gPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4vLyBQb3B1bGF0ZSBDT05TVEFOVF9QT09MX1RJRVIuIFB1dCBpbnRvIGEgY2xvc3VyZSB0byBhdm9pZCBzY29wZSBwb2xsdXRpb24uXG4oKHRpZXJJbmZvczogZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGVbXVtdKSA9PiB7XG4gIHRpZXJJbmZvcy5mb3JFYWNoKCh0aWVySW5mbzogZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGVbXSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIHRpZXJJbmZvLmZvckVhY2goKHR5cGU6IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlKSA9PiB7XG4gICAgICBDT05TVEFOVF9QT09MX1RJRVJbdHlwZV0gPSBpbmRleDtcbiAgICB9KTtcbiAgfSk7XG59KShbXG4gICAgLy8gVGllciAwXG4gICAgW1xuICAgICAgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuVVRGOCxcbiAgICAgIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLklOVEVHRVIsXG4gICAgICBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5GTE9BVCxcbiAgICAgIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkxPTkcsXG4gICAgICBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5ET1VCTEVcbiAgICBdLFxuICAgIC8vIFRpZXIgMVxuICAgIFtcbiAgICAgIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkNMQVNTLFxuICAgICAgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuU1RSSU5HLFxuICAgICAgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTkFNRV9BTkRfVFlQRSxcbiAgICAgIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk1FVEhPRF9UWVBFXG4gICAgXSxcbiAgICAvLyBUaWVyIDJcbiAgICBbXG4gICAgICBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5GSUVMRFJFRixcbiAgICAgIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk1FVEhPRFJFRixcbiAgICAgIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLklOVEVSRkFDRV9NRVRIT0RSRUYsXG4gICAgICBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5JTlZPS0VfRFlOQU1JQ1xuICAgIF0sXG4gICAgLy8gVGllciAzXG4gICAgW1xuICAgICAgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX0hBTkRMRVxuICAgIF1cbiAgXSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnN0YW50IHBvb2wgZm9yIGEgcGFydGljdWxhciBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0YW50UG9vbCB7XG4gIC8qKlxuICAgKiBUaGUgY29yZSBjb25zdGFudCBwb29sIGFycmF5LiBOb3RlIHRoYXQgc29tZSBpbmRpY2VzIGFyZSB1bmRlZmluZWQuXG4gICAqL1xuICBwcml2YXRlIGNvbnN0YW50UG9vbDogSUNvbnN0YW50UG9vbEl0ZW1bXTtcblxuICBwdWJsaWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY3BQYXRjaGVzOiBKVk1UeXBlcy5KVk1BcnJheTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiA9IG51bGwpOiBCeXRlU3RyZWFtIHtcbiAgICB2YXIgY3BDb3VudCA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICAvLyBGaXJzdCBrZXkgaXMgdGhlIHRpZXIuXG4gICAgICBkZWZlcnJlZFF1ZXVlOiB7IG9mZnNldDogbnVtYmVyOyBpbmRleDogbnVtYmVyIH1bXVtdID0gW1tdLCBbXSwgW11dLFxuICAgICAgLy8gVGhlIGVuZGluZyBvZmZzZXQgb2YgdGhlIGNvbnN0YW50IHBvb2wgaXRlbXMuXG4gICAgICBlbmRJZHggPSAwLCBpZHggPSAxLFxuICAgICAgLy8gVGFnIG9mIHRoZSBjdXJyZW50bHktYmVpbmctcHJvY2Vzc2VkIGl0ZW0uXG4gICAgICB0YWcgPSAwLFxuICAgICAgLy8gT2Zmc2V0IG9mIHRoZSBjdXJyZW50bHktYmVpbmctcHJvY2Vzc2VkIGl0ZW0uXG4gICAgICBpdGVtT2Zmc2V0ID0gMCxcbiAgICAgIC8vIFRpZXIgb2YgdGhlIGN1cnJlbnRseS1iZWluZy1wcm9jZXNzZWQgaXRlbS5cbiAgICAgIGl0ZW1UaWVyID0gMDtcbiAgICB0aGlzLmNvbnN0YW50UG9vbCA9IG5ldyBBcnJheTxJQ29uc3RhbnRQb29sSXRlbT4oY3BDb3VudCk7XG5cbiAgICAvLyBTY2FuIGZvciB0aWVyIGluZm8uXG4gICAgd2hpbGUgKGlkeCA8IGNwQ291bnQpIHtcbiAgICAgIGl0ZW1PZmZzZXQgPSBieXRlU3RyZWFtLnBvcygpO1xuICAgICAgdGFnID0gYnl0ZVN0cmVhbS5nZXRVaW50OCgpO1xuICAgICAgYXNzZXJ0KENQX0NMQVNTRVNbdGFnXSAhPT0gbnVsbCAmJiBDUF9DTEFTU0VTW3RhZ10gIT09IHVuZGVmaW5lZCxcbiAgICAgICAgJ1Vua25vd24gQ29uc3RhbnRQb29sIHRhZzogJyArIHRhZyk7XG4gICAgICBpdGVtVGllciA9IENPTlNUQU5UX1BPT0xfVElFUlt0YWddO1xuICAgICAgaWYgKGl0ZW1UaWVyID4gMCkge1xuICAgICAgICBkZWZlcnJlZFF1ZXVlW2l0ZW1UaWVyIC0gMV0ucHVzaCh7IG9mZnNldDogaXRlbU9mZnNldCwgaW5kZXg6IGlkeCB9KTtcbiAgICAgICAgYnl0ZVN0cmVhbS5za2lwKENQX0NMQVNTRVNbdGFnXS5pbmZvQnl0ZVNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25zdGFudFBvb2xbaWR4XSA9IENQX0NMQVNTRVNbdGFnXS5mcm9tQnl0ZXMoYnl0ZVN0cmVhbSwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZHggKz0gQ1BfQ0xBU1NFU1t0YWddLnNpemU7XG4gICAgfVxuICAgIGVuZElkeCA9IGJ5dGVTdHJlYW0ucG9zKCk7XG5cbiAgICAvLyBQcm9jZXNzIHRpZXJzLlxuICAgIGRlZmVycmVkUXVldWUuZm9yRWFjaCgoZGVmZXJyZWRJdGVtczogeyBvZmZzZXQ6IG51bWJlcjsgaW5kZXg6IG51bWJlcjsgfVtdKSA9PiB7XG4gICAgICBkZWZlcnJlZEl0ZW1zLmZvckVhY2goKGl0ZW06IHsgb2Zmc2V0OiBudW1iZXI7IGluZGV4OiBudW1iZXI7IH0pID0+IHtcbiAgICAgICAgYnl0ZVN0cmVhbS5zZWVrKGl0ZW0ub2Zmc2V0KTtcbiAgICAgICAgdGFnID0gYnl0ZVN0cmVhbS5nZXRVaW50OCgpO1xuICAgICAgICB0aGlzLmNvbnN0YW50UG9vbFtpdGVtLmluZGV4XSA9IENQX0NMQVNTRVNbdGFnXS5mcm9tQnl0ZXMoYnl0ZVN0cmVhbSwgdGhpcyk7XG4gICAgICAgIGlmIChjcFBhdGNoZXMgIT09IG51bGwgJiYgY3BQYXRjaGVzLmFycmF5W2l0ZW0uaW5kZXhdICE9PSBudWxsICYmIGNwUGF0Y2hlcy5hcnJheVtpdGVtLmluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBGb3IgZWFjaCBDUCBlbnRyeSwgdGhlIGNvcnJlc3BvbmRpbmcgQ1AgcGF0Y2ggbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBoYXZlXG4gICAgICAgICAgICogdGhlIGZvcm1hdCB0aGF0IG1hdGNoZXMgaXRzIHRhZzpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICogSW50ZWdlciwgTG9uZywgRmxvYXQsIERvdWJsZTogdGhlIGNvcnJlc3BvbmRpbmcgd3JhcHBlciBvYmplY3QgdHlwZSBmcm9tIGphdmEubGFuZ1xuICAgICAgICAgICAqICogVXRmODogYSBzdHJpbmcgKG11c3QgaGF2ZSBzdWl0YWJsZSBzeW50YXggaWYgdXNlZCBhcyBzaWduYXR1cmUgb3IgbmFtZSlcbiAgICAgICAgICAgKiAqIENsYXNzOiBhbnkgamF2YS5sYW5nLkNsYXNzIG9iamVjdFxuICAgICAgICAgICAqICogU3RyaW5nOiBhbnkgb2JqZWN0IChub3QganVzdCBhIGphdmEubGFuZy5TdHJpbmcpXG4gICAgICAgICAgICogKiBJbnRlcmZhY2VNZXRob2RSZWY6IChOWUkpIGEgbWV0aG9kIGhhbmRsZSB0byBpbnZva2Ugb24gdGhhdCBjYWxsIHNpdGUncyBhcmd1bWVudHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgcGF0Y2hPYmo6IEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3QgPSBjcFBhdGNoZXMuYXJyYXlbaXRlbS5pbmRleF07XG4gICAgICAgICAgc3dpdGNoIChwYXRjaE9iai5nZXRDbGFzcygpLmdldEludGVybmFsTmFtZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdMamF2YS9sYW5nL0ludGVnZXI7JzpcbiAgICAgICAgICAgICAgYXNzZXJ0KHRhZyA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuSU5URUdFUik7XG4gICAgICAgICAgICAgICg8Q29uc3RJbnQzMj4gdGhpcy5jb25zdGFudFBvb2xbaXRlbS5pbmRleF0pLnZhbHVlID0gKDxKVk1UeXBlcy5qYXZhX2xhbmdfSW50ZWdlcj4gcGF0Y2hPYmopWydqYXZhL2xhbmcvSW50ZWdlci92YWx1ZSddO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xqYXZhL2xhbmcvTG9uZzsnOlxuICAgICAgICAgICAgICBhc3NlcnQodGFnID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5MT05HKTtcbiAgICAgICAgICAgICAgKDxDb25zdExvbmc+IHRoaXMuY29uc3RhbnRQb29sW2l0ZW0uaW5kZXhdKS52YWx1ZSA9ICg8SlZNVHlwZXMuamF2YV9sYW5nX0xvbmc+IHBhdGNoT2JqKVsnamF2YS9sYW5nL0xvbmcvdmFsdWUnXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMamF2YS9sYW5nL0Zsb2F0Oyc6XG4gICAgICAgICAgICAgIGFzc2VydCh0YWcgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkZMT0FUKTtcbiAgICAgICAgICAgICAgKDxDb25zdEZsb2F0PiB0aGlzLmNvbnN0YW50UG9vbFtpdGVtLmluZGV4XSkudmFsdWUgPSAoPEpWTVR5cGVzLmphdmFfbGFuZ19GbG9hdD4gcGF0Y2hPYmopWydqYXZhL2xhbmcvRmxvYXQvdmFsdWUnXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMamF2YS9sYW5nL0RvdWJsZTsnOlxuICAgICAgICAgICAgICBhc3NlcnQodGFnID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5ET1VCTEUpO1xuICAgICAgICAgICAgICAoPENvbnN0RG91YmxlPiB0aGlzLmNvbnN0YW50UG9vbFtpdGVtLmluZGV4XSkudmFsdWUgPSAoPEpWTVR5cGVzLmphdmFfbGFuZ19Eb3VibGU+IHBhdGNoT2JqKVsnamF2YS9sYW5nL0RvdWJsZS92YWx1ZSddO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xqYXZhL2xhbmcvU3RyaW5nOyc6XG4gICAgICAgICAgICAgIGFzc2VydCh0YWcgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLlVURjgpO1xuICAgICAgICAgICAgICAoPENvbnN0VVRGOD4gdGhpcy5jb25zdGFudFBvb2xbaXRlbS5pbmRleF0pLnZhbHVlID0gKDxKVk1UeXBlcy5qYXZhX2xhbmdfU3RyaW5nPiBwYXRjaE9iaikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMamF2YS9sYW5nL0NsYXNzOyc6XG4gICAgICAgICAgICAgIGFzc2VydCh0YWcgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkNMQVNTKTtcbiAgICAgICAgICAgICAgKDxDbGFzc1JlZmVyZW5jZT4gdGhpcy5jb25zdGFudFBvb2xbaXRlbS5pbmRleF0pLm5hbWUgPSAoPEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzcz4gcGF0Y2hPYmopLiRjbHMuZ2V0SW50ZXJuYWxOYW1lKCk7XG4gICAgICAgICAgICAgICg8Q2xhc3NSZWZlcmVuY2U+IHRoaXMuY29uc3RhbnRQb29sW2l0ZW0uaW5kZXhdKS5jbHMgPSA8Q2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0Pj4gKDxKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3M+IHBhdGNoT2JqKS4kY2xzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGFzc2VydCh0YWcgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLlNUUklORyk7XG4gICAgICAgICAgICAgICg8Q29uc3RTdHJpbmc+IHRoaXMuY29uc3RhbnRQb29sW2l0ZW0uaW5kZXhdKS5zdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgIC8vIFhYWDogTm90IGFjdHVhbGx5IGEgc3RyaW5nLCBidXQgdGhlIEpWTSBkb2VzIHRoaXMuXG4gICAgICAgICAgICAgICg8Q29uc3RTdHJpbmc+IHRoaXMuY29uc3RhbnRQb29sW2l0ZW0uaW5kZXhdKS52YWx1ZSA9IDxKVk1UeXBlcy5qYXZhX2xhbmdfU3RyaW5nPiBwYXRjaE9iajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFJldHVybiB0byB0aGUgY29ycmVjdCBvZmZzZXQsIGF0IHRoZSBlbmQgb2YgdGhlIENQIGRhdGEuXG4gICAgYnl0ZVN0cmVhbS5zZWVrKGVuZElkeCk7XG4gICAgcmV0dXJuIGJ5dGVTdHJlYW07XG4gIH1cblxuICBwdWJsaWMgZ2V0KGlkeDogbnVtYmVyKTogSUNvbnN0YW50UG9vbEl0ZW0ge1xuICAgIGFzc2VydCh0aGlzLmNvbnN0YW50UG9vbFtpZHhdICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBDb25zdGFudFBvb2wgcmVmZXJlbmNlLlwiKTtcbiAgICByZXR1cm4gdGhpcy5jb25zdGFudFBvb2xbaWR4XTtcbiAgfVxuXG4gIHB1YmxpYyBlYWNoKGZuOiAoaWR4OiBudW1iZXIsIGl0ZW06IElDb25zdGFudFBvb2xJdGVtKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5jb25zdGFudFBvb2wuZm9yRWFjaCgoaXRlbTogSUNvbnN0YW50UG9vbEl0ZW0sIGlkeDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZuKGlkeCwgaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8vIFJlc29sdmVkIGZvcm1zIG9mIGNvbnN0YW50IHBvb2wgaXRlbXMuXG4iLCIvKipcbiAqIFRvcC1sZXZlbCBEb3BwaW8uRGVidWcgbmFtZXNwYWNlLlxuICovXG5cbmltcG9ydCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuaW1wb3J0ICogYXMgTG9nZ2luZyBmcm9tICcuL2xvZ2dpbmcnO1xuaW1wb3J0ICogYXMgRGlmZmxpYiBmcm9tICcuL2RpZmZsaWInO1xuXG5leHBvcnQge0Fzc2VydCwgTG9nZ2luZywgRGlmZmxpYn07XG4iLCJpbXBvcnQgdGhyZWFkaW5nID0gcmVxdWlyZSgnLi90aHJlYWRpbmcnKTtcbmltcG9ydCBlbnVtcyA9IHJlcXVpcmUoJy4vZW51bXMnKTtcbmltcG9ydCBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBKVk0gbW9uaXRvci5cbiAqL1xuY2xhc3MgTW9uaXRvciB7XG4gIC8qKlxuICAgKiBUaGUgb3duZXIgb2YgdGhlIG1vbml0b3IuXG4gICAqL1xuICBwcml2YXRlIG93bmVyOiB0aHJlYWRpbmcuSlZNVGhyZWFkID0gbnVsbDtcbiAgLyoqXG4gICAqIE51bWJlciBvZiB0aW1lcyB0aGF0IHRoZSBjdXJyZW50IG93bmVyIGhhcyBsb2NrZWQgdGhpcyBtb25pdG9yLlxuICAgKi9cbiAgcHJpdmF0ZSBjb3VudDogbnVtYmVyID0gMDtcbiAgLyoqXG4gICAqIEpWTSB0aHJlYWRzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoZSBjdXJyZW50IG93bmVyIHRvIHJlbGlucXVpc2ggdGhlXG4gICAqIG1vbml0b3IuXG4gICAqL1xuICBwcml2YXRlIGJsb2NrZWQ6IHtcbiAgICBbdGhyZWFkUmVmOiBudW1iZXJdOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBibG9ja2VkIHRocmVhZC5cbiAgICAgICAqL1xuICAgICAgdGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSB0aHJlYWQgYmVjb21lcyB0aGVcbiAgICAgICAqIG93bmVyIG9mIHRoZSBtb25pdG9yLlxuICAgICAgICovXG4gICAgICBjYjogKCkgPT4gdm9pZDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxvY2sgY291bnQgdG8gcmVzdG9yZSBvbmNlIHRoZSB0aHJlYWQgb3ducyB0aGUgbG9jay5cbiAgICAgICAqL1xuICAgICAgY291bnQ6IG51bWJlcjtcbiAgICB9XG4gIH0gPSB7fTtcbiAgLyoqXG4gICAqIFF1ZXVlIG9mIEpWTSB0aHJlYWRzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIGEgSlZNIHRocmVhZCB0byBub3RpZnkgdGhlbS5cbiAgICovXG4gIHByaXZhdGUgd2FpdGluZzoge1xuICAgIFt0aHJlYWRSZWY6IG51bWJlcl06IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGJsb2NrZWQgdGhyZWFkLlxuICAgICAgICovXG4gICAgICB0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQ7XG4gICAgICAvKipcbiAgICAgICAqIEEgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkIG9uY2UgdGhlIHRocmVhZCBvd25zIHRoZSBtb25pdG9yLlxuICAgICAgICovXG4gICAgICBjYjogKGZyb21UaW1lcjogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRocmVhZCdzIGxvY2sgY291bnQgYXQgdGhlIHRpbWUgaXQgaW52b2tlZCBPYmplY3Qud2FpdC5cbiAgICAgICAqL1xuICAgICAgY291bnQ6IG51bWJlcjtcbiAgICAgIC8qKlxuICAgICAgICogVHJ1ZSBpZiB0aGUgdGhyZWFkIGlzc3VlZCB3YWl0aW5nIHdpdGggYSB0aW1lb3V0LlxuICAgICAgICovXG4gICAgICBpc1RpbWVkOiBib29sZWFuO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdGltZXIgSUQgZm9yIHRoZSB0aW1lb3V0IGNhbGxiYWNrLCBpZiBpc1RpbWVkIGlzIHRydWUuIEFsbG93cyB1c1xuICAgICAgICogdG8gcmV2b2tlIHRpbWVvdXQgdGltZXJzIGJlZm9yZSB0aGV5IGV4ZWN1dGUuXG4gICAgICAgKi9cbiAgICAgIHRpbWVyPzogbnVtYmVyO1xuICAgIH1cbiAgfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBhY3F1aXJlIHRoZSBtb25pdG9yLlxuICAgKlxuICAgKiBUaHJlYWQgdHJhbnNpdGlvbnM6XG4gICAqICogUlVOTkFCTEUgPT4gQkxPQ0tFRCBbSWYgZmFpbHMgdG8gYWNxdWlyZSBsb2NrXVxuICAgKlxuICAgKiBAcGFyYW0gdGhyZWFkIFRoZSB0aHJlYWQgdGhhdCBpcyB0cnlpbmcgdG8gYWNxdWlyZSB0aGUgbW9uaXRvci5cbiAgICogQHBhcmFtIGNiIElmIHRoaXMgbWV0aG9kIHJldHVybnMgZmFsc2UsIHRoZW4gdGhpcyBjYWxsYmFjayB3aWxsIGJlXG4gICAqICAgdHJpZ2dlcmVkIG9uY2UgdGhlIHRocmVhZCBiZWNvbWVzIG93bmVyIG9mIHRoZSBtb25pdG9yLiBBdCB0aGF0IHRpbWUsXG4gICAqICAgdGhlIHRocmVhZCB3aWxsIGJlIGluIHRoZSBSVU5OQUJMRSBzdGF0ZS5cbiAgICogQHJldHVybiBUcnVlIGlmIHN1Y2Nlc3NmdWxsLCBmYWxzZSBpZiBub3QuIElmIG5vdCBzdWNjZXNzZnVsLCB0aGUgdGhyZWFkXG4gICAqICAgYmVjb21lcyBCTE9DS0VELCBhbmQgdGhlIGlucHV0IGNhbGxiYWNrIHdpbGwgYmUgdHJpZ2dlcmVkIG9uY2UgdGhlXG4gICAqICAgdGhyZWFkIG93bnMgdGhlIG1vbml0b3IgYW5kIGlzIFJVTk5BQkxFLlxuICAgKi9cbiAgcHVibGljIGVudGVyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2I6ICgpID0+IHZvaWQpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5vd25lciA9PT0gdGhyZWFkKSB7XG4gICAgICB0aGlzLmNvdW50Kys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVuZEZvckxvY2sodGhyZWFkLCAxLCBlbnVtcy5UaHJlYWRTdGF0dXMuQkxPQ0tFRCwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmljIHZlcnNpb24gb2YgTW9uaXRvci5lbnRlciBmb3IgY29udGVuZGluZyBmb3IgdGhlIGxvY2suXG4gICAqXG4gICAqIFRocmVhZCB0cmFuc2l0aW9uczpcbiAgICogKiBSVU5OQUJMRSA9PiBVTklOVEVSUlVQVElCTFlfQkxPQ0tFRCBbSWYgZmFpbHMgdG8gYWNxdWlyZSBsb2NrXVxuICAgKiAqIFJVTk5BQkxFID0+IEJMT0NLRUQgW0lmIGZhaWxzIHRvIGFjcXVpcmUgbG9ja11cbiAgICpcbiAgICogQHBhcmFtIHRocmVhZCBUaGUgdGhyZWFkIGNvbnRlbmRpbmcgZm9yIHRoZSBsb2NrLlxuICAgKiBAcGFyYW0gY291bnQgVGhlIGxvY2sgY291bnQgdG8gdXNlIG9uY2UgdGhlIHRocmVhZCBvd25zIHRoZSBsb2NrLlxuICAgKiBAcGFyYW0gYmxvY2tTdGF0dXMgVGhlIFRocmVhZFN0YXR1cyB0byB1c2Ugc2hvdWxkIHRoZSB0aHJlYWQgbmVlZCB0b1xuICAgKiAgIGNvbnRlbmQgZm9yIHRoZSBsb2NrIChlaXRoZXIgQkxPQ0tFRCBvciBVTklOVEVSUlVQVElCTFlfQkxPQ0tFRCkuXG4gICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCBvbmNlIHRoZSB0aHJlYWQgYmVjb21lcyBvd25lciBvZiB0aGUgbG9jay5cbiAgICogQHJldHVybiBUcnVlIGlmIHRoZSB0aHJlYWQgaW1tZWRpYXRlbHkgYWNxdWlyZWQgdGhlIGxvY2ssIGZhbHNlIGlmIHRoZVxuICAgKiAgIHRocmVhZCBpcyBub3cgYmxvY2tlZCBvbiB0aGUgbG9jay5cbiAgICovXG4gIHByaXZhdGUgY29udGVuZEZvckxvY2sodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjb3VudDogbnVtYmVyLCBibG9ja1N0YXR1czogZW51bXMuVGhyZWFkU3RhdHVzLCBjYjogKCkgPT4gdm9pZCk6IGJvb2xlYW4ge1xuICAgIHZhciBvd25lciA9IHRoaXMub3duZXI7XG4gICAgYXNzZXJ0KG93bmVyICE9IHRocmVhZCwgXCJUaHJlYWQgYXR0ZW1wdGluZyB0byBjb250ZW5kIGZvciBsb2NrIGl0IGFscmVhZHkgb3ducyFcIik7XG4gICAgaWYgKG93bmVyID09PSBudWxsKSB7XG4gICAgICBhc3NlcnQodGhpcy5jb3VudCA9PT0gMCk7XG4gICAgICB0aGlzLm93bmVyID0gdGhyZWFkO1xuICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogXCJJZiBhbm90aGVyIHRocmVhZCBhbHJlYWR5IG93bnMgdGhlIG1vbml0b3IgYXNzb2NpYXRlZCB3aXRoIG9iamVjdHJlZixcbiAgICAgICAqICB0aGUgdGhyZWFkIGJsb2NrcyB1bnRpbCB0aGUgbW9uaXRvcidzIGVudHJ5IGNvdW50IGlzIHplcm8sIHRoZW4gdHJpZXNcbiAgICAgICAqICBhZ2FpbiB0byBnYWluIG93bmVyc2hpcC5cIlxuICAgICAgICogQGZyb20gaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvanZtcy9zZTcvaHRtbC9qdm1zLTYuaHRtbCNqdm1zLTYuNS5tb25pdG9yZW50ZXJcbiAgICAgICAqL1xuICAgICAgdGhpcy5ibG9ja2VkW3RocmVhZC5nZXRSZWYoKV0gPSB7IHRocmVhZDogdGhyZWFkLCBjYjogY2IsIGNvdW50OiBjb3VudCB9O1xuICAgICAgdGhyZWFkLnNldFN0YXR1cyhibG9ja1N0YXR1cywgdGhpcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4aXRzIHRoZSBtb25pdG9yLiBIYW5kbGVzIG5vdGlmeWluZyB0aGUgd2FpdGluZyB0aHJlYWRzIGlmIHRoZSBsb2NrXG4gICAqIGJlY29tZXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBUaHJlYWQgdHJhbnNpdGlvbnM6XG4gICAqICogKk5PTkUqIG9uIHRoZSBhcmd1bWVudCB0aHJlYWQuXG4gICAqICogQSAqQkxPQ0tFRCogdGhyZWFkIG1heSBiZSBzY2hlZHVsZWQgaWYgdGhlIG93bmVyIGdpdmVzIHVwIHRoZSBtb25pdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gdGhyZWFkIFRoZSB0aHJlYWQgdGhhdCBpcyBleGl0aW5nIHRoZSBtb25pdG9yLlxuICAgKiBAcmV0dXJuIFRydWUgaWYgZXhpdCBzdWNjZWVkZWQsIGZhbHNlIGlmIGFuIGV4Y2VwdGlvbiBvY2N1cnJlZC5cbiAgICovXG4gIHB1YmxpYyBleGl0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCk6IGJvb2xlYW4ge1xuICAgIHZhciBvd25lciA9IHRoaXMub3duZXI7XG4gICAgaWYgKG93bmVyID09PSB0aHJlYWQpIHtcbiAgICAgIGlmICgtLXRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwb2ludE5ld093bmVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogXCJJZiB0aGUgdGhyZWFkIHRoYXQgZXhlY3V0ZXMgbW9uaXRvcmV4aXQgaXMgbm90IHRoZSBvd25lciBvZiB0aGVcbiAgICAgICAqICBtb25pdG9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5zdGFuY2UgcmVmZXJlbmNlZCBieSBvYmplY3RyZWYsXG4gICAgICAgKiAgbW9uaXRvcmV4aXQgdGhyb3dzIGFuIElsbGVnYWxNb25pdG9yU3RhdGVFeGNlcHRpb24uXCJcbiAgICAgICAqIEBmcm9tIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U3L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUubW9uaXRvcmV4aXRcbiAgICAgICAqL1xuICAgICAgdGhyZWFkLnRocm93TmV3RXhjZXB0aW9uKCdMamF2YS9sYW5nL0lsbGVnYWxNb25pdG9yU3RhdGVFeGNlcHRpb247JywgXCJDYW5ub3QgZXhpdCBhIG1vbml0b3IgdGhhdCB5b3UgZG8gbm90IG93bi5cIik7XG4gICAgfVxuICAgIHJldHVybiBvd25lciA9PT0gdGhyZWFkO1xuICB9XG5cbiAgLyoqXG4gICAqIENob29zZXMgb25lIG9mIHRoZSBibG9ja2VkIHRocmVhZHMgdG8gYmVjb21lIHRoZSBtb25pdG9yJ3Mgb3duZXIuXG4gICAqL1xuICBwcml2YXRlIGFwcG9pbnROZXdPd25lcigpIHtcbiAgICB2YXIgYmxvY2tlZFRocmVhZFJlZnMgPSBPYmplY3Qua2V5cyh0aGlzLmJsb2NrZWQpO1xuICAgIGlmIChibG9ja2VkVGhyZWFkUmVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBVbmJsb2NrIGEgcmFuZG9tIHRocmVhZC5cbiAgICAgIHZhciB1bmJsb2NrZWRSZWYgPSBibG9ja2VkVGhyZWFkUmVmc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBibG9ja2VkVGhyZWFkUmVmcy5sZW5ndGgpXSxcbiAgICAgICAgLy8gWFhYOiBUeXBpbmcgaGFjay4gS2V5IG11c3QgYmUgYSBudW1iZXIuXG4gICAgICAgIHVuYmxvY2tlZCA9IHRoaXMuYmxvY2tlZFs8bnVtYmVyPjxhbnk+dW5ibG9ja2VkUmVmXTtcbiAgICAgIHRoaXMudW5ibG9jayh1bmJsb2NrZWQudGhyZWFkLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFwiQ2F1c2VzIHRoZSBjdXJyZW50IHRocmVhZCB0byB3YWl0IHVudGlsIGFub3RoZXIgdGhyZWFkIGludm9rZXMgdGhlXG4gICAqICBub3RpZnkoKSBtZXRob2Qgb3IgdGhlIG5vdGlmeUFsbCgpIG1ldGhvZCBmb3IgdGhpcyBvYmplY3QsIG9yIHNvbWUgb3RoZXJcbiAgICogIHRocmVhZCBpbnRlcnJ1cHRzIHRoZSBjdXJyZW50IHRocmVhZCwgb3IgYSBjZXJ0YWluIGFtb3VudCBvZiByZWFsIHRpbWVcbiAgICogIGhhcyBlbGFwc2VkLlxuICAgKlxuICAgKiAgVGhpcyBtZXRob2QgY2F1c2VzIHRoZSBjdXJyZW50IHRocmVhZCAoY2FsbCBpdCBUKSB0byBwbGFjZSBpdHNlbGYgaW4gdGhlXG4gICAqICB3YWl0IHNldCBmb3IgdGhpcyBvYmplY3QgYW5kIHRoZW4gdG8gcmVsaW5xdWlzaCBhbnkgYW5kIGFsbFxuICAgKiAgc3luY2hyb25pemF0aW9uIGNsYWltcyBvbiB0aGlzIG9iamVjdC5cIlxuICAgKlxuICAgKiBXZSBjb2FsZXNjZSBhbGwgcG9zc2libGUgd2FpdCBjb25maWd1cmF0aW9ucyBpbnRvIHRoaXMgb25lIGZ1bmN0aW9uLlxuICAgKiBAZnJvbSBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS83L2RvY3MvYXBpL2phdmEvbGFuZy9PYmplY3QuaHRtbCN3YWl0KGxvbmcsIGludClcbiAgICogQHBhcmFtIHRocmVhZCBUaGUgdGhyZWFkIHRoYXQgd2FudHMgdG8gd2FpdCBvbiB0aGlzIG1vbml0b3IuXG4gICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdHJpZ2dlcmVkIG9uY2UgdGhlIHRocmVhZCB3YWtlcyB1cC5cbiAgICogQHBhcmFtIHRpbWVvdXRNcz8gQW4gb3B0aW9uYWwgdGltZW91dCB0aGF0IHNwZWNpZmllcyBob3cgbG9uZyB0aGUgdGhyZWFkXG4gICAqICAgc2hvdWxkIHdhaXQsIGluIG1pbGxpc2Vjb25kcy4gSWYgdGhpcyB2YWx1ZSBpcyAwLCB0aGVuIHdlIGlnbm9yZSBpdC5cbiAgICogQHBhcmFtIHRpbWVvdXROcz8gQW4gb3B0aW9uYWwgdGltZW91dCB0aGF0IHNwZWNpZmllcyBob3cgbG9uZyB0aGUgdGhyZWFkXG4gICAqICAgc2hvdWxkIHdhaXQsIGluIG5hbm9zZWNvbmQgcHJlY2lzaW9uIChjdXJyZW50bHkgaWdub3JlZCkuXG4gICAqIEB0b2RvIFVzZSBoaWdoLXByZWNpc2lvbiB0aW1lcnMgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIHdhaXQgc3VjY2VlZGVkLCBmYWxzZSBpZiBpdCB0cmlnZ2VyZWQgYW4gZXhjZXB0aW9uLlxuICAgKi9cbiAgcHVibGljIHdhaXQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjYjogKGZyb21UaW1lcjogYm9vbGVhbikgPT4gdm9pZCwgdGltZW91dE1zPzogbnVtYmVyLCB0aW1lb3V0TnM/OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5nZXRPd25lcigpID09PSB0aHJlYWQpIHtcbiAgICAgIC8vIElOVkFSSUFOVDogVGhyZWFkIHNob3VsZG4ndCBjdXJyZW50bHkgYmUgYmxvY2tlZCBvbiBhIG1vbml0b3IuXG4gICAgICBhc3NlcnQodGhyZWFkLmdldFN0YXR1cygpICE9PSBlbnVtcy5UaHJlYWRTdGF0dXMuQkxPQ0tFRCk7XG4gICAgICB0aGlzLndhaXRpbmdbdGhyZWFkLmdldFJlZigpXSA9IHtcbiAgICAgICAgdGhyZWFkOiB0aHJlYWQsXG4gICAgICAgIGNiOiBjYixcbiAgICAgICAgY291bnQ6IHRoaXMuY291bnQsXG4gICAgICAgIGlzVGltZWQ6IHRpbWVvdXRNcyAhPSBudWxsICYmIHRpbWVvdXRNcyAhPT0gMFxuICAgICAgfTtcblxuICAgICAgLy8gUmV2b2tlIG93bmVyc2hpcC5cbiAgICAgIHRoaXMub3duZXIgPSBudWxsO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICAgIGlmICh0aW1lb3V0TXMgIT0gbnVsbCAmJiB0aW1lb3V0TXMgIT09IDApIHtcbiAgICAgICAgLy8gU2NoZWR1bGVyIGEgdGltZXIgdGhhdCB3YWtlcyB1cCB0aGUgdGhyZWFkLlxuICAgICAgICAvLyBYWFg6IENhc3RpbmcgdG8gJ251bWJlcicsIHNpbmNlIE5vZGVKUyB0eXBpbmdzIHNwZWNpZnkgYSBUaW1lci5cbiAgICAgICAgdGhpcy53YWl0aW5nW3RocmVhZC5nZXRSZWYoKV0udGltZXIgPSA8bnVtYmVyPjxhbnk+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMudW53YWl0KHRocmVhZCwgdHJ1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICAgIHRocmVhZC5zZXRTdGF0dXMoZW51bXMuVGhyZWFkU3RhdHVzLlRJTUVEX1dBSVRJTkcsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyZWFkLnNldFN0YXR1cyhlbnVtcy5UaHJlYWRTdGF0dXMuV0FJVElORywgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCBhIG5ldyBvd25lci5cbiAgICAgIHRoaXMuYXBwb2ludE5ld093bmVyKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBcIlRoZSBjdXJyZW50IHRocmVhZCBtdXN0IG93biB0aGlzIG9iamVjdCdzIG1vbml0b3JcIlxuICAgICAgICovXG4gICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvSWxsZWdhbE1vbml0b3JTdGF0ZUV4Y2VwdGlvbjsnLCBcIkNhbm5vdCB3YWl0IG9uIGFuIG9iamVjdCB0aGF0IHlvdSBkbyBub3Qgb3duLlwiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIHRocmVhZCBmcm9tIHRoZSB3YWl0aW5nIHNldCwgYW5kIG1ha2VzIGl0IGNvbXBldGVcbiAgICogZm9yIHRoZSBtb25pdG9yIGxvY2suIE9uY2UgaXQgYWNxdWlyZXMgdGhlIGxvY2ssIHdlIHJlc3RvcmUgaXRzIGxvY2tcbiAgICogY291bnQgcHJpb3IgdG8gdHJpZ2dlcmluZyB0aGUgd2FpdCBjYWxsYmFjay5cbiAgICpcbiAgICogSWYgdGhlIHRocmVhZCBpcyBpbnRlcnJ1cHRlZCwgdGhlIHdhaXQgY2FsbGJhY2sgaXMgKm5vdCogdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gdGhyZWFkIFRoZSB0aHJlYWQgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gZnJvbVRpbWVyIEluZGljYXRlcyBpZiB0aGlzIGZ1bmN0aW9uIGNhbGwgd2FzIHRyaWdnZXJlZCBmcm9tIGFcbiAgICogICB0aW1lciBldmVudC5cbiAgICogQHBhcmFtIFtpbnRlcnJ1cHRpbmddIElmIHRydWUsIHRoZW4gd2UgYXJlICppbnRlcnJ1cHRpbmcqIHRoZSB3YWl0LiBEbyBub3RcbiAgICogICB0cmlnZ2VyIHRoZSB3YWl0IGNhbGxiYWNrLlxuICAgKiBAcGFyYW0gW3Vud2FpdENiXSBJZiBpbnRlcnJ1cHRpbmcgaXMgdHJ1ZSwgdGhlbiB0aGlzIGNhbGxiYWNrIGlzIHRyaWdnZXJlZFxuICAgKiAgIG9uY2UgdGhlIHRocmVhZCByZWFjcXVpcmVzIHRoZSBsb2NrLlxuICAgKi9cbiAgcHVibGljIHVud2FpdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyb21UaW1lcjogYm9vbGVhbiwgaW50ZXJydXB0aW5nOiBib29sZWFuID0gZmFsc2UsIHVud2FpdENiOiAoKSA9PiB2b2lkID0gbnVsbCk6IHZvaWQge1xuICAgIC8vIFN0ZXAgMTogUmVtb3ZlIHRoZSB0aHJlYWQgZnJvbSB0aGUgd2FpdGluZyBzZXQuXG4gICAgdmFyIHdhaXRFbnRyeSA9IHRoaXMud2FpdGluZ1t0aHJlYWQuZ2V0UmVmKCldLFxuICAgICAgLy8gSW50ZXJydXB0aW5nIGEgcHJldmlvdXNseS13YWl0aW5nIHRocmVhZCBiZWZvcmUgaXQgYWNxdWlyZXMgYSBsb2NrXG4gICAgICAvLyBtYWtlcyBubyBzZW1hbnRpYyBzZW5zZSwgYXMgdGhlIHRocmVhZCBpcyBjdXJyZW50bHkgc3VzcGVuZGVkIGluIGFcbiAgICAgIC8vIHN5bmNocm9uaXplZCBibG9jayB0aGF0IHJlcXVpcmVzIG93bmVyc2hpcCBvZiB0aGUgbW9uaXRvci5cbiAgICAgIGJsb2NrU3RhdHVzID0gZW51bXMuVGhyZWFkU3RhdHVzLlVOSU5URVJSVVBUQUJMWV9CTE9DS0VELFxuICAgICAgYmxvY2tDYiA9ICgpID0+IHtcbiAgICAgICAgLy8gVGhyZWFkIGlzIFJVTk5BQkxFIGJlZm9yZSB3ZSB0cmlnZ2VyIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdGhyZWFkLnNldFN0YXR1cyhlbnVtcy5UaHJlYWRTdGF0dXMuUlVOTkFCTEUpO1xuICAgICAgICBpZiAoaW50ZXJydXB0aW5nKSB7XG4gICAgICAgICAgdW53YWl0Q2IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YWl0RW50cnkuY2IoZnJvbVRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBhc3NlcnQod2FpdEVudHJ5ICE9IG51bGwpO1xuICAgIGRlbGV0ZSB0aGlzLndhaXRpbmdbdGhyZWFkLmdldFJlZigpXTtcbiAgICAvLyBTdGVwIDI6IFJlbW92ZSB0aGUgdGltZXIgaWYgdGhlIHRpbWVyIGRpZCBub3QgdHJpZ2dlciB0aGlzIGV2ZW50LlxuICAgIGlmICh0aHJlYWQuZ2V0U3RhdHVzKCkgPT09IGVudW1zLlRocmVhZFN0YXR1cy5USU1FRF9XQUlUSU5HICYmICFmcm9tVGltZXIpIHtcbiAgICAgIHZhciB0aW1lcklkID0gd2FpdEVudHJ5LnRpbWVyO1xuICAgICAgYXNzZXJ0KHRpbWVySWQgIT0gbnVsbCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAzOiBBY3F1aXJlIHRoZSBtb25pdG9yIFtBU1lOQ11cbiAgICBpZiAodGhpcy5jb250ZW5kRm9yTG9jayh0aHJlYWQsIHdhaXRFbnRyeS5jb3VudCwgYmxvY2tTdGF0dXMsIGJsb2NrQ2IpKSB7XG4gICAgICAvLyBTdWNjZXNzISBUcmlnZ2VyIHRoZSBibG9ja0NiIGFueXdheS4gSWYgJ2NvbnRlbmRGb3JMb2NrJyByZXR1cm5zIGZhbHNlLFxuICAgICAgLy8gaXQgd2lsbCB0cmlnZ2VyIGJsb2NrQ2Igb25jZSB0aGUgdGhyZWFkIGFjcXVpcmVzIHRoZSBsb2NrLlxuICAgICAgYmxvY2tDYigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgdGhyZWFkIGZyb20gYmVpbmcgYmxvY2tlZCBvbiB0aGUgbW9uaXRvciBzbyBpdCBjYW5cbiAgICogcmUtY29tcGV0ZSBmb3Igb3duZXJzaGlwLlxuICAgKiBAcGFyYW0gW2ludGVycnVwdGluZ10gSWYgdHJ1ZSwgd2UgYXJlIGludGVycnVwdGluZyB0aGUgbW9uaXRvciBibG9jay4gVGhlXG4gICAqICAgdGhyZWFkIHNob3VsZCBub3QgYWNxdWlyZSB0aGUgbG9jaywgYW5kIHRoZSBibG9jayBjYWxsYmFjayBzaG91bGQgbm90XG4gICAqICAgYmUgdHJpZ2dlcmVkLlxuICAgKi9cbiAgcHVibGljIHVuYmxvY2sodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBpbnRlcnJ1cHRpbmc6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIHZhciBibG9ja0VudHJ5ID0gdGhpcy5ibG9ja2VkW3RocmVhZC5nZXRSZWYoKV07XG4gICAgLy8gQ2Fubm90IGludGVycnVwdCBhbiB1bmludGVycnVwdGlibHkgYmxvY2tlZCB0aHJlYWQuXG4gICAgYXNzZXJ0KGludGVycnVwdGluZyA/IHRocmVhZC5nZXRTdGF0dXMoKSA9PT0gZW51bXMuVGhyZWFkU3RhdHVzLkJMT0NLRUQgOiB0cnVlKTtcbiAgICBpZiAoYmxvY2tFbnRyeSAhPSBudWxsKSB7XG4gICAgICBkZWxldGUgdGhpcy5ibG9ja2VkW3RocmVhZC5nZXRSZWYoKV07XG4gICAgICB0aHJlYWQuc2V0U3RhdHVzKGVudW1zLlRocmVhZFN0YXR1cy5SVU5OQUJMRSk7XG4gICAgICBpZiAoIWludGVycnVwdGluZykge1xuICAgICAgICAvLyBObyBvbmUgZWxzZSBjYW4gb3duIHRoZSBtb25pdG9yLlxuICAgICAgICBhc3NlcnQodGhpcy5vd25lciA9PSBudWxsICYmIHRoaXMuY291bnQgPT09IDAsIFwiVFwiICsgdGhyZWFkLmdldFJlZigpICsgXCI6IFdlJ3JlIG5vdCBpbnRlcnJ1cHRpbmcgYSBibG9jaywgYnV0IHNvbWVvbmUgZWxzZSBvd25zIHRoZSBtb25pdG9yPyEgT3duZWQgYnkgXCIgKyAodGhpcy5vd25lciA9PSBudWxsID8gXCJbbm8gb25lXVwiIDogXCJcIiArIHRoaXMub3duZXIuZ2V0UmVmKCkpICsgXCIgQ291bnQ6IFwiICsgdGhpcy5jb3VudCk7XG4gICAgICAgIC8vIEFzc2lnbiB0aGlzIHRocmVhZCBhcyB0aGUgbW9uaXRvciBvd25lci5cbiAgICAgICAgdGhpcy5vd25lciA9IHRocmVhZDtcbiAgICAgICAgdGhpcy5jb3VudCA9IGJsb2NrRW50cnkuY291bnQ7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrLlxuICAgICAgICBibG9ja0VudHJ5LmNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIGEgc2luZ2xlIHdhaXRpbmcgdGhyZWFkLlxuICAgKiBAcGFyYW0gdGhyZWFkIFRoZSBub3RpZnlpbmcgdGhyZWFkLiAqTVVTVCogYmUgdGhlIG93bmVyLlxuICAgKi9cbiAgcHVibGljIG5vdGlmeSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vd25lciA9PT0gdGhyZWFkKSB7XG4gICAgICB2YXIgd2FpdGluZ1JlZnMgPSBPYmplY3Qua2V5cyh0aGlzLndhaXRpbmcpO1xuICAgICAgaWYgKHdhaXRpbmdSZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gTm90aWZ5IGEgcmFuZG9tIHRocmVhZC5cbiAgICAgICAgdGhpcy51bndhaXQodGhpcy53YWl0aW5nWzxudW1iZXI+PGFueT53YWl0aW5nUmVmc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB3YWl0aW5nUmVmcy5sZW5ndGgpXV0udGhyZWFkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogXCJUaHJvd3MgSWxsZWdhbE1vbml0b3JTdGF0ZUV4Y2VwdGlvbiBpZiB0aGUgY3VycmVudCB0aHJlYWQgaXMgbm90IHRoZVxuICAgICAgICogIG93bmVyIG9mIHRoaXMgb2JqZWN0J3MgbW9uaXRvci5cIlxuICAgICAgICogQGZyb20gaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNy9kb2NzL2FwaS9qYXZhL2xhbmcvT2JqZWN0Lmh0bWwjbm90aWZ5KClcbiAgICAgICAqL1xuICAgICAgdGhyZWFkLnRocm93TmV3RXhjZXB0aW9uKCdMamF2YS9sYW5nL0lsbGVnYWxNb25pdG9yU3RhdGVFeGNlcHRpb247JywgXCJDYW5ub3Qgbm90aWZ5IG9uIGEgbW9uaXRvciB0aGF0IHlvdSBkbyBub3Qgb3duLlwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgYWxsIHdhaXRpbmcgdGhyZWFkcy5cbiAgICogQHBhcmFtIHRocmVhZCBUaGUgbm90aWZ5aW5nIHRocmVhZC4gKk1VU1QqIGJlIHRoZSBvd25lci5cbiAgICovXG4gIHB1YmxpYyBub3RpZnlBbGwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3duZXIgPT09IHRocmVhZCkge1xuICAgICAgdmFyIHdhaXRpbmdSZWZzID0gT2JqZWN0LmtleXModGhpcy53YWl0aW5nKSwgaTogbnVtYmVyO1xuICAgICAgLy8gTm90aWZ5IGVhY2ggdGhyZWFkLlxuICAgICAgZm9yIChpID0gMDsgaSA8IHdhaXRpbmdSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudW53YWl0KHRoaXMud2FpdGluZ1s8bnVtYmVyPjxhbnk+d2FpdGluZ1JlZnNbaV1dLnRocmVhZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKipcbiAgICAgICAqIFwiVGhyb3dzIElsbGVnYWxNb25pdG9yU3RhdGVFeGNlcHRpb24gaWYgdGhlIGN1cnJlbnQgdGhyZWFkIGlzIG5vdCB0aGVcbiAgICAgICAqICBvd25lciBvZiB0aGlzIG9iamVjdCdzIG1vbml0b3IuXCJcbiAgICAgICAqIEBmcm9tIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzcvZG9jcy9hcGkvamF2YS9sYW5nL09iamVjdC5odG1sI25vdGlmeUFsbCgpXG4gICAgICAgKi9cbiAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9JbGxlZ2FsTW9uaXRvclN0YXRlRXhjZXB0aW9uOycsIFwiQ2Fubm90IG5vdGlmeUFsbCBvbiBhIG1vbml0b3IgdGhhdCB5b3UgZG8gbm90IG93bi5cIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4gVGhlIG93bmVyIG9mIHRoZSBtb25pdG9yLlxuICAgKi9cbiAgcHVibGljIGdldE93bmVyKCk6IHRocmVhZGluZy5KVk1UaHJlYWQge1xuICAgIHJldHVybiB0aGlzLm93bmVyO1xuICB9XG5cbiAgcHVibGljIGlzV2FpdGluZyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpOiBib29sZWFuIHtcbiAgICAvLyBXYWl0aW5nLCBidXQgKm5vdCogdGltZWQgd2FpdGluZy5cbiAgICByZXR1cm4gdGhpcy53YWl0aW5nW3RocmVhZC5nZXRSZWYoKV0gIT0gbnVsbCAmJiAhdGhpcy53YWl0aW5nW3RocmVhZC5nZXRSZWYoKV0uaXNUaW1lZDtcbiAgfVxuXG4gIHB1YmxpYyBpc1RpbWVkV2FpdGluZyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpOiBib29sZWFuIHtcbiAgICAvLyBUaW1lZCB3YWl0aW5nLCAqbm90KiB3YWl0aW5nLlxuICAgIHJldHVybiB0aGlzLndhaXRpbmdbdGhyZWFkLmdldFJlZigpXSAhPSBudWxsICYmIHRoaXMud2FpdGluZ1t0aHJlYWQuZ2V0UmVmKCldLmlzVGltZWQ7XG4gIH1cblxuICBwdWJsaWMgaXNCbG9ja2VkKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCk6IGJvb2xlYW4ge1xuICAgIC8vIEJsb2NrZWQuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2tlZFt0aHJlYWQuZ2V0UmVmKCldICE9IG51bGw7XG4gIH1cbn1cblxuZXhwb3J0ID0gTW9uaXRvcjtcbiIsIu+7vy8qKlxuICogQSBzYWZlIHRvIHVzZSBrZXkgdmFsdWUgbWFwLlxuICogXG4gKiBKYXZhU2NyaXB0IG9iamVjdHMgY2Fubm90IGJlIHVzZWQgYXMgZ2VuZXJhbC1wdXJwb3NlIGtleSB2YWx1ZSBtYXBzLCBhcyB0aGV5XG4gKiBjb250YWluIGEgbnVtYmVyIG9mIGRlZmF1bHQgZmllbGRzLiBUaGlzIGNsYXNzIGF2b2lkcyB0aG9zZSBpc3N1ZXMuXG4gKi9cbmNsYXNzIFNhZmVNYXA8VD4ge1xuICBwcml2YXRlIGNhY2hlOiB7IFtrZXk6IHN0cmluZ106IFQgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgIC8vIGhhcyBubyBkZWZpbmVkIHByb3BlcnRpZXMgYXNpZGUgZnJvbSBfX3Byb3RvX19cbiAgfVxuXG4gIC8qKlxuICAgKiBNdXRhdGVzIHRoZSBrZXkgc28gdGhhdCBpdCBjYW5ub3QgcG9zc2libHkgY29uZmxpY3Qgd2l0aCBleGlzdGluZyBvYmplY3RcbiAgICogcHJvcGVydGllcy5cbiAgICovXG4gIHByaXZhdGUgZml4S2V5KGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJzsnICsga2V5O1xuICB9XG5cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IFQge1xuICAgIGtleSA9IHRoaXMuZml4S2V5KGtleSk7XG4gICAgaWYgKHRoaXMuY2FjaGVba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldChrZXkpICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGVbdGhpcy5maXhLZXkoa2V5KV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgPSBTYWZlTWFwO1xuIiwiLyoqXG4gKiBVdGlsaXR5IGNsYXNzLiBcInN0cmVhbVwiIG91dCBzdHJpbmcgZGF0YSwgYW5kIGNvbXBpbGUgaW50byBhIHNpbmdsZSBzdHJpbmcuXG4gKi9cbmNsYXNzIFN0cmluZ091dHB1dFN0cmVhbSB7XG4gIHByaXZhdGUgX2RhdGE6IHN0cmluZ1tdID0gW107XG4gIHB1YmxpYyB3cml0ZShkYXRhOiBzdHJpbmcpIHsgdGhpcy5fZGF0YS5wdXNoKGRhdGEpOyB9XG4gIHB1YmxpYyBmbHVzaCgpOiBzdHJpbmcge1xuICAgIHZhciBydiA9IHRoaXMuX2RhdGEuam9pbihcIlwiKTtcbiAgICB0aGlzLl9kYXRhID0gW107XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbn1cblxuZXhwb3J0ID0gU3RyaW5nT3V0cHV0U3RyZWFtO1xuIiwiLyoqXG4gKiBUb3AtbGV2ZWwgRG9wcGlvLlZNIEFQSS5cbiAqL1xuaW1wb3J0IEpWTSA9IHJlcXVpcmUoJy4vanZtJyk7XG5pbXBvcnQgQ0xJID0gcmVxdWlyZSgnLi9qYXZhX2NsaScpO1xuaW1wb3J0ICogYXMgQ2xhc3NGaWxlIGZyb20gJy4vQ2xhc3NGaWxlJztcbmltcG9ydCAqIGFzIFRocmVhZGluZyBmcm9tICcuL3RocmVhZGluZyc7XG5pbXBvcnQgTG9uZyA9IHJlcXVpcmUoJy4vZ0xvbmcnKTtcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCAqIGFzIEVudW1zIGZyb20gJy4vZW51bXMnO1xuaW1wb3J0ICogYXMgSW50ZXJmYWNlcyBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IE1vbml0b3IgPSByZXF1aXJlKCcuL01vbml0b3InKTtcblxuZXhwb3J0IHtKVk0sIENMSSwgQ2xhc3NGaWxlLCBUaHJlYWRpbmcsIExvbmcsIFV0aWwsIEVudW1zLCBJbnRlcmZhY2VzLCBNb25pdG9yfTtcbiIsImltcG9ydCB0aHJlYWRpbmcgPSByZXF1aXJlKCcuL3RocmVhZGluZycpO1xuXG4vKipcbiAqIENoZWNrcyB0aGUgZ2l2ZW4gYXNzZXJ0aW9uLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb246IGJvb2xlYW4sIG1zZz86IHN0cmluZywgdGhyZWFkPzogdGhyZWFkaW5nLkpWTVRocmVhZCkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGZhaWxlZDogJHttc2d9XFxuJHt0aHJlYWQgPyB0aHJlYWQuZ2V0UHJpbnRhYmxlU3RhY2tUcmFjZSgpIDogJyd9YCk7XG4gIH1cbn1cblxuZXhwb3J0ID0gYXNzZXJ0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuaW1wb3J0IEJ5dGVTdHJlYW0gPSByZXF1aXJlKCcuL0J5dGVTdHJlYW0nKTtcbmltcG9ydCBDb25zdGFudFBvb2wgPSByZXF1aXJlKCcuL0NvbnN0YW50UG9vbCcpO1xuaW1wb3J0IGVudW1zID0gcmVxdWlyZSgnLi9lbnVtcycpO1xuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5pbXBvcnQgZ2xvYmFsID0gcmVxdWlyZSgnLi9nbG9iYWwnKTtcblxuZGVjbGFyZSB2YXIgUkVMRUFTRTogYm9vbGVhbjtcbmlmICh0eXBlb2YgUkVMRUFTRSA9PT0gJ3VuZGVmaW5lZCcpIGdsb2JhbC5SRUxFQVNFID0gZmFsc2U7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF0dHJpYnV0ZUNsYXNzIHtcbiAgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sLCBhdHRyTGVuOiBudW1iZXIsIG5hbWU6IHN0cmluZyk6IElBdHRyaWJ1dGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF0dHJpYnV0ZSB7XG4gIGdldE5hbWUoKTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElJbm5lckNsYXNzSW5mbyB7XG4gIGlubmVySW5mb0luZGV4OiBudW1iZXI7XG4gIG91dGVySW5mb0luZGV4OiBudW1iZXI7XG4gIGlubmVyTmFtZUluZGV4OiBudW1iZXI7XG4gIGlubmVyQWNjZXNzRmxhZ3M6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEV4Y2VwdGlvbkhhbmRsZXIgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHVibGljIHN0YXJ0UEM6IG51bWJlcjtcbiAgcHVibGljIGVuZFBDOiBudW1iZXI7XG4gIHB1YmxpYyBoYW5kbGVyUEM6IG51bWJlcjtcbiAgcHVibGljIGNhdGNoVHlwZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihzdGFydFBDOiBudW1iZXIsIGVuZFBDOiBudW1iZXIsIGhhbmRsZXJQQzogbnVtYmVyLCBjYXRjaFR5cGU6IHN0cmluZykge1xuICAgIHRoaXMuc3RhcnRQQyA9IHN0YXJ0UEM7XG4gICAgdGhpcy5lbmRQQyA9IGVuZFBDO1xuICAgIHRoaXMuaGFuZGxlclBDID0gaGFuZGxlclBDO1xuICAgIHRoaXMuY2F0Y2hUeXBlID0gY2F0Y2hUeXBlO1xuICB9XG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnRXhjZXB0aW9uSGFuZGxlcic7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBwYXJzZShieXRlc0FycmF5OiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wpOiBJQXR0cmlidXRlIHtcbiAgICB2YXIgc3RhcnRQQyA9IGJ5dGVzQXJyYXkuZ2V0VWludDE2KCksXG4gICAgICBlbmRQQyA9IGJ5dGVzQXJyYXkuZ2V0VWludDE2KCksXG4gICAgICBoYW5kbGVyUEMgPSBieXRlc0FycmF5LmdldFVpbnQxNigpLFxuICAgICAgY3RpID0gYnl0ZXNBcnJheS5nZXRVaW50MTYoKSxcbiAgICAgIGNhdGNoVHlwZSA9IGN0aSA9PT0gMCA/IFwiPGFueT5cIiA6ICg8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPiBjb25zdGFudFBvb2wuZ2V0KGN0aSkpLm5hbWU7XG4gICAgcmV0dXJuIG5ldyB0aGlzKHN0YXJ0UEMsIGVuZFBDLCBoYW5kbGVyUEMsIGNhdGNoVHlwZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvZGUgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHJpdmF0ZSBtYXhTdGFjazogbnVtYmVyO1xuICBwcml2YXRlIG1heExvY2FsczogbnVtYmVyO1xuICBwdWJsaWMgZXhjZXB0aW9uSGFuZGxlcnM6IEV4Y2VwdGlvbkhhbmRsZXJbXTtcbiAgcHJpdmF0ZSBhdHRyczogSUF0dHJpYnV0ZVtdO1xuICBwcml2YXRlIGNvZGU6IEJ1ZmZlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhTdGFjazogbnVtYmVyLCBtYXhMb2NhbHM6IG51bWJlciwgZXhjZXB0aW9uSGFuZGxlcnM6IEV4Y2VwdGlvbkhhbmRsZXJbXSwgYXR0cnM6IElBdHRyaWJ1dGVbXSwgY29kZTogQnVmZmVyKSB7XG4gICAgdGhpcy5tYXhTdGFjayA9IG1heFN0YWNrO1xuICAgIHRoaXMubWF4TG9jYWxzID0gbWF4TG9jYWxzO1xuICAgIHRoaXMuZXhjZXB0aW9uSGFuZGxlcnMgPSBleGNlcHRpb25IYW5kbGVycztcbiAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnQ29kZSc7XG4gIH1cblxuICBwdWJsaWMgZ2V0TWF4U3RhY2soKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTdGFjaztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUF0dHJpYnV0ZSB7XG4gICAgdmFyIG1heFN0YWNrID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIG1heExvY2FscyA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBjb2RlTGVuID0gYnl0ZVN0cmVhbS5nZXRVaW50MzIoKTtcbiAgICBpZiAoY29kZUxlbiA9PT0gMCkge1xuICAgICAgaWYgKFJFTEVBU0UpIHtcbiAgICAgICAgdGhyb3cgXCJFcnJvciBwYXJzaW5nIGNvZGU6IENvZGUgbGVuZ3RoIGlzIHplcm9cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNvZGUgPSBieXRlU3RyZWFtLnNsaWNlKGNvZGVMZW4pLmdldEJ1ZmZlcigpLFxuICAgICAgZXhjZXB0TGVuID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIGV4Y2VwdGlvbkhhbmRsZXJzOiBFeGNlcHRpb25IYW5kbGVyW10gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2VwdExlbjsgaSsrKSB7XG4gICAgICBleGNlcHRpb25IYW5kbGVycy5wdXNoKDxFeGNlcHRpb25IYW5kbGVyPiBFeGNlcHRpb25IYW5kbGVyLnBhcnNlKGJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbCkpO1xuICAgIH1cbiAgICAvLyB5ZXMsIHRoZXJlIGFyZSBldmVuIGF0dHJzIG9uIGF0dHJzLiBCV09NLi4uIEJXT00uLi5cbiAgICB2YXIgYXR0cnMgPSBtYWtlQXR0cmlidXRlcyhieXRlU3RyZWFtLCBjb25zdGFudFBvb2wpO1xuICAgIHJldHVybiBuZXcgdGhpcyhtYXhTdGFjaywgbWF4TG9jYWxzLCBleGNlcHRpb25IYW5kbGVycywgYXR0cnMsIGNvZGUpO1xuICB9XG5cbiAgcHVibGljIGdldENvZGUoKTogTm9kZUJ1ZmZlciB7XG4gICAgcmV0dXJuIHRoaXMuY29kZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdHRyaWJ1dGUobmFtZTogc3RyaW5nKTogSUF0dHJpYnV0ZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cnNbaV07XG4gICAgICBpZiAoYXR0ci5nZXROYW1lKCkgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUxpbmVOdW1iZXJUYWJsZUVudHJ5IHtcbiAgc3RhcnRQQzogbnVtYmVyO1xuICBsaW5lTnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBMaW5lTnVtYmVyVGFibGUgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHJpdmF0ZSBlbnRyaWVzOiBJTGluZU51bWJlclRhYmxlRW50cnlbXTtcblxuICBjb25zdHJ1Y3RvcihlbnRyaWVzOiBJTGluZU51bWJlclRhYmxlRW50cnlbXSkge1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gJ0xpbmVOdW1iZXJUYWJsZSc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsZXZhbnQgc291cmNlIGNvZGUgbGluZSBudW1iZXIgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbVxuICAgKiBjb3VudGVyLlxuICAgKi9cbiAgcHVibGljIGdldExpbmVOdW1iZXIocGM6IG51bWJlcik6IG51bWJlciB7XG4gICAgdmFyIGo6IG51bWJlciwgbGluZU51bWJlciA9IC0xO1xuICAgIC8vIGdldCB0aGUgbGFzdCBsaW5lIG51bWJlciBiZWZvcmUgdGhlIHN0YWNrIGZyYW1lJ3MgcGNcbiAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbal07XG4gICAgICBpZiAoZW50cnkuc3RhcnRQQyA8PSBwYykge1xuICAgICAgICBsaW5lTnVtYmVyID0gZW50cnkubGluZU51bWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZ1cnRoZXIgZW50cmllcyBhcmUgcGFzdCB0aGUgUEMuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZU51bWJlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUF0dHJpYnV0ZSB7XG4gICAgdmFyIGVudHJpZXM6IElMaW5lTnVtYmVyVGFibGVFbnRyeVtdID0gW107XG4gICAgdmFyIGxudExlbiA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsbnRMZW47IGkrKykge1xuICAgICAgdmFyIHNwYyA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCk7XG4gICAgICB2YXIgbG4gPSBieXRlU3RyZWFtLmdldFVpbnQxNigpO1xuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgJ3N0YXJ0UEMnOiBzcGMsXG4gICAgICAgICdsaW5lTnVtYmVyJzogbG5cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoZW50cmllcyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNvdXJjZUZpbGUgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHVibGljIGZpbGVuYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZmlsZW5hbWU6IHN0cmluZykge1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnU291cmNlRmlsZSc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHBhcnNlKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCk6IElBdHRyaWJ1dGUge1xuICAgIHJldHVybiBuZXcgdGhpcygoPENvbnN0YW50UG9vbC5Db25zdFVURjg+IGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpLnZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTdGFja01hcFRhYmxlRW50cnkge1xuICB0eXBlOiBlbnVtcy5TdGFja01hcFRhYmxlRW50cnlUeXBlO1xuICBvZmZzZXREZWx0YTogbnVtYmVyO1xuICBudW1Mb2NhbHM/OiBudW1iZXI7XG4gIGxvY2Fscz86IHN0cmluZ1tdO1xuICBudW1TdGFja0l0ZW1zPzogbnVtYmVyO1xuICBzdGFjaz86IHN0cmluZ1tdO1xuICBrPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgU3RhY2tNYXBUYWJsZSBpbXBsZW1lbnRzIElBdHRyaWJ1dGUge1xuICBwcml2YXRlIGVudHJpZXM6IElTdGFja01hcFRhYmxlRW50cnlbXTtcblxuICBjb25zdHJ1Y3RvcihlbnRyaWVzOiBJU3RhY2tNYXBUYWJsZUVudHJ5W10pIHtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICB9XG5cbiAgcHVibGljIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuICdTdGFja01hcFRhYmxlJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUF0dHJpYnV0ZSB7XG4gICAgdmFyIG51bUVudHJpZXMgPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgZW50cmllczogSVN0YWNrTWFwVGFibGVFbnRyeVtdID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FbnRyaWVzOyBpKyspIHtcbiAgICAgIGVudHJpZXMucHVzaCh0aGlzLnBhcnNlRW50cnkoYnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhlbnRyaWVzKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlRW50cnkoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSVN0YWNrTWFwVGFibGVFbnRyeSB7XG4gICAgdmFyIGZyYW1lVHlwZSA9IGJ5dGVTdHJlYW0uZ2V0VWludDgoKSwgbG9jYWxzOiBzdHJpbmdbXSxcbiAgICAgIG9mZnNldERlbHRhOiBudW1iZXIsIGk6IG51bWJlcjtcbiAgICBpZiAoZnJhbWVUeXBlIDwgNjQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGVudW1zLlN0YWNrTWFwVGFibGVFbnRyeVR5cGUuU0FNRV9GUkFNRSxcbiAgICAgICAgb2Zmc2V0RGVsdGE6IGZyYW1lVHlwZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lVHlwZSA8IDEyOCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogZW51bXMuU3RhY2tNYXBUYWJsZUVudHJ5VHlwZS5TQU1FX0xPQ0FMU18xX1NUQUNLX0lURU1fRlJBTUUsXG4gICAgICAgIG9mZnNldERlbHRhOiBmcmFtZVR5cGUgLSA2NCxcbiAgICAgICAgc3RhY2s6IFt0aGlzLnBhcnNlVmVyaWZpY2F0aW9uVHlwZUluZm8oYnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sKV1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmcmFtZVR5cGUgPCAyNDcpIHtcbiAgICAgIC8vIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlXG4gICAgfSBlbHNlIGlmIChmcmFtZVR5cGUgPT09IDI0Nykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogZW51bXMuU3RhY2tNYXBUYWJsZUVudHJ5VHlwZS5TQU1FX0xPQ0FMU18xX1NUQUNLX0lURU1fRlJBTUVfRVhURU5ERUQsXG4gICAgICAgIG9mZnNldERlbHRhOiBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgICBzdGFjazogW3RoaXMucGFyc2VWZXJpZmljYXRpb25UeXBlSW5mbyhieXRlU3RyZWFtLCBjb25zdGFudFBvb2wpXVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZyYW1lVHlwZSA8IDI1MSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogZW51bXMuU3RhY2tNYXBUYWJsZUVudHJ5VHlwZS5DSE9QX0ZSQU1FLFxuICAgICAgICBvZmZzZXREZWx0YTogYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgICAgazogMjUxIC0gZnJhbWVUeXBlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZnJhbWVUeXBlID09PSAyNTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGVudW1zLlN0YWNrTWFwVGFibGVFbnRyeVR5cGUuU0FNRV9GUkFNRV9FWFRFTkRFRCxcbiAgICAgICAgb2Zmc2V0RGVsdGE6IGJ5dGVTdHJlYW0uZ2V0VWludDE2KClcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmcmFtZVR5cGUgPCAyNTUpIHtcbiAgICAgIG9mZnNldERlbHRhID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgICAgIGxvY2FscyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyYW1lVHlwZSAtIDI1MTsgaSsrKSB7XG4gICAgICAgIGxvY2Fscy5wdXNoKHRoaXMucGFyc2VWZXJpZmljYXRpb25UeXBlSW5mbyhieXRlU3RyZWFtLCBjb25zdGFudFBvb2wpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGVudW1zLlN0YWNrTWFwVGFibGVFbnRyeVR5cGUuQVBQRU5EX0ZSQU1FLFxuICAgICAgICBvZmZzZXREZWx0YTogb2Zmc2V0RGVsdGEsXG4gICAgICAgIGxvY2FsczogbG9jYWxzXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZnJhbWVUeXBlID09PSAyNTUpIHtcbiAgICAgIG9mZnNldERlbHRhID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgICAgIHZhciBudW1Mb2NhbHMgPSBieXRlU3RyZWFtLmdldFVpbnQxNigpO1xuICAgICAgbG9jYWxzID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTG9jYWxzOyBpKyspIHtcbiAgICAgICAgbG9jYWxzLnB1c2godGhpcy5wYXJzZVZlcmlmaWNhdGlvblR5cGVJbmZvKGJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbCkpO1xuICAgICAgfVxuICAgICAgdmFyIG51bVN0YWNrSXRlbXMgPSBieXRlU3RyZWFtLmdldFVpbnQxNigpO1xuICAgICAgdmFyIHN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVN0YWNrSXRlbXM7IGkrKykge1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMucGFyc2VWZXJpZmljYXRpb25UeXBlSW5mbyhieXRlU3RyZWFtLCBjb25zdGFudFBvb2wpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGVudW1zLlN0YWNrTWFwVGFibGVFbnRyeVR5cGUuRlVMTF9GUkFNRSxcbiAgICAgICAgb2Zmc2V0RGVsdGE6IG9mZnNldERlbHRhLFxuICAgICAgICBudW1Mb2NhbHM6IG51bUxvY2FscyxcbiAgICAgICAgbG9jYWxzOiBsb2NhbHMsXG4gICAgICAgIG51bVN0YWNrSXRlbXM6IG51bVN0YWNrSXRlbXMsXG4gICAgICAgIHN0YWNrOiBzdGFja1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBwYXJzZVZlcmlmaWNhdGlvblR5cGVJbmZvKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCk6IHN0cmluZyB7XG4gICAgdmFyIHRhZyA9IGJ5dGVTdHJlYW0uZ2V0VWludDgoKTtcbiAgICBpZiAodGFnID09PSA3KSB7XG4gICAgICB2YXIgY2xzID0gKDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpLm5hbWU7XG4gICAgICByZXR1cm4gJ2NsYXNzICcgKyAoL1xcdy8udGVzdChjbHNbMF0pID8gdXRpbC5kZXNjcmlwdG9yMnR5cGVzdHIoY2xzKSA6IFwiXFxcIlwiICsgY2xzICsgXCJcXFwiXCIpO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSA4KSB7XG4gICAgICByZXR1cm4gJ3VuaW5pdGlhbGl6ZWQgJyArIGJ5dGVTdHJlYW0uZ2V0VWludDE2KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdUb1R5cGUgPSBbJ2JvZ3VzJywgJ2ludCcsICdmbG9hdCcsICdkb3VibGUnLCAnbG9uZycsICdudWxsJywgJ3RoaXMnLCAnb2JqZWN0JywgJ3VuaW5pdGlhbGl6ZWQnXTtcbiAgICAgIHJldHVybiB0YWdUb1R5cGVbdGFnXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTG9jYWxWYXJpYWJsZVRhYmxlRW50cnkge1xuICBzdGFydFBDOiBudW1iZXI7XG4gIGxlbmd0aDogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0b3I6IHN0cmluZztcbiAgcmVmOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBMb2NhbFZhcmlhYmxlVGFibGUgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHJpdmF0ZSBlbnRyaWVzOiBJTG9jYWxWYXJpYWJsZVRhYmxlRW50cnlbXTtcblxuICBjb25zdHJ1Y3RvcihlbnRyaWVzOiBJTG9jYWxWYXJpYWJsZVRhYmxlRW50cnlbXSkge1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gJ0xvY2FsVmFyaWFibGVUYWJsZSc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHBhcnNlKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCk6IElBdHRyaWJ1dGUge1xuICAgIHZhciBudW1FbnRyaWVzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIGVudHJpZXM6IElMb2NhbFZhcmlhYmxlVGFibGVFbnRyeVtdID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FbnRyaWVzOyBpKyspIHtcbiAgICAgIGVudHJpZXMucHVzaCh0aGlzLnBhcnNlRW50cmllcyhieXRlU3RyZWFtLCBjb25zdGFudFBvb2wpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKGVudHJpZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VFbnRyaWVzKGJ5dGVzX2FycmF5OiBCeXRlU3RyZWFtLCBjb25zdGFudF9wb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUxvY2FsVmFyaWFibGVUYWJsZUVudHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRQQzogYnl0ZXNfYXJyYXkuZ2V0VWludDE2KCksXG4gICAgICBsZW5ndGg6IGJ5dGVzX2FycmF5LmdldFVpbnQxNigpLFxuICAgICAgbmFtZTogKDxDb25zdGFudFBvb2wuQ29uc3RVVEY4PiBjb25zdGFudF9wb29sLmdldChieXRlc19hcnJheS5nZXRVaW50MTYoKSkpLnZhbHVlLFxuICAgICAgZGVzY3JpcHRvcjogKDxDb25zdGFudFBvb2wuQ29uc3RVVEY4PiBjb25zdGFudF9wb29sLmdldChieXRlc19hcnJheS5nZXRVaW50MTYoKSkpLnZhbHVlLFxuICAgICAgcmVmOiBieXRlc19hcnJheS5nZXRVaW50MTYoKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTG9jYWxWYXJpYWJsZVR5cGVUYWJsZUVudHJ5IHtcbiAgc3RhcnRQQzogbnVtYmVyO1xuICBsZW5ndGg6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBzaWduYXR1cmU6IHN0cmluZztcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIExvY2FsVmFyaWFibGVUeXBlVGFibGUgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHVibGljIGVudHJpZXM6IElMb2NhbFZhcmlhYmxlVHlwZVRhYmxlRW50cnlbXTtcbiAgY29uc3RydWN0b3IoZW50cmllczogSUxvY2FsVmFyaWFibGVUeXBlVGFibGVFbnRyeVtdKSB7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfVxuICBwdWJsaWMgZ2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnTG9jYWxWYXJpYWJsZVR5cGVUYWJsZSc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHBhcnNlKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCk6IElBdHRyaWJ1dGUge1xuICAgIHZhciBudW1FbnRyaWVzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSwgaTogbnVtYmVyLFxuICAgICAgZW50cmllczogSUxvY2FsVmFyaWFibGVUeXBlVGFibGVFbnRyeVtdID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgICAgZW50cmllcy5wdXNoKHRoaXMucGFyc2VUYWJsZUVudHJ5KGJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoZW50cmllcyk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBwYXJzZVRhYmxlRW50cnkoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUxvY2FsVmFyaWFibGVUeXBlVGFibGVFbnRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0UEM6IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBsZW5ndGg6IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBuYW1lOiAoPENvbnN0YW50UG9vbC5Db25zdFVURjg+IGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpLnZhbHVlLFxuICAgICAgc2lnbmF0dXJlOiAoPENvbnN0YW50UG9vbC5Db25zdFVURjg+IGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpLnZhbHVlLFxuICAgICAgaW5kZXg6IGJ5dGVTdHJlYW0uZ2V0VWludDE2KClcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFeGNlcHRpb25zIGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyBleGNlcHRpb25zOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3RvcihleGNlcHRpb25zOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuZXhjZXB0aW9ucyA9IGV4Y2VwdGlvbnM7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gJ0V4Y2VwdGlvbnMnO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwYXJzZShieXRlU3RyZWFtOiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wpOiBJQXR0cmlidXRlIHtcbiAgICB2YXIgbnVtRXhjZXB0aW9ucyA9IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCk7XG4gICAgdmFyIGV4Y1JlZnM6IG51bWJlcltdID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FeGNlcHRpb25zOyBpKyspIHtcbiAgICAgIGV4Y1JlZnMucHVzaChieXRlU3RyZWFtLmdldFVpbnQxNigpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKGV4Y1JlZnMubWFwKChyZWY6IG51bWJlcikgPT4gKDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGNvbnN0YW50UG9vbC5nZXQocmVmKSkubmFtZSkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbm5lckNsYXNzZXMgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHVibGljIGNsYXNzZXM6IElJbm5lckNsYXNzSW5mb1tdO1xuXG4gIGNvbnN0cnVjdG9yKGNsYXNzZXM6IElJbm5lckNsYXNzSW5mb1tdKSB7XG4gICAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcztcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnSW5uZXJDbGFzc2VzJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZXNfYXJyYXk6IEJ5dGVTdHJlYW0sIGNvbnN0YW50X3Bvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wpOiBJQXR0cmlidXRlIHtcbiAgICB2YXIgbnVtQ2xhc3NlcyA9IGJ5dGVzX2FycmF5LmdldFVpbnQxNigpLFxuICAgICAgY2xhc3NlczogSUlubmVyQ2xhc3NJbmZvW10gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNsYXNzZXM7IGkrKykge1xuICAgICAgY2xhc3Nlcy5wdXNoKHRoaXMucGFyc2VDbGFzcyhieXRlc19hcnJheSwgY29uc3RhbnRfcG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoY2xhc3Nlcyk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHBhcnNlQ2xhc3MoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUlubmVyQ2xhc3NJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5uZXJJbmZvSW5kZXg6IGJ5dGVTdHJlYW0uZ2V0VWludDE2KCksXG4gICAgICBvdXRlckluZm9JbmRleDogYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIGlubmVyTmFtZUluZGV4OiBieXRlU3RyZWFtLmdldFVpbnQxNigpLFxuICAgICAgaW5uZXJBY2Nlc3NGbGFnczogYnl0ZVN0cmVhbS5nZXRVaW50MTYoKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbnN0YW50VmFsdWUgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHVibGljIHZhbHVlOiBDb25zdGFudFBvb2wuSUNvbnN0YW50UG9vbEl0ZW07XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IENvbnN0YW50UG9vbC5JQ29uc3RhbnRQb29sSXRlbSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnQ29uc3RhbnRWYWx1ZSc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHBhcnNlKGJ5dGVzX2FycmF5OiBCeXRlU3RyZWFtLCBjb25zdGFudF9wb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUF0dHJpYnV0ZSB7XG4gICAgdmFyIHJlZiA9IGJ5dGVzX2FycmF5LmdldFVpbnQxNigpO1xuICAgIHJldHVybiBuZXcgdGhpcyhjb25zdGFudF9wb29sLmdldChyZWYpKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3ludGhldGljIGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnU3ludGhldGljJztcbiAgfVxuICBwdWJsaWMgc3RhdGljIHBhcnNlKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCk6IElBdHRyaWJ1dGUge1xuICAgIHJldHVybiBuZXcgdGhpcygpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXByZWNhdGVkIGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnRGVwcmVjYXRlZCc7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBwYXJzZShieXRlU3RyZWFtOiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wpOiBJQXR0cmlidXRlIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2lnbmF0dXJlIGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyBzaWc6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihzaWc6IHN0cmluZykge1xuICAgIHRoaXMuc2lnID0gc2lnO1xuICB9XG5cbiAgcHVibGljIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuICdTaWduYXR1cmUnO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwYXJzZShieXRlU3RyZWFtOiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wpOiBJQXR0cmlidXRlIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKDxDb25zdGFudFBvb2wuQ29uc3RVVEY4PiBjb25zdGFudFBvb2wuZ2V0KGJ5dGVTdHJlYW0uZ2V0VWludDE2KCkpKS52YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bnRpbWVWaXNpYmxlQW5ub3RhdGlvbnMgaW1wbGVtZW50cyBJQXR0cmlidXRlIHtcbiAgcHVibGljIHJhd0J5dGVzOiBCdWZmZXI7XG4gIHB1YmxpYyBpc0hpZGRlbjogYm9vbGVhbjtcbiAgcHVibGljIGlzQ2FsbGVyU2Vuc2l0aXZlOiBib29sZWFuO1xuICBwdWJsaWMgaXNDb21waWxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihyYXdCeXRlczogQnVmZmVyLCBpc0hpZGRlbjogYm9vbGVhbiwgaXNDYWxsZXJTZW5zaXRpdmU6IGJvb2xlYW4sIGlzQ29tcGlsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnJhd0J5dGVzID0gcmF3Qnl0ZXM7XG4gICAgdGhpcy5pc0hpZGRlbiA9IGlzSGlkZGVuO1xuICAgIHRoaXMuaXNDYWxsZXJTZW5zaXRpdmUgPSBpc0NhbGxlclNlbnNpdGl2ZTtcbiAgICB0aGlzLmlzQ29tcGlsZWQgPSBpc0NvbXBpbGVkO1xuICB9XG5cbiAgcHVibGljIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuICdSdW50aW1lVmlzaWJsZUFubm90YXRpb25zJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sLCBhdHRyTGVuOiBudW1iZXIpOiBJQXR0cmlidXRlIHtcbiAgICAvLyBObyBuZWVkIHRvIHBhcnNlOyBPcGVuSkRLIHBhcnNlcyB0aGVzZSBmcm9tIHdpdGhpbiBKYXZhIGNvZGUgZnJvbVxuICAgIC8vIHRoZSByYXcgYnl0ZXMuXG4gICAgLy8gLi4uYnV0IHdlIG5lZWQgdG8gbG9vayBmb3IgdGhlICdIaWRkZW4nIGFubm90YXRpb24sIHdoaWNoIHNwZWNpZmllcyBpZlxuICAgIC8vIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG9taXR0ZWQgZnJvbSBzdGFjayBmcmFtZXMuXG4gICAgLy8gQW5kIHRoZSAnY29tcGlsZWQnIGFubm90YXRpb24sIHdoaWNoIHNwZWNpZmllcyBpZiB0aGUgbWV0aG9kIHdhc1xuICAgIC8vIGNvbXBpbGVkLlxuICAgIC8vIEFuZCB0aGUgJ0NhbGxlclNlbnNpdGl2ZScgYW5ub3RhdGlvbiwgd2hpY2ggc3BlY2lmaWVzIHRoYXQgdGhlIGZ1bmN0aW9uJ3NcbiAgICAvLyBiZWhhdmlvciBkaWZmZXJzIGRlcGVuZGluZyBvbiB0aGUgY2FsbGVyLlxuXG4gICAgLyoqXG4gICAgICogU2tpcCB0aGUgY3VycmVudCBSdW50aW1lVmlzaWJsZUFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2tpcEFubm90YXRpb24oKSB7XG4gICAgICBieXRlU3RyZWFtLnNraXAoMik7IC8vIHR5cGUgaW5kZXhcbiAgICAgIHZhciBudW1WYWx1ZVBhaXJzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgICAgaTogbnVtYmVyO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVZhbHVlUGFpcnM7IGkrKykge1xuICAgICAgICBieXRlU3RyZWFtLnNraXAoMik7IC8vIGVsZW1lbnQgbmFtZSBpbmRleFxuICAgICAgICBza2lwRWxlbWVudFZhbHVlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2tpcCB0aGlzIHBhcnRpY3VsYXIgZWxlbWVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBza2lwRWxlbWVudFZhbHVlKCkge1xuICAgICAgdmFyIHRhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZVN0cmVhbS5nZXRVaW50OCgpKTtcbiAgICAgIHN3aXRjaCh0YWcpIHtcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgLy8gRmFsbC10aHJvdWdoLlxuICAgICAgICAgIGJ5dGVTdHJlYW0uc2tpcCgyKTtcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNhc2UgJ0InOlxuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgIGNhc2UgJ0knOlxuICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgY2FzZSAnSic6XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgYnl0ZVN0cmVhbS5za2lwKDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgICBza2lwQW5ub3RhdGlvbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICB2YXIgbnVtVmFsdWVzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSwgaTogbnVtYmVyO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgc2tpcEVsZW1lbnRWYWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByYXdCeXRlcyA9IGJ5dGVTdHJlYW0ucmVhZChhdHRyTGVuKSxcbiAgICAgIGlzSGlkZGVuID0gZmFsc2UsIGlzQ29tcGlsZWQgPSBmYWxzZSwgaXNDYWxsZXJTZW5zaXRpdmUgPSBmYWxzZTtcbiAgICBieXRlU3RyZWFtLnNlZWsoYnl0ZVN0cmVhbS5wb3MoKSAtIHJhd0J5dGVzLmxlbmd0aCk7XG4gICAgdmFyIG51bUF0dHJpYnV0ZXMgPSBieXRlU3RyZWFtLmdldFVpbnQxNigpLCBpOiBudW1iZXI7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7IGkrKykge1xuICAgICAgdmFyIHR5cGVOYW1lID0gKDxDb25zdGFudFBvb2wuQ29uc3RVVEY4PiBjb25zdGFudFBvb2wuZ2V0KGJ5dGVTdHJlYW0uZ2V0VWludDE2KCkpKTtcbiAgICAgIC8vIFJld2luZC5cbiAgICAgIGJ5dGVTdHJlYW0uc2VlayhieXRlU3RyZWFtLnBvcygpIC0gMik7XG4gICAgICBza2lwQW5ub3RhdGlvbigpO1xuICAgICAgc3dpdGNoICh0eXBlTmFtZS52YWx1ZSkge1xuICAgICAgICBjYXNlICdMamF2YS9sYW5nL2ludm9rZS9MYW1iZGFGb3JtJEhpZGRlbjsnOlxuICAgICAgICAgIGlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTHNpZy9zdW4vcmVmbGVjdC9DYWxsZXJTZW5zaXRpdmU7JzpcbiAgICAgICAgICBpc0NhbGxlclNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xzaWcvamF2YS9sYW5nL2ludm9rZS9MYW1iZGFGb3JtJENvbXBpbGVkJzpcbiAgICAgICAgICBpc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMocmF3Qnl0ZXMsIGlzSGlkZGVuLCBpc0NhbGxlclNlbnNpdGl2ZSwgaXNDb21waWxlZCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFubm90YXRpb25EZWZhdWx0IGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyByYXdCeXRlczogQnVmZmVyO1xuICBjb25zdHJ1Y3RvcihyYXdCeXRlczogQnVmZmVyKSB7XG4gICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICB9XG5cbiAgcHVibGljIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuICdBbm5vdGF0aW9uRGVmYXVsdCc7XG4gIH1cbiAgcHVibGljIHN0YXRpYyBwYXJzZShieXRlU3RyZWFtOiBCeXRlU3RyZWFtLCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wsIGF0dHJMZW4/OiBudW1iZXIpOiBJQXR0cmlidXRlIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoYnl0ZVN0cmVhbS5yZWFkKGF0dHJMZW4pKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRW5jbG9zaW5nTWV0aG9kIGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyBlbmNDbGFzczogQ29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlO1xuICAvKipcbiAgICogTm90ZTogSXMgTlVMTCBpZiB0aGUgY3VycmVudCBjbGFzcyBpcyBub3QgaW1tZWRpYXRlbHkgZW5jbG9zZWQgYnkgYSBtZXRob2RcbiAgICogb3IgYSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHB1YmxpYyBlbmNNZXRob2Q6IENvbnN0YW50UG9vbC5OYW1lQW5kVHlwZUluZm87XG4gIGNvbnN0cnVjdG9yKGVuY0NsYXNzOiBDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2UsIGVuY01ldGhvZDogQ29uc3RhbnRQb29sLk5hbWVBbmRUeXBlSW5mbykge1xuICAgIHRoaXMuZW5jQ2xhc3MgPSBlbmNDbGFzcztcbiAgICB0aGlzLmVuY01ldGhvZCA9IGVuY01ldGhvZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnRW5jbG9zaW5nTWV0aG9kJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUF0dHJpYnV0ZSB7XG4gICAgdmFyIGVuY0NsYXNzID0gKDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpLFxuICAgICAgbWV0aG9kUmVmID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSwgZW5jTWV0aG9kOiBDb25zdGFudFBvb2wuTmFtZUFuZFR5cGVJbmZvID0gbnVsbDtcbiAgICBpZiAobWV0aG9kUmVmID4gMCkge1xuICAgICAgZW5jTWV0aG9kID0gPENvbnN0YW50UG9vbC5OYW1lQW5kVHlwZUluZm8+IGNvbnN0YW50UG9vbC5nZXQobWV0aG9kUmVmKTtcbiAgICAgIGFzc2VydChlbmNNZXRob2QuZ2V0VHlwZSgpID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5OQU1FX0FORF9UWVBFLCBcIkVuY2xvc2luZyBtZXRob2QgbXVzdCBiZSBhIG5hbWUgYW5kIHR5cGUgaW5mby5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhlbmNDbGFzcywgZW5jTWV0aG9kKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQm9vdHN0cmFwTWV0aG9kcyBpbXBsZW1lbnRzIElBdHRyaWJ1dGUge1xuICBwdWJsaWMgYm9vdHN0cmFwTWV0aG9kczogQXJyYXk8W0NvbnN0YW50UG9vbC5NZXRob2RIYW5kbGUsIENvbnN0YW50UG9vbC5JQ29uc3RhbnRQb29sSXRlbVtdXT47XG4gIGNvbnN0cnVjdG9yKGJvb3RzdHJhcE1ldGhvZHM6IEFycmF5PFtDb25zdGFudFBvb2wuTWV0aG9kSGFuZGxlLCBDb25zdGFudFBvb2wuSUNvbnN0YW50UG9vbEl0ZW1bXV0+KSB7XG4gICAgdGhpcy5ib290c3RyYXBNZXRob2RzID0gYm9vdHN0cmFwTWV0aG9kcztcbiAgfVxuXG4gIHB1YmxpYyBnZXROYW1lKCkge1xuICAgIHJldHVybiAnQm9vdHN0cmFwTWV0aG9kcyc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHBhcnNlKGJ5dGVTdHJlYW06IEJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCk6IElBdHRyaWJ1dGUge1xuICAgIHZhciBudW1Cb290c3RyYXBNZXRob2RzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSxcbiAgICAgIGJvb3RzdHJhcE1ldGhvZHM6IEFycmF5PFtDb25zdGFudFBvb2wuTWV0aG9kSGFuZGxlLCBDb25zdGFudFBvb2wuSUNvbnN0YW50UG9vbEl0ZW1bXV0+ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Cb290c3RyYXBNZXRob2RzOyBpKyspIHtcbiAgICAgIHZhciBtZXRob2RIYW5kbGUgPSA8Q29uc3RhbnRQb29sLk1ldGhvZEhhbmRsZT4gY29uc3RhbnRQb29sLmdldChieXRlU3RyZWFtLmdldFVpbnQxNigpKTtcbiAgICAgIHZhciBudW1BcmdzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgICAgIHZhciBhcmdzOiBDb25zdGFudFBvb2wuSUNvbnN0YW50UG9vbEl0ZW1bXSA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpO1xuICAgICAgfVxuICAgICAgYm9vdHN0cmFwTWV0aG9kcy5wdXNoKFttZXRob2RIYW5kbGUsIGFyZ3NdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKGJvb3RzdHJhcE1ldGhvZHMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW50aW1lVmlzaWJsZVBhcmFtZXRlckFubm90YXRpb25zIGltcGxlbWVudHMgSUF0dHJpYnV0ZSB7XG4gIHB1YmxpYyByYXdCeXRlczogQnVmZmVyO1xuICBjb25zdHJ1Y3RvcihyYXdCeXRlczogQnVmZmVyKSB7XG4gICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xuICB9XG5cbiAgcHVibGljIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuICdSdW50aW1lVmlzaWJsZVBhcmFtZXRlckFubm90YXRpb25zJztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sLCBhdHRyTGVuOiBudW1iZXIpOiBJQXR0cmlidXRlIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoYnl0ZVN0cmVhbS5yZWFkKGF0dHJMZW4pKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUF0dHJpYnV0ZXMoYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSwgY29uc3RhbnRQb29sOiBDb25zdGFudFBvb2wuQ29uc3RhbnRQb29sKTogSUF0dHJpYnV0ZVtde1xuICB2YXIgYXR0clR5cGVzOiB7IFtuYW1lOiBzdHJpbmddOiBJQXR0cmlidXRlQ2xhc3MgfSA9IHtcbiAgICAnQ29kZSc6IENvZGUsXG4gICAgJ0xpbmVOdW1iZXJUYWJsZSc6IExpbmVOdW1iZXJUYWJsZSxcbiAgICAnU291cmNlRmlsZSc6IFNvdXJjZUZpbGUsXG4gICAgJ1N0YWNrTWFwVGFibGUnOiBTdGFja01hcFRhYmxlLFxuICAgICdMb2NhbFZhcmlhYmxlVGFibGUnOiBMb2NhbFZhcmlhYmxlVGFibGUsXG4gICAgJ0xvY2FsVmFyaWFibGVUeXBlVGFibGUnOiBMb2NhbFZhcmlhYmxlVHlwZVRhYmxlLFxuICAgICdDb25zdGFudFZhbHVlJzogQ29uc3RhbnRWYWx1ZSxcbiAgICAnRXhjZXB0aW9ucyc6IEV4Y2VwdGlvbnMsXG4gICAgJ0lubmVyQ2xhc3Nlcyc6IElubmVyQ2xhc3NlcyxcbiAgICAnU3ludGhldGljJzogU3ludGhldGljLFxuICAgICdEZXByZWNhdGVkJzogRGVwcmVjYXRlZCxcbiAgICAnU2lnbmF0dXJlJzogU2lnbmF0dXJlLFxuICAgICdSdW50aW1lVmlzaWJsZUFubm90YXRpb25zJzogUnVudGltZVZpc2libGVBbm5vdGF0aW9ucyxcbiAgICAnQW5ub3RhdGlvbkRlZmF1bHQnOiBBbm5vdGF0aW9uRGVmYXVsdCxcbiAgICAnRW5jbG9zaW5nTWV0aG9kJzogRW5jbG9zaW5nTWV0aG9kLFxuICAgICdCb290c3RyYXBNZXRob2RzJzogQm9vdHN0cmFwTWV0aG9kcyxcbiAgICAnUnVudGltZVZpc2libGVQYXJhbWV0ZXJBbm5vdGF0aW9ucyc6IFJ1bnRpbWVWaXNpYmxlUGFyYW1ldGVyQW5ub3RhdGlvbnNcbiAgfTtcbiAgdmFyIG51bUF0dHJzID0gYnl0ZVN0cmVhbS5nZXRVaW50MTYoKTtcbiAgdmFyIGF0dHJzIDogSUF0dHJpYnV0ZVtdID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQXR0cnM7IGkrKykge1xuICAgIHZhciBuYW1lID0gKDxDb25zdGFudFBvb2wuQ29uc3RVVEY4PiBjb25zdGFudFBvb2wuZ2V0KGJ5dGVTdHJlYW0uZ2V0VWludDE2KCkpKS52YWx1ZTtcbiAgICB2YXIgYXR0ckxlbiA9IGJ5dGVTdHJlYW0uZ2V0VWludDMyKCk7XG4gICAgaWYgKGF0dHJUeXBlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICB2YXIgb2xkTGVuID0gYnl0ZVN0cmVhbS5zaXplKCk7XG4gICAgICB2YXIgYXR0ciA9IGF0dHJUeXBlc1tuYW1lXS5wYXJzZShieXRlU3RyZWFtLCBjb25zdGFudFBvb2wsIGF0dHJMZW4sIG5hbWUpO1xuICAgICAgdmFyIG5ld0xlbiA9IGJ5dGVTdHJlYW0uc2l6ZSgpO1xuICAgICAgYXNzZXJ0KChvbGRMZW4gLSBuZXdMZW4pIDw9IGF0dHJMZW4sIGBBIHBhcnNlZCBhdHRyaWJ1dGUgcmVhZCBiZXlvbmQgaXRzIGRhdGEhICR7bmFtZX1gKTtcbiAgICAgIGlmIChvbGRMZW4gLSBuZXdMZW4gIT09IGF0dHJMZW4pIHtcbiAgICAgICAgYnl0ZVN0cmVhbS5za2lwKGF0dHJMZW4gLSBvbGRMZW4gKyBuZXdMZW4pO1xuICAgICAgfVxuICAgICAgYXR0cnMucHVzaChhdHRyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgbXVzdCBzaWxlbnRseSBpZ25vcmUgb3RoZXIgYXR0cnNcbiAgICAgIGJ5dGVTdHJlYW0uc2tpcChhdHRyTGVuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dHJzO1xufVxuIiwiaW1wb3J0IHtUcmlTdGF0ZX0gZnJvbSAnLi9lbnVtcyc7XG5pbXBvcnQgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCBCcm93c2VyRlMgPSByZXF1aXJlKCdicm93c2VyZnMnKTtcbmltcG9ydCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4vLyBUeXBlIGluZm9ybWF0aW9uIG9ubHkuXG5pbXBvcnQgVEJGU0ZTIGZyb20gJ2Jyb3dzZXJmcy9kaXN0L25vZGUvY29yZS9GUyc7XG4vLyBFeHBvcnQgc28gaXQgY2FuIGJlIHJldHVybmVkIGZyb20gQ2xhc3NwYXRoSmFyLlxuZXhwb3J0IHR5cGUgVFppcEZTID0gQnJvd3NlckZTLkZpbGVTeXN0ZW0uWmlwRlM7XG5sZXQgQkZTRlMgPSBCcm93c2VyRlMuQkZTUmVxdWlyZSgnZnMnKTtcbmxldCBaaXBGUyA9IEJyb3dzZXJGUy5GaWxlU3lzdGVtLlppcEZTO1xuZXhwb3J0IHR5cGUgTWV0YUluZGV4ID0ge1twa2dOYW1lOiBzdHJpbmddOiBib29sZWFuIHwgTWV0YUluZGV4fTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGl0ZW0gb24gdGhlIGNsYXNzcGF0aC4gVXNlZCBieSB0aGUgYm9vdHN0cmFwIGNsYXNzbG9hZGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDbGFzc3BhdGhJdGVtIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoaXMgaXRlbSBvbiB0aGUgY2xhc3NwYXRoLiBBc3luY2hyb25vdXMsIGFzIHRoZSBjbGFzc3BhdGhcbiAgICogaXRlbSBuZWVkcyB0byBwb3B1bGF0ZSBpdHMgY2xhc3NsaXN0LlxuICAgKi9cbiAgaW5pdGlhbGl6ZShjYjogKCkgPT4gdm9pZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjbGFzc3BhdGggaXRlbSBoYXMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBSZWZlcmVuY2UgdHlwZXMgb25seS5cbiAgICogTk9URTogTG9hZGluZyBvZiBzYWlkIGNsYXNzIGlzIG5vdCBndWFyYW50ZWVkIHRvIHN1Y2NlZWQuXG4gICAqIEBwYXJhbSB0eXBlIENsYXNzIG5hbWUgaW4gcGtnL3BhdGgvTmFtZSBmb3JtYXQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgaXQgaGFzIHRoZSBjbGFzcywgZmFsc2UgaWYgbm90LCBpbmRldGVybWluYXRlIGlmIGl0XG4gICAqICAgY2Fubm90IGJlIGRldGVybWluZWQgc3luY2hyb25vdXNseS5cbiAgICovXG4gIGhhc0NsYXNzKHR5cGU6IHN0cmluZyk6IFRyaVN0YXRlO1xuICAvKipcbiAgICogQXR0ZW1wdCB0byBsb2FkIHRoZSBnaXZlbiBjbGFzcyBzeW5jaHJvbm91c2x5LiBSZXR1cm5zIGEgYnVmZmVyLFxuICAgKiBvciByZXR1cm5zIE5VTEwgaWYgdW5zdWNjZXNzZnVsLlxuICAgKiBAcGFyYW0gdHlwZSBDbGFzcyBuYW1lIGluIHBrZy9wYXRoL05hbWUgZm9ybWF0LlxuICAgKi9cbiAgdHJ5TG9hZENsYXNzU3luYyh0eXBlOiBzdHJpbmcpOiBCdWZmZXI7XG4gIC8qKlxuICAgKiBMb2FkIGEgY2xhc3Mgd2l0aCB0aGUgZ2l2ZW4gdHlwZSAoZS5nLiBMamF2YS9sYW5nL1N0cmluZzspLlxuICAgKiBAcGFyYW0gdHlwZSBDbGFzcyBuYW1lIGluIHBrZy9wYXRoL05hbWUgZm9ybWF0LlxuICAgKi9cbiAgbG9hZENsYXNzKHR5cGU6IHN0cmluZywgY2I6IChlcnI6IEVycm9yLCBkYXRhPzogQnVmZmVyKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNsYXNzcGF0aCBpdGVtLlxuICAgKi9cbiAgZ2V0UGF0aCgpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTdGF0IGEgcGFydGljdWxhciByZXNvdXJjZSBpbiB0aGUgY2xhc3NwYXRoLlxuICAgKi9cbiAgc3RhdFJlc291cmNlKHA6IHN0cmluZywgY2I6IChlOiBFcnJvciwgc3RhdD86IGZzLlN0YXRzKSA9PiB2b2lkKTogdm9pZFxuICAvKipcbiAgICogUmVhZCB0aGUgZ2l2ZW4gZGlyZWN0b3J5IHdpdGhpbiB0aGUgY2xhc3NwYXRoIGl0ZW0uXG4gICAqL1xuICByZWFkZGlyKHA6IHN0cmluZywgY2I6IChlOiBFcnJvciwgbGlzdD86IHN0cmluZ1tdKSA9PiB2b2lkKTogdm9pZDtcbiAgLyoqXG4gICAqIFRyaWVzIHRvIHBlcmZvcm0gYSByZWFkZGlyIHN5bmNocm9ub3VzbHkuIFJldHVybnMgbnVsbCBpZiB1bnN1Y2Nlc3NmdWwuXG4gICAqL1xuICB0cnlSZWFkZGlyU3luYyhwOiBzdHJpbmcpOiBzdHJpbmdbXTtcbiAgLyoqXG4gICAqIFRyaWVzIHRvIHBlcmZvcm0gYSBzdGF0IG9wZXJhdGlvbiBzeW5jaHJvbm91c2x5LiBSZXR1cm5zIG51bGwgaWYgdW5zdWNjZXNzZnVsLlxuICAgKi9cbiAgdHJ5U3RhdFN5bmMocDogc3RyaW5nKTogZnMuU3RhdHM7XG59XG5cbmZ1bmN0aW9uIHdpbjJuaXgocDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHAucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBKQVIgZmlsZSBvbiB0aGUgY2xhc3NwYXRoLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RDbGFzc3BhdGhKYXIge1xuICBwcm90ZWN0ZWQgX2ZzID0gbmV3IEJGU0ZTLkZTKCk7XG4gIC8qKlxuICAgKiBXYXMgdGhlIEpBUiBmaWxlIHN1Y2Nlc3NmdWxseSByZWFkP1xuICAgKiAtIFRSVUU6IEpBUiBmaWxlIGlzIHJlYWQgYW5kIG1vdW50ZWQgaW4gdGhpcy5fZnMuXG4gICAqIC0gRkFMU0U6IEpBUiBmaWxlIGNvdWxkIG5vdCBiZSByZWFkLlxuICAgKiAtIElOREVURVJNSU5BVEU6IFdlIGhhdmUgeWV0IHRvIHRyeSByZWFkaW5nIHRoaXMgSkFSIGZpbGUuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2phclJlYWQgPSBUcmlTdGF0ZS5JTkRFVEVSTUlOQVRFO1xuICBwcm90ZWN0ZWQgX3BhdGg6IHN0cmluZztcbiAgY29uc3RydWN0b3IocGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0UGF0aCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fcGF0aDsgfVxuXG4gIHB1YmxpYyBsb2FkSmFyKGNiOiAoZT86IEVycm9yKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2phclJlYWQgIT09IFRyaVN0YXRlLlRSVUUpIHtcbiAgICAgIGZzLnJlYWRGaWxlKHRoaXMuX3BhdGgsIChlLCBkYXRhKSA9PiB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgdGhpcy5famFyUmVhZCA9IFRyaVN0YXRlLkZBTFNFO1xuICAgICAgICAgIGNiKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaaXBGUy5jb21wdXRlSW5kZXgoZGF0YSwgKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnMuaW5pdGlhbGl6ZShuZXcgWmlwRlMoaW5kZXgsIHBhdGguYmFzZW5hbWUodGhpcy5fcGF0aCkpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qYXJSZWFkID0gVHJpU3RhdGUuVFJVRTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5famFyUmVhZCA9IFRyaVN0YXRlLkZBTFNFO1xuICAgICAgICAgICAgICAgIGNiKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9qYXJSZWFkID0gVHJpU3RhdGUuRkFMU0U7XG4gICAgICAgICAgICBjYihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gY2IodGhpcy5famFyUmVhZCA9PT0gVHJpU3RhdGUuVFJVRSA/IG51bGwgOiBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBKQVIgZmlsZS5cIikpKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgaGFzQ2xhc3ModHlwZTogc3RyaW5nKTogVHJpU3RhdGU7XG5cbiAgcHVibGljIHRyeUxvYWRDbGFzc1N5bmModHlwZTogc3RyaW5nKTogQnVmZmVyIHtcbiAgICBpZiAodGhpcy5famFyUmVhZCA9PT0gVHJpU3RhdGUuVFJVRSkge1xuICAgICAgaWYgKHRoaXMuaGFzQ2xhc3ModHlwZSkgIT09IFRyaVN0YXRlLkZBTFNFKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTk9URTogUGF0aCBtdXN0IGJlIGFic29sdXRlLCBvdGhlcndpc2UgQnJvd3NlckZTXG4gICAgICAgICAgLy8gd2lsbCB0cnkgdG8gdXNlIHByb2Nlc3MuY3dkKCkuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZzLnJlYWRGaWxlU3luYyhgLyR7dHlwZX0uY2xhc3NgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTXVzdCBnbyB0aGUgYXN5bmMgcm91dGUuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbiBvcGVyYXRpb24gdGhhdCBkZXBlbmRzIG9uIHRoZSBqYXIgYmVpbmcgbG9hZGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBfd3JhcE9wKG9wOiAoKSA9PiB2b2lkLCBmYWlsQ2I6IChlOiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHN3aXRjaCAodGhpcy5famFyUmVhZCkge1xuICAgICAgY2FzZSBUcmlTdGF0ZS5UUlVFOlxuICAgICAgICBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJpU3RhdGUuRkFMU0U6XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBmYWlsQ2IobmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvYWQgSkFSIGZpbGUuXCIpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5sb2FkSmFyKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl93cmFwT3Aob3AsIGZhaWxDYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhIHN5bmNocm9ub3VzIG9wZXJhdGlvbiB0aGF0IGRlcGVuZHMgb24gdGhlIGphciBiZWluZyBsb2FkZWQuXG4gICAqIFJldHVybnMgbnVsbCBpZiB0aGUgamFyIGlzbid0IGxvYWRlZCwgb3IgaWYgdGhlIG9wZXJhdGlvbiBmYWlscy5cbiAgICovXG4gIHByaXZhdGUgX3dyYXBTeW5jT3A8VD4ob3A6ICgpID0+IFQpOiBUIHtcbiAgICBpZiAodGhpcy5famFyUmVhZCA9PT0gVHJpU3RhdGUuVFJVRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9wKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbG9hZENsYXNzKHR5cGU6IHN0cmluZywgY2I6IChlcnI6IEVycm9yLCBkYXRhPzogQnVmZmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fd3JhcE9wKCgpID0+IHtcbiAgICAgIC8vIFBhdGggbXVzdCBiZSBhYnNvbHV0ZSB0byBhdm9pZCByZWxhdGl2ZSBwYXRoIGlzc3Vlcy5cbiAgICAgIHRoaXMuX2ZzLnJlYWRGaWxlKGAvJHt0eXBlfS5jbGFzc2AsIGNiKTtcbiAgICB9LCBjYik7XG4gIH1cblxuICBwdWJsaWMgc3RhdFJlc291cmNlKHA6IHN0cmluZywgY2I6IChlcnI6IEVycm9yLCBzdGF0cz86IGZzLlN0YXRzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fd3JhcE9wKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnN0YXQocCwgY2IpO1xuICAgIH0sIGNiKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkZGlyKHA6IHN0cmluZywgY2I6IChlOiBFcnJvciwgbGlzdD86IHN0cmluZ1tdKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fd3JhcE9wKCgpID0+IHtcbiAgICAgIHRoaXMuX2ZzLnJlYWRkaXIod2luMm5peChwKSwgY2IpO1xuICAgIH0sIGNiKTtcbiAgfVxuXG4gIHB1YmxpYyB0cnlSZWFkZGlyU3luYyhwOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBTeW5jT3A8c3RyaW5nW10+KCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9mcy5yZWFkZGlyU3luYyh3aW4ybml4KHApKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB0cnlTdGF0U3luYyhwOiBzdHJpbmcpOiBmcy5TdGF0cyB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBTeW5jT3A8ZnMuU3RhdHM+KCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9mcy5zdGF0U3luYyh3aW4ybml4KHApKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRGUygpOiBUWmlwRlMge1xuICAgIHJldHVybiA8VFppcEZTPiB0aGlzLl9mcy5nZXRSb290RlMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgSkFSIGl0ZW0gb24gdGhlIGNsYXNzcGF0aCB0aGF0IGlzIG5vdCBpbiB0aGUgbWV0YSBpbmRleC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVuaW5kZXhlZENsYXNzcGF0aEphciBleHRlbmRzIEFic3RyYWN0Q2xhc3NwYXRoSmFyIGltcGxlbWVudHMgSUNsYXNzcGF0aEl0ZW0ge1xuICAvLyBDb250YWlucyB0aGUgbGlzdCBvZiBjbGFzc2VzIGFjY2Vzc2libGUgZnJvbSB0aGlzIGNsYXNzcGF0aCBpdGVtLlxuICBwcml2YXRlIF9jbGFzc0xpc3Q6IHtbY2xhc3NOYW1lOiBzdHJpbmddOiBib29sZWFufSA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocDogc3RyaW5nKSB7XG4gICAgc3VwZXIocCk7XG4gIH1cblxuICBwdWJsaWMgaGFzQ2xhc3ModHlwZTogc3RyaW5nKTogVHJpU3RhdGUge1xuICAgIGlmICh0aGlzLl9qYXJSZWFkID09PSBUcmlTdGF0ZS5GQUxTRSkge1xuICAgICAgcmV0dXJuIFRyaVN0YXRlLkZBTFNFO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzQ2xhc3ModHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIF9oYXNDbGFzcyh0eXBlOiBzdHJpbmcpOiBUcmlTdGF0ZSB7XG4gICAgaWYgKHRoaXMuX2NsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzTGlzdFt0eXBlXSA/IFRyaVN0YXRlLlRSVUUgOiBUcmlTdGF0ZS5GQUxTRTtcbiAgICB9XG4gICAgcmV0dXJuIFRyaVN0YXRlLklOREVURVJNSU5BVEU7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGlzIGl0ZW0gb24gdGhlIGNsYXNzcGF0aCB3aXRoIHRoZSBnaXZlbiBjbGFzc2xpc3QuXG4gICAqIEBwYXJhbSBjbGFzc2VzIExpc3Qgb2YgY2xhc3NlcyBpbiBwa2cvcGF0aC9OYW1lIGZvcm1hdC5cbiAgICovXG4gIHB1YmxpYyBpbml0aWFsaXplV2l0aENsYXNzbGlzdChjbGFzc2VzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGFzc2VydCh0aGlzLl9jbGFzc0xpc3QgPT09IG51bGwsIGBJbml0aWFsaXppbmcgYSBjbGFzc3BhdGggaXRlbSB0d2ljZSFgKTtcbiAgICB0aGlzLl9jbGFzc0xpc3QgPSB7fTtcbiAgICBsZXQgbGVuID0gY2xhc3Nlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fY2xhc3NMaXN0W2NsYXNzZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZShjYjogKGU/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMubG9hZEphcigoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcGF0aFN0YWNrOiBzdHJpbmdbXSA9IFsnLyddO1xuICAgICAgICBsZXQgY2xhc3NsaXN0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgZnMgPSB0aGlzLl9mcztcbiAgICAgICAgd2hpbGUgKHBhdGhTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHAgPSBwYXRoU3RhY2sucG9wKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBzdGF0ID0gZnMuc3RhdFN5bmMocCk7XG4gICAgICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgIGxldCBsaXN0aW5nID0gZnMucmVhZGRpclN5bmMocCk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhdGhTdGFjay5wdXNoKHBhdGguam9pbihwLCBsaXN0aW5nW2ldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF0aC5leHRuYW1lKHApID09PSAnLmNsYXNzJykge1xuICAgICAgICAgICAgICAvLyBDdXQgb2ZmIGluaXRpYWwgLyBmcm9tIGFic29sdXRlIHBhdGguXG4gICAgICAgICAgICAgIGNsYXNzbGlzdC5wdXNoKHAuc2xpY2UoMSwgcC5sZW5ndGggLSA2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGZpbGVzeXN0ZW0gZXJyb3IgYW5kIHByb2NlZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVdpdGhDbGFzc2xpc3QoY2xhc3NsaXN0KTtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgSkFSIGZpbGUgb24gdGhlIGNsYXNzcGF0aCB0aGF0IGlzIGluIHRoZSBtZXRhLWluZGV4LlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZENsYXNzcGF0aEphciBleHRlbmRzIEFic3RyYWN0Q2xhc3NwYXRoSmFyIGltcGxlbWVudHMgSUNsYXNzcGF0aEl0ZW0ge1xuICBwcml2YXRlIF9tZXRhSW5kZXg6IE1ldGFJbmRleDtcbiAgcHJpdmF0ZSBfbWV0YU5hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihtZXRhSW5kZXg6IE1ldGFJbmRleCwgcDogc3RyaW5nKSB7XG4gICAgc3VwZXIocCk7XG4gICAgdGhpcy5fbWV0YUluZGV4ID0gbWV0YUluZGV4O1xuICAgIHRoaXMuX21ldGFOYW1lID0gcGF0aC5iYXNlbmFtZShwKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplKGNiOiAoZT86IEVycm9yKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IGNiKCkpO1xuICB9XG5cbiAgcHVibGljIGhhc0NsYXNzKHR5cGU6IHN0cmluZyk6IFRyaVN0YXRlIHtcbiAgICBpZiAodGhpcy5famFyUmVhZCA9PT0gVHJpU3RhdGUuRkFMU0UpIHtcbiAgICAgIHJldHVybiBUcmlTdGF0ZS5GQUxTRTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBrZ0NvbXBvbmVudHMgPSB0eXBlLnNwbGl0KCcvJyk7XG4gICAgICBsZXQgc2VhcmNoOiBNZXRhSW5kZXggPSB0aGlzLl9tZXRhSW5kZXg7XG4gICAgICAvLyBQb3Agb2ZmIGNsYXNzIG5hbWUuXG4gICAgICBwa2dDb21wb25lbnRzLnBvcCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwa2dDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpdGVtID0gc2VhcmNoW3BrZ0NvbXBvbmVudHNbaV1dO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAvLyBpdGVtID09PSB1bmRlZmluZWQgb3IgZmFsc2UuXG4gICAgICAgICAgcmV0dXJuIFRyaVN0YXRlLkZBTFNFO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gVHJpU3RhdGUuSU5ERVRFUk1JTkFURTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNdXN0IGJlIGFuIG9iamVjdC5cbiAgICAgICAgICBzZWFyY2ggPSA8YW55PiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgbWV0YS1pbmRleCBpcyBjb21wbGV0ZS5cbiAgICAgIHJldHVybiBUcmlTdGF0ZS5GQUxTRTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZm9sZGVyIG9uIHRoZSBjbGFzc3BhdGguXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGFzc3BhdGhGb2xkZXIgaW1wbGVtZW50cyBJQ2xhc3NwYXRoSXRlbSB7XG4gIHByaXZhdGUgX3BhdGg6IHN0cmluZztcbiAgY29uc3RydWN0b3IocGF0aDogc3RyaW5nKSB7XG4gICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0UGF0aCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fcGF0aDsgfVxuXG4gIHB1YmxpYyBoYXNDbGFzcyh0eXBlOiBzdHJpbmcpOiBUcmlTdGF0ZSB7XG4gICAgcmV0dXJuIFRyaVN0YXRlLklOREVURVJNSU5BVEU7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZShjYjogKGU/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIC8vIE5PUC5cbiAgICBzZXRJbW1lZGlhdGUoY2IpO1xuICB9XG5cbiAgcHVibGljIHRyeUxvYWRDbGFzc1N5bmModHlwZTogc3RyaW5nKTogQnVmZmVyIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhwYXRoLnJlc29sdmUodGhpcy5fcGF0aCwgYCR7dHlwZX0uY2xhc3NgKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGxvYWRDbGFzcyh0eXBlOiBzdHJpbmcsIGNiOiAoZXJyOiBFcnJvciwgZGF0YT86IEJ1ZmZlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIGZzLnJlYWRGaWxlKHBhdGgucmVzb2x2ZSh0aGlzLl9wYXRoLCBgJHt0eXBlfS5jbGFzc2ApLCBjYik7XG4gIH1cblxuICBwdWJsaWMgc3RhdFJlc291cmNlKHA6IHN0cmluZywgY2I6IChlcnI6IEVycm9yLCBzdGF0cz86IGZzLlN0YXRzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZnMuc3RhdChwYXRoLnJlc29sdmUodGhpcy5fcGF0aCwgcCksIGNiKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkZGlyKHA6IHN0cmluZywgY2I6IChlOiBFcnJvciwgbGlzdD86IHN0cmluZ1tdKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZnMucmVhZGRpcihwYXRoLnJlc29sdmUodGhpcy5fcGF0aCwgcCksIGNiKTtcbiAgfVxuXG4gIHB1YmxpYyB0cnlSZWFkZGlyU3luYyhwOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhwYXRoLnJlc29sdmUodGhpcy5fcGF0aCwgcCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB0cnlTdGF0U3luYyhwOiBzdHJpbmcpOiBmcy5TdGF0cyB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcy5zdGF0U3luYyhwYXRoLnJlc29sdmUodGhpcy5fcGF0aCwgcCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGFzc3BhdGggaXRlbSB0aGF0IGNhbm5vdCBiZSBmb3VuZC5cbiAqL1xuZXhwb3J0IGNsYXNzIENsYXNzcGF0aE5vdEZvdW5kIGltcGxlbWVudHMgSUNsYXNzcGF0aEl0ZW0ge1xuICBwcml2YXRlIF9wYXRoOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHBhdGg6IHN0cmluZykge1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICB9XG5cbiAgcHVibGljIGdldFBhdGgoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3BhdGg7IH1cblxuICBwdWJsaWMgaGFzQ2xhc3ModHlwZTogc3RyaW5nKTogVHJpU3RhdGUgeyByZXR1cm4gVHJpU3RhdGUuRkFMU0U7IH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZShjYjogKGU/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQgeyBzZXRJbW1lZGlhdGUoY2IpOyB9XG5cbiAgcHVibGljIGluaXRpYWxpemVXaXRoQ2xhc3NsaXN0KGNsYXNzbGlzdDogc3RyaW5nW10pOiB2b2lkIHt9XG5cbiAgcHVibGljIHRyeUxvYWRDbGFzc1N5bmModHlwZTogc3RyaW5nKTogQnVmZmVyIHsgcmV0dXJuIG51bGw7IH1cblxuICBwcml2YXRlIF9ub3RGb3VuZEVycm9yKGNiOiAoZXJyOiBFcnJvcikgPT4gdm9pZCk6IHZvaWQgeyBzZXRJbW1lZGlhdGUoKCkgPT4gY2IobmV3IEVycm9yKFwiQ2xhc3MgY2Fubm90IGJlIGZvdW5kLlwiKSkpOyB9XG5cbiAgcHVibGljIGxvYWRDbGFzcyh0eXBlOiBzdHJpbmcsIGNiOiAoZXJyOiBFcnJvciwgZGF0YT86IEJ1ZmZlcikgPT4gdm9pZCk6IHZvaWQgeyB0aGlzLl9ub3RGb3VuZEVycm9yKGNiKTsgfVxuXG4gIHB1YmxpYyBzdGF0UmVzb3VyY2UocDogc3RyaW5nLCBjYjogKGVycjogRXJyb3IsIHN0YXRzPzogZnMuU3RhdHMpID0+IHZvaWQpOiB2b2lkIHsgdGhpcy5fbm90Rm91bmRFcnJvcihjYik7IH1cblxuICBwdWJsaWMgcmVhZGRpcihwOiBzdHJpbmcsIGNiOiAoZTogRXJyb3IsIGxpc3Q/OiBzdHJpbmdbXSkgPT4gdm9pZCk6IHZvaWQgeyB0aGlzLl9ub3RGb3VuZEVycm9yKGNiKTsgfVxuXG4gIHB1YmxpYyB0cnlSZWFkZGlyU3luYyhwOiBzdHJpbmcpOiBzdHJpbmdbXSB7IHJldHVybiBudWxsOyB9XG5cbiAgcHVibGljIHRyeVN0YXRTeW5jKHA6IHN0cmluZyk6IGZzLlN0YXRzIHsgcmV0dXJuIG51bGw7IH1cbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWV0YSBpbmRleCBpbnRvIGEgbG9va3VwIHRhYmxlIGZyb20gcGFja2FnZSBuYW1lICh3aXRoIHNsYXNoZXMpIHRvIEpBUiBmaWxlLlxuICogUmV0dXJucyBhIHR1cGxlIG9mIEpBUiBmaWxlcyBpbiB0aGUgbWV0YSBpbmRleCBhbmQgdGhlIG1ldGEgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0YUluZGV4KG1ldGFJbmRleDogc3RyaW5nKToge1tqYXJGaWxlOiBzdHJpbmddOiBNZXRhSW5kZXh9IHtcbiAgbGV0IGxpbmVzID0gbWV0YUluZGV4LnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgcnY6IHtbamFyRmlsZTogc3RyaW5nXTogTWV0YUluZGV4fSA9IHt9O1xuICBsZXQgY3VycmVudEphcjogTWV0YUluZGV4ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgc3dpdGNoIChsaW5lWzBdKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgICAvLyBDb21tZW50IG9yIHJlc291cmNlLW9ubHkgSkFSIGZpbGUuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAvLyBKQVIgZmlsZSB3LyBjbGFzc2VzLlxuICAgICAgICAgIC8vIFNraXAgc3ltYm9sIGFuZCBzcGFjZS5cbiAgICAgICAgICBsZXQgamFyTmFtZSA9IGxpbmUuc2xpY2UoMik7XG4gICAgICAgICAgcnZbamFyTmFtZV0gPSBjdXJyZW50SmFyID0ge307XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gUGFja2FnZSBuYW1lLiBJZiBpdCBlbmRzIHdpdGggLywgdGhlbiBpdCdzIHNoYXJlZFxuICAgICAgICAgIC8vIGFtb25nc3QgbXVsdGlwbGUgSkFSIGZpbGVzLlxuICAgICAgICAgIC8vIFdlIGRvbid0IHRyZWF0IHRob3NlIHNlcGFyYXRlbHksIHRob3VnaCwgc28gc3RhbmRhcmRpemUgaXQuXG4gICAgICAgICAgaWYgKGxpbmVbbGluZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcGtnQ29tcG9uZW50cyA9IGxpbmUuc3BsaXQoJy8nKTtcbiAgICAgICAgICBsZXQgY3VycmVudCA9IGN1cnJlbnRKYXI7XG4gICAgICAgICAgbGV0IGk6IG51bWJlcjtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGtnQ29tcG9uZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjbXAgPSBwa2dDb21wb25lbnRzW2ldLFxuICAgICAgICAgICAgICBuZXh0ID0gY3VycmVudFtjbXBdO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2NtcF0gPSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEludmFyaWFudDogWW91IGNhbid0IGxpc3QgYSBwYWNrYWdlIGFuZCBpdHMgc3VicGFja2FnZXNcbiAgICAgICAgICAgICAgLy8gZm9yIHNhbWUgamFyIGZpbGUuIFRodXMsIGN1cnJlbnRbY21wXSBjYW5ub3QgYmUgYSBib29sZWFuLlxuICAgICAgICAgICAgICBjdXJyZW50ID0gPGFueT4gY3VycmVudFtjbXBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50W3BrZ0NvbXBvbmVudHNbaV1dID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbGlzdCBvZiBwYXRocyAod2hpY2ggbWF5IG9yIG1heSBub3QgZXhpc3QpLCBwcm9kdWNlcyBhIGxpc3Qgb2ZcbiAqIGNsYXNzcGF0aCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQ2xhc3NwYXRoRmFjdG9yeShqYXZhSG9tZVBhdGg6IHN0cmluZywgcGF0aHM6IHN0cmluZ1tdLCBjYjogKGl0ZW1zOiBJQ2xhc3NwYXRoSXRlbVtdKSA9PiB2b2lkKTogdm9pZCB7XG4gIGxldCBjbGFzc3BhdGhJdGVtczogSUNsYXNzcGF0aEl0ZW1bXSA9IG5ldyBBcnJheTxJQ2xhc3NwYXRoSXRlbT4ocGF0aHMubGVuZ3RoKSxcbiAgICBpOiBudW1iZXIgPSAwO1xuXG4gIGZzLnJlYWRGaWxlKHBhdGguam9pbihqYXZhSG9tZVBhdGgsICdsaWInLCAnbWV0YS1pbmRleCcpLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgbGV0IG1ldGFJbmRleDoge1tqYXJOYW1lOiBzdHJpbmddOiBNZXRhSW5kZXh9ID0ge307XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIG1ldGFJbmRleCA9IHBhcnNlTWV0YUluZGV4KGRhdGEudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHV0aWwuYXN5bmNGb3JFYWNoKHBhdGhzLCAocCwgbmV4dEl0ZW0pID0+IHtcbiAgICAgIGxldCBwUmVsVG9Ib21lID0gcGF0aC5yZWxhdGl2ZShgJHtqYXZhSG9tZVBhdGh9L2xpYmAsIHApO1xuICAgICAgZnMuc3RhdChwLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICBsZXQgY3BJdGVtOiBJQ2xhc3NwYXRoSXRlbTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNwSXRlbSA9IG5ldyBDbGFzc3BhdGhOb3RGb3VuZChwKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgY3BJdGVtID0gbmV3IENsYXNzcGF0aEZvbGRlcihwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWV0YUluZGV4W3BSZWxUb0hvbWVdKSB7XG4gICAgICAgICAgICBjcEl0ZW0gPSBuZXcgSW5kZXhlZENsYXNzcGF0aEphcihtZXRhSW5kZXhbcFJlbFRvSG9tZV0sIHApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcEl0ZW0gPSBuZXcgVW5pbmRleGVkQ2xhc3NwYXRoSmFyKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGFzc3BhdGhJdGVtc1tpKytdID0gY3BJdGVtO1xuICAgICAgICBjcEl0ZW0uaW5pdGlhbGl6ZShuZXh0SXRlbSk7XG4gICAgICB9KTtcbiAgICB9LCAoZT8pID0+IHtcbiAgICAgIGNiKGNsYXNzcGF0aEl0ZW1zKTtcbiAgICB9KTtcbiAgfSlcbn1cbiIsIi8qKipcblRoaXMgaXMgbW9kaWZpZWQgZnJvbSBwYXJ0IG9mIGpzZGlmZmxpYiB2MS4wLiA8aHR0cDovL3Nub3d0aWRlLmNvbS9qc2RpZmZsaWI+XG5cbkNvcHlyaWdodCAoYykgMjAwNywgU25vd3RpZGUgSW5mb3JtYXRpY3MgU3lzdGVtcywgSW5jLlxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuXHQqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuXHRcdGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXHQqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcblx0XHR0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG5cdFx0YW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cdCogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgU25vd3RpZGUgSW5mb3JtYXRpY3MgU3lzdGVtcyBub3IgdGhlIG5hbWVzIG9mIGl0c1xuXHRcdGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXNcblx0XHRzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWVxuRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVFxuU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbklOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbkNPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbkFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIXG5EQU1BR0UuXG4qKiovXG4vKiBPcmlnaW5hbCBhdXRob3I6IENoYXMgRW1lcmljayA8Y2VtZXJpY2tAc25vd3RpZGUuY29tPiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHRfZGlmZihhX2xpbmVzOiBzdHJpbmdbXSwgYl9saW5lczogc3RyaW5nW10sIGNvbnRleHQ6IG51bWJlcik6IHN0cmluZ1tdIHtcblx0cmV0dXJuIChuZXcgU2VxdWVuY2VNYXRjaGVyKGFfbGluZXMsIGJfbGluZXMpKS50ZXh0X2RpZmYoY29udGV4dCk7XG59XG5cbi8vIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIHNvcnRpbmcgbGlzdHMgb2YgbnVtZXJpYyB0dXBsZXNcbmZ1bmN0aW9uIF9fbnR1cGxlY29tcChhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pIHtcblx0dmFyIG1sZW4gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG1sZW47IGkrKykge1xuXHRcdGlmIChhW2ldIDwgYltpXSkgcmV0dXJuIC0xO1xuXHRcdGlmIChhW2ldID4gYltpXSkgcmV0dXJuIDE7XG5cdH1cblxuXHRyZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggPyAwIDogKGEubGVuZ3RoIDwgYi5sZW5ndGggPyAtMSA6IDEpO1xufVxuXG4vLyByZXBsYWNlbWVudCBmb3IgcHl0aG9uJ3MgZGljdC5nZXQgZnVuY3Rpb24gLS0gbmVlZCBlYXN5IGRlZmF1bHQgdmFsdWVzXG5mdW5jdGlvbiBfX2RpY3RnZXQoZGljdDogYW55LCBrZXk6IGFueSwgZGVmYXVsdFZhbHVlOiBhbnkpOiBhbnkge1xuXHRyZXR1cm4gZGljdC5oYXNPd25Qcm9wZXJ0eShrZXkpID8gZGljdFtrZXldIDogZGVmYXVsdFZhbHVlO1xufVxuXG5leHBvcnQgY2xhc3MgU2VxdWVuY2VNYXRjaGVyIHtcblx0cHJpdmF0ZSBhIDogc3RyaW5nW107XG5cdHByaXZhdGUgYiA6IHN0cmluZ1tdO1xuXHRwcml2YXRlIG1hdGNoaW5nX2Jsb2NrczogbnVtYmVyW11bXTtcblx0cHJpdmF0ZSBvcGNvZGVzOiBhbnlbXTtcblx0cHJpdmF0ZSBiMmo6IHtbZWx0OiBzdHJpbmddOiBudW1iZXJbXX07XG5cblx0Y29uc3RydWN0b3IoYTogc3RyaW5nW10sIGI6IHN0cmluZ1tdKSB7XG5cdFx0dGhpcy5hID0gYTtcblx0XHR0aGlzLmIgPSBiO1xuXHRcdHRoaXMuYjJqID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWx0ID0gYltpXTtcblx0XHRcdGlmICh0aGlzLmIyai5oYXNPd25Qcm9wZXJ0eShlbHQpKSB7XG5cdFx0XHRcdHRoaXMuYjJqW2VsdF0ucHVzaChpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYjJqW2VsdF0gPSBbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBmaW5kX2xvbmdlc3RfbWF0Y2goYWxvOiBudW1iZXIsIGFoaTogbnVtYmVyLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgYmxvOiBudW1iZXIsIGJoaTogbnVtYmVyKTogW251bWJlcixudW1iZXIsbnVtYmVyXSB7XG5cdFx0dmFyIGEgPSB0aGlzLmE7XG5cdFx0dmFyIGIgPSB0aGlzLmI7XG5cdFx0dmFyIGIyaiA9IHRoaXMuYjJqO1xuXHRcdHZhciBiZXN0aSA9IGFsbztcblx0XHR2YXIgYmVzdGogPSBibG87XG5cdFx0dmFyIGJlc3RzaXplID0gMDtcblxuXHRcdHZhciBqMmxlbiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSBhbG87IGkgPCBhaGk7IGkrKykge1xuXHRcdFx0dmFyIG5ld2oybGVuOiBhbnkgPSB7fTtcblx0XHRcdHZhciBqZGljdCA9IF9fZGljdGdldChiMmosIGFbaV0sIFtdKTtcblx0XHRcdGZvciAodmFyIGprZXkgaW4gamRpY3QpIHtcblx0XHRcdFx0aWYgKGpkaWN0Lmhhc093blByb3BlcnR5KGprZXkpKSB7XG5cdFx0XHRcdFx0dmFyIGogPSBqZGljdFtqa2V5XTtcblx0XHRcdFx0XHRpZiAoaiA8IGJsbykgY29udGludWU7XG5cdFx0XHRcdFx0aWYgKGogPj0gYmhpKSBicmVhaztcblx0XHRcdFx0XHR2YXIgayA9IF9fZGljdGdldChqMmxlbiwgaiAtIDEsIDApICsgMVxuXHRcdFx0XHRcdG5ld2oybGVuW2pdID0gaztcblx0XHRcdFx0XHRpZiAoayA+IGJlc3RzaXplKSB7XG5cdFx0XHRcdFx0XHRiZXN0aSA9IGkgLSBrICsgMTtcblx0XHRcdFx0XHRcdGJlc3RqID0gaiAtIGsgKyAxO1xuXHRcdFx0XHRcdFx0YmVzdHNpemUgPSBrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ajJsZW4gPSBuZXdqMmxlbjtcblx0XHR9XG5cblx0XHR3aGlsZSAoYmVzdGkgPiBhbG8gJiYgYmVzdGogPiBibG8gJiYgYVtiZXN0aSAtIDFdID09IGJbYmVzdGogLSAxXSkge1xuXHRcdFx0YmVzdGktLTtcblx0XHRcdGJlc3RqLS07XG5cdFx0XHRiZXN0c2l6ZSsrO1xuXHRcdH1cblxuXHRcdHdoaWxlIChiZXN0aSArIGJlc3RzaXplIDwgYWhpICYmIGJlc3RqICsgYmVzdHNpemUgPCBiaGkgJiZcblx0XHRcdFx0YVtiZXN0aSArIGJlc3RzaXplXSA9PSBiW2Jlc3RqICsgYmVzdHNpemVdKSB7XG5cdFx0XHRiZXN0c2l6ZSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBbYmVzdGksIGJlc3RqLCBiZXN0c2l6ZV07XG5cdH1cblxuXHRwcml2YXRlIGdldF9tYXRjaGluZ19ibG9ja3MoKTogbnVtYmVyW11bXSB7XG5cdFx0aWYgKHRoaXMubWF0Y2hpbmdfYmxvY2tzICE9IG51bGwpIHJldHVybiB0aGlzLm1hdGNoaW5nX2Jsb2Nrcztcblx0XHR2YXIgbGEgPSB0aGlzLmEubGVuZ3RoO1xuXHRcdHZhciBsYiA9IHRoaXMuYi5sZW5ndGg7XG5cblx0XHR2YXIgcXVldWUgPSBbWzAsIGxhLCAwLCBsYl1dO1xuXHRcdHZhciBtYXRjaGluZ19ibG9ja3M6IEFycmF5PFtudW1iZXIsbnVtYmVyLG51bWJlcl0+ID0gW107XG5cdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdFx0dmFyIHFpID0gcXVldWUucG9wKCk7XG5cdFx0XHR2YXIgYWxvID0gcWlbMF07XG5cdFx0XHR2YXIgYWhpID0gcWlbMV07XG5cdFx0XHR2YXIgYmxvID0gcWlbMl07XG5cdFx0XHR2YXIgYmhpID0gcWlbM107XG5cdFx0XHR2YXIgeCA9IHRoaXMuZmluZF9sb25nZXN0X21hdGNoKGFsbywgYWhpLCBibG8sIGJoaSk7XG5cdFx0XHR2YXIgaSA9IHhbMF07XG5cdFx0XHR2YXIgaiA9IHhbMV07XG5cdFx0XHR2YXIgayA9IHhbMl07XG5cblx0XHRcdGlmIChrKSB7XG5cdFx0XHRcdG1hdGNoaW5nX2Jsb2Nrcy5wdXNoKHgpO1xuXHRcdFx0XHRpZiAoYWxvIDwgaSAmJiBibG8gPCBqKVxuXHRcdFx0XHRcdHF1ZXVlLnB1c2goW2FsbywgaSwgYmxvLCBqXSk7XG5cdFx0XHRcdGlmIChpK2sgPCBhaGkgJiYgaitrIDwgYmhpKVxuXHRcdFx0XHRcdHF1ZXVlLnB1c2goW2kgKyBrLCBhaGksIGogKyBrLCBiaGldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtYXRjaGluZ19ibG9ja3Muc29ydChfX250dXBsZWNvbXApO1xuXG5cdFx0dmFyIGkxID0gMCxcblx0XHQgICAgajEgPSAwLFxuXHRcdCAgICBrMSA9IDA7XG5cdFx0dmFyIG5vbl9hZGphY2VudDogQXJyYXk8W251bWJlcixudW1iZXIsbnVtYmVyXT4gPSBbXTtcblx0XHRmb3IgKHZhciBpZHg9MDsgaWR4IDwgbWF0Y2hpbmdfYmxvY2tzLmxlbmd0aDsgaWR4KyspIHtcblx0XHRcdHZhciBibG9jayA9IG1hdGNoaW5nX2Jsb2Nrc1tpZHhdO1xuXHRcdFx0dmFyIGkyID0gYmxvY2tbMF07XG5cdFx0XHR2YXIgajIgPSBibG9ja1sxXTtcblx0XHRcdHZhciBrMiA9IGJsb2NrWzJdO1xuXHRcdFx0aWYgKGkxICsgazEgPT0gaTIgJiYgajEgKyBrMSA9PSBqMikge1xuXHRcdFx0XHRrMSArPSBrMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChrMSkgbm9uX2FkamFjZW50LnB1c2goW2kxLCBqMSwgazFdKTtcblx0XHRcdFx0aTEgPSBpMjtcblx0XHRcdFx0ajEgPSBqMjtcblx0XHRcdFx0azEgPSBrMjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoazEpIG5vbl9hZGphY2VudC5wdXNoKFtpMSwgajEsIGsxXSk7XG5cblx0XHRub25fYWRqYWNlbnQucHVzaChbbGEsIGxiLCAwXSk7XG5cdFx0dGhpcy5tYXRjaGluZ19ibG9ja3MgPSBub25fYWRqYWNlbnQ7XG5cdFx0cmV0dXJuIHRoaXMubWF0Y2hpbmdfYmxvY2tzO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRfb3Bjb2RlcygpOiBhbnlbXSB7XG5cdFx0aWYgKHRoaXMub3Bjb2RlcyAhPSBudWxsKSByZXR1cm4gdGhpcy5vcGNvZGVzO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgaiA9IDA7XG5cdFx0dmFyIGFuc3dlcjogYW55W10gPSBbXTtcblx0XHR0aGlzLm9wY29kZXMgPSBhbnN3ZXI7XG5cdFx0dmFyIGJsb2NrcyA9IHRoaXMuZ2V0X21hdGNoaW5nX2Jsb2NrcygpO1xuXHRcdGZvciAodmFyIGlkeD0wOyBpZHggPCBibG9ja3MubGVuZ3RoOyBpZHgrKykge1xuXHRcdFx0dmFyIGJsb2NrID0gYmxvY2tzW2lkeF07XG5cdFx0XHR2YXIgYWkgPSBibG9ja1swXTtcblx0XHRcdHZhciBiaiA9IGJsb2NrWzFdO1xuXHRcdFx0dmFyIHNpemUgPSBibG9ja1syXTtcblx0XHRcdHZhciB0YWcgPSAnJztcblx0XHRcdGlmIChpIDwgYWkgJiYgaiA8IGJqKSB7XG5cdFx0XHRcdHRhZyA9ICdyZXBsYWNlJztcblx0XHRcdH0gZWxzZSBpZiAoaSA8IGFpKSB7XG5cdFx0XHRcdHRhZyA9ICdkZWxldGUnO1xuXHRcdFx0fSBlbHNlIGlmIChqIDwgYmopIHtcblx0XHRcdFx0dGFnID0gJ2luc2VydCc7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGFnKSBhbnN3ZXIucHVzaChbdGFnLCBpLCBhaSwgaiwgYmpdKTtcblx0XHRcdGkgPSBhaSArIHNpemU7XG5cdFx0XHRqID0gYmogKyBzaXplO1xuXG5cdFx0XHRpZiAoc2l6ZSkgYW5zd2VyLnB1c2goWydlcXVhbCcsIGFpLCBpLCBiaiwgal0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYW5zd2VyO1xuXHR9XG5cblx0cHVibGljIHRleHRfZGlmZihjb250ZXh0OiBudW1iZXIpOiBzdHJpbmdbXSB7XG5cdFx0dmFyIG9wY29kZXMgPSB0aGlzLmdldF9vcGNvZGVzKCk7XG5cdFx0dmFyIGRpZmY6IHN0cmluZ1tdID0gW107XG5cdFx0dmFyIGFfc2lkZTogc3RyaW5nW10gPSBbXTtcblx0XHR2YXIgYl9zaWRlOiBzdHJpbmdbXSA9IFtdO1xuXHRcdHZhciBhX21heF9sZW4gPSAwO1xuXHRcdHZhciBsYXN0X3NlZW4gPSAtMTtcblx0XHRmb3IgKHZhciBvcF9pZHg9MDsgb3BfaWR4PG9wY29kZXMubGVuZ3RoOyBvcF9pZHgrKykge1xuXHRcdFx0dmFyIG9wID0gb3Bjb2Rlc1tvcF9pZHhdO1xuXHRcdFx0aWYgKG9wWzBdID09PSAnZXF1YWwnKSBjb250aW51ZTtcblx0XHRcdHZhciBhaSA9IG9wWzFdO1xuXHRcdFx0dmFyIGJpID0gb3BbM107XG5cdFx0XHR2YXIgYWogPSBvcFsyXS0xO1xuXHRcdFx0dmFyIGJqID0gb3BbNF0tMTtcblx0XHRcdHZhciBzdGFydCA9IE1hdGgubWluKGFpLGJpKTtcblx0XHRcdHZhciBlbmQgPSBNYXRoLm1heChhaixiaik7XG5cdFx0XHR2YXIgYyA9ICcnO1xuXHRcdFx0c3dpdGNoIChvcFswXSkge1xuXHRcdFx0Y2FzZSAnZGVsZXRlJzogYyA9ICcgPCAnOyBicmVhaztcblx0XHRcdGNhc2UgJ2luc2VydCc6IGMgPSAnID4gJzsgYnJlYWs7XG5cdFx0XHRjYXNlICdyZXBsYWNlJzogYyA9ICcgfCAnOyBicmVhaztcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGk9TWF0aC5tYXgobGFzdF9zZWVuKzEsc3RhcnQtY29udGV4dCk7IGk8c3RhcnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgcHJlZml4ID0gaSArICc6ICc7XG5cdFx0XHRcdGlmIChpIDwgdGhpcy5hLmxlbmd0aCkge1xuXHRcdFx0XHRcdGFfc2lkZS5wdXNoKHByZWZpeCArIHRoaXMuYVtpXSk7XG5cdFx0XHRcdFx0YV9tYXhfbGVuID0gTWF0aC5tYXgoYV9tYXhfbGVuLCB0aGlzLmFbaV0ubGVuZ3RoICsgcHJlZml4Lmxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YV9zaWRlLnB1c2gocHJlZml4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaSA8IHRoaXMuYi5sZW5ndGgpIHtcblx0XHRcdFx0XHRiX3NpZGUucHVzaCh0aGlzLmJbaV0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJfc2lkZS5wdXNoKCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaWZmLnB1c2goJyAgICcpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaT1zdGFydDsgaTw9ZW5kOyBpKyspIHtcblx0XHRcdFx0dmFyIHByZWZpeCA9IGkgKyAnOiAnO1xuXHRcdFx0XHRpZiAoaSA+PSBhaSAmJiBpIDw9IGFqKSB7XG5cdFx0XHRcdFx0YV9zaWRlLnB1c2gocHJlZml4ICsgdGhpcy5hW2ldKTtcblx0XHRcdFx0XHRhX21heF9sZW4gPSBNYXRoLm1heChhX21heF9sZW4sIHRoaXMuYVtpXS5sZW5ndGggKyBwcmVmaXgubGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhX3NpZGUucHVzaChwcmVmaXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpID49IGJpICYmIGkgPD0gYmopIHtcblx0XHRcdFx0XHRiX3NpZGUucHVzaCh0aGlzLmJbaV0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJfc2lkZS5wdXNoKCcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaWZmLnB1c2goYyk7XG5cdFx0XHR9XG5cdFx0XHRsYXN0X3NlZW4gPSBlbmQ7XG5cdFx0fVxuXHRcdGZvciAodmFyIGk9MDsgaTxkaWZmLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYSA9IGFfc2lkZVtpXTtcblx0XHRcdHZhciBiID0gYl9zaWRlW2ldO1xuXHRcdFx0aWYgKGEubGVuZ3RoIDwgYV9tYXhfbGVuKVxuXHRcdFx0XHRhICs9IChuZXcgQXJyYXkoYV9tYXhfbGVuIC0gYS5sZW5ndGggKyAxKSkuam9pbignICcpO1xuXHRcdFx0ZGlmZltpXSA9IGEgKyBkaWZmW2ldICsgYjtcblx0XHR9XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cbn1cbiIsIi8qKlxuICogVG9wLWxldmVsIGRvcHBpbyBpbnRlcmZhY2UuIEV4cG9zZWQgdGhyb3VnaCB0aGUgYERvcHBpb0pWTWAgZ2xvYmFsLlxuICovXG5pbXBvcnQgKiBhcyBUZXN0aW5nIGZyb20gJy4vdGVzdGluZyc7XG5pbXBvcnQgSGVhcCA9IHJlcXVpcmUoJy4vaGVhcCcpO1xuaW1wb3J0ICogYXMgVk0gZnJvbSAnLi9WTSc7XG5pbXBvcnQgKiBhcyBEZWJ1ZyBmcm9tICcuL0RlYnVnJztcblxuZXhwb3J0IHtUZXN0aW5nLCBWTSwgSGVhcCwgRGVidWd9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQSBjbGFzcyBjYW4gYmUgaW4gb25lIG9mIHRoZXNlIHN0YXRlcyBhdCBhbnkgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cbiAqL1xuZXhwb3J0IGVudW0gQ2xhc3NTdGF0ZSB7XG4gIC8vIFRoZSBjbGFzcyBoYXMgeWV0IHRvIGJlIGxvYWRlZC5cbiAgTk9UX0xPQURFRCxcbiAgLy8gVGhlIGNsYXNzJ3MgZGVmaW5pdGlvbiBoYXMgYmVlbiBkb3dubG9hZGVkIGFuZCBwYXJzZWQuXG4gIExPQURFRCxcbiAgLy8gVGhpcyBjbGFzcyBhbmQgaXRzIHN1cGVyIGNsYXNzZXMnIGRlZmluaXRpb25zIGhhdmUgYmVlbiBkb3dubG9hZGVkIGFuZFxuICAvLyBwYXJzZWQuXG4gIFJFU09MVkVELFxuICAvLyBUaGlzIGNsYXNzLCBpdHMgc3VwZXIgY2xhc3NlcycsIGFuZCBpdHMgaW50ZXJmYWNlcyBoYXZlIGJlZW4gZG93bmxvYWRlZCxcbiAgLy8gcGFyc2VkLCBhbmQgc3RhdGljYWxseSBpbml0aWFsaXplZC5cbiAgSU5JVElBTElaRURcbn1cblxuLyoqXG4gKiBBIHRocmVhZCBjYW4gYmUgaW4gb25lIG9mIHRoZXNlIHN0YXRlcyBhdCBhbnkgZ2l2ZW4gcG9pbnQgaW4gdGltZS5cbiAqXG4gKiBOT1RFOiBXaGVuIGFsdGVyaW5nIFRocmVhZFN0YXR1cywgcmVtZW1iZXIgdG8gdXBkYXRlIHRoZSBmb2xsb3dpbmcgdGhpbmdzLlxuICpcbiAqIC0gVGhyZWFkLnZhbGlkVHJhbnNpdGlvbnM6IERlc2NyaWJlcyBlYWNoIHZhbGlkIHRocmVhZCB0cmFuc2l0aW9uLlxuICogLSBzdW4ubWlzYy5WTS5nZXRUaHJlYWRTdGF0ZVZhbHVlczogTWFwcyBUaHJlYWRTdGF0dXMgdmFsdWVzIHRvIFRocmVhZC5TdGF0ZVxuICogICB2YWx1ZXMuXG4gKiAtIEFzc2VydGlvbiBzdGF0ZW1lbnRzIGluIFRocmVhZCByZWdhcmRpbmcgaXRzIHN0YXR1cy5cbiAqL1xuZXhwb3J0IGVudW0gVGhyZWFkU3RhdHVzIHtcbiAgLy8gQSB0aHJlYWQgdGhhdCBoYXMgbm90IHlldCBzdGFydGVkIGlzIGluIHRoaXMgc3RhdGUuXG4gIE5FVyxcbiAgLy8gQSB0aHJlYWQgdGhhdCBpcyBhYmxlIHRvIGJlIHJ1bi4gVGhlIHRocmVhZCBtYXkgYWN0dWFsbHkgYmUgcnVubmluZy5cbiAgLy8gUXVlcnkgdGhlIFRocmVhZFBvb2wgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gIFJVTk5BQkxFLFxuICAvLyBBIHRocmVhZCB0aGF0IGlzIGJsb2NrZWQgd2FpdGluZyBmb3IgYSBtb25pdG9yIGxvY2sgaXMgaW4gdGhpcyBzdGF0ZS5cbiAgQkxPQ0tFRCxcbiAgLy8gQSB0aHJlYWQgdGhhdCBpcyBibG9ja2VkIHdhaXRpbmcgZm9yIGEgbW9uaXRvciBsb2NrIHRoYXQgd2FzIHByZXZpb3VzbHlcbiAgLy8gaW50ZXJydXB0ZWQgZnJvbSB3YWl0aW5nIG9uIGEgbW9uaXRvciBpcyBpbiB0aGlzIHN0YXRlLlxuICAvLyBXaHk/IFdlbGwsIHRoZSB0aHJlYWQgaGFzICphbHJlYWR5KiBiZWVuIGludGVycnVwdGVkIG9uY2UsIGJ1dCBjYW5ub3RcbiAgLy8gcHJvY2VzcyB0aGUgaW50ZXJydXB0aW9uIHVudGlsIGl0IHJlZ2FpbnMgdGhlIGxvY2suXG4gIFVOSU5URVJSVVBUQUJMWV9CTE9DS0VELFxuICAvLyBBIHRocmVhZCB0aGF0IGlzIHdhaXRpbmcgaW5kZWZpbml0ZWx5IGZvciBhbm90aGVyIHRocmVhZCB0byBwZXJmb3JtIGFcbiAgLy8gcGFydGljdWxhciBhY3Rpb24gaXMgaW4gdGhpcyBzdGF0ZS5cbiAgV0FJVElORyxcbiAgLy8gQSB0aHJlYWQgdGhhdCBpcyB3YWl0aW5nIGZvciBhbm90aGVyIHRocmVhZCB0byBwZXJmb3JtIGFuIGFjdGlvbiBmb3IgdXAgdG9cbiAgLy8gYSBzcGVjaWZpZWQgd2FpdGluZyB0aW1lIGlzIGluIHRoaXMgc3RhdGUuXG4gIFRJTUVEX1dBSVRJTkcsXG4gIC8vIEEgdGhyZWFkIHRoYXQgaXMgd2FpdGluZyBmb3IgYW4gYXN5bmNocm9ub3VzIGJyb3dzZXIgb3BlcmF0aW9uIHRvIGNvbXBsZXRlLlxuICBBU1lOQ19XQUlUSU5HLFxuICAvLyBBIHRocmVhZCB0aGF0IGlzIHBhcmtlZC5cbiAgUEFSS0VELFxuICAvLyBBIHRocmVhZCB0aGF0IGhhcyBleGl0ZWQgaXMgaW4gdGhpcyBzdGF0ZS5cbiAgVEVSTUlOQVRFRFxufVxuXG4vKipcbiAqIEphdmEtdmlzaWJsZSB0aHJlYWQgc3RhdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZW51bSBKVk1USVRocmVhZFN0YXRlIHtcbiAgQUxJVkUgPSAweDAwMDEsXG4gIFRFUk1JTkFURUQgPSAweDAwMDIsXG4gIFJVTk5BQkxFID0gMHgwMDA0LFxuICBCTE9DS0VEX09OX01PTklUT1JfRU5URVIgPSAweDA0MDAsXG4gIFdBSVRJTkdfSU5ERUZJTklURUxZID0gMHgwMDEwLFxuICBXQUlUSU5HX1dJVEhfVElNRU9VVCA9IDB4MDAyMFxufVxuXG4vKipcbiAqIFRocmVlLXN0YXRlIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBlbnVtIFRyaVN0YXRlIHtcbiAgVFJVRSxcbiAgRkFMU0UsXG4gIElOREVURVJNSU5BVEVcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIEpWTS5cbiAqL1xuZXhwb3J0IGVudW0gSlZNU3RhdHVzIHtcbiAgLy8gVGhlIEpWTSBpcyBib290aW5nIHVwLlxuICBCT09USU5HLFxuICAvLyBUaGUgSlZNIGlzIGJvb3RlZCwgYW5kIHdhaXRpbmcgZm9yIGEgY2xhc3MgdG8gcnVuLlxuICBCT09URUQsXG4gIC8vIFRoZSBKVk0gaXMgcnVubmluZy5cbiAgUlVOTklORyxcbiAgLy8gVGhlIEpWTSBoYXMgY29tcGxldGVkIHJ1bm5pbmcsIGFuZCBpcyBwZXJmb3JtaW5nIHRlcm1pbmF0aW9uIHN0ZXBzLlxuICBURVJNSU5BVElORyxcbiAgLy8gVGhlIEpWTSBpcyBjb21wbGV0ZWx5IGZpbmlzaGVkIGV4ZWN1dGluZy5cbiAgVEVSTUlOQVRFRFxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGUgdHlwZSBvZiBhIHN0YWNrIGZyYW1lLlxuICovXG5leHBvcnQgZW51bSBTdGFja0ZyYW1lVHlwZSB7XG4gIC8qKlxuICAgKiBBIEpWTSBpbnRlcm5hbCBzdGFjayBmcmFtZS4gVGhlc2Ugc2hvdWxkIGJlIGNvbXBsZXRlbHkgaW52aXNpYmxlIHRvIHRoZVxuICAgKiBKVk0gcHJvZ3JhbS5cbiAgICovXG4gIElOVEVSTkFMLFxuICAvKipcbiAgICogQSBieXRlY29kZSBtZXRob2QncyBzdGFjayBmcmFtZS4gVGhlc2UgaGF2ZSBhbiBhY3R1YWwgc3RhY2suXG4gICAqL1xuICBCWVRFQ09ERSxcbiAgLyoqXG4gICAqIEEgbmF0aXZlIG1ldGhvZCdzIHN0YWNrIGZyYW1lLiBUaGVzZSB0eXBpY2FsbHkgY29uc2lzdCBvZiBqdXN0IGEgSmF2YVNjcmlwdFxuICAgKiBmdW5jdGlvbiBhbmQgYSBtZXRob2QgYXNzb2NpYXRpb24uXG4gICAqL1xuICBOQVRJVkVcbn1cblxuLyoqXG4gKiBWYXJpb3VzIGNvbnN0YW50IHZhbHVlcy4gRW51bSdkIHNvIHRoZXkgYXJlIGlubGluZWQgYnkgdGhlIFR5cGVTY3JpcHRcbiAqIGNvbXBpbGVyLlxuICovXG5leHBvcnQgZW51bSBDb25zdGFudHMge1xuICBJTlRfTUFYID0gTWF0aC5wb3coMiwgMzEpIC0gMSxcbiAgSU5UX01JTiA9IC1JTlRfTUFYIC0gMSxcbiAgRkxPQVRfUE9TX0lORklOSVRZID0gTWF0aC5wb3coMiwgMTI4KSxcbiAgRkxPQVRfTkVHX0lORklOSVRZID0gLTEgKiBGTE9BVF9QT1NfSU5GSU5JVFksXG4gIEZMT0FUX1BPU19JTkZJTklUWV9BU19JTlQgPSAweDdGODAwMDAwLFxuICBGTE9BVF9ORUdfSU5GSU5JVFlfQVNfSU5UID0gLTgzODg2MDgsXG4gIC8vIFdlIHVzZSB0aGUgSmF2YVNjcmlwdCBOYU4gYXMgb3VyIE5hTiB2YWx1ZSwgYW5kIGNvbnZlcnQgaXQgdG9cbiAgLy8gYSBOYU4gdmFsdWUgaW4gdGhlIFNOYU4gcmFuZ2Ugd2hlbiBhbiBpbnQgZXF1aXZhbGVudCBpcyByZXF1ZXN0ZWQuXG4gIEZMT0FUX05hTl9BU19JTlQgPSAweDdmYzAwMDAwXG59XG5cbi8qKlxuICogSW50ZWdlciBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIGEgY29uc3RhbnQgcG9vbCBpdGVtLlxuICogQHVybCBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvanZtcy9zZTcvaHRtbC9qdm1zLTQuaHRtbCNqdm1zLTQuNC0xNDBcbiAqL1xuZXhwb3J0IGVudW0gQ29uc3RhbnRQb29sSXRlbVR5cGUge1xuICBDTEFTUyA9IDcsXG4gIEZJRUxEUkVGID0gOSxcbiAgTUVUSE9EUkVGID0gMTAsXG4gIElOVEVSRkFDRV9NRVRIT0RSRUYgPSAxMSxcbiAgU1RSSU5HID0gOCxcbiAgSU5URUdFUiA9IDMsXG4gIEZMT0FUID0gNCxcbiAgTE9ORyA9IDUsXG4gIERPVUJMRSA9IDYsXG4gIE5BTUVfQU5EX1RZUEUgPSAxMixcbiAgVVRGOCA9IDEsXG4gIE1FVEhPRF9IQU5ETEUgPSAxNSxcbiAgTUVUSE9EX1RZUEUgPSAxNixcbiAgSU5WT0tFX0RZTkFNSUMgPSAxOFxufVxuXG4vKipcbiAqIEludGVnZXIgaW5kaWNhdGluZyB0aGUgdHlwZSBvZiBhIFN0YWNrTWFwVGFibGUgZW50cnkuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qdm1zL3NlNy9odG1sL2p2bXMtNC5odG1sI2p2bXMtNC43LjRcbiAqL1xuZXhwb3J0IGVudW0gU3RhY2tNYXBUYWJsZUVudHJ5VHlwZSB7XG4gIFNBTUVfRlJBTUUsXG4gIFNBTUVfTE9DQUxTXzFfU1RBQ0tfSVRFTV9GUkFNRSxcbiAgU0FNRV9MT0NBTFNfMV9TVEFDS19JVEVNX0ZSQU1FX0VYVEVOREVELFxuICBDSE9QX0ZSQU1FLFxuICBTQU1FX0ZSQU1FX0VYVEVOREVELFxuICBBUFBFTkRfRlJBTUUsXG4gIEZVTExfRlJBTUVcbn1cblxuLyoqXG4gKiBJbnRlZ2VyIGluZGljYXRpbmcgdGhlIHJlZmVyZW5jZSB0eXBlIG9mIGEgTWV0aG9kSGFuZGxlIGl0ZW0gaW4gdGhlIGNvbnN0YW50XG4gKiBwb29sLlxuICogQHNlZSBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvanZtcy9zZTcvaHRtbC9qdm1zLTQuaHRtbCNqdm1zLTQuNC44XG4gKi9cbmV4cG9ydCBlbnVtIE1ldGhvZEhhbmRsZVJlZmVyZW5jZUtpbmQge1xuICBHRVRGSUVMRCA9IDEsXG4gIEdFVFNUQVRJQyA9IDIsXG4gIFBVVEZJRUxEID0gMyxcbiAgUFVUU1RBVElDID0gNCxcbiAgSU5WT0tFVklSVFVBTCA9IDUsXG4gIElOVk9LRVNUQVRJQyA9IDYsXG4gIElOVk9LRVNQRUNJQUwgPSA3LFxuICBORVdJTlZPS0VTUEVDSUFMID0gOCxcbiAgSU5WT0tFSU5URVJGQUNFID0gOVxufVxuXG4vKipcbiAqIEpWTSBvcCBjb2Rlcy4gVGhlIGVudW0gdmFsdWUgY29ycmVzcG9uZHMgdG8gdGhhdCBvcGNvZGUncyB2YWx1ZS5cbiAqL1xuZXhwb3J0IGVudW0gT3BDb2RlIHtcbiAgQUFMT0FEID0gMHgzMixcbiAgQUFTVE9SRSA9IDB4NTMsXG4gIEFDT05TVF9OVUxMID0gMHgwMSxcbiAgQUxPQUQgPSAweDE5LFxuICBBTE9BRF8wID0gMHgyYSxcbiAgQUxPQURfMSA9IDB4MmIsXG4gIEFMT0FEXzIgPSAweDJjLFxuICBBTE9BRF8zID0gMHgyZCxcbiAgQU5FV0FSUkFZID0gMHhiZCxcbiAgQVJFVFVSTiA9IDB4YjAsXG4gIEFSUkFZTEVOR1RIID0gMHhiZSxcbiAgQVNUT1JFID0gMHgzYSxcbiAgQVNUT1JFXzAgPSAweDRiLFxuICBBU1RPUkVfMSA9IDB4NGMsXG4gIEFTVE9SRV8yID0gMHg0ZCxcbiAgQVNUT1JFXzMgPSAweDRlLFxuICBBVEhST1cgPSAweGJmLFxuICBCQUxPQUQgPSAweDMzLFxuICBCQVNUT1JFID0gMHg1NCxcbiAgQklQVVNIID0gMHgxMCxcbiAgQlJFQUtQT0lOVCA9IDB4Y2EsXG4gIENBTE9BRCA9IDB4MzQsXG4gIENBU1RPUkUgPSAweDU1LFxuICBDSEVDS0NBU1QgPSAweGMwLFxuICBEMkYgPSAweDkwLFxuICBEMkkgPSAweDhlLFxuICBEMkwgPSAweDhmLFxuICBEQUREID0gMHg2MyxcbiAgREFMT0FEID0gMHgzMSxcbiAgREFTVE9SRSA9IDB4NTIsXG4gIERDTVBHID0gMHg5OCxcbiAgRENNUEwgPSAweDk3LFxuICBEQ09OU1RfMCA9IDB4MGUsXG4gIERDT05TVF8xID0gMHgwZixcbiAgRERJViA9IDB4NmYsXG4gIERMT0FEID0gMHgxOCxcbiAgRExPQURfMCA9IDB4MjYsXG4gIERMT0FEXzEgPSAweDI3LFxuICBETE9BRF8yID0gMHgyOCxcbiAgRExPQURfMyA9IDB4MjksXG4gIERNVUwgPSAweDZiLFxuICBETkVHID0gMHg3NyxcbiAgRFJFTSA9IDB4NzMsXG4gIERSRVRVUk4gPSAweGFmLFxuICBEU1RPUkUgPSAweDM5LFxuICBEU1RPUkVfMCA9IDB4NDcsXG4gIERTVE9SRV8xID0gMHg0OCxcbiAgRFNUT1JFXzIgPSAweDQ5LFxuICBEU1RPUkVfMyA9IDB4NGEsXG4gIERTVUIgPSAweDY3LFxuICBEVVAgPSAweDU5LFxuICBEVVBfWDEgPSAweDVhLFxuICBEVVBfWDIgPSAweDViLFxuICBEVVAyID0gMHg1YyxcbiAgRFVQMl9YMSA9IDB4NWQsXG4gIERVUDJfWDIgPSAweDVlLFxuICBGMkQgPSAweDhkLFxuICBGMkkgPSAweDhiLFxuICBGMkwgPSAweDhjLFxuICBGQUREID0gMHg2MixcbiAgRkFMT0FEID0gMHgzMCxcbiAgRkFTVE9SRSA9IDB4NTEsXG4gIEZDTVBHID0gMHg5NixcbiAgRkNNUEwgPSAweDk1LFxuICBGQ09OU1RfMCA9IDB4MGIsXG4gIEZDT05TVF8xID0gMHgwYyxcbiAgRkNPTlNUXzIgPSAweDBkLFxuICBGRElWID0gMHg2ZSxcbiAgRkxPQUQgPSAweDE3LFxuICBGTE9BRF8wID0gMHgyMixcbiAgRkxPQURfMSA9IDB4MjMsXG4gIEZMT0FEXzIgPSAweDI0LFxuICBGTE9BRF8zID0gMHgyNSxcbiAgRk1VTCA9IDB4NmEsXG4gIEZORUcgPSAweDc2LFxuICBGUkVNID0gMHg3MixcbiAgRlJFVFVSTiA9IDB4YWUsXG4gIEZTVE9SRSA9IDB4MzgsXG4gIEZTVE9SRV8wID0gMHg0MyxcbiAgRlNUT1JFXzEgPSAweDQ0LFxuICBGU1RPUkVfMiA9IDB4NDUsXG4gIEZTVE9SRV8zID0gMHg0NixcbiAgRlNVQiA9IDB4NjYsXG4gIEdFVEZJRUxEID0gMHhiNCxcbiAgR0VUU1RBVElDID0gMHhiMixcbiAgR09UTyA9IDB4YTcsXG4gIEdPVE9fVyA9IDB4YzgsXG4gIEkyQiA9IDB4OTEsXG4gIEkyQyA9IDB4OTIsXG4gIEkyRCA9IDB4ODcsXG4gIEkyRiA9IDB4ODYsXG4gIEkyTCA9IDB4ODUsXG4gIEkyUyA9IDB4OTMsXG4gIElBREQgID0gMHg2MCxcbiAgSUFMT0FEID0gMHgyZSxcbiAgSUFORCA9IDB4N2UsXG4gIElBU1RPUkUgPSAweDRmLFxuICBJQ09OU1RfTTEgPSAweDIsXG4gIElDT05TVF8wID0gMyxcbiAgSUNPTlNUXzEgPSA0LFxuICBJQ09OU1RfMiA9IDUsXG4gIElDT05TVF8zID0gNixcbiAgSUNPTlNUXzQgPSA3LFxuICBJQ09OU1RfNSA9IDgsXG4gIElESVYgID0gMHg2YyxcbiAgSUZfQUNNUEVRID0gMHhhNSxcbiAgSUZfQUNNUE5FID0gMHhhNixcbiAgSUZfSUNNUEVRID0gMHg5ZixcbiAgSUZfSUNNUEdFID0gMHhhMixcbiAgSUZfSUNNUEdUID0gMHhhMyxcbiAgSUZfSUNNUExFID0gMHhhNCxcbiAgSUZfSUNNUExUID0gMHhhMSxcbiAgSUZfSUNNUE5FID0gMHhhMCxcbiAgSUZFUSAgPSAweDk5LFxuICBJRkdFICA9IDB4OWMsXG4gIElGR1QgID0gMHg5ZCxcbiAgSUZMRSAgPSAweDllLFxuICBJRkxUICA9IDB4OWIsXG4gIElGTkUgID0gMHg5YSxcbiAgSUZOT05OVUxMID0gMHhjNyxcbiAgSUZOVUxMID0gMHhjNixcbiAgSUlOQyAgPSAweDg0LFxuICBJTE9BRCA9IDB4MTUsXG4gIElMT0FEXzAgPSAweDFhLFxuICBJTE9BRF8xID0gMHgxYixcbiAgSUxPQURfMiA9IDB4MWMsXG4gIElMT0FEXzMgPSAweDFkLFxuICAvLyBJTVBERVAxID0gMHhmZSxcbiAgLy8gSU1QREVQMiA9IDB4ZmYsXG4gIElNVUwgID0gMHg2OCxcbiAgSU5FRyAgPSAweDc0LFxuICBJTlNUQU5DRU9GID0gMHhjMSxcbiAgSU5WT0tFRFlOQU1JQyA9IDB4YmEsXG4gIElOVk9LRUlOVEVSRkFDRSA9IDB4YjksXG4gIElOVk9LRVNQRUNJQUwgPSAweGI3LFxuICBJTlZPS0VTVEFUSUMgPSAweGI4LFxuICBJTlZPS0VWSVJUVUFMID0gMHhiNixcbiAgSU9SICAgPSAweDgwLFxuICBJUkVNICA9IDB4NzAsXG4gIElSRVRVUk4gPSAweGFjLFxuICBJU0hMICA9IDB4NzgsXG4gIElTSFIgID0gMHg3YSxcbiAgSVNUT1JFID0gMHgzNixcbiAgSVNUT1JFXzAgPSAweDNiLFxuICBJU1RPUkVfMSA9IDB4M2MsXG4gIElTVE9SRV8yID0gMHgzZCxcbiAgSVNUT1JFXzMgPSAweDNlLFxuICBJU1VCID0gMHg2NCxcbiAgSVVTSFIgPSAweDdjLFxuICBJWE9SID0gMHg4MixcbiAgSlNSID0gMHhhOCxcbiAgSlNSX1cgPSAweGM5LFxuICBMMkQgPSAweDhhLFxuICBMMkYgPSAweDg5LFxuICBMMkkgPSAweDg4LFxuICBMQUREID0gMHg2MSxcbiAgTEFMT0FEID0gMHgyZixcbiAgTEFORCA9IDB4N2YsXG4gIExBU1RPUkUgPSAweDUwLFxuICBMQ01QID0gMHg5NCxcbiAgTENPTlNUXzAgPSAweDA5LFxuICBMQ09OU1RfMSA9IDB4MGEsXG4gIExEQyA9IDB4MTIsXG4gIExEQ19XID0gMHgxMyxcbiAgTERDMl9XID0gMHgxNCxcbiAgTERJViA9IDB4NmQsXG4gIExMT0FEID0gMHgxNixcbiAgTExPQURfMCA9IDB4MWUsXG4gIExMT0FEXzEgPSAweDFmLFxuICBMTE9BRF8yID0gMHgyMCxcbiAgTExPQURfMyA9IDB4MjEsXG4gIExNVUwgPSAweDY5LFxuICBMTkVHID0gMHg3NSxcbiAgTE9PS1VQU1dJVENIID0gMHhhYixcbiAgTE9SID0gMHg4MSxcbiAgTFJFTSA9IDB4NzEsXG4gIExSRVRVUk4gPSAweGFkLFxuICBMU0hMID0gMHg3OSxcbiAgTFNIUiA9IDB4N2IsXG4gIExTVE9SRSA9IDB4MzcsXG4gIExTVE9SRV8wID0gMHgzZixcbiAgTFNUT1JFXzEgPSAweDQwLFxuICBMU1RPUkVfMiA9IDB4NDEsXG4gIExTVE9SRV8zID0gMHg0MixcbiAgTFNVQiA9IDB4NjUsXG4gIExVU0hSID0gMHg3ZCxcbiAgTFhPUiA9IDB4ODMsXG4gIE1PTklUT1JFTlRFUiA9IDB4YzIsXG4gIE1PTklUT1JFWElUID0gMHhjMyxcbiAgTVVMVElBTkVXQVJSQVkgPSAweGM1LFxuICBORVcgPSAweGJiLFxuICBORVdBUlJBWSA9IDB4YmMsXG4gIE5PUCA9IDB4MDAsXG4gIFBPUCA9IDB4NTcsXG4gIFBPUDIgPSAweDU4LFxuICBQVVRGSUVMRCA9IDB4YjUsXG4gIFBVVFNUQVRJQyA9IDB4YjMsXG4gIFJFVCA9IDB4YTksXG4gIFJFVFVSTiA9IDB4YjEsXG4gIFNBTE9BRCA9IDB4MzUsXG4gIFNBU1RPUkUgPSAweDU2LFxuICBTSVBVU0ggPSAweDExLFxuICBTV0FQID0gMHg1ZixcbiAgVEFCTEVTV0lUQ0ggPSAweGFhLFxuICBXSURFID0gMHhjNCxcblxuICAvLyBTcGVjaWFsIERvcHBpbyAnZmFzdCcgb3Bjb2Rlc1xuICBHRVRTVEFUSUNfRkFTVDMyID0gMHhkMCxcbiAgR0VUU1RBVElDX0ZBU1Q2NCA9IDB4ZDEsXG4gIE5FV19GQVNUID0gMHhkMixcbiAgQU5FV0FSUkFZX0ZBU1QgPSAweGQ1LFxuICBDSEVDS0NBU1RfRkFTVCA9IDB4ZDYsXG4gIElOU1RBTkNFT0ZfRkFTVCA9IDB4ZDcsXG4gIE1VTFRJQU5FV0FSUkFZX0ZBU1QgPSAweGQ4LFxuICBQVVRTVEFUSUNfRkFTVDMyID0gMHhkOSxcbiAgUFVUU1RBVElDX0ZBU1Q2NCA9IDB4ZGEsXG4gIEdFVEZJRUxEX0ZBU1QzMiA9IDB4ZGIsXG4gIEdFVEZJRUxEX0ZBU1Q2NCA9IDB4ZGMsXG4gIFBVVEZJRUxEX0ZBU1QzMiA9IDB4ZGQsXG4gIFBVVEZJRUxEX0ZBU1Q2NCA9IDB4ZGUsXG4gIElOVk9LRU5PTlZJUlRVQUxfRkFTVCA9IDB4ZGYsXG4gIElOVk9LRVNUQVRJQ19GQVNUID0gMHhmMCxcbiAgSU5WT0tFVklSVFVBTF9GQVNUID0gMHhmMSxcbiAgSU5WT0tFSU5URVJGQUNFX0ZBU1QgPSAweGYyLFxuICBJTlZPS0VIQU5ETEUgPSAweGYzLFxuICBJTlZPS0VCQVNJQyA9IDB4ZjQsXG4gIExJTktUT1NQRUNJQUwgPSAweGY1LFxuICBMSU5LVE9WSVJUVUFMID0gMHhmNyxcbiAgSU5WT0tFRFlOQU1JQ19GQVNUID0gMHhmOFxufVxuXG5leHBvcnQgZW51bSBPcGNvZGVMYXlvdXRUeXBlIHtcbiAgT1BDT0RFX09OTFksXG4gIENPTlNUQU5UX1BPT0xfVUlOVDgsXG4gIENPTlNUQU5UX1BPT0wsXG4gIENPTlNUQU5UX1BPT0xfQU5EX1VJTlQ4X1ZBTFVFLFxuICBVSU5UOF9WQUxVRSxcbiAgVUlOVDhfQU5EX0lOVDhfVkFMVUUsXG4gIElOVDhfVkFMVUUsXG4gIElOVDE2X1ZBTFVFLFxuICBJTlQzMl9WQUxVRSxcbiAgLy8gTE9PS1VQU1dJVENILFxuICAvLyBUQUJMRVNXSVRDSCxcbiAgQVJSQVlfVFlQRSxcbiAgV0lERVxufVxuXG4vLyBDb250YWlucyB0aGUgb3Bjb2RlIGxheW91dCB0eXBlcyBmb3IgZWFjaCB2YWxpZCBvcGNvZGUuXG4vLyBUbyBjb25zZXJ2ZSBjb2RlIHNwYWNlLCBpdCdzIGFzc3VtZWQgYWxsIG9wY29kZXMgbm90IGluIHRoZSB0YWJsZVxuLy8gYXJlIE9QQ09ERV9PTkxZLlxudmFyIG9sdDogT3Bjb2RlTGF5b3V0VHlwZVtdID0gbmV3IEFycmF5KDB4ZmYpO1xuKCgpID0+IHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAweGZmOyBpKyspIHtcbiAgICBvbHRbaV0gPSBPcGNvZGVMYXlvdXRUeXBlLk9QQ09ERV9PTkxZO1xuICB9XG59KSgpO1xuZnVuY3Rpb24gYXNzaWduT3Bjb2RlTGF5b3V0KGxheW91dFR5cGU6IE9wY29kZUxheW91dFR5cGUsIG9wY29kZXM6IE9wQ29kZVtdKTogdm9pZCB7XG4gIG9wY29kZXMuZm9yRWFjaCgob3Bjb2RlKSA9PiB7XG4gICAgb2x0W29wY29kZV0gPSBsYXlvdXRUeXBlO1xuICB9KTtcbn1cblxuYXNzaWduT3Bjb2RlTGF5b3V0KE9wY29kZUxheW91dFR5cGUuVUlOVDhfVkFMVUUsXG4gIFtPcENvZGUuQUxPQUQsIE9wQ29kZS5BU1RPUkUsIE9wQ29kZS5ETE9BRCwgT3BDb2RlLkRTVE9SRSxcbiAgIE9wQ29kZS5GTE9BRCwgT3BDb2RlLkZTVE9SRSwgT3BDb2RlLklMT0FELCBPcENvZGUuSVNUT1JFLFxuICAgT3BDb2RlLkxMT0FELCBPcENvZGUuTFNUT1JFLCBPcENvZGUuUkVUXSk7XG5hc3NpZ25PcGNvZGVMYXlvdXQoT3Bjb2RlTGF5b3V0VHlwZS5DT05TVEFOVF9QT09MX1VJTlQ4LCBbT3BDb2RlLkxEQ10pO1xuYXNzaWduT3Bjb2RlTGF5b3V0KE9wY29kZUxheW91dFR5cGUuQ09OU1RBTlRfUE9PTCxcbiAgW09wQ29kZS5MRENfVywgT3BDb2RlLkxEQzJfVyxcbiAgIE9wQ29kZS5BTkVXQVJSQVksIE9wQ29kZS5DSEVDS0NBU1QsIE9wQ29kZS5HRVRGSUVMRCxcbiAgIE9wQ29kZS5HRVRTVEFUSUMsIE9wQ29kZS5JTlNUQU5DRU9GLCBPcENvZGUuSU5WT0tFRFlOQU1JQyxcbiAgIE9wQ29kZS5JTlZPS0VTUEVDSUFMLCBPcENvZGUuSU5WT0tFU1RBVElDLCBPcENvZGUuSU5WT0tFVklSVFVBTCxcbiAgIE9wQ29kZS5ORVcsIE9wQ29kZS5QVVRGSUVMRCwgT3BDb2RlLlBVVFNUQVRJQywgT3BDb2RlLk1VTFRJQU5FV0FSUkFZX0ZBU1QsXG4gICBPcENvZGUuSU5WT0tFTk9OVklSVFVBTF9GQVNULCBPcENvZGUuSU5WT0tFU1RBVElDX0ZBU1QsIE9wQ29kZS5DSEVDS0NBU1RfRkFTVCxcbiAgIE9wQ29kZS5ORVdfRkFTVCxcbiAgIE9wQ29kZS5BTkVXQVJSQVlfRkFTVCwgT3BDb2RlLklOU1RBTkNFT0ZfRkFTVCwgT3BDb2RlLkdFVFNUQVRJQ19GQVNUMzIsXG4gICBPcENvZGUuR0VUU1RBVElDX0ZBU1Q2NCwgT3BDb2RlLlBVVFNUQVRJQ19GQVNUMzIsIE9wQ29kZS5QVVRTVEFUSUNfRkFTVDY0LFxuICAgT3BDb2RlLlBVVEZJRUxEX0ZBU1QzMiwgT3BDb2RlLlBVVEZJRUxEX0ZBU1Q2NCxcbiAgIE9wQ29kZS5HRVRGSUVMRF9GQVNUMzIsIE9wQ29kZS5HRVRGSUVMRF9GQVNUNjQsIE9wQ29kZS5JTlZPS0VWSVJUVUFMX0ZBU1Rcbl0pO1xuYXNzaWduT3Bjb2RlTGF5b3V0KE9wY29kZUxheW91dFR5cGUuQ09OU1RBTlRfUE9PTF9BTkRfVUlOVDhfVkFMVUUsXG4gIFtPcENvZGUuSU5WT0tFSU5URVJGQUNFLCBPcENvZGUuSU5WT0tFSU5URVJGQUNFX0ZBU1QsIE9wQ29kZS5NVUxUSUFORVdBUlJBWV0pO1xuYXNzaWduT3Bjb2RlTGF5b3V0KE9wY29kZUxheW91dFR5cGUuSU5UOF9WQUxVRSwgW09wQ29kZS5CSVBVU0hdKTtcbmFzc2lnbk9wY29kZUxheW91dChPcGNvZGVMYXlvdXRUeXBlLklOVDE2X1ZBTFVFLFxuICBbT3BDb2RlLlNJUFVTSCwgT3BDb2RlLkdPVE8sIE9wQ29kZS5JRkdULCBPcENvZGUuSUZFUSwgT3BDb2RlLklGR0UsIE9wQ29kZS5JRkxFLFxuICAgT3BDb2RlLklGTFQsIE9wQ29kZS5JRk5FLCBPcENvZGUuSUZOVUxMLCBPcENvZGUuSUZOT05OVUxMLCBPcENvZGUuSUZfSUNNUExFLFxuICAgT3BDb2RlLklGX0FDTVBFUSwgT3BDb2RlLklGX0FDTVBORSwgT3BDb2RlLklGX0lDTVBFUSwgT3BDb2RlLklGX0lDTVBHRSxcbiAgIE9wQ29kZS5JRl9JQ01QR1QsIE9wQ29kZS5JRl9JQ01QTFQsIE9wQ29kZS5JRl9JQ01QTkUsIE9wQ29kZS5KU1JdKTtcbmFzc2lnbk9wY29kZUxheW91dChPcGNvZGVMYXlvdXRUeXBlLklOVDMyX1ZBTFVFLCBbT3BDb2RlLkdPVE9fVywgT3BDb2RlLkpTUl9XXSk7XG5hc3NpZ25PcGNvZGVMYXlvdXQoT3Bjb2RlTGF5b3V0VHlwZS5VSU5UOF9BTkRfSU5UOF9WQUxVRSwgW09wQ29kZS5JSU5DXSk7XG5hc3NpZ25PcGNvZGVMYXlvdXQoT3Bjb2RlTGF5b3V0VHlwZS5BUlJBWV9UWVBFLCBbT3BDb2RlLk5FV0FSUkFZXSk7XG5cbmV4cG9ydCB2YXIgT3Bjb2RlTGF5b3V0cyA9IG9sdDtcbiIsIi8vIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBhIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0LWJpdCB0d28ncy1jb21wbGVtZW50XG4gKiBpbnRlZ2VyIHZhbHVlLCB3aGljaCBmYWl0aGZ1bGx5IHNpbXVsYXRlcyB0aGUgYmVoYXZpb3Igb2YgYSBKYXZhIFwibG9uZ1wiLiBUaGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBpcyBkZXJpdmVkIGZyb20gTG9uZ0xpYiBpbiBHV1QuXG4gKlxuICovXG5jbGFzcyBnTG9uZyB7XG4gIHByaXZhdGUgbG93XyA6IG51bWJlclxuICBwcml2YXRlIGhpZ2hfIDogbnVtYmVyXG4gIC8vIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICBwcml2YXRlIHN0YXRpYyBJbnRDYWNoZV86IHsgW3ZhbDogbnVtYmVyXTogZ0xvbmcgfSA9IHt9XG4gIC8vIENvbW1vbmx5IHVzZWQgY29uc3RhbnQgdmFsdWVzLlxuICBwcml2YXRlIHN0YXRpYyBUV09fUFdSXzE2X0RCTF8gPSAxIDw8IDE2O1xuICBwcml2YXRlIHN0YXRpYyBUV09fUFdSXzI0X0RCTF8gPSAxIDw8IDI0O1xuICBwcml2YXRlIHN0YXRpYyBUV09fUFdSXzMyX0RCTF8gPSBnTG9uZy5UV09fUFdSXzE2X0RCTF8gKiBnTG9uZy5UV09fUFdSXzE2X0RCTF87XG4gIHByaXZhdGUgc3RhdGljIFRXT19QV1JfMzFfREJMXyA9IGdMb25nLlRXT19QV1JfMzJfREJMXyAvIDI7XG4gIHByaXZhdGUgc3RhdGljIFRXT19QV1JfNDhfREJMXyA9IGdMb25nLlRXT19QV1JfMzJfREJMXyAqIGdMb25nLlRXT19QV1JfMTZfREJMXztcbiAgcHJpdmF0ZSBzdGF0aWMgVFdPX1BXUl82NF9EQkxfID0gZ0xvbmcuVFdPX1BXUl8zMl9EQkxfICogZ0xvbmcuVFdPX1BXUl8zMl9EQkxfO1xuICBwcml2YXRlIHN0YXRpYyBUV09fUFdSXzYzX0RCTF8gPSBnTG9uZy5UV09fUFdSXzY0X0RCTF8gLyAyO1xuXG4gIHB1YmxpYyBzdGF0aWMgWkVSTyA9IGdMb25nLmZyb21JbnQoMCk7XG4gIHB1YmxpYyBzdGF0aWMgT05FID0gZ0xvbmcuZnJvbUludCgxKTtcbiAgcHVibGljIHN0YXRpYyBORUdfT05FID0gZ0xvbmcuZnJvbUludCgtMSk7XG4gIHB1YmxpYyBzdGF0aWMgTUFYX1ZBTFVFID0gZ0xvbmcuZnJvbUJpdHMoMHhGRkZGRkZGRiwgMHg3RkZGRkZGRik7XG4gIHB1YmxpYyBzdGF0aWMgTUlOX1ZBTFVFID0gZ0xvbmcuZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCk7XG4gIHByaXZhdGUgc3RhdGljIFRXT19QV1JfMjRfID0gZ0xvbmcuZnJvbUludChnTG9uZy5UV09fUFdSXzI0X0RCTF8pO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgNjQtYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMi1iaXRcbiAgICogdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmVcbiAgICogY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cbiAgICpcbiAgICogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbiAgICogV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbiAgICogSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4gICAqIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2LWJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbiAgICogbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbiAgICogb3IgY2hhbmdlIGluIHNpZ24uXG4gICAqXG4gICAqIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbiAgICogcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4gICAqIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuICAgKiAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4gICAqIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbiAgICogY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG93ICBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoICBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIpIHtcbiAgICB0aGlzLmxvd18gPSBsb3cgfCAwOyAgLy8gZm9yY2UgaW50byAzMiBzaWduZWQgYml0cy5cbiAgICB0aGlzLmhpZ2hfID0gaGlnaCB8IDA7ICAvLyBmb3JjZSBpbnRvIDMyIHNpZ25lZCBiaXRzLlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gKDMyLWJpdCkgaW50ZWdlciB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMi1iaXQgaW50ZWdlciBpbiBxdWVzdGlvbi5cbiAgICogQHJldHVybiB7IWdMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tSW50KHZhbHVlOiBudW1iZXIpOiBnTG9uZyB7XG4gICAgaWYgKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcbiAgICAgIHZhciBjYWNoZWRPYmogPSBnTG9uZy5JbnRDYWNoZV9bdmFsdWVdO1xuICAgICAgaWYgKGNhY2hlZE9iaikge1xuICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvYmogPSBuZXcgZ0xvbmcodmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCk7XG4gICAgaWYgKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcbiAgICAgIGdMb25nLkludENhY2hlX1t2YWx1ZV0gPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZVxuICAgKiBudW1iZXIuICBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uLlxuICAgKiBAcmV0dXJuIHshZ0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21OdW1iZXIodmFsdWU6IG51bWJlcik6IGdMb25nIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBnTG9uZy5aRVJPO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gLWdMb25nLlRXT19QV1JfNjNfREJMXykge1xuICAgICAgcmV0dXJuIGdMb25nLk1JTl9WQUxVRTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICsgMSA+PSBnTG9uZy5UV09fUFdSXzYzX0RCTF8pIHtcbiAgICAgIHJldHVybiBnTG9uZy5NQVhfVkFMVUU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIHJldHVybiBnTG9uZy5mcm9tTnVtYmVyKC12YWx1ZSkubmVnYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgZ0xvbmcoXG4gICAgICAgICAgKHZhbHVlICUgZ0xvbmcuVFdPX1BXUl8zMl9EQkxfKSB8IDAsXG4gICAgICAgICAgKHZhbHVlIC8gZ0xvbmcuVFdPX1BXUl8zMl9EQkxfKSB8IDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0LWJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZ1xuICAgKiB0aGUgZ2l2ZW4gaGlnaCBhbmQgbG93IGJpdHMuICBFYWNoIGlzIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzItYml0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyLWJpdHMuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUJpdHMobG93Qml0czogbnVtYmVyLCBoaWdoQml0czogbnVtYmVyKTogZ0xvbmcge1xuICAgIHJldHVybiBuZXcgZ0xvbmcobG93Qml0cywgaGlnaEJpdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIGdpdmVuXG4gICAqIHJhZGl4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbi5cbiAgICogQHJldHVybiB7IWdMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tU3RyaW5nKHN0cjogc3RyaW5nLCBvcHRfcmFkaXg/OiBudW1iZXIpOiBnTG9uZyB7XG4gICAgaWYgKHN0ci5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ251bWJlciBmb3JtYXQgZXJyb3I6IGVtcHR5IHN0cmluZycpO1xuICAgIH1cblxuICAgIHZhciByYWRpeCA9IG9wdF9yYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHtcbiAgICAgIHRocm93IEVycm9yKCdyYWRpeCBvdXQgb2YgcmFuZ2U6ICcgKyByYWRpeCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ci5jaGFyQXQoMCkgPT0gJy0nKSB7XG4gICAgICByZXR1cm4gZ0xvbmcuZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCByYWRpeCkubmVnYXRlKCk7XG4gICAgfSBlbHNlIGlmIChzdHIuaW5kZXhPZignLScpID49IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXI6ICcgKyBzdHIpO1xuICAgIH1cblxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZ0xvbmcuZnJvbU51bWJlcihNYXRoLnBvdyhyYWRpeCwgOCkpO1xuXG4gICAgdmFyIHJlc3VsdCA9IGdMb25nLlpFUk87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpO1xuICAgICAgdmFyIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgICB2YXIgcG93ZXIgPSBnTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCBzaXplKSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShwb3dlcikuYWRkKGdMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShyYWRpeFRvUG93ZXIpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGdMb25nLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSwgYXNzdW1pbmcgaXQgaXMgYSAzMi1iaXQgaW50ZWdlci4gKi9cbiAgcHVibGljIHRvSW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubG93XztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjbG9zZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHRvIHRoaXMgdmFsdWUuICovXG4gIHB1YmxpYyB0b051bWJlcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhpZ2hfICogZ0xvbmcuVFdPX1BXUl8zMl9EQkxfICsgdGhpcy5nZXRMb3dCaXRzVW5zaWduZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIHdyaXR0ZW4uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyB0b1N0cmluZyhvcHRfcmFkaXg/OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHZhciByYWRpeCA9IG9wdF9yYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHtcbiAgICAgIHRocm93IEVycm9yKCdyYWRpeCBvdXQgb2YgcmFuZ2U6ICcgKyByYWRpeCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBpZiAodGhpcy5lcXVhbHMoZ0xvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxuICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXG4gICAgICAgIHZhciByYWRpeExvbmcgPSBnTG9uZy5mcm9tTnVtYmVyKHJhZGl4KTtcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyk7XG4gICAgICAgIHZhciByZW0gPSBkaXYubXVsdGlwbHkocmFkaXhMb25nKS5zdWJ0cmFjdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0udG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWdhdGUoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBnTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA2KSk7XG4gICAgdmFyIHJlbTogZ0xvbmcgPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKTtcbiAgICAgIHZhciBpbnR2YWwgPSByZW0uc3VidHJhY3QocmVtRGl2Lm11bHRpcGx5KHJhZGl4VG9Qb3dlcikpLnRvSW50KCk7XG4gICAgICB2YXIgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcblxuICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgaWYgKHJlbS5pc1plcm8oKSkge1xuICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoaWdoIDMyLWJpdHMgYXMgYSBzaWduZWQgdmFsdWUuICovXG4gIHB1YmxpYyBnZXRIaWdoQml0cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhpZ2hfO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gVGhlIGxvdyAzMi1iaXRzIGFzIGEgc2lnbmVkIHZhbHVlLiAqL1xuICBwdWJsaWMgZ2V0TG93Qml0cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxvd187XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSBUaGUgbG93IDMyLWJpdHMgYXMgYW4gdW5zaWduZWQgdmFsdWUuICovXG4gIHB1YmxpYyBnZXRMb3dCaXRzVW5zaWduZWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKHRoaXMubG93XyA+PSAwKSA/IHRoaXMubG93XyA6IGdMb25nLlRXT19QV1JfMzJfREJMXyArIHRoaXMubG93XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlXG4gICAqICAgICB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gICAqL1xuICBwdWJsaWMgZ2V0TnVtQml0c0FicygpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgaWYgKHRoaXMuZXF1YWxzKGdMb25nLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgcmV0dXJuIDY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkuZ2V0TnVtQml0c0FicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsID0gdGhpcy5oaWdoXyAhPSAwID8gdGhpcy5oaWdoXyA6IHRoaXMubG93XztcbiAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkge1xuICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGlnaF8gIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHZhbHVlIGlzIHplcm8uICovXG4gIHB1YmxpYyBpc1plcm8oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaF8gPT0gMCAmJiB0aGlzLmxvd18gPT0gMDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmFsdWUgaXMgbmVnYXRpdmUuICovXG4gIHB1YmxpYyBpc05lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmhpZ2hfIDwgMDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgdmFsdWUgaXMgb2RkLiAqL1xuICBwdWJsaWMgaXNPZGQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLmxvd18gJiAxKSA9PSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Z0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBlcXVhbHMgdGhlIG90aGVyLlxuICAgKi9cbiAgcHVibGljIGVxdWFscyhvdGhlcjogZ0xvbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuaGlnaF8gPT0gb3RoZXIuaGlnaF8pICYmICh0aGlzLmxvd18gPT0gb3RoZXIubG93Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGRvZXMgbm90IGVxdWFsIHRoZSBvdGhlci5cbiAgICovXG4gIHB1YmxpYyBub3RFcXVhbHMob3RoZXI6IGdMb25nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLmhpZ2hfICE9IG90aGVyLmhpZ2hfKSB8fCAodGhpcy5sb3dfICE9IG90aGVyLmxvd18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Z0xvbmd9IG90aGVyIExvbmcgdG8gY29tcGFyZSBhZ2FpbnN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgTG9uZyBpcyBsZXNzIHRoYW4gdGhlIG90aGVyLlxuICAgKi9cbiAgcHVibGljIGxlc3NUaGFuKG90aGVyOiBnTG9uZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpIDwgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2dMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBvdGhlci5cbiAgICovXG4gIHB1YmxpYyBsZXNzVGhhbk9yRXF1YWwob3RoZXI6IGdMb25nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2dMb25nfSBvdGhlciBMb25nIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIExvbmcgaXMgZ3JlYXRlciB0aGFuIHRoZSBvdGhlci5cbiAgICovXG4gIHB1YmxpYyBncmVhdGVyVGhhbihvdGhlcjogZ0xvbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyKSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBMb25nIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgb3RoZXIuXG4gICAqL1xuICBwdWJsaWMgZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyOiBnTG9uZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyB0byBjb21wYXJlIGFnYWluc3QuXG4gICAqIEByZXR1cm4ge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyLCBhbmQgLTFcbiAgICogICAgIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlci5cbiAgICovXG4gIHB1YmxpYyBjb21wYXJlKG90aGVyOiBnTG9uZyk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZXF1YWxzKG90aGVyKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKTtcbiAgICB2YXIgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgdGhlIHNpZ25zIGFyZSB0aGUgc2FtZSwgc28gc3VidHJhY3Rpb24gd2lsbCBub3Qgb3ZlcmZsb3dcbiAgICBpZiAodGhpcy5zdWJ0cmFjdChvdGhlcikuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshZ0xvbmd9IFRoZSBuZWdhdGlvbiBvZiB0aGlzIHZhbHVlLiAqL1xuICBwdWJsaWMgbmVnYXRlKCk6IGdMb25nIHtcbiAgICBpZiAodGhpcy5lcXVhbHMoZ0xvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgcmV0dXJuIGdMb25nLk1JTl9WQUxVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKGdMb25nLk9ORSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyB0byBhZGQgdG8gdGhpcyBvbmUuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cbiAgICovXG4gIHB1YmxpYyBhZGQob3RoZXI6IGdMb25nKTogZ0xvbmcge1xuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxuXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaF8gPj4+IDE2O1xuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2hfICYgMHhGRkZGO1xuICAgIHZhciBhMTYgPSB0aGlzLmxvd18gPj4+IDE2O1xuICAgIHZhciBhMDAgPSB0aGlzLmxvd18gJiAweEZGRkY7XG5cbiAgICB2YXIgYjQ4ID0gb3RoZXIuaGlnaF8gPj4+IDE2O1xuICAgIHZhciBiMzIgPSBvdGhlci5oaWdoXyAmIDB4RkZGRjtcbiAgICB2YXIgYjE2ID0gb3RoZXIubG93XyA+Pj4gMTY7XG4gICAgdmFyIGIwMCA9IG90aGVyLmxvd18gJiAweEZGRkY7XG5cbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGdMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gTG9uZy5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyB0byBzdWJ0cmFjdCBmcm9tIHRoaXMuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIGdpdmVuIExvbmcuXG4gICAqL1xuICBwdWJsaWMgc3VidHJhY3Qob3RoZXI6IGdMb25nKTogZ0xvbmcge1xuICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gbG9uZy5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyB0byBtdWx0aXBseSB3aXRoIHRoaXMuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIG90aGVyLlxuICAgKi9cbiAgcHVibGljIG11bHRpcGx5KG90aGVyOiBnTG9uZyk6IGdMb25nIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGdMb25nLlpFUk87XG4gICAgfSBlbHNlIGlmIChvdGhlci5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGdMb25nLlpFUk87XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXF1YWxzKGdMb25nLk1JTl9WQUxVRSkpIHtcbiAgICAgIHJldHVybiBvdGhlci5pc09kZCgpID8gZ0xvbmcuTUlOX1ZBTFVFIDogZ0xvbmcuWkVSTztcbiAgICB9IGVsc2UgaWYgKG90aGVyLmVxdWFscyhnTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gZ0xvbmcuTUlOX1ZBTFVFIDogZ0xvbmcuWkVSTztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgIGlmIChvdGhlci5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkob3RoZXIubmVnYXRlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkob3RoZXIpLm5lZ2F0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShvdGhlci5uZWdhdGUoKSkubmVnYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxuICAgIGlmICh0aGlzLmxlc3NUaGFuKGdMb25nLlRXT19QV1JfMjRfKSAmJlxuICAgICAgICBvdGhlci5sZXNzVGhhbihnTG9uZy5UV09fUFdSXzI0XykpIHtcbiAgICAgIHJldHVybiBnTG9uZy5mcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG90aGVyLnRvTnVtYmVyKCkpO1xuICAgIH1cblxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG5cbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoXyA+Pj4gMTY7XG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaF8gJiAweEZGRkY7XG4gICAgdmFyIGExNiA9IHRoaXMubG93XyA+Pj4gMTY7XG4gICAgdmFyIGEwMCA9IHRoaXMubG93XyAmIDB4RkZGRjtcblxuICAgIHZhciBiNDggPSBvdGhlci5oaWdoXyA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IG90aGVyLmhpZ2hfICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBvdGhlci5sb3dfID4+PiAxNjtcbiAgICB2YXIgYjAwID0gb3RoZXIubG93XyAmIDB4RkZGRjtcblxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xuICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgYzAwICY9IDB4RkZGRjtcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgIGMxNiAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgYzQ4ICY9IDB4RkZGRjtcbiAgICByZXR1cm4gZ0xvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBnaXZlbiBvbmUuXG4gICAqIEBwYXJhbSB7Z0xvbmd9IG90aGVyIExvbmcgYnkgd2hpY2ggdG8gZGl2aWRlLlxuICAgKiBAcmV0dXJuIHshZ0xvbmd9IFRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBnaXZlbiBvbmUuXG4gICAqL1xuICBwdWJsaWMgZGl2KG90aGVyOiBnTG9uZyk6IGdMb25nIHtcbiAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gZ0xvbmcuWkVSTztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lcXVhbHMoZ0xvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgaWYgKG90aGVyLmVxdWFscyhnTG9uZy5PTkUpIHx8XG4gICAgICAgICAgb3RoZXIuZXF1YWxzKGdMb25nLk5FR19PTkUpKSB7XG4gICAgICAgIHJldHVybiBnTG9uZy5NSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxuICAgICAgfSBlbHNlIGlmIChvdGhlci5lcXVhbHMoZ0xvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgICByZXR1cm4gZ0xvbmcuT05FO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNoaWZ0UmlnaHQoMSk7XG4gICAgICAgIHZhciBsX2FwcHJveCA9IGhhbGZUaGlzLmRpdihvdGhlcikuc2hpZnRMZWZ0KDEpO1xuICAgICAgICBpZiAobF9hcHByb3guZXF1YWxzKGdMb25nLlpFUk8pKSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyLmlzTmVnYXRpdmUoKSA/IGdMb25nLk9ORSA6IGdMb25nLk5FR19PTkU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlbSA9IHRoaXMuc3VidHJhY3Qob3RoZXIubXVsdGlwbHkobF9hcHByb3gpKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbF9hcHByb3guYWRkKHJlbS5kaXYob3RoZXIpKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlci5lcXVhbHMoZ0xvbmcuTUlOX1ZBTFVFKSkge1xuICAgICAgcmV0dXJuIGdMb25nLlpFUk87XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmRpdihvdGhlci5uZWdhdGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5kaXYob3RoZXIpLm5lZ2F0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXYob3RoZXIubmVnYXRlKCkpLm5lZ2F0ZSgpO1xuICAgIH1cblxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXG4gICAgdmFyIHJlcyA9IGdMb25nLlpFUk87XG4gICAgdmFyIHJlbTogZ0xvbmcgPSB0aGlzO1xuICAgIHdoaWxlIChyZW0uZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSkge1xuICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxuICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICB2YXIgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIG90aGVyLnRvTnVtYmVyKCkpKTtcblxuICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxuICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKTtcbiAgICAgIHZhciBkZWx0YSA9IDE7XG4gICAgICBpZiAobG9nMiA+IDQ4KVxuICAgICAgICBkZWx0YSA9IE1hdGgucG93KDIsIGxvZzIgLSA0OCk7XG5cbiAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXG4gICAgICB2YXIgYXBwcm94UmVzID0gZ0xvbmcuZnJvbU51bWJlcihhcHByb3gpO1xuICAgICAgdmFyIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWx0aXBseShvdGhlcik7XG4gICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3JlYXRlclRoYW4ocmVtKSkge1xuICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgIGFwcHJveFJlcyA9IGdMb25nLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bHRpcGx5KG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXG4gICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cbiAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIHtcbiAgICAgICAgYXBwcm94UmVzID0gZ0xvbmcuT05FO1xuICAgICAgfVxuXG4gICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgICByZW0gPSByZW0uc3VidHJhY3QoYXBwcm94UmVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIGdpdmVuIG9uZS5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgTG9uZyBieSB3aGljaCB0byBtb2QuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhpcyBMb25nIG1vZHVsbyB0aGUgZ2l2ZW4gb25lLlxuICAgKi9cbiAgcHVibGljIG1vZHVsbyhvdGhlcjogZ0xvbmcpOiBnTG9uZyB7XG4gICAgcmV0dXJuIHRoaXMuc3VidHJhY3QodGhpcy5kaXYob3RoZXIpLm11bHRpcGx5KG90aGVyKSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IWdMb25nfSBUaGUgYml0d2lzZS1OT1Qgb2YgdGhpcyB2YWx1ZS4gKi9cbiAgcHVibGljIG5vdCgpOiBnTG9uZyB7XG4gICAgcmV0dXJuIGdMb25nLmZyb21CaXRzKH50aGlzLmxvd18sIH50aGlzLmhpZ2hfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlLUFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAqIEBwYXJhbSB7Z0xvbmd9IG90aGVyIFRoZSBMb25nIHdpdGggd2hpY2ggdG8gQU5ELlxuICAgKiBAcmV0dXJuIHshZ0xvbmd9IFRoZSBiaXR3aXNlLUFORCBvZiB0aGlzIGFuZCB0aGUgb3RoZXIuXG4gICAqL1xuICBwdWJsaWMgYW5kKG90aGVyOiBnTG9uZyk6IGdMb25nIHtcbiAgICByZXR1cm4gZ0xvbmcuZnJvbUJpdHModGhpcy5sb3dfICYgb3RoZXIubG93XyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdoXyAmIG90aGVyLmhpZ2hfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlLU9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgVGhlIExvbmcgd2l0aCB3aGljaCB0byBPUi5cbiAgICogQHJldHVybiB7IWdMb25nfSBUaGUgYml0d2lzZS1PUiBvZiB0aGlzIGFuZCB0aGUgb3RoZXIuXG4gICAqL1xuICBwdWJsaWMgb3Iob3RoZXI6IGdMb25nKTogZ0xvbmcge1xuICAgIHJldHVybiBnTG9uZy5mcm9tQml0cyh0aGlzLmxvd18gfCBvdGhlci5sb3dfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hfIHwgb3RoZXIuaGlnaF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UtWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICogQHBhcmFtIHtnTG9uZ30gb3RoZXIgVGhlIExvbmcgd2l0aCB3aGljaCB0byBYT1IuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhlIGJpdHdpc2UtWE9SIG9mIHRoaXMgYW5kIHRoZSBvdGhlci5cbiAgICovXG4gIHB1YmxpYyB4b3Iob3RoZXI6IGdMb25nKTogZ0xvbmcge1xuICAgIHJldHVybiBnTG9uZy5mcm9tQml0cyh0aGlzLmxvd18gXiBvdGhlci5sb3dfLCB0aGlzLmhpZ2hfIF4gb3RoZXIuaGlnaF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIFRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0byBzaGlmdC5cbiAgICogQHJldHVybiB7IWdMb25nfSBUaGlzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICovXG4gIHB1YmxpYyBzaGlmdExlZnQobnVtQml0czogbnVtYmVyKTogZ0xvbmcge1xuICAgIG51bUJpdHMgJj0gNjM7XG4gICAgaWYgKG51bUJpdHMgPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb3cgPSB0aGlzLmxvd187XG4gICAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoXztcbiAgICAgICAgcmV0dXJuIGdMb25nLmZyb21CaXRzKGxvdyA8PCBudW1CaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhpZ2ggPDwgbnVtQml0cykgfCAobG93ID4+PiAoMzIgLSBudW1CaXRzKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdMb25nLmZyb21CaXRzKDAsIGxvdyA8PCAobnVtQml0cyAtIDMyKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggdG8gc2hpZnQuXG4gICAqIEByZXR1cm4geyFnTG9uZ30gVGhpcyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKi9cbiAgcHVibGljIHNoaWZ0UmlnaHQobnVtQml0czogbnVtYmVyKTogZ0xvbmcge1xuICAgIG51bUJpdHMgJj0gNjM7XG4gICAgaWYgKG51bUJpdHMgPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoXztcbiAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93XztcbiAgICAgICAgcmV0dXJuIGdMb25nLmZyb21CaXRzKFxuICAgICAgICAgICAgKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksXG4gICAgICAgICAgICBoaWdoID4+IG51bUJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdMb25nLmZyb21CaXRzKFxuICAgICAgICAgICAgaGlnaCA+PiAobnVtQml0cyAtIDMyKSxcbiAgICAgICAgICAgIGhpZ2ggPj0gMCA/IDAgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LCB3aXRoXG4gICAqIHRoZSBuZXcgdG9wIGJpdHMgbWF0Y2hpbmcgdGhlIGN1cnJlbnQgc2lnbiBiaXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1CaXRzIFRoZSBudW1iZXIgb2YgYml0cyBieSB3aGljaCB0byBzaGlmdC5cbiAgICogQHJldHVybiB7IWdMb25nfSBUaGlzIHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQsIHdpdGhcbiAgICogICAgIHplcm9zIHBsYWNlZCBpbnRvIHRoZSBuZXcgbGVhZGluZyBiaXRzLlxuICAgKi9cbiAgcHVibGljIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzOiBudW1iZXIpOiBnTG9uZyB7XG4gICAgbnVtQml0cyAmPSA2MztcbiAgICBpZiAobnVtQml0cyA9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2hfO1xuICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3dfO1xuICAgICAgICByZXR1cm4gZ0xvbmcuZnJvbUJpdHMoXG4gICAgICAgICAgICAobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSxcbiAgICAgICAgICAgIGhpZ2ggPj4+IG51bUJpdHMpO1xuICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09IDMyKSB7XG4gICAgICAgIHJldHVybiBnTG9uZy5mcm9tQml0cyhoaWdoLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnTG9uZy5mcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vLyBFeHBvcnQgb25seSB0aGUgY2xhc3MuXG5leHBvcnQgPSBnTG9uZ1xuIiwiLyoqXG4gKiBFeHBvcnRzIHRoZSBnbG9iYWwgc2NvcGUgdmFyaWFibGUuXG4gKiBJbiB0aGUgbWFpbiBicm93c2VyIHRocmVhZCwgdGhpcyBpcyBcIndpbmRvd1wiLlxuICogSW4gYSBXZWJXb3JrZXIsIHRoaXMgaXMgXCJzZWxmXCIuXG4gKiBJbiBOb2RlLCB0aGlzIGlzIFwiZ2xvYmFsXCIuXG4gKi9cbmRlY2xhcmUgdmFyIGdsb2JhbDogYW55O1xudmFyIHRvRXhwb3J0OiBhbnk7XG5pZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7XG4gIHRvRXhwb3J0ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Yoc2VsZikgIT09ICd1bmRlZmluZWQnKSB7XG4gIHRvRXhwb3J0ID0gc2VsZjtcbn0gZWxzZSB7XG4gIHRvRXhwb3J0ID0gZ2xvYmFsO1xufVxuZXhwb3J0ID0gdG9FeHBvcnQ7IiwiLy8gQSBwb3dlci1vZi10d28gc2VncmVnYXRlZCBmcmVlbGlzdCBcImhlYXBcIixcbi8vIGZvciBleHBsaWNpdCBtZW1vcnkgbWFuYWdlbWVudCBpbnRvIGEgYnVmZmVyLlxuLy8gYnkgRW1lcnkgQmVyZ2VyLCB3d3cuY3MudW1hc3MuZWR1L35lbWVyeVxuXG5cInVzZSBzdHJpY3RcIjtcblxuaW50ZXJmYWNlIEhhc2hUYWJsZTxUPiB7XG4gIFtrZXkgOiBudW1iZXJdOiBUO1xufVxuXG5jbGFzcyBIZWFwIHtcblxuICAvLyBzaXplID0gdG90YWwgYW1vdW50IG9mIG1lbW9yeSBmb3IgdGhlIGhlYXAuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2l6ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5fYnVmZmVyICAgID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICB0aGlzLl9yZW1haW5pbmcgPSBzaXplOyAgLy8gdGhlIHdob2xlIHRoaW5nIGlzIGF2YWlsYWJsZS5cbiAgICB0aGlzLl9vZmZzZXQgICAgPSAwOyAgICAgLy8gc3RhcnQgb2YgdGhlIGJ1ZmZlci5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBmcmVlbGlzdHMuXG4gICAgdGhpcy5fZnJlZUxpc3RzID0gbmV3IEFycmF5PEFycmF5PG51bWJlcj4+KEhlYXAuX251bVNpemVDbGFzc2VzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhlYXAuX251bVNpemVDbGFzc2VzOyBpKyspIHtcbiAgICAgIHRoaXMuX2ZyZWVMaXN0c1tpXSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHNpemUgYnl0ZXMsIHJldHVybmluZyB0aGUgXCJhZGRyZXNzXCIuXG4gIG1hbGxvYyhzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIGlmIHNpemUgaXMgbGVzcyB0aGFuIGEgd29yZCwgcm91bmQgaXQgdXAgdG8gYSB3b3JkICg0IGJ5dGVzKS5cbiAgICBpZiAoc2l6ZSA8PSA0KSB7XG4gICAgICBzaXplID0gNDtcbiAgICB9XG4gICAgLy8gaWYgd2UgYXJlIG91dCBvZiBtZW1vcnksIHRocm93IGFuIGV4Y2VwdGlvbi5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nIDwgc2l6ZSkge1xuICAgICAgLy8gVE9ETzogY291bGQgYWN0dWFsbHkgc2NhbiBsYXJnZXIgZnJlZWxpc3RzIHRvIHNlZSBpZiB0aGVyZSdzXG4gICAgICAvLyBmcmVlIG1lbW9yeSB0aGVyZS5cbiAgICAgIHRocm93IFwib3V0IG9mIG1lbW9yeVwiO1xuICAgIH1cbiAgICAvLyBjb21wdXRlIHRoZSBzaXplIGNsYXNzLlxuICAgIHZhciBhZGRyIDogbnVtYmVyO1xuICAgIHZhciBjbCAgIDogbnVtYmVyO1xuICAgIGNsICAgPSBIZWFwLnNpemVfdG9fY2xhc3Moc2l6ZSk7XG4gICAgYWRkciA9IHRoaXMuX2ZyZWVMaXN0c1tjbF0ucG9wKCk7XG4gICAgLy8gaWYgdGhlcmUncyBubyBtb3JlIG1lbW9yeSwgZ2V0IHNvbWUuXG4gICAgaWYgKGFkZHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWRkciA9IHRoaXMucmVmaWxsKGNsKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHI7XG4gIH1cblxuICAvLyBEZWFsbG9jYXRlIG1lbW9yeS5cbiAgZnJlZShhZGRyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBwdXNoIHRoaXMgYWRkcmVzcyBvbnRvIHRoZSBhcHByb3ByaWF0ZSBmcmVlbGlzdC5cbiAgICAvLyBmaXJzdCwgbWFzayB0aGUgYWRkcmVzcy5cbiAgICB2YXIgbWFza2VkID0gYWRkciAmIH4oSGVhcC5fY2h1bmtTaXplIC0gMSk7XG4gICAgLy8gbmV4dCwgbG9vayB1cCB0aGUgY2xhc3MgdXNpbmcgdGhlIG1hc2tlZCBhZGRyZXNzLlxuICAgIHZhciBjbCA9IHRoaXMuX3NpemVNYXBbbWFza2VkXTtcbiAgICAvLyBmaW5hbGx5LCBwdXNoIG9udG8gdGhlIGFwcHJvcHJpYXRlIGZyZWUgbGlzdC5cbiAgICAvLyBUT0RPOiBmb3Igc2FuaXR5LCB3ZSBjb3VsZCBjaGVjayB0byBzZWUgaWYgdGhpcyB3YXMgKnJlYWxseSogZnJlZWRcbiAgICAvLyBhbmQgZHJvcCBpdCBpZiBub3QuXG4gICAgdGhpcy5fZnJlZUxpc3RzW2NsXS5wdXNoKGFkZHIpO1xuICB9XG5cbiAgLy8gU3RvcmUgYSB3b3JkICgzMi1iaXRzKSBhdCB0aGlzIGFkZHJlc3MuXG4gIHN0b3JlX3dvcmQoYWRkcjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVE9ETzogYWRkIHNhbml0eSBjaGVja3M/XG4gICAgdGhpcy5fYnVmZmVyLndyaXRlSW50MzJMRSAodmFsdWUsIGFkZHIpO1xuICB9XG5cbiAgLy8gQWNjZXNzIGEgYnl0ZSBhdCB0aGlzIGxvY2F0aW9uLlxuICBnZXRfYnl0ZShhZGRyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIC8vIFRPRE86IGFkZCBzYW5pdHkgY2hlY2tzP1xuICAgIHJldHVybiB0aGlzLl9idWZmZXIucmVhZFVJbnQ4KGFkZHIpO1xuICB9XG5cbiAgZ2V0X3dvcmQoYWRkcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnJlYWRJbnQzMkxFKGFkZHIpO1xuICB9XG5cbiAgZ2V0X2J1ZmZlcihhZGRyOiBudW1iZXIsIGxlbjogbnVtYmVyKTogQnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xuICB9XG5cbiAgZ2V0X3NpZ25lZF9ieXRlKGFkZHI6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5yZWFkSW50OChhZGRyKTtcbiAgfVxuXG4gIHNldF9ieXRlKGFkZHI6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2J1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBhZGRyKTtcbiAgfVxuXG4gIHNldF9zaWduZWRfYnl0ZShhZGRyOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9idWZmZXIud3JpdGVJbnQ4KHZhbHVlLCBhZGRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5IGxlbiBieXRlcyBmcm9tIHNyY0FkZHIgdG8gZHN0QWRkci5cbiAgICovXG4gIG1lbWNweShzcmNBZGRyOiBudW1iZXIsIGRzdEFkZHI6IG51bWJlciwgbGVuOiBudW1iZXIpIHtcbiAgICB0aGlzLl9idWZmZXIuY29weSh0aGlzLl9idWZmZXIsIGRzdEFkZHIsIHNyY0FkZHIsIHNyY0FkZHIgKyBsZW4pO1xuICB9XG5cbiAgLy8gR2V0IG1vcmUgbWVtb3J5IGZvciBhIHBhcnRpY3VsYXIgc2l6ZSBjbGFzcy5cbiAgcHJpdmF0ZSByZWZpbGwoY2w6IG51bWJlcik6IG51bWJlciB7XG4gICAgLy8gR2V0IHRoZSBsYXJnZXN0IHNpemUgZm9yIHRoaXMgY2xhc3MuXG4gICAgdmFyIHN6ID0gdGhpcy5jbF90b19zaXplKGNsKTtcbiAgICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IG9iamVjdHMgd2UgYXJlIGdvaW5nIHRvIFwiYWxsb2NhdGVcIi5cbiAgICB2YXIgY291bnQgOiBudW1iZXIgPSBNYXRoLmZsb29yKEhlYXAuX2NodW5rU2l6ZSAvIHN6KTtcbiAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICBjb3VudCA9IDE7XG4gICAgfVxuICAgIC8vIE5vdyBzdG9yZSB0aGUgc2l6ZSBjbGFzcyAqZm9yIHRoZSBmaXJzdCBvYmplY3QqIG9ubHkuXG4gICAgLy8gV2Ugd2lsbCBsYXRlciBsb29rIHVwIHRoaXMgb2JqZWN0IHZpYSBcInBvaW50ZXIgYXJpdGhtZXRpY1wiLlxuICAgIHZhciBhZGRyID0gdGhpcy5fb2Zmc2V0O1xuICAgIHRoaXMuX3NpemVNYXBbYWRkcl0gPSBjbDtcbiAgICAvLyBBZGQgZWFjaCBvbmUgdG8gdGhlIGZyZWVsaXN0LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgdGhpcy5fcmVtYWluaW5nIC09IHN6O1xuICAgICAgYWRkciA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX2ZyZWVMaXN0c1tjbF0ucHVzaCAoYWRkcik7XG4gICAgICB0aGlzLl9vZmZzZXQgKz0gc3o7XG4gICAgfVxuICAgIHJldHVybiBhZGRyO1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgY2VpbChsb2cyKG51bSkpLlxuICBwcml2YXRlIHN0YXRpYyBpbG9nMihudW06IG51bWJlcik6IG51bWJlciB7XG4gICAgdmFyIGxvZzIgID0gMDtcbiAgICB2YXIgdmFsdWUgPSAxO1xuICAgIHdoaWxlICh2YWx1ZSA8IG51bSkge1xuICAgICAgdmFsdWUgPDw9ICgxKTtcbiAgICAgIGxvZzIrKztcbiAgICB9XG4gICAgcmV0dXJuIChsb2cyKTtcbiAgfVxuXG4gIC8vIHBvd2VyLW9mLXR3byBzaXplIGNsYXNzZXMgKGp1c3QgYSByZWYgdG8gaWxvZzIpLlxuICBwcml2YXRlIHN0YXRpYyBzaXplX3RvX2NsYXNzKHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIEhlYXAuaWxvZzIoc2l6ZSk7XG4gIH1cblxuICAvLyBzZWUgYWJvdmU6IGNsYXNzZXMgYXJlIGp1c3QgcG93ZXJzIG9mIHR3by5cbiAgcHJpdmF0ZSBjbF90b19zaXplKGNsOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiAoMSA8PCBjbCk7XG4gIH1cblxuICAvLyBIb2xkcyBhbGwgbWVtb3J5LCB3aGljaCB3ZSB3aWxsIGFsbG9jYXRlIGZyb20gdmlhIHBvaW50ZXIgYnVtcGluZy5cbiAgcHJpdmF0ZSBfYnVmZmVyIDogTm9kZUJ1ZmZlcjtcblxuICAvLyBIb3cgbXVjaCBpcyBsZWZ0IGluIHRoZSBidWZmZXIsIGluIGJ5dGVzLlxuICBwcml2YXRlIF9yZW1haW5pbmcgOiBudW1iZXI7XG5cbiAgLy8gVGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBidWZmZXIuXG4gIHByaXZhdGUgX29mZnNldCA6IG51bWJlcjtcblxuICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIHNpemUgY2xhc3Nlcy5cbiAgcHJpdmF0ZSBzdGF0aWMgX251bVNpemVDbGFzc2VzIDogbnVtYmVyID0gNjQ7IC8vIHdheSBtb3JlIHRoYW4gd2UnbGwgZXZlciBuZWVkLlxuXG4gIC8vIEhvdyBtdWNoIHRvIGdyYWIgYXQgb25lIHRpbWUuXG4gIHByaXZhdGUgc3RhdGljIF9jaHVua1NpemUgOiBudW1iZXIgPSA0MDk2OyAgICAvLyBzaG91bGQgYmUgYSBwb3dlciBvZiB0d28uXG5cbiAgLy8gVGhlIHNpemUgY2xhc3MgYXJyYXkgb2Ygc3R1ZmYuXG4gIHByaXZhdGUgX2ZyZWVMaXN0cyA6IEFycmF5PEFycmF5PG51bWJlcj4+O1xuXG4gIC8vIEEgbWFwIG9mIHNpemUgY2xhc3NlcyBwZXIgY2h1bmsgKHNlZSBhYm92ZSkuXG4gIHByaXZhdGUgX3NpemVNYXAgOiBIYXNoVGFibGU8bnVtYmVyPiA9IHt9O1xuXG59XG5cbmV4cG9ydCA9IEhlYXA7XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdHlwaW5ncy9tYWluLmQudHNcIiAvPlxuLy8gTWFpbiBlbnRyeSBwb2ludCBmb3IgYnJvd3NlcmlmeS4gU2VwYXJhdGUgZnJvbSBkb3BwaW9qdm0udHMgc28gd2UgY2FuIHJlZmVyZW5jZVxuLy8gbWFpbi5kLnRzIGhlcmUgd2l0aG91dCBwb2xsdXRpbmcgb3VyIG9mZmljaWFsIHR5cGluZ3MuXG5pbXBvcnQgZG9wcGlvanZtID0gcmVxdWlyZSgnLi9kb3BwaW9qdm0nKTtcbmV4cG9ydCA9IGRvcHBpb2p2bTtcbiIsIi8qKlxuICogQSBtb2R1bGUgZm9yIGdlbmVyaWMgaW50ZXJmYWNlcy4gTGlrZSBlbnVtcy50cywgd2UgdXNlIHRoaXMgdG8gYXZvaWRcbiAqIHVubmVlZGVkIGRlcGVuZGVuY2llcyBiZXR3ZWVuIG1vZHVsZXMsIHdoaWNoIGNhbiBpbmR1Y2UgY2lyY3VsYXJcbiAqIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4vKipcbiAqIFN0YW5kYXJkIEpWTSBvcHRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEpWTU9wdGlvbnMge1xuICAvLyBbUmVxdWlyZWRdIFBhdGggd2hlcmUgRG9wcGlvSlZNJ3MgdGhpbmdzIGFyZS5cbiAgLy8gRG9wcGlvSlZNIGV4cGVjdHMgdGhhdDpcbiAgLy8gLSBuYXRpdmVzIGFyZSBpbiB0aGUgJ25hdGl2ZXMnIHN1YmRpcmVjdG9yeS5cbiAgLy8gLSBKQ0wgaXMgaW4gdGhlICd2ZW5kb3IvamF2YV9ob21lJyBzdWJkaXJlY3RvcnkuXG4gIC8vIElmIHRoaXMgaXMgbm90IHRydWUsIGNoYW5nZSB0aGUgcmVsZXZhbnQgb3B0aW9ucyBiZWxvdy5cbiAgZG9wcGlvSG9tZVBhdGg6IHN0cmluZztcbiAgLy8gTm9uLUpDTCBwYXRocyBvbiB0aGUgY2xhc3MgcGF0aC4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gIGNsYXNzcGF0aD86IHN0cmluZ1tdO1xuICAvLyBUaGUgYm9vdHN0cmFwIGNsYXNzcGF0aCwgaW5jbHVkaW5nIHBhdGhzIHJlbGF0ZWQgdG8gdGhlIEphdmEgQ2xhc3MgTGlicmFyeSAoSkNMKS5cbiAgYm9vdHN0cmFwQ2xhc3NwYXRoPzogc3RyaW5nW107XG4gIC8vIFBhdGggdG8gSkFWQV9IT01FLlxuICBqYXZhSG9tZVBhdGg/OiBzdHJpbmc7XG4gIC8vIFhYWDogUGF0aCB3aGVyZSBuYXRpdmUgbWV0aG9kcyBhcmUgbG9jYXRlZC5cbiAgbmF0aXZlQ2xhc3NwYXRoPzogc3RyaW5nW107XG4gIC8vIFRydWUgaWYgYXNzZXJ0aW9ucyBhcmUgZW5hYmxlZCBpbiBzeXN0ZW0gY2xhc3NlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAvLyAoZXF1aXZhbGVudCB0byAtZXNhIGNvbW1hbmQgbGluZSBvcHRpb24pXG4gIGVuYWJsZVN5c3RlbUFzc2VydGlvbnM/OiBib29sZWFuO1xuICAvLyBFbmFibGUgYXNzZXJ0aW9ucyBhY3Jvc3MgYWxsIGNsYXNzZXMgKGlmIGB0cnVlYCkgb3JcbiAgLy8gc2VsZWN0ZWQgcGFja2FnZXMvY2xhc3Nlc1xuICAvLyAoc2VlIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzcvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL2xhbmd1YWdlL2Fzc2VydC5odG1sIGZvciBzeW50YXgpXG4gIGVuYWJsZUFzc2VydGlvbnM/OiBib29sZWFuIHwgc3RyaW5nW107XG4gIC8vIERpc2FibGUgYXNzZXJ0aW9ucyBvbiBzcGVjaWZpYyBjbGFzc2VzIC8gcGFja2FnZXNcbiAgLy8gKHNlZSBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS83L2RvY3MvdGVjaG5vdGVzL2d1aWRlcy9sYW5ndWFnZS9hc3NlcnQuaHRtbCBmb3Igc3ludGF4KVxuICBkaXNhYmxlQXNzZXJ0aW9ucz86IHN0cmluZ1tdO1xuICAvLyBTeXN0ZW0gcHJvcGVydGllcyBmb3IgdGhlIEpWTS5cbiAgcHJvcGVydGllcz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfTtcbiAgLy8gUGF0aCB3aGVyZSBEb3BwaW9KVk0gY2FuIHN0b3JlIHRlbXBvcmFyeSBmaWxlcy4gRGVmYXVsdHMgdG8gL3RtcC5cbiAgdG1wRGlyPzogc3RyaW5nO1xuICAvLyBSZXNwb25zaXZlbmVzcyBvZiBKVk0gKGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGEgdGhyZWFkIHlpZWxkcyBjby1vcGVyYXRpdmVseSlcbiAgcmVzcG9uc2l2ZW5lc3M/OiBudW1iZXIgfCAoKCkgPT4gbnVtYmVyKTtcbn1cblxuLyoqXG4gKiBQYXJ0aWFsIHR5cGluZyBmb3IgV2Vic29ja2lmeSBXZWJTb2NrZXRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElXZWJzb2NrIHtcbiAgclFsZW4oKTogbnVtYmVyO1xuICByUXNoaWZ0Qnl0ZXMobGVuOiBudW1iZXIpOiBudW1iZXJbXTtcbiAgb24oZXZlbnROYW1lOiBzdHJpbmcsIGNiOiBGdW5jdGlvbik6IHZvaWQ7XG4gIG9wZW4odXJpOiBzdHJpbmcpOiB2b2lkO1xuICBjbG9zZSgpOiB2b2lkO1xuICBzZW5kKGRhdGE6IG51bWJlcik6IHZvaWQ7XG4gIHNlbmQoZGF0YTogbnVtYmVyW10pOiB2b2lkO1xuICAvLyBYWFg6IERpZCB3ZSBhZGQgdGhpcyB0byB0aGUgbGlicmFyeT8gSSB0aGluayB3ZSBkaWQuXG4gIGdldF9yYXdfc3RhdGUoKTogbnVtYmVyO1xufVxuXG4vKipcbiAqIERvcHBpby1zcGVjaWZpYyBjb25maWd1cmF0aW9uIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgSmF2YSBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSlZNQ0xJT3B0aW9ucyBleHRlbmRzIEpWTU9wdGlvbnMge1xuICAvLyBOYW1lIG9mIHRoZSBjb21tYW5kIHVzZWQgdG8gbGF1bmNoIGBqYXZhYC4gVXNlZCBpbiB0aGUgJ3VzYWdlJyBwb3J0aW9uIG9mXG4gIC8vIHRoZSBoZWxwIG1lc3NhZ2UuXG4gIGxhdW5jaGVyTmFtZTogc3RyaW5nO1xufVxuXG4iLCJpbXBvcnQge09wdGlvblBhcnNlciwgUGFyc2VUeXBlLCBQcmVmaXhQYXJzZVJlc3VsdH0gZnJvbSAnLi9vcHRpb25fcGFyc2VyJztcbmltcG9ydCBKVk0gPSByZXF1aXJlKCcuL2p2bScpO1xuaW1wb3J0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmltcG9ydCBsb2dnaW5nID0gcmVxdWlyZSgnLi9sb2dnaW5nJyk7XG5pbXBvcnQge0pWTUNMSU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbmxldCBwYXJzZXIgPSBuZXcgT3B0aW9uUGFyc2VyKHtcbiAgZGVmYXVsdDoge1xuICAgIGNsYXNzcGF0aDoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLk5PUk1BTF9WQUxVRV9TWU5UQVgsXG4gICAgICBhbGlhczogJ2NwJyxcbiAgICAgIG9wdERlc2M6ICcgPGNsYXNzIHNlYXJjaCBwYXRoIG9mIGRpcmVjdG9yaWVzIGFuZCB6aXAvamFyIGZpbGVzPicsXG4gICAgICBkZXNjOiAnQSA6IHNlcGFyYXRlZCBsaXN0IG9mIGRpcmVjdG9yaWVzLCBKQVIgYXJjaGl2ZXMsIGFuZCBaSVAgYXJjaGl2ZXMgdG8gc2VhcmNoIGZvciBjbGFzcyBmaWxlcy4nLFxuICAgIH0sXG4gICAgRDoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLk1BUF9TWU5UQVgsXG4gICAgICBvcHREZXNjOiAnPG5hbWU+PTx2YWx1ZT4nLFxuICAgICAgZGVzYzogJ3NldCBhIHN5c3RlbSBwcm9wZXJ0eSdcbiAgICB9LFxuICAgIGphcjoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLk5PUk1BTF9WQUxVRV9TWU5UQVgsXG4gICAgICBzdG9wUGFyc2luZzogdHJ1ZVxuICAgIH0sXG4gICAgaGVscDogeyBhbGlhczogJz8nLCBkZXNjOiAncHJpbnQgdGhpcyBoZWxwIG1lc3NhZ2UnIH0sXG4gICAgWDogeyBkZXNjOiAncHJpbnQgaGVscCBvbiBub24tc3RhbmRhcmQgb3B0aW9ucycgfSxcbiAgICBlbmFibGVhc3NlcnRpb25zOiB7XG4gICAgICB0eXBlOiBQYXJzZVR5cGUuQ09MT05fVkFMVUVfT1JfRkxBR19TWU5UQVgsXG4gICAgICBvcHREZXNjOiAnWzo8cGFja2FnZW5hbWU+Li4ufDo8Y2xhc3NuYW1lPl0nLFxuICAgICAgYWxpYXM6ICdlYScsXG4gICAgICBkZXNjOiAnZW5hYmxlIGFzc2VydGlvbnMgd2l0aCBzcGVjaWZpZWQgZ3JhbnVsYXJpdHknXG4gICAgfSxcbiAgICBkaXNhYmxlYXNzZXJ0aW9uczoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLkNPTE9OX1ZBTFVFX09SX0ZMQUdfU1lOVEFYLFxuICAgICAgb3B0RGVzYzogJ1s6PHBhY2thZ2VuYW1lPi4uLnw6PGNsYXNzbmFtZT5dJyxcbiAgICAgIGFsaWFzOiAnZGEnLFxuICAgICAgZGVzYzogJ2Rpc2FibGUgYXNzZXJ0aW9ucyB3aXRoIHNwZWNpZmllZCBncmFudWxhcml0eSdcbiAgICB9LFxuICAgIGVuYWJsZXN5c3RlbWFzc2VydGlvbnM6IHsgYWxpYXM6ICdlc2EnLCBkZXNjOiAnZW5hYmxlIHN5c3RlbSBhc3NlcnRpb25zJyB9LFxuICAgIGRpc2FibGVzeXN0ZW1hc3NlcnRpb25zOiB7IGFsaWFzOiAnZHNhJywgZGVzYzogJ2Rpc2FibGUgc3lzdGVtIGFzc2VydGlvbnMgJ31cbiAgfSxcbiAgWDoge1xuICAgIGxvZzoge1xuICAgICAgZGVzYzogJ2xvZyBsZXZlbCwgWzAtMTBdfHZ0cmFjZXx0cmFjZXxkZWJ1Z3xlcnJvcicsXG4gICAgICB0eXBlOiBQYXJzZVR5cGUuTk9STUFMX1ZBTFVFX1NZTlRBWFxuICAgIH0sXG4gICAgJ3Z0cmFjZS1tZXRob2RzJzoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLk5PUk1BTF9WQUxVRV9TWU5UQVgsXG4gICAgICBvcHREZXNjOiAnIDxqYXZhL2xhbmcvT2JqZWN0L2dldEhhc2hDb2RlKClJOi4uLj4nLFxuICAgICAgZGVzYzogJ3NwZWNpZnkgcGFydGljdWxhciBtZXRob2RzIHRvIHZ0cmFjZSBzZXBhcmF0ZWQgYnkgY29sb25zJ1xuICAgIH0sXG4gICAgJ2xpc3QtY2xhc3MtY2FjaGUnOiB7XG4gICAgICBkZXNjOiAnbGlzdCBhbGwgb2YgdGhlIGJvb3RzdHJhcCBsb2FkZWQgY2xhc3NlcyBhZnRlciBleGVjdXRpb24nXG4gICAgfSxcbiAgICAnZHVtcC1jb21waWxlZC1jb2RlJzoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLk5PUk1BTF9WQUxVRV9TWU5UQVgsXG4gICAgICBvcHREZXNjOiAnIDxkaXJlY3Rvcnk+JyxcbiAgICAgIGRlc2M6ICdsb2NhdGlvbiB0byBkdW1wIGNvbXBpbGVkIG9iamVjdCBkZWZpbml0aW9ucydcbiAgICB9LFxuICAgIC8vIFRPRE86IFVzZSAtRGphdmEubGlicmFyeS5wYXRoXG4gICAgJ25hdGl2ZS1jbGFzc3BhdGgnOiB7XG4gICAgICB0eXBlOiBQYXJzZVR5cGUuTk9STUFMX1ZBTFVFX1NZTlRBWCxcbiAgICAgIG9wdERlc2M6ICcgPGNsYXNzIHNlYXJjaCBwYXRoIG9mIGRpcmVjdG9yaWVzPicsXG4gICAgICBkZXNjOiAnQSA6IHNlcGFyYXRlZCBsaXN0IG9mIGRpcmVjdG9yaWVzIHRvIHNlYXJjaCBmb3IgbmF0aXZlIG1hdGhvZHMgaW4gSlMgZmlsZXMuJ1xuICAgIH0sXG4gICAgJ2Jvb3RjbGFzc3BhdGgvYSc6IHtcbiAgICAgIHR5cGU6IFBhcnNlVHlwZS5DT0xPTl9WQUxVRV9TWU5UQVgsXG4gICAgICBvcHREZXNjOiAnOjxkaXJlY3RvcmllcyBhbmQgemlwL2phciBmaWxlcyBzZXBhcmF0ZWQgYnkgOj4nLFxuICAgICAgZGVzYzogJ2FwcGVuZCB0byBlbmQgb2YgYm9vdHN0cmFwIGNsYXNzIHBhdGgnXG4gICAgfSxcbiAgICAnYm9vdGNsYXNzcGF0aC9wJzoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLkNPTE9OX1ZBTFVFX1NZTlRBWCxcbiAgICAgIG9wdERlc2M6ICc6PGRpcmVjdG9yaWVzIGFuZCB6aXAvamFyIGZpbGVzIHNlcGFyYXRlZCBieSA6PicsXG4gICAgICBkZXNjOiAncHJlcGVuZCBpbiBmcm9udCBvZiBib290c3RyYXAgY2xhc3MgcGF0aCdcbiAgICB9LFxuICAgICdib290Y2xhc3NwYXRoJzoge1xuICAgICAgdHlwZTogUGFyc2VUeXBlLkNPTE9OX1ZBTFVFX1NZTlRBWCxcbiAgICAgIG9wdERlc2M6ICc6PGRpcmVjdG9yaWVzIGFuZCB6aXAvamFyIGZpbGVzIHNlcGFyYXRlZCBieSA6PicsXG4gICAgICBkZXNjOiAnc2V0IHNlYXJjaCBwYXRoIGZvciBib290c3RyYXAgY2xhc3NlcyBhbmQgcmVzb3VyY2VzJ1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQ29uc3VtZXMgYSBgamF2YWAgY29tbWFuZCBsaW5lIHN0cmluZy4gQ29uc3RydWN0cyBhIEpWTSwgbGF1bmNoZXMgdGhlIGNvbW1hbmQsIGFuZFxuICogcmV0dXJucyB0aGUgSlZNIG9iamVjdC4gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBwYXJzaW5nIGZhaWxzLlxuICpcbiAqIFJldHVybnMgYG51bGxgIGlmIG5vIEpWTSBuZWVkZWQgdG8gYmUgY29uc3RydWN0ZWQgKGUuZy4gLWggZmxhZykuXG4gKlxuICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIHRoZSAnamF2YScgY29tbWFuZC5cbiAqIEBwYXJhbSBvcHRzIERlZmF1bHQgb3B0aW9ucy5cbiAqIEBwYXJhbSBkb25lQ2IgQ2FsbGVkIHdoZW4gSlZNIGV4ZWN1dGlvbiBmaW5pc2hlcy4gUGFzc2VzIGFcbiAqICAgbnVtYmVyIHRvIHRoZSBjYWxsYmFjayBpbmRpY2F0aW5nIHRoZSBleGl0IHZhbHVlLlxuICogQHBhcmFtIFtqdm1TdGFydGVkXSBDYWxsZWQgd2l0aCB0aGUgSlZNIG9iamVjdCBvbmNlIHdlIGhhdmUgaW52b2tlZCBpdC5cbiAqL1xuZnVuY3Rpb24gamF2YShhcmdzOiBzdHJpbmdbXSwgb3B0czogSlZNQ0xJT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgIGRvbmVDYjogKHN0YXR1czogbnVtYmVyKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAganZtU3RhcnRlZDogKGp2bTogSlZNKSA9PiB2b2lkID0gZnVuY3Rpb24oanZtOiBKVk0pOiB2b2lkIHt9KTogdm9pZCB7XG4gIGxldCBwYXJzZWRBcmdzID0gcGFyc2VyLnBhcnNlKGFyZ3MpLFxuICAgIHN0YW5kYXJkID0gcGFyc2VkQXJnc1snZGVmYXVsdCddLFxuICAgIG5vblN0YW5kYXJkID0gcGFyc2VkQXJnc1snWCddLFxuICAgIGp2bVN0YXRlOiBKVk07XG5cbiAgLy8gU3lzdGVtIHByb3BlcnRpZXMuXG4gIG9wdHMucHJvcGVydGllcyA9IHN0YW5kYXJkLm1hcE9wdGlvbignRCcpO1xuXG4gIGlmIChzdGFuZGFyZC5mbGFnKCdoZWxwJywgZmFsc2UpKSB7XG4gICAgcmV0dXJuIHByaW50SGVscChvcHRzLmxhdW5jaGVyTmFtZSwgcGFyc2VyLmhlbHAoJ2RlZmF1bHQnKSwgZG9uZUNiLCAwKTtcbiAgfSBlbHNlIGlmIChzdGFuZGFyZC5mbGFnKCdYJywgZmFsc2UpKSB7XG4gICAgcmV0dXJuIHByaW50Tm9uU3RhbmRhcmRIZWxwKG9wdHMubGF1bmNoZXJOYW1lLCBwYXJzZXIuaGVscCgnWCcpLCBkb25lQ2IsIDApO1xuICB9XG5cbiAgLy8gR0xPQkFMIENPTkZJR1VSQVRJT05cbiAgbGV0IGxvZ09wdGlvbiA9IG5vblN0YW5kYXJkLnN0cmluZ09wdGlvbignbG9nJywgJ0VSUk9SJyk7XG5cbiAgaWYgKC9eWzAtOV0rJC8udGVzdChsb2dPcHRpb24pKSB7XG4gICAgbG9nZ2luZy5sb2dfbGV2ZWwgPSBwYXJzZUludChsb2dPcHRpb24sIDEwKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbGV2ZWwgPSAoPGFueT4gbG9nZ2luZylbbG9nT3B0aW9uLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShgVW5yZWNvZ25pemVkIGxvZyBsZXZlbDogJHtsb2dPcHRpb259LmApO1xuICAgICAgcmV0dXJuIHByaW50SGVscChvcHRzLmxhdW5jaGVyTmFtZSwgcGFyc2VyLmhlbHAoJ2RlZmF1bHQnKSwgZG9uZUNiLCAxKTtcbiAgICB9XG4gICAgbG9nZ2luZy5sb2dfbGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIGlmIChub25TdGFuZGFyZC5mbGFnKCdsaXN0LWNsYXNzLWNhY2hlJywgZmFsc2UpKSB7XG4gICAgLy8gUmVkZWZpbmUgZG9uZV9jYiBzbyB3ZSBwcmludCB0aGUgbG9hZGVkIGNsYXNzIGZpbGVzIG9uIEpWTSBleGl0LlxuICAgIGRvbmVDYiA9ICgob2xkX2RvbmVfY2I6IChhcmc6IG51bWJlcikgPT4gdm9pZCk6IChhcmc6IG51bWJlcikgPT4gdm9pZCA9PiB7XG4gICAgICByZXR1cm4gKHJlc3VsdDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIGxldCBmcGF0aHMgPSBqdm1TdGF0ZS5nZXRCb290c3RyYXBDbGFzc0xvYWRlcigpLmdldExvYWRlZENsYXNzRmlsZXMoKTtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoZnBhdGhzLmpvaW4oJ1xcbicpICsgJ1xcbicpO1xuICAgICAgICBvbGRfZG9uZV9jYihyZXN1bHQpO1xuICAgICAgfTtcbiAgICB9KShkb25lQ2IpO1xuICB9XG5cbiAgaWYgKHN0YW5kYXJkLmZsYWcoJ2VuYWJsZXN5c3RlbWFzc2VydGlvbnMnLCBmYWxzZSkpIHtcbiAgICBvcHRzLmVuYWJsZVN5c3RlbUFzc2VydGlvbnMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHN0YW5kYXJkLmZsYWcoJ2Rpc2FibGVzeXN0ZW1hc3NlcnRpb25zJywgZmFsc2UpKSB7XG4gICAgb3B0cy5lbmFibGVTeXN0ZW1Bc3NlcnRpb25zID0gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhbmRhcmQuZmxhZygnZW5hYmxlYXNzZXJ0aW9ucycsIGZhbHNlKSkge1xuICAgIG9wdHMuZW5hYmxlQXNzZXJ0aW9ucyA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhbmRhcmQuc3RyaW5nT3B0aW9uKCdlbmFibGVhc3NlcnRpb25zJywgbnVsbCkpIHtcbiAgICBvcHRzLmVuYWJsZUFzc2VydGlvbnMgPSBzdGFuZGFyZC5zdHJpbmdPcHRpb24oJ2VuYWJsZWFzc2VydGlvbnMnLCBudWxsKS5zcGxpdCgnOicpO1xuICB9XG5cbiAgaWYgKHN0YW5kYXJkLnN0cmluZ09wdGlvbignZGlzYWJsZWFzc2VydGlvbnMnLCBudWxsKSkge1xuICAgIG9wdHMuZGlzYWJsZUFzc2VydGlvbnMgPSBzdGFuZGFyZC5zdHJpbmdPcHRpb24oJ2Rpc2FibGVhc3NlcnRpb25zJywgbnVsbCkuc3BsaXQoJzonKTtcbiAgfVxuICAvLyBOT1RFOiBCb29sZWFuIGZvcm0gb2YgLWRpc2FibGVhc3NlcnRpb25zIGlzIGEgTk9QLlxuXG4gIC8vIEJvb3RzdHJhcCBjbGFzc3BhdGggaXRlbXMuXG4gIGxldCBic2NsID0gbm9uU3RhbmRhcmQuc3RyaW5nT3B0aW9uKCdib290Y2xhc3NwYXRoJywgbnVsbCk7XG4gIGlmIChic2NsICE9PSBudWxsKSB7XG4gICAgb3B0cy5ib290c3RyYXBDbGFzc3BhdGggPSBic2NsLnNwbGl0KCc6Jyk7XG4gIH1cbiAgbGV0IGJzQ2xBcHBlbmQgPSBub25TdGFuZGFyZC5zdHJpbmdPcHRpb24oJ2Jvb3RjbGFzc3BhdGgvYScsIG51bGwpO1xuICBpZiAoYnNDbEFwcGVuZCkge1xuICAgIG9wdHMuYm9vdHN0cmFwQ2xhc3NwYXRoID0gb3B0cy5ib290c3RyYXBDbGFzc3BhdGguY29uY2F0KGJzQ2xBcHBlbmQuc3BsaXQoJzonKSk7XG4gIH1cbiAgbGV0IGJzQ2xQcmVwZW5kID0gbm9uU3RhbmRhcmQuc3RyaW5nT3B0aW9uKCdib290Y2xhc3NwYXRoL3AnLCBudWxsKTtcbiAgaWYgKGJzQ2xQcmVwZW5kKSB7XG4gICAgb3B0cy5ib290c3RyYXBDbGFzc3BhdGggPSBic0NsUHJlcGVuZC5zcGxpdCgnOicpLmNvbmNhdChvcHRzLmJvb3RzdHJhcENsYXNzcGF0aCk7XG4gIH1cblxuICAvLyBVc2VyLXN1cHBsaWVkIGNsYXNzcGF0aCBpdGVtcy5cbiAgaWYgKCFvcHRzLmNsYXNzcGF0aCkge1xuICAgIG9wdHMuY2xhc3NwYXRoID0gW107XG4gIH1cblxuICBpZiAoc3RhbmRhcmQuc3RyaW5nT3B0aW9uKCdqYXInLCBudWxsKSkge1xuICAgIG9wdHMuY2xhc3NwYXRoLnB1c2goc3RhbmRhcmQuc3RyaW5nT3B0aW9uKCdqYXInLCBudWxsKSk7XG4gIH0gZWxzZSBpZiAoc3RhbmRhcmQuc3RyaW5nT3B0aW9uKCdjbGFzc3BhdGgnLCBudWxsKSkge1xuICAgIG9wdHMuY2xhc3NwYXRoID0gb3B0cy5jbGFzc3BhdGguY29uY2F0KHN0YW5kYXJkLnN0cmluZ09wdGlvbignY2xhc3NwYXRoJywgbnVsbCkuc3BsaXQoJzonKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gREVGQVVMVDogSWYgbm8gdXNlci1zdXBwbGllZCBjbGFzc3BhdGgsIGFkZCB0aGUgY3VycmVudCBkaXJlY3RvcnkgdG9cbiAgICAvLyB0aGUgY2xhc3MgcGF0aC5cbiAgICBvcHRzLmNsYXNzcGF0aC5wdXNoKHByb2Nlc3MuY3dkKCkpO1xuICB9XG5cbiAgLy8gVXNlci1zdXBwbGllZCBuYXRpdmUgY2xhc3NwYXRoLlxuICBsZXQgbmF0aXZlQ2xhc3NwYXRoID0gc3RhbmRhcmQuc3RyaW5nT3B0aW9uKCduYXRpdmUtY2xhc3NwYXRoJywgbnVsbCk7XG4gIGlmIChuYXRpdmVDbGFzc3BhdGgpIHtcbiAgICBvcHRzLm5hdGl2ZUNsYXNzcGF0aCA9IG9wdHMubmF0aXZlQ2xhc3NwYXRoLmNvbmNhdChuYXRpdmVDbGFzc3BhdGguc3BsaXQoJzonKSk7XG4gIH1cblxuICAvLyBDb25zdHJ1Y3QgdGhlIEpWTS5cbiAganZtU3RhdGUgPSBuZXcgSlZNKG9wdHMsIChlcnI/OiBhbnkpOiB2b2lkID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIkVycm9yIGNvbnN0cnVjdGluZyBKVk06XFxuXCIpO1xuICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoZXJyLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcbiAgICAgIGRvbmVDYigxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF1bmNoSnZtKHN0YW5kYXJkLCBvcHRzLCBqdm1TdGF0ZSwgZG9uZUNiLCBqdm1TdGFydGVkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCB2dHJhY2VNZXRob2RzID0gbm9uU3RhbmRhcmQuc3RyaW5nT3B0aW9uKCd2dHJhY2UtbWV0aG9kcycsIG51bGwpO1xuICBpZiAodnRyYWNlTWV0aG9kcykge1xuICAgIHZ0cmFjZU1ldGhvZHMuc3BsaXQoJzonKS5mb3JFYWNoKChtOiBzdHJpbmcpID0+IGp2bVN0YXRlLnZ0cmFjZU1ldGhvZChtKSk7XG4gIH1cblxuICBsZXQgZHVtcENvbXBpbGVkQ29kZSA9IG5vblN0YW5kYXJkLnN0cmluZ09wdGlvbignZHVtcENvbXBpbGVkQ29kZScsIG51bGwpO1xuICBpZiAoZHVtcENvbXBpbGVkQ29kZSkge1xuICAgIGp2bVN0YXRlLmR1bXBDb21waWxlZENvZGUoZHVtcENvbXBpbGVkQ29kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb25zdW1lcyBhIGZ1bGx5LWNvbmZpZ3VyZWQgSlZNLCBwYXJzZWQgYXJndW1lbnRzLCBhbmQgYSBjYWxsYmFjay5cbiAqIEZpZ3VyZXMgb3V0IGZyb20gdGhpcyBob3cgdG8gbGF1bmNoIHRoZSBKVk0gKGUuZy4gdXNpbmcgYSBKQVIgZmlsZSBvciBhXG4gKiBwYXJ0aWN1bGFyIGNsYXNzKS5cbiAqL1xuZnVuY3Rpb24gbGF1bmNoSnZtKHN0YW5kYXJkT3B0aW9uczogUHJlZml4UGFyc2VSZXN1bHQsIG9wdHM6IEpWTUNMSU9wdGlvbnMsIGp2bVN0YXRlOiBKVk0sIGRvbmVDYjogKHN0YXR1czogbnVtYmVyKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgICAgICBqdm1TdGFydGVkOiAoanZtU3RhdGU6IEpWTSkgPT4gdm9pZCk6IHZvaWQge1xuICBsZXQgbWFpbkFyZ3MgPSBzdGFuZGFyZE9wdGlvbnMudW5wYXJzZWRBcmdzKCk7XG4gIGlmIChzdGFuZGFyZE9wdGlvbnMuc3RyaW5nT3B0aW9uKCdqYXInLCBudWxsKSkge1xuICAgIGp2bVN0YXRlLnJ1bkphcihtYWluQXJncywgZG9uZUNiKTtcbiAgICBqdm1TdGFydGVkKGp2bVN0YXRlKTtcbiAgfSBlbHNlIGlmIChtYWluQXJncy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IGNuYW1lID0gbWFpbkFyZ3NbMF07XG4gICAgaWYgKGNuYW1lLnNsaWNlKC02KSA9PT0gJy5jbGFzcycpIHtcbiAgICAgIGNuYW1lID0gY25hbWUuc2xpY2UoMCwgLTYpO1xuICAgIH1cbiAgICBpZiAoY25hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgLy8gaGFjazogY29udmVydCBqYXZhLmZvby5CYXIgdG8gamF2YS9mb28vQmFyXG4gICAgICBjbmFtZSA9IHV0aWwuZGVzY3JpcHRvcjJ0eXBlc3RyKHV0aWwuaW50X2NsYXNzbmFtZShjbmFtZSkpO1xuICAgIH1cbiAgICBqdm1TdGF0ZS5ydW5DbGFzcyhjbmFtZSwgbWFpbkFyZ3Muc2xpY2UoMSksIGRvbmVDYik7XG4gICAganZtU3RhcnRlZChqdm1TdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gY2xhc3Mgc3BlY2lmaWVkLCBubyBqYXIgc3BlY2lmaWVkIVxuICAgIHByaW50SGVscChvcHRzLmxhdW5jaGVyTmFtZSwgcGFyc2VyLmhlbHAoJ2RlZmF1bHQnKSwgZG9uZUNiLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludEhlbHAobGF1bmNoZXJOYW1lOiBzdHJpbmcsIHN0cjogc3RyaW5nLCBkb25lQ2I6IChhcmc6IG51bWJlcikgPT4gdm9pZCwgcnY6IG51bWJlcik6IHZvaWQge1xuICBwcm9jZXNzLnN0ZG91dC53cml0ZShcbmBVc2FnZTogJHtsYXVuY2hlck5hbWV9IFstb3B0aW9uc10gY2xhc3MgW2FyZ3MuLi5dXG4gICAgICAgICh0byBleGVjdXRlIGEgY2xhc3MpXG5vciAgJHtsYXVuY2hlck5hbWV9IFstb3B0aW9uc10gLWphciBqYXJmaWxlIFthcmdzLi4uXVxuICAgICAgICAodG8gZXhlY3V0ZSBhIGphciBmaWxlKVxud2hlcmUgb3B0aW9ucyBpbmNsdWRlOlxcbiR7c3RyfWApO1xuICBkb25lQ2IocnYpO1xufVxuXG5mdW5jdGlvbiBwcmludE5vblN0YW5kYXJkSGVscChsYXVuY2hlck5hbWU6IHN0cmluZywgc3RyOiBzdHJpbmcsIGRvbmVDYjogKGFyZzogbnVtYmVyKSA9PiB2b2lkLCBydjogbnVtYmVyKTogdm9pZCB7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGAke3N0cn1cXG5cXG5UaGUgLVggb3B0aW9ucyBhcmUgbm9uLXN0YW5kYXJkIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cXG5gKTtcbiAgZG9uZUNiKHJ2KTtcbn1cblxuZXhwb3J0ID0gamF2YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmltcG9ydCBTYWZlTWFwID0gcmVxdWlyZSgnLi9TYWZlTWFwJyk7XG5pbXBvcnQgbWV0aG9kcyA9IHJlcXVpcmUoJy4vbWV0aG9kcycpO1xuaW1wb3J0IHtDbGFzc0RhdGEsIFJlZmVyZW5jZUNsYXNzRGF0YSwgQXJyYXlDbGFzc0RhdGF9IGZyb20gJy4vQ2xhc3NEYXRhJztcbmltcG9ydCBDbGFzc0xvYWRlciA9IHJlcXVpcmUoJy4vQ2xhc3NMb2FkZXInKTtcbmltcG9ydCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5pbXBvcnQgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmltcG9ydCBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbmltcG9ydCB7SlZNVGhyZWFkfSBmcm9tICcuL3RocmVhZGluZyc7XG5pbXBvcnQge1RocmVhZFN0YXR1cywgSlZNU3RhdHVzfSBmcm9tICcuL2VudW1zJztcbmltcG9ydCBIZWFwID0gcmVxdWlyZSgnLi9oZWFwJyk7XG5pbXBvcnQgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmltcG9ydCBpbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XG5pbXBvcnQgSlZNVHlwZXMgPSByZXF1aXJlKCcuLi9pbmNsdWRlcy9KVk1UeXBlcycpO1xuaW1wb3J0IFBhcmtlciA9IHJlcXVpcmUoJy4vcGFya2VyJyk7XG5pbXBvcnQgVGhyZWFkUG9vbCBmcm9tICcuL3RocmVhZHBvb2wnO1xuaW1wb3J0IGxvZ2dpbmcgPSByZXF1aXJlKCcuL2xvZ2dpbmcnKTtcbmltcG9ydCBKREtJbmZvID0gcmVxdWlyZSgnLi4vdmVuZG9yL2phdmFfaG9tZS9qZGsuanNvbicpO1xuZGVjbGFyZSB2YXIgUkVMRUFTRTogYm9vbGVhbjtcblxuLy8gRG8gbm90IGltcG9ydCwgb3RoZXJ3aXNlIFR5cGVTY3JpcHQgd2lsbCBwcnVuZSBpdC5cbi8vIFJlZmVyZW5jZWQgb25seSBpbiBldmFsJ2QgY29kZS5cbmxldCBCcm93c2VyRlMgPSByZXF1aXJlKCdicm93c2VyZnMnKTtcbmxldCBkZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlJyk7XG5sZXQgaW5mbGF0ZSA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvaW5mbGF0ZScpO1xubGV0IHpzdHJlYW0gPSByZXF1aXJlKCdwYWtvL2xpYi96bGliL3pzdHJlYW0nKTtcbmxldCBjcmMzMiA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvY3JjMzInKTtcbmxldCBhZGxlcjMyID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9hZGxlcjMyJyk7XG4vLyBGb3IgdmVyc2lvbiBpbmZvcm1hdGlvbi5cbmxldCBwa2c6IGFueTtcbmlmICh1dGlsLmFyZV9pbl9icm93c2VyKCkpIHtcbiAgcGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG59IGVsc2Uge1xuICBwa2cgPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcbn1cblxuXG4vLyBYWFg6IFdlIGN1cnJlbnRseSBpbml0aWFsaXplIHRoZXNlIGNsYXNzZXMgYXQgSlZNIGJvb3R1cC4gVGhpcyBpcyBleHBlbnNpdmUuXG4vLyBXZSBzaG91bGQgYXR0ZW1wdCB0byBwcnVuZSB0aGlzIGxpc3QgYXMgbXVjaCBhcyBwb3NzaWJsZS5cbnZhciBjb3JlQ2xhc3NlcyA9IFtcbiAgJ0xqYXZhL2xhbmcvU3RyaW5nOycsXG4gICdMamF2YS9sYW5nL0NsYXNzOycsICdMamF2YS9sYW5nL0NsYXNzTG9hZGVyOycsXG4gICdMamF2YS9sYW5nL3JlZmxlY3QvQ29uc3RydWN0b3I7JywgJ0xqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZDsnLFxuICAnTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsnLFxuICAnTGphdmEvbGFuZy9FcnJvcjsnLCAnTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDsnLFxuICAnTGphdmEvbGFuZy9TeXN0ZW07JyxcbiAgJ0xqYXZhL2xhbmcvVGhyZWFkOycsXG4gICdMamF2YS9sYW5nL1RocmVhZEdyb3VwOycsXG4gICdMamF2YS9sYW5nL1Rocm93YWJsZTsnLFxuICAnTGphdmEvbmlvL0J5dGVPcmRlcjsnLFxuICAnTHN1bi9taXNjL1ZNOycsICdMc3VuL3JlZmxlY3QvQ29uc3RhbnRQb29sOycsICdMamF2YS9sYW5nL0J5dGU7JyxcbiAgJ0xqYXZhL2xhbmcvQ2hhcmFjdGVyOycsICdMamF2YS9sYW5nL0RvdWJsZTsnLCAnTGphdmEvbGFuZy9GbG9hdDsnLFxuICAnTGphdmEvbGFuZy9JbnRlZ2VyOycsICdMamF2YS9sYW5nL0xvbmc7JywgJ0xqYXZhL2xhbmcvU2hvcnQ7JyxcbiAgJ0xqYXZhL2xhbmcvVm9pZDsnLCAnTGphdmEvaW8vRmlsZURlc2NyaXB0b3I7JyxcbiAgJ0xqYXZhL2xhbmcvQm9vbGVhbjsnLCAnW0xzdW4vbWFuYWdlbWVudC9NZW1vcnlNYW5hZ2VySW1wbDsnLFxuICAnW0xzdW4vbWFuYWdlbWVudC9NZW1vcnlQb29sSW1wbDsnLFxuICAvLyBDb250YWlucyBpbXBvcnRhbnQgRlMgY29uc3RhbnRzIHVzZWQgYnkgbmF0aXZlcy4gVGhlc2UgY29uc3RhbnRzIGFyZVxuICAvLyBpbmxpbmVkIGludG8gSkNMIGNsYXNzIGZpbGVzLCBzbyBpdCB0eXBpY2FsbHkgbmV2ZXIgZ2V0cyBpbml0aWFsaXplZFxuICAvLyBpbXBsaWNpdGx5IGJ5IHRoZSBKVk0uXG4gICdMc3VuL25pby9mcy9Vbml4Q29uc3RhbnRzOydcbl07XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIGEgc2luZ2xlIEpWTSBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgSlZNIHtcbiAgcHJpdmF0ZSBzeXN0ZW1Qcm9wZXJ0aWVzOiB7W3Byb3A6IHN0cmluZ106IHN0cmluZ30gPSBudWxsO1xuICBwcml2YXRlIGludGVybmVkU3RyaW5nczogU2FmZU1hcDxKVk1UeXBlcy5qYXZhX2xhbmdfU3RyaW5nPiA9IG5ldyBTYWZlTWFwPEpWTVR5cGVzLmphdmFfbGFuZ19TdHJpbmc+KCk7XG4gIHByaXZhdGUgYnNDbDogQ2xhc3NMb2FkZXIuQm9vdHN0cmFwQ2xhc3NMb2FkZXIgPSBudWxsO1xuICBwcml2YXRlIHRocmVhZFBvb2w6IFRocmVhZFBvb2w8SlZNVGhyZWFkPiA9IG51bGw7XG4gIHByaXZhdGUgbmF0aXZlczogeyBbY2xzTmFtZTogc3RyaW5nXTogeyBbbWV0aFNpZzogc3RyaW5nXTogRnVuY3Rpb24gfSB9ID0ge307XG4gIC8vIDIwTUIgaGVhcFxuICAvLyBAdG9kbyBNYWtlIGhlYXAgcmVzaXplYWJsZS5cbiAgcHJpdmF0ZSBoZWFwOiBIZWFwID0gbmV3IEhlYXAoMjAgKiAxMDI0ICogMTAyNCk7XG4gIHByaXZhdGUgbmF0aXZlQ2xhc3NwYXRoOiBzdHJpbmdbXSA9IG51bGw7XG4gIHByaXZhdGUgc3RhcnR1cFRpbWU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICBwcml2YXRlIHRlcm1pbmF0aW9uQ2I6IChjb2RlOiBudW1iZXIpID0+IHZvaWQgPSBudWxsO1xuICAvLyBUaGUgaW5pdGlhbCBKVk0gdGhyZWFkIHVzZWQgdG8ga2ljayBvZmYgZXhlY3V0aW9uLlxuICBwcml2YXRlIGZpcnN0VGhyZWFkOiBKVk1UaHJlYWQgPSBudWxsO1xuICBwcml2YXRlIHJlc3BvbnNpdmVuZXNzOiBudW1iZXIgfCAoKCkgPT4gbnVtYmVyKSA9IG51bGw7XG4gIHByaXZhdGUgZW5hYmxlU3lzdGVtQXNzZXJ0aW9uczogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGVuYWJsZWRBc3NlcnRpb25zOiBib29sZWFuIHwgc3RyaW5nW10gPSBmYWxzZTtcbiAgcHJpdmF0ZSBkaXNhYmxlZEFzc2VydGlvbnM6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgc3lzdGVtQ2xhc3NMb2FkZXI6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyID0gbnVsbDtcbiAgcHJpdmF0ZSBuZXh0UmVmOiBudW1iZXIgPSAwO1xuICAvLyBTZXQgb2YgYWxsIG9mIHRoZSBtZXRob2RzIHdlIHdhbnQgdnRyYWNlIHRvIGJlIGVuYWJsZWQgb24uXG4gIC8vIERFQlVHIGJ1aWxkcyBvbmx5LlxuICBwcml2YXRlIHZ0cmFjZU1ldGhvZHM6IHtbZnVsbFNpZzogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcbiAgLy8gW0RFQlVHXSBkaXJlY3RvcnkgdG8gZHVtcCBjb21waWxlZCBjb2RlIHRvLlxuICBwcml2YXRlIGR1bXBDb21waWxlZENvZGVEaXI6IHN0cmluZyA9IG51bGw7XG4gIC8vIEhhbmRsZXMgcGFya2luZy91bnBhcmtpbmcgdGhyZWFkcy5cbiAgcHJpdmF0ZSBwYXJrZXIgPSBuZXcgUGFya2VyKCk7XG4gIC8vIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgSlZNLlxuICBwcml2YXRlIHN0YXR1czogSlZNU3RhdHVzID0gSlZNU3RhdHVzLkJPT1RJTkc7XG4gIC8vIFRoZSBKVk0ncyBwbGFubmVkIGV4aXQgY29kZS5cbiAgcHJpdmF0ZSBleGl0Q29kZTogbnVtYmVyID0gMDtcblxuICAvKipcbiAgICogKEFzeW5jKSBDb25zdHJ1Y3QgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEphdmEgVmlydHVhbCBNYWNoaW5lLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0czogaW50ZXJmYWNlcy5KVk1PcHRpb25zLCBjYjogKGU6IGFueSwganZtPzogSlZNKSA9PiB2b2lkKSB7XG4gICAgaWYgKHR5cGVvZihvcHRzLmRvcHBpb0hvbWVQYXRoKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRzLmRvcHBpb0hvbWVQYXRoICptdXN0KiBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBvcHRzID0gPGludGVyZmFjZXMuSlZNT3B0aW9ucz4gdXRpbC5tZXJnZShKVk0uZ2V0RGVmYXVsdE9wdGlvbnMob3B0cy5kb3BwaW9Ib21lUGF0aCksIG9wdHMpO1xuXG4gICAgdmFyIGJvb3RzdHJhcENsYXNzcGF0aDogc3RyaW5nW10gPSBvcHRzLmJvb3RzdHJhcENsYXNzcGF0aC5tYXAoKHA6IHN0cmluZyk6IHN0cmluZyA9PiBwYXRoLnJlc29sdmUocCkpLFxuICAgICAgLy8gSlZNIGJvb3R1cCB0YXNrcywgZnJvbSBmaXJzdCB0byBsYXN0IHRhc2suXG4gICAgICBib290dXBUYXNrczogeyhuZXh0OiAoZXJyPzogYW55KSA9PiB2b2lkKTogdm9pZH1bXSA9IFtdLFxuICAgICAgZmlyc3RUaHJlYWQ6IEpWTVRocmVhZCxcbiAgICAgIGZpcnN0VGhyZWFkT2JqOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyZWFkO1xuXG4gICAgLy8gU2FuaXR5IGNoZWNrcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5ib290c3RyYXBDbGFzc3BhdGgpIHx8IG9wdHMuYm9vdHN0cmFwQ2xhc3NwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdHMuYm9vdHN0cmFwQ2xhc3NwYXRoIG11c3QgYmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mIGZpbGUgcGF0aHMuXCIpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5jbGFzc3BhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0cy5jbGFzc3BhdGggbXVzdCBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2YgZmlsZSBwYXRocy5cIik7XG4gICAgfVxuICAgIGlmKHR5cGVvZihvcHRzLmphdmFIb21lUGF0aCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0cy5qYXZhSG9tZVBhdGggbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5uYXRpdmVDbGFzc3BhdGgpIHx8IG9wdHMubmF0aXZlQ2xhc3NwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdHMubmF0aXZlQ2xhc3NwYXRoIG11c3QgYmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mIGZpbGUgcGF0aHMuXCIpO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ2xhc3NwYXRoID0gb3B0cy5uYXRpdmVDbGFzc3BhdGg7XG4gICAgaWYgKG9wdHMuZW5hYmxlU3lzdGVtQXNzZXJ0aW9ucykge1xuICAgICAgdGhpcy5lbmFibGVTeXN0ZW1Bc3NlcnRpb25zID0gb3B0cy5lbmFibGVTeXN0ZW1Bc3NlcnRpb25zO1xuICAgIH1cbiAgICBpZiAob3B0cy5lbmFibGVBc3NlcnRpb25zKSB7XG4gICAgICB0aGlzLmVuYWJsZWRBc3NlcnRpb25zID0gb3B0cy5lbmFibGVBc3NlcnRpb25zO1xuICAgIH1cbiAgICBpZiAob3B0cy5kaXNhYmxlQXNzZXJ0aW9ucykge1xuICAgICAgdGhpcy5kaXNhYmxlZEFzc2VydGlvbnMgPSBvcHRzLmRpc2FibGVBc3NlcnRpb25zO1xuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2l2ZW5lc3MgPSBvcHRzLnJlc3BvbnNpdmVuZXNzO1xuXG4gICAgdGhpcy5faW5pdFN5c3RlbVByb3BlcnRpZXMoYm9vdHN0cmFwQ2xhc3NwYXRoLFxuICAgICAgb3B0cy5jbGFzc3BhdGgubWFwKChwOiBzdHJpbmcpOiBzdHJpbmcgPT4gcGF0aC5yZXNvbHZlKHApKSxcbiAgICAgIHBhdGgucmVzb2x2ZShvcHRzLmphdmFIb21lUGF0aCksXG4gICAgICBwYXRoLnJlc29sdmUob3B0cy50bXBEaXIpLFxuICAgICAgb3B0cy5wcm9wZXJ0aWVzKTtcblxuICAgIC8qKlxuICAgICAqIFRhc2sgIzE6IEluaXRpYWxpemUgbmF0aXZlIG1ldGhvZHMuXG4gICAgICovXG4gICAgYm9vdHVwVGFza3MucHVzaCgobmV4dDogKGVycj86IGFueSkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplTmF0aXZlcyhuZXh0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRhc2sgIzI6IENvbnN0cnVjdCB0aGUgYm9vdHN0cmFwIGNsYXNzIGxvYWRlci5cbiAgICAgKi9cbiAgICBib290dXBUYXNrcy5wdXNoKChuZXh0OiAoZXJyPzogYW55KSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLmJzQ2wgPVxuICAgICAgICBuZXcgQ2xhc3NMb2FkZXIuQm9vdHN0cmFwQ2xhc3NMb2FkZXIodGhpcy5zeXN0ZW1Qcm9wZXJ0aWVzWydqYXZhLmhvbWUnXSwgYm9vdHN0cmFwQ2xhc3NwYXRoLCBuZXh0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRhc2sgIzM6IENvbnN0cnVjdCB0aGUgdGhyZWFkIHBvb2wsIHJlc29sdmUgdGhyZWFkIGNsYXNzLCBhbmQgY29uc3RydWN0XG4gICAgICogdGhlIGZpcnN0IHRocmVhZC5cbiAgICAgKi9cbiAgICBib290dXBUYXNrcy5wdXNoKChuZXh0OiAoZXJyPzogYW55KSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICB0aGlzLnRocmVhZFBvb2wgPSBuZXcgVGhyZWFkUG9vbDxKVk1UaHJlYWQ+KCgpOiBib29sZWFuID0+IHsgcmV0dXJuIHRoaXMudGhyZWFkUG9vbElzRW1wdHkoKTsgfSk7XG4gICAgICAvLyBSZXNvbHZlIExqYXZhL2xhbmcvVGhyZWFkIHNvIHdlIGNhbiBmYWtlIGEgdGhyZWFkLlxuICAgICAgLy8gTk9URTogVGhpcyBzaG91bGQgbmV2ZXIgYWN0dWFsbHkgdXNlIHRoZSBUaHJlYWQgb2JqZWN0IHVubGVzc1xuICAgICAgLy8gdGhlcmUncyBhbiBlcnJvciBsb2FkaW5nIGphdmEvbGFuZy9UaHJlYWQgYW5kIGFzc29jaWF0ZWQgY2xhc3Nlcy5cbiAgICAgIHRoaXMuYnNDbC5yZXNvbHZlQ2xhc3MobnVsbCwgJ0xqYXZhL2xhbmcvVGhyZWFkOycsICh0aHJlYWRDZGF0YTogUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19UaHJlYWQ+KSA9PiB7XG4gICAgICAgIGlmICh0aHJlYWRDZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gRmFpbGVkLlxuICAgICAgICAgIG5leHQoXCJGYWlsZWQgdG8gcmVzb2x2ZSBqYXZhL2xhbmcvVGhyZWFkLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSB0aHJlYWQuXG4gICAgICAgICAgZmlyc3RUaHJlYWRPYmogPSBuZXcgKHRocmVhZENkYXRhLmdldENvbnN0cnVjdG9yKG51bGwpKShudWxsKTtcbiAgICAgICAgICBmaXJzdFRocmVhZE9iai4kdGhyZWFkID0gZmlyc3RUaHJlYWQgPSB0aGlzLmZpcnN0VGhyZWFkID0gbmV3IEpWTVRocmVhZCh0aGlzLCB0aGlzLnRocmVhZFBvb2wsIGZpcnN0VGhyZWFkT2JqKTtcbiAgICAgICAgICBmaXJzdFRocmVhZE9iai5yZWYgPSAxO1xuICAgICAgICAgIGZpcnN0VGhyZWFkT2JqWydqYXZhL2xhbmcvVGhyZWFkL3ByaW9yaXR5J10gPSA1O1xuICAgICAgICAgIGZpcnN0VGhyZWFkT2JqWydqYXZhL2xhbmcvVGhyZWFkL25hbWUnXSA9IHV0aWwuaW5pdENhcnIodGhpcy5ic0NsLCAnbWFpbicpO1xuICAgICAgICAgIGZpcnN0VGhyZWFkT2JqWydqYXZhL2xhbmcvVGhyZWFkL2Jsb2NrZXJMb2NrJ10gPSBuZXcgKCg8UmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+PiB0aGlzLmJzQ2wuZ2V0UmVzb2x2ZWRDbGFzcygnTGphdmEvbGFuZy9PYmplY3Q7JykpLmdldENvbnN0cnVjdG9yKGZpcnN0VGhyZWFkKSkoZmlyc3RUaHJlYWQpO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUYXNrICM0OiBQcmVpbml0aWFsaXplIHNvbWUgZXNzZW50aWFsIEpWTSBjbGFzc2VzLCBhbmQgaW5pdGlhbGl6ZXMgdGhlXG4gICAgICogSlZNJ3MgVGhyZWFkR3JvdXAgb25jZSB0aGF0IGNsYXNzIGlzIGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIGJvb3R1cFRhc2tzLnB1c2goKG5leHQ6IChlcnI/OiBhbnkpID0+IHZvaWQpOiB2b2lkID0+IHtcbiAgICAgIHV0aWwuYXN5bmNGb3JFYWNoPHN0cmluZz4oY29yZUNsYXNzZXMsIChjb3JlQ2xhc3M6IHN0cmluZywgbmV4dEl0ZW06IChlcnI/OiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgICAgdGhpcy5ic0NsLmluaXRpYWxpemVDbGFzcyhmaXJzdFRocmVhZCwgY29yZUNsYXNzLCAoY2RhdGE6IENsYXNzRGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChjZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXh0SXRlbShgRmFpbGVkIHRvIGluaXRpYWxpemUgJHtjb3JlQ2xhc3N9YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9uZSBvZiB0aGUgbGF0ZXIgcHJlaW5pdGlhbGl6ZWQgY2xhc3NlcyByZWZlcmVuY2VzIFRocmVhZC5ncm91cC5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHN5c3RlbSdzIFRocmVhZEdyb3VwIG5vdy5cbiAgICAgICAgICAgIGlmIChjb3JlQ2xhc3MgPT09ICdMamF2YS9sYW5nL1RocmVhZEdyb3VwOycpIHtcbiAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGEgVGhyZWFkR3JvdXAgb2JqZWN0IGZvciB0aGUgZmlyc3QgdGhyZWFkLlxuICAgICAgICAgICAgICB2YXIgdGhyZWFkR3JvdXBDb25zID0gKDxSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX1RocmVhZEdyb3VwPj4gY2RhdGEpLmdldENvbnN0cnVjdG9yKGZpcnN0VGhyZWFkKSxcbiAgICAgICAgICAgICAgICBncm91cE9iaiA9IG5ldyB0aHJlYWRHcm91cENvbnMoZmlyc3RUaHJlYWQpO1xuICAgICAgICAgICAgICBncm91cE9ialsnPGluaXQ+KClWJ10oZmlyc3RUaHJlYWQsIG51bGwsIChlPzogSlZNVHlwZXMuamF2YV9sYW5nX1Rocm93YWJsZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGluaXRpYWwgdGhyZWFkIHRvIHVzZSB0aGlzIGdyb3VwLlxuICAgICAgICAgICAgICAgIGZpcnN0VGhyZWFkT2JqWydqYXZhL2xhbmcvVGhyZWFkL2dyb3VwJ10gPSBncm91cE9iajtcbiAgICAgICAgICAgICAgICBuZXh0SXRlbShlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0SXRlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBuZXh0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRhc2sgIzU6IEluaXRpYWxpemUgdGhlIHN5c3RlbSBjbGFzcy5cbiAgICAgKi9cbiAgICBib290dXBUYXNrcy5wdXNoKChuZXh0OiAoZXJyPzogYW55KSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBzeXN0ZW0gY2xhc3MgKGluaXRpYWxpemVzIHRoaW5ncyBsaWtlIHByaW50bG4vZXRjKS5cbiAgICAgIHZhciBzeXNJbml0ID0gPHR5cGVvZiBKVk1UeXBlcy5qYXZhX2xhbmdfU3lzdGVtPiAoPFJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfU3lzdGVtPj4gdGhpcy5ic0NsLmdldEluaXRpYWxpemVkQ2xhc3MoZmlyc3RUaHJlYWQsICdMamF2YS9sYW5nL1N5c3RlbTsnKSkuZ2V0Q29uc3RydWN0b3IoZmlyc3RUaHJlYWQpO1xuICAgICAgc3lzSW5pdFsnamF2YS9sYW5nL1N5c3RlbS9pbml0aWFsaXplU3lzdGVtQ2xhc3MoKVYnXShmaXJzdFRocmVhZCwgbnVsbCwgbmV4dCk7O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGFzayAjNjogSW5pdGlhbGl6ZSB0aGUgYXBwbGljYXRpb24ncyBjbGFzc2xvYWRlci5cbiAgICAgKi9cbiAgICBib290dXBUYXNrcy5wdXNoKChuZXh0OiAoZXJyPzogYW55KSA9PiB2b2lkKSA9PiB7XG4gICAgICB2YXIgY2xDb25zID0gPHR5cGVvZiBKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3NMb2FkZXI+ICg8UmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzc0xvYWRlcj4+IHRoaXMuYnNDbC5nZXRJbml0aWFsaXplZENsYXNzKGZpcnN0VGhyZWFkLCAnTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsnKSkuZ2V0Q29uc3RydWN0b3IoZmlyc3RUaHJlYWQpO1xuICAgICAgY2xDb25zWydqYXZhL2xhbmcvQ2xhc3NMb2FkZXIvZ2V0U3lzdGVtQ2xhc3NMb2FkZXIoKUxqYXZhL2xhbmcvQ2xhc3NMb2FkZXI7J10oZmlyc3RUaHJlYWQsIG51bGwsIChlPzogSlZNVHlwZXMuamF2YV9sYW5nX1Rocm93YWJsZSwgcnY/OiBKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3NMb2FkZXIpID0+IHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBuZXh0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3lzdGVtQ2xhc3NMb2FkZXIgPSBydi4kbG9hZGVyO1xuICAgICAgICAgIGZpcnN0VGhyZWFkT2JqWydqYXZhL2xhbmcvVGhyZWFkL2NvbnRleHRDbGFzc0xvYWRlciddID0gcnY7XG5cbiAgICAgICAgICAvLyBJbml0aWFsaXplIGFzc2VydGlvbiBkYXRhLlxuICAgICAgICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBmb3JjZSB0aGlzPyA6fFxuICAgICAgICAgIGxldCBkZWZhdWx0QXNzZXJ0aW9uU3RhdHVzID0gdGhpcy5lbmFibGVkQXNzZXJ0aW9ucyA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgICAgICAgIHJ2WydqYXZhL2xhbmcvQ2xhc3NMb2FkZXIvc2V0RGVmYXVsdEFzc2VydGlvblN0YXR1cyhaKVYnXShmaXJzdFRocmVhZCwgW2RlZmF1bHRBc3NlcnRpb25TdGF0dXNdLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBQZXJmb3JtIGJvb3R1cCB0YXNrcywgYW5kIHRoZW4gdHJpZ2dlciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgdXRpbC5hc3luY1Nlcmllcyhib290dXBUYXNrcywgKGVycj86IGFueSk6IHZvaWQgPT4ge1xuICAgICAgLy8gWFhYOiBXaXRob3V0IHNldEltbWVkaWF0ZSwgdGhlIGZpcnN0VGhyZWFkIHdvbid0IGNsZWFyIG91dCB0aGUgc3RhY2tcbiAgICAgIC8vIGZyYW1lIHRoYXQgdHJpZ2dlcmVkIHVzLCBhbmQgdGhlIGZpcnN0VGhyZWFkIHdvbid0IHRyYW5zaXRpb24gdG8gYVxuICAgICAgLy8gJ3Rlcm1pbmF0ZWQnIHN0YXR1cy5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IEpWTVN0YXR1cy5URVJNSU5BVEVEO1xuICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBKVk1TdGF0dXMuQk9PVEVEO1xuICAgICAgICAgIGNiKG51bGwsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZXNwb25zaXZlbmVzcygpOm51bWJlciB7XG4gICAgY29uc3QgcmVzcCA9IHRoaXMucmVzcG9uc2l2ZW5lc3M7XG4gICAgaWYgKHR5cGVvZiByZXNwID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJlc3AoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldERlZmF1bHRPcHRpb25zKGRvcHBpb0hvbWU6IHN0cmluZyk6IGludGVyZmFjZXMuSlZNT3B0aW9ucyB7XG4gICAgbGV0IGphdmFIb21lID0gcGF0aC5qb2luKGRvcHBpb0hvbWUsICd2ZW5kb3InLCAnamF2YV9ob21lJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvcHBpb0hvbWVQYXRoOiBkb3BwaW9Ib21lLFxuICAgICAgY2xhc3NwYXRoOiBbJy4nXSxcbiAgICAgIGJvb3RzdHJhcENsYXNzcGF0aDogSkRLSW5mby5jbGFzc3BhdGgubWFwKChpdGVtKSA9PiBwYXRoLmpvaW4oamF2YUhvbWUsIGl0ZW0pKSxcbiAgICAgIGphdmFIb21lUGF0aDogamF2YUhvbWUsXG4gICAgICBuYXRpdmVDbGFzc3BhdGg6IFtwYXRoLmpvaW4oZG9wcGlvSG9tZSwgJ25hdGl2ZXMnKV0sXG4gICAgICBlbmFibGVTeXN0ZW1Bc3NlcnRpb25zOiBmYWxzZSxcbiAgICAgIGVuYWJsZUFzc2VydGlvbnM6IGZhbHNlLFxuICAgICAgZGlzYWJsZUFzc2VydGlvbnM6IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIHRtcERpcjogJy90bXAnLFxuICAgICAgcmVzcG9uc2l2ZW5lc3M6IDEwMDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVJMIHRvIHRoZSB2ZXJzaW9uIG9mIHRoZSBKREsgdGhhdCBEb3BwaW9KVk0gd2FzIGNvbXBpbGVkIHdpdGguXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldENvbXBpbGVkSkRLVVJMKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEpES0luZm8udXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSkRLIGluZm9ybWF0aW9uIHRoYXQgRG9wcGlvSlZNIHdhcyBjb21waWxlZCBhZ2FpbnN0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRKREtJbmZvKCk6IGFueSB7XG4gICAgcmV0dXJuIEpES0luZm87XG4gIH1cblxuICBwdWJsaWMgZ2V0U3lzdGVtQ2xhc3NMb2FkZXIoKTogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIge1xuICAgIHJldHVybiB0aGlzLnN5c3RlbUNsYXNzTG9hZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpc1JlbGVhc2VCdWlsZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mKFJFTEVBU0UpICE9PSAndW5kZWZpbmVkJyAmJiBSRUxFQVNFO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBcInJlZlwiIG51bWJlciBmb3IgSlZNIG9iamVjdHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0TmV4dFJlZigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm5leHRSZWYrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgSlZNJ3MgcGFya2VyLiBIYW5kbGVzIHBhcmtpbmcvdW5wYXJraW5nIHRocmVhZHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFya2VyKCk6IFBhcmtlciB7XG4gICAgcmV0dXJuIHRoaXMucGFya2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgc3BlY2lmaWVkIGNsYXNzIG9uIHRoaXMgSlZNIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gY2xhc3NOYW1lIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBydW4uIENhbiBiZSBzcGVjaWZpZWQgaW4gZWl0aGVyXG4gICAqICAgZm9vLmJhci5CYXogb3IgZm9vL2Jhci9CYXogZm9ybWF0LlxuICAgKiBAcGFyYW0gYXJncyBDb21tYW5kIGxpbmUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2xhc3MuXG4gICAqIEBwYXJhbSBjYiBDYWxsZWQgd2hlbiB0aGUgSlZNIGZpbmlzaGVzIGV4ZWN1dGluZy4gQ2FsbGVkIHdpdGggJ3RydWUnIGlmXG4gICAqICAgdGhlIEpWTSBleGl0ZWQgbm9ybWFsbHksICdmYWxzZScgaWYgdGhlcmUgd2FzIGFuIGVycm9yLlxuICAgKi9cbiAgcHVibGljIHJ1bkNsYXNzKGNsYXNzTmFtZTogc3RyaW5nLCBhcmdzOiBzdHJpbmdbXSwgY2I6IChjb2RlOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEpWTVN0YXR1cy5CT09URUQpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBKVk1TdGF0dXMuQk9PVElORzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEpWTSBpcyBjdXJyZW50bHkgYm9vdGluZyB1cC4gUGxlYXNlIHdhaXQgZm9yIGl0IHRvIGNhbGwgdGhlIGJvb3R1cCBjYWxsYmFjaywgd2hpY2ggeW91IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuYCk7XG4gICAgICAgIGNhc2UgSlZNU3RhdHVzLlJVTk5JTkc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBKVk0gaXMgYWxyZWFkeSBydW5uaW5nLmApO1xuICAgICAgICBjYXNlIEpWTVN0YXR1cy5URVJNSU5BVEVEOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBKVk0gaGFzIGFscmVhZHkgdGVybWluYXRlZC4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBKVk0uYCk7XG4gICAgICAgIGNhc2UgSlZNU3RhdHVzLlRFUk1JTkFUSU5HOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBKVk0gaXMgY3VycmVudGx5IHRlcm1pbmF0aW5nLiBZb3Ugc2hvdWxkIGNyZWF0ZSBhIG5ldyBKVk0gZm9yIGVhY2ggY2xhc3MgeW91IHdpc2ggdG8gcnVuLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRlcm1pbmF0aW9uQ2IgPSBjYjtcblxuICAgIHZhciB0aHJlYWQgPSB0aGlzLmZpcnN0VGhyZWFkO1xuICAgIGFzc2VydCh0aHJlYWQgIT0gbnVsbCwgYFRocmVhZCBpc24ndCBjcmVhdGVkIHlldD9gKTtcbiAgICAvLyBDb252ZXJ0IGZvby5iYXIuQmF6ID0+IExmb28vYmFyL0JhejtcbiAgICBjbGFzc05hbWUgPSB1dGlsLmludF9jbGFzc25hbWUoY2xhc3NOYW1lKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGNsYXNzLlxuICAgIHRoaXMuc3lzdGVtQ2xhc3NMb2FkZXIuaW5pdGlhbGl6ZUNsYXNzKHRocmVhZCwgY2xhc3NOYW1lLCAoY2RhdGE6IFJlZmVyZW5jZUNsYXNzRGF0YTxhbnk+KSA9PiB7XG4gICAgICAvLyBJZiBjZGF0YSBpcyBudWxsLCB0aGVyZSB3YXMgYW4gZXJyb3IgdGhhdCBlbmRlZCBleGVjdXRpb24uXG4gICAgICBpZiAoY2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciBzdHJBcnJDb25zID0gKDxBcnJheUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfU3RyaW5nPj4gdGhpcy5ic0NsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnW0xqYXZhL2xhbmcvU3RyaW5nOycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpLFxuICAgICAgICAgIGp2bWlmaWVkQXJncyA9IG5ldyBzdHJBcnJDb25zKHRocmVhZCwgYXJncy5sZW5ndGgpLCBpOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBqdm1pZmllZEFyZ3MuYXJyYXlbaV0gPSB1dGlsLmluaXRTdHJpbmcodGhpcy5ic0NsLCBhcmdzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIG1haW4gbWV0aG9kLCBhbmQgcnVuIGl0LlxuICAgICAgICB0aGlzLnN0YXR1cyA9IEpWTVN0YXR1cy5SVU5OSU5HO1xuICAgICAgICB2YXIgY2RhdGFTdGF0aWNzID0gPGFueT4gY2RhdGEuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcbiAgICAgICAgaWYgKGNkYXRhU3RhdGljc1snbWFpbihbTGphdmEvbGFuZy9TdHJpbmc7KVYnXSkge1xuICAgICAgICAgIGNkYXRhU3RhdGljc1snbWFpbihbTGphdmEvbGFuZy9TdHJpbmc7KVYnXSh0aHJlYWQsIFtqdm1pZmllZEFyZ3NdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oXCJMamF2YS9sYW5nL05vU3VjaE1ldGhvZEVycm9yO1wiLCBgQ291bGQgbm90IGZpbmQgbWFpbiBtZXRob2QgaW4gY2xhc3MgJHtjZGF0YS5nZXRFeHRlcm5hbE5hbWUoKX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBFcnJvcjogQ291bGQgbm90IGZpbmQgb3IgbG9hZCBtYWluIGNsYXNzICR7dXRpbC5leHRfY2xhc3NuYW1lKGNsYXNzTmFtZSl9XFxuYCk7XG4gICAgICAgIC8vIEVycm9uZW91cyBleGl0LlxuICAgICAgICB0aGlzLnRlcm1pbmF0aW9uQ2IoMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogW0RFQlVHXSBSZXR1cm5zICd0cnVlJyBpZiB0aGUgc3BlY2lmaWVkIG1ldGhvZCBzaG91bGQgYmUgdnRyYWNlZC5cbiAgICovXG4gIHB1YmxpYyBzaG91bGRWdHJhY2Uoc2lnOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52dHJhY2VNZXRob2RzW3NpZ10gPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogW0RFQlVHXSBTcGVjaWZ5IGEgbWV0aG9kIHRvIHZ0cmFjZS5cbiAgICovXG4gIHB1YmxpYyB2dHJhY2VNZXRob2Qoc2lnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnZ0cmFjZU1ldGhvZHNbc2lnXSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRoZSBzcGVjaWZpZWQgSkFSIGZpbGUgb24gdGhpcyBKVk0gaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBhcmdzIENvbW1hbmQgbGluZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjbGFzcy5cbiAgICogQHBhcmFtIGNiIENhbGxlZCB3aGVuIHRoZSBKVk0gZmluaXNoZXMgZXhlY3V0aW5nLiBDYWxsZWQgd2l0aCAndHJ1ZScgaWZcbiAgICogICB0aGUgSlZNIGV4aXRlZCBub3JtYWxseSwgJ2ZhbHNlJyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgcnVuSmFyKGFyZ3M6IHN0cmluZ1tdLCBjYjogKGNvZGU6IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMucnVuQ2xhc3MoJ2RvcHBpby5KYXJMYXVuY2hlcicsIGFyZ3MsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgVGhyZWFkUG9vbCBpcyBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgdGhyZWFkUG9vbElzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgdmFyIHN5c3RlbUNsYXNzOiBSZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX1N5c3RlbT4sXG4gICAgICBzeXN0ZW1Db25zOiB0eXBlb2YgSlZNVHlwZXMuamF2YV9sYW5nX1N5c3RlbTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICBjYXNlIEpWTVN0YXR1cy5CT09USU5HOlxuICAgICAgICAvLyBJZ25vcmUgZW1wdHkgdGhyZWFkIHBvb2xzIGR1cmluZyBib290IHByb2Nlc3MuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgSlZNU3RhdHVzLkJPT1RFRDpcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgVGhyZWFkIHBvb2wgc2hvdWxkIG5vdCBiZWNvbWUgZW1wdHkgYWZ0ZXIgSlZNIGlzIGJvb3RlZCwgYnV0IGJlZm9yZSBpdCBiZWdpbnMgdG8gcnVuLmApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIEpWTVN0YXR1cy5SVU5OSU5HOlxuICAgICAgICB0aGlzLnN0YXR1cyA9IEpWTVN0YXR1cy5URVJNSU5BVElORztcbiAgICAgICAgc3lzdGVtQ2xhc3MgPSA8YW55PiB0aGlzLmJzQ2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aGlzLmZpcnN0VGhyZWFkLCAnTGphdmEvbGFuZy9TeXN0ZW07Jyk7XG4gICAgICAgIGFzc2VydChzeXN0ZW1DbGFzcyAhPT0gbnVsbCwgYEludmFyaWFudCBmYWlsdXJlOiBTeXN0ZW0gY2xhc3MgbXVzdCBiZSBpbml0aWFsaXplZCB3aGVuIEpWTSBpcyBpbiBSVU5OSU5HIHN0YXRlLmApO1xuICAgICAgICBzeXN0ZW1Db25zID0gPGFueT4gc3lzdGVtQ2xhc3MuZ2V0Q29uc3RydWN0b3IodGhpcy5maXJzdFRocmVhZCk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBub3JtYWwsIG5vbi1lcnJvbmVvdXMgZXhpdC4gV2hlbiB0aGlzIGZ1bmN0aW9uIGNvbXBsZXRlcywgdGhyZWFkUG9vbElzRW1wdHkoKSB3aWxsIGJlIGludm9rZWQgYWdhaW4uXG4gICAgICAgIHN5c3RlbUNvbnNbJ2phdmEvbGFuZy9TeXN0ZW0vZXhpdChJKVYnXSh0aGlzLmZpcnN0VGhyZWFkLCBbMF0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIEpWTVN0YXR1cy5URVJNSU5BVEVEOlxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBJbnZhcmlhbnQgZmFpbHVyZTogVGhyZWFkIHBvb2wgY2Fubm90IGJlIGVtcHRpZWQgcG9zdC1KVk0gdGVybWluYXRpb24uYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgSlZNU3RhdHVzLlRFUk1JTkFUSU5HOlxuICAgICAgICB0aGlzLnN0YXR1cyA9IEpWTVN0YXR1cy5URVJNSU5BVEVEO1xuICAgICAgICBpZiAodGhpcy50ZXJtaW5hdGlvbkNiKSB7XG4gICAgICAgICAgdGhpcy50ZXJtaW5hdGlvbkNiKHRoaXMuZXhpdENvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3RUaHJlYWQuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBKVk0gaGFzIHN0YXJ0ZWQgcnVubmluZyB0aGUgbWFpbiBjbGFzcy5cbiAgICovXG4gIHB1YmxpYyBoYXNWTUJvb3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISh0aGlzLnN0YXR1cyA9PT0gSlZNU3RhdHVzLkJPT1RJTkcgfHwgdGhpcy5zdGF0dXMgPT09IEpWTVN0YXR1cy5CT09URUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlbHkgaGFsdCB0aGUgSlZNLlxuICAgKi9cbiAgcHVibGljIGhhbHQoc3RhdHVzOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmV4aXRDb2RlID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzID0gSlZNU3RhdHVzLlRFUk1JTkFUSU5HO1xuICAgIHRoaXMudGhyZWFkUG9vbC5nZXRUaHJlYWRzKCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5zZXRTdGF0dXMoVGhyZWFkU3RhdHVzLlRFUk1JTkFURUQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBnaXZlbiBzeXN0ZW0gcHJvcGVydHkuXG4gICAqL1xuICBwdWJsaWMgZ2V0U3lzdGVtUHJvcGVydHkocHJvcDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zeXN0ZW1Qcm9wZXJ0aWVzW3Byb3BdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgc3lzdGVtIHByb3BlcnR5IG5hbWVzLlxuICAgKi9cbiAgcHVibGljIGdldFN5c3RlbVByb3BlcnR5TmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN5c3RlbVByb3BlcnRpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSB1bm1hbmFnZWQgaGVhcC5cbiAgICovXG4gIHB1YmxpYyBnZXRIZWFwKCk6IEhlYXAge1xuICAgIHJldHVybiB0aGlzLmhlYXA7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJucyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBzdHJpbmcuIFJldHVybnMgdGhlIGludGVybmVkIHN0cmluZy5cbiAgICovXG4gIHB1YmxpYyBpbnRlcm5TdHJpbmcoc3RyOiBzdHJpbmcsIGphdmFPYmo/OiBKVk1UeXBlcy5qYXZhX2xhbmdfU3RyaW5nKTogSlZNVHlwZXMuamF2YV9sYW5nX1N0cmluZyB7XG4gICAgaWYgKHRoaXMuaW50ZXJuZWRTdHJpbmdzLmhhcyhzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcm5lZFN0cmluZ3MuZ2V0KHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghamF2YU9iaikge1xuICAgICAgICBqYXZhT2JqID0gdXRpbC5pbml0U3RyaW5nKHRoaXMuYnNDbCwgc3RyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW50ZXJuZWRTdHJpbmdzLnNldChzdHIsIGphdmFPYmopO1xuICAgICAgcmV0dXJuIGphdmFPYmo7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIG5hdGl2ZSBtb2R1bGVzLiBFbXVsYXRlcyBDb21tb25KUyBmdW5jdGlvbmFsaXR5LlxuICAgKi9cbiAgcHJpdmF0ZSBldmFsTmF0aXZlTW9kdWxlKG1vZDogc3RyaW5nKTogYW55IHtcbiAgICBcInVzZSBzdHJpY3RcIjsgLy8gUHJldmVudCBldmFsIGZyb20gYmVpbmcgdGVycmlibGUuXG4gICAgdmFyIHJ2OiBhbnksXG4gICAgICAvLyBQcm92aWRlIHRoZSBuYXRpdmVzIHdpdGggdGhlIERvcHBpbyBBUEksIGlmIG5lZWRlZC5cbiAgICAgIERvcHBpb0pWTSA9IHJlcXVpcmUoJy4vZG9wcGlvanZtJyksXG4gICAgICBCdWZmZXIgPSAoPGFueT4gYnVmZmVyKS5CdWZmZXIsXG4gICAgICBwcm9jZXNzMiA9IHByb2Nlc3MsXG4gICAgICBzYXZlZFJlcXVpcmUgPSB0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlIDogZnVuY3Rpb24obW9kdWxlTmFtZTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBtb2R1bGUgJHttb2R1bGVOYW1lfWApO1xuICAgICAgfTtcbiAgICAoKCkgPT4ge1xuICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCBieSB0aGUgbmF0aXZlIG1ldGhvZCBmaWxlLiBSZWdpc3RlcnMgdGhlIHBhY2thZ2UncyBuYXRpdmVcbiAgICAgICAqIG1ldGhvZHMgd2l0aCB0aGUgSlZNLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiByZWdpc3Rlck5hdGl2ZXMoZGVmczogYW55KTogdm9pZCB7XG4gICAgICAgIHJ2ID0gZGVmcztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRW11bGF0ZXMgQ29tbW9uSlMgcmVxdWlyZSgpLlxuICAgICAgICogUGxhY2VkIGludG8gYW4gZXZhbCgpIGNhbGwgdG8gYXZvaWQgYnJvd3NlcmlmeS1kZXJlcSBmcm9tXG4gICAgICAgKiBmdWNraW5nIHJlbmFtaW5nIHRoZSBnb2RkYW1uIHRoaW5nIHRvIF9kZXJlcV8uXG4gICAgICAgKi9cbiAgICAgIGV2YWwoYFxudmFyIHByb2Nlc3MgPSBwcm9jZXNzMjtcbmZ1bmN0aW9uIHJlcXVpcmUobmFtZSkge1xuICBzd2l0Y2gobmFtZSkge1xuICAgIGNhc2UgJ2RvcHBpb2p2bSc6XG4gICAgY2FzZSAnLi4vZG9wcGlvanZtJzpcbiAgICAgIHJldHVybiBEb3BwaW9KVk07XG4gICAgY2FzZSAnZnMnOlxuICAgICAgcmV0dXJuIGZzO1xuICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgY2FzZSAnYnJvd3NlcmZzJzpcbiAgICAgIHJldHVybiBCcm93c2VyRlM7XG4gICAgY2FzZSAncGFrby9saWIvemxpYi96c3RyZWFtJzpcbiAgICAgIHJldHVybiB6c3RyZWFtO1xuICAgIGNhc2UgJ3Bha28vbGliL3psaWIvaW5mbGF0ZSc6XG4gICAgICByZXR1cm4gaW5mbGF0ZTtcbiAgICBjYXNlICdwYWtvL2xpYi96bGliL2RlZmxhdGUnOlxuICAgICAgcmV0dXJuIGRlZmxhdGU7XG4gICAgY2FzZSAncGFrby9saWIvemxpYi9jcmMzMic6XG4gICAgICByZXR1cm4gY3JjMzI7XG4gICAgY2FzZSAncGFrby9saWIvemxpYi9hZGxlcjMyJzpcbiAgICAgIHJldHVybiBhZGxlcjMyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc2F2ZWRSZXF1aXJlKG5hbWUpO1xuICB9XG59XG4vKipcbiAqIEVtdWxhdGUgQU1EIG1vZHVsZSAnZGVmaW5lJyBmdW5jdGlvbiBmb3IgbmF0aXZlcyBjb21waWxlZCBhcyBBTUQgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKHJlc291cmNlcywgbW9kdWxlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgc3dpdGNoIChyZXNvdXJjZSkge1xuICAgICAgY2FzZSAncmVxdWlyZSc6XG4gICAgICAgIGFyZ3MucHVzaChyZXF1aXJlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdleHBvcnRzJzpcbiAgICAgICAgYXJncy5wdXNoKHt9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzLnB1c2gocmVxdWlyZShyZXNvdXJjZSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICBtb2R1bGUuYXBwbHkobnVsbCwgYXJncyk7XG59XG5ldmFsKG1vZCk7XG5gKTtcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG4gICAgfSkoKTtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgbmF0aXZlIG1ldGhvZHMgd2l0aCB0aGUgdmlydHVhbCBtYWNoaW5lLlxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyTmF0aXZlcyhuZXdOYXRpdmVzOiB7IFtjbHNOYW1lOiBzdHJpbmddOiB7IFttZXRoU2lnOiBzdHJpbmddOiBGdW5jdGlvbiB9IH0pOiB2b2lkIHtcbiAgICB2YXIgY2xzTmFtZTogc3RyaW5nLCBtZXRoU2lnOiBzdHJpbmc7XG4gICAgZm9yIChjbHNOYW1lIGluIG5ld05hdGl2ZXMpIHtcbiAgICAgIGlmIChuZXdOYXRpdmVzLmhhc093blByb3BlcnR5KGNsc05hbWUpKSB7XG4gICAgICAgIGlmICghdGhpcy5uYXRpdmVzLmhhc093blByb3BlcnR5KGNsc05hbWUpKSB7XG4gICAgICAgICAgdGhpcy5uYXRpdmVzW2Nsc05hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsc01ldGhvZHMgPSBuZXdOYXRpdmVzW2Nsc05hbWVdO1xuICAgICAgICBmb3IgKG1ldGhTaWcgaW4gY2xzTWV0aG9kcykge1xuICAgICAgICAgIGlmIChjbHNNZXRob2RzLmhhc093blByb3BlcnR5KG1ldGhTaWcpKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjaGVjayBpZiBpdCBleGlzdHMgYWxyZWFkeS4gVGhpcyBhbGxvd3MgdXMgdG8gb3ZlcndyaXRlXG4gICAgICAgICAgICAvLyBuYXRpdmUgbWV0aG9kcyBkeW5hbWljYWxseSBhdCBydW50aW1lLlxuICAgICAgICAgICAgdGhpcy5uYXRpdmVzW2Nsc05hbWVdW21ldGhTaWddID0gY2xzTWV0aG9kc1ttZXRoU2lnXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24uIFJlZ2lzdGVyIGEgc2luZ2xlIG5hdGl2ZSBtZXRob2Qgd2l0aCB0aGUgdmlydHVhbFxuICAgKiBtYWNoaW5lLiBDYW4gYmUgdXNlZCB0byB1cGRhdGUgZXhpc3RpbmcgbmF0aXZlIG1ldGhvZHMgYmFzZWQgb24gcnVudGltZVxuICAgKiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHB1YmxpYyByZWdpc3Rlck5hdGl2ZShjbHNOYW1lOiBzdHJpbmcsIG1ldGhTaWc6IHN0cmluZywgbmF0aXZlOiBGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMucmVnaXN0ZXJOYXRpdmVzKHsgY2xzTmFtZTogeyBtZXRoU2lnOiBuYXRpdmUgfSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgbmF0aXZlIG1ldGhvZCBmb3IgdGhlIGdpdmVuIG1ldGhvZCBvZiB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIFJldHVybnMgbnVsbCBpZiBub25lIGZvdW5kLlxuICAgKi9cbiAgcHVibGljIGdldE5hdGl2ZShjbHNOYW1lOiBzdHJpbmcsIG1ldGhTaWc6IHN0cmluZyk6IEZ1bmN0aW9uIHtcbiAgICBjbHNOYW1lID0gdXRpbC5kZXNjcmlwdG9yMnR5cGVzdHIoY2xzTmFtZSk7XG4gICAgaWYgKHRoaXMubmF0aXZlcy5oYXNPd25Qcm9wZXJ0eShjbHNOYW1lKSkge1xuICAgICAgdmFyIGNsc01ldGhvZHMgPSB0aGlzLm5hdGl2ZXNbY2xzTmFtZV07XG4gICAgICBpZiAoY2xzTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShtZXRoU2lnKSkge1xuICAgICAgICByZXR1cm4gY2xzTWV0aG9kc1ttZXRoU2lnXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogISFETyBOT1QgTVVUQVRFIFRIRSBSRVRVUk5FRCBWQUxVRSEhXG4gICAqIFVzZWQgYnkgdGhlIGZpbmRfaW52YWxpZF9uYXRpdmVzIHRvb2wuXG4gICAqL1xuICBwdWJsaWMgZ2V0TmF0aXZlcygpOiB7IFtjbHNOYW1lOiBzdHJpbmddOiB7IFttZXRoU2lnOiBzdHJpbmddOiBGdW5jdGlvbiB9IH0ge1xuICAgIHJldHVybiB0aGlzLm5hdGl2ZXM7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgaW4gYWxsIG9mIHRoZSBuYXRpdmUgbWV0aG9kIG1vZHVsZXMgcHJpb3IgdG8gZXhlY3V0aW9uLlxuICAgKiBDdXJyZW50bHkgYSBoYWNrIGFyb3VuZCBvdXIgY2xhc3Nsb2FkZXIuXG4gICAqIEB0b2RvIE1ha2UgbmVhdGVyIHdpdGggdXRpbC5hc3luYyBzdHVmZi5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZU5hdGl2ZXMoZG9uZUNiOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdmFyIG5leHREaXIgPSAoKSA9PiB7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5uYXRpdmVDbGFzc3BhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5leHQgcGhhc2U6IExvYWQgdXAgdGhlIGZpbGVzLlxuICAgICAgICB2YXIgY291bnQ6IG51bWJlciA9IHByb2Nlc3NGaWxlcy5sZW5ndGg7XG4gICAgICAgIHByb2Nlc3NGaWxlcy5mb3JFYWNoKChmaWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBmcy5yZWFkRmlsZShmaWxlLCAoZXJyOiBhbnksIGRhdGE6IE5vZGVCdWZmZXIpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJOYXRpdmVzKHRoaXMuZXZhbE5hdGl2ZU1vZHVsZShkYXRhLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgtLWNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIGRvbmVDYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXIgPSB0aGlzLm5hdGl2ZUNsYXNzcGF0aFtpKytdO1xuICAgICAgICBmcy5yZWFkZGlyKGRpciwgKGVycjogYW55LCBmaWxlczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZUNiKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGo6IG51bWJlciwgZmlsZTogc3RyaW5nO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmaWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZmlsZSA9IGZpbGVzW2pdO1xuICAgICAgICAgICAgaWYgKGZpbGUuc3Vic3RyaW5nKGZpbGUubGVuZ3RoIC0gMywgZmlsZS5sZW5ndGgpID09PSAnLmpzJykge1xuICAgICAgICAgICAgICBwcm9jZXNzRmlsZXMucHVzaChwYXRoLmpvaW4oZGlyLCBmaWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHREaXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgaTogbnVtYmVyID0gMCwgcHJvY2Vzc0ZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgbmV4dERpcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtQcml2YXRlXSBTYW1lIGFzIHJlc2V0X3N5c3RlbV9wcm9wZXJ0aWVzLCBidXQgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHByaXZhdGUgX2luaXRTeXN0ZW1Qcm9wZXJ0aWVzKGJvb3RzdHJhcENsYXNzcGF0aDogc3RyaW5nW10sIGphdmFDbGFzc1BhdGg6IHN0cmluZ1tdLCBqYXZhSG9tZVBhdGg6IHN0cmluZywgdG1wRGlyOiBzdHJpbmcsIG9wdHM6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSk6IHZvaWQge1xuICAgIHRoaXMuc3lzdGVtUHJvcGVydGllcyA9IHV0aWwubWVyZ2Uoe1xuICAgICAgJ2phdmEuY2xhc3MucGF0aCc6IGphdmFDbGFzc1BhdGguam9pbignOicpLFxuICAgICAgJ2phdmEuaG9tZSc6IGphdmFIb21lUGF0aCxcbiAgICAgICdqYXZhLmV4dC5kaXJzJzogcGF0aC5qb2luKGphdmFIb21lUGF0aCwgJ2xpYicsICdleHQnKSxcbiAgICAgICdqYXZhLmlvLnRtcGRpcic6IHRtcERpcixcbiAgICAgICdzdW4uYm9vdC5jbGFzcy5wYXRoJzogYm9vdHN0cmFwQ2xhc3NwYXRoLmpvaW4oJzonKSxcbiAgICAgICdmaWxlLmVuY29kaW5nJzogJ1VURi04JyxcbiAgICAgICdqYXZhLnZlbmRvcic6ICdEb3BwaW8nLFxuICAgICAgJ2phdmEudmVyc2lvbic6ICcxLjgnLFxuICAgICAgJ2phdmEudmVuZG9yLnVybCc6ICdodHRwczovL2dpdGh1Yi5jb20vcGxhc21hLXVtYXNzL2RvcHBpbycsXG4gICAgICAnamF2YS5jbGFzcy52ZXJzaW9uJzogJzUyLjAnLFxuICAgICAgJ2phdmEuc3BlY2lmaWNhdGlvbi52ZXJzaW9uJzogJzEuOCcsXG4gICAgICAnbGluZS5zZXBhcmF0b3InOiAnXFxuJyxcbiAgICAgICdmaWxlLnNlcGFyYXRvcic6IHBhdGguc2VwLFxuICAgICAgJ3BhdGguc2VwYXJhdG9yJzogJzonLFxuICAgICAgJ3VzZXIuZGlyJzogcGF0aC5yZXNvbHZlKCcuJyksXG4gICAgICAndXNlci5ob21lJzogJy4nLFxuICAgICAgJ3VzZXIubmFtZSc6ICdEb3BwaW9Vc2VyJyxcbiAgICAgICdvcy5uYW1lJzogJ2RvcHBpbycsXG4gICAgICAnb3MuYXJjaCc6ICdqcycsXG4gICAgICAnb3MudmVyc2lvbic6ICcwJyxcbiAgICAgICdqYXZhLnZtLm5hbWUnOiAnRG9wcGlvSlZNIDMyLWJpdCBWTScsXG4gICAgICAnamF2YS52bS52ZXJzaW9uJzogcGtnLnZlcnNpb24sXG4gICAgICAnamF2YS52bS52ZW5kb3InOiAnUExBU01BQFVNYXNzJyxcbiAgICAgICdqYXZhLmF3dC5oZWFkbGVzcyc6ICh1dGlsLmFyZV9pbl9icm93c2VyKCkpLnRvU3RyaW5nKCksIC8vIHRydWUgaWYgd2UncmUgdXNpbmcgdGhlIGNvbnNvbGUgZnJvbnRlbmRcbiAgICAgICdqYXZhLmF3dC5ncmFwaGljc2Vudic6ICdjbGFzc2VzLmF3dC5DYW52YXNHcmFwaGljc0Vudmlyb25tZW50JyxcbiAgICAgICdqbGluZS50ZXJtaW5hbCc6ICdqbGluZS5VbnN1cHBvcnRlZFRlcm1pbmFsJywgLy8gd2UgY2FuJ3Qgc2hlbGwgb3V0IHRvIGBzdHR5YCxcbiAgICAgICdzdW4uYXJjaC5kYXRhLm1vZGVsJzogJzMyJywgLy8gSWRlbnRpZnkgYXMgMzItYml0LCBiZWNhdXNlIHRoYXQncyBob3cgd2UgYWN0LlxuICAgICAgJ3N1bi5qbnUuZW5jb2RpbmcnOiBcIlVURi04XCIgLy8gRGV0ZXJtaW5lcyBob3cgSmF2YSBwYXJzZXMgY29tbWFuZCBsaW5lIG9wdGlvbnMuXG4gICAgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBib290c3RyYXAgY2xhc3MgbG9hZGVyLlxuICAgKi9cbiAgcHVibGljIGdldEJvb3RzdHJhcENsYXNzTG9hZGVyKCk6IENsYXNzTG9hZGVyLkJvb3RzdHJhcENsYXNzTG9hZGVyIHtcbiAgICByZXR1cm4gdGhpcy5ic0NsO1xuICB9XG5cbiAgcHVibGljIGdldFN0YXJ0dXBUaW1lKCk6IERhdGUge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0dXBUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHN5c3RlbSBhc3NlcnRpb25zIGFyZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBwdWJsaWMgYXJlU3lzdGVtQXNzZXJ0aW9uc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlU3lzdGVtQXNzZXJ0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0aW5nIG9mIGNsYXNzZXMgd2l0aCBhc3NlcnRpb25zIGVuYWJsZWQuIENhbiBhbHNvIHJldHVybiAndHJ1ZScgb3IgJ2ZhbHNlLlxuICAgKi9cbiAgcHVibGljIGdldEVuYWJsZWRBc3NlcnRpb25zKCk6IHN0cmluZ1tdIHwgYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZEFzc2VydGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdGluZyBvZiBjbGFzc2VzIHdpdGggYXNzZXJ0aW9ucyBkaXNhYmxlZC5cbiAgICovXG4gIHB1YmxpYyBnZXREaXNhYmxlZEFzc2VydGlvbnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkQXNzZXJ0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgYSBkaXJlY3RvcnkgdG8gZHVtcCBjb21waWxlZCBjb2RlIHRvLlxuICAgKi9cbiAgcHVibGljIGR1bXBDb21waWxlZENvZGUoZGlyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmR1bXBDb21waWxlZENvZGVEaXIgPSBkaXI7XG4gIH1cblxuICBwdWJsaWMgc2hvdWxkRHVtcENvbXBpbGVkQ29kZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5kdW1wQ29tcGlsZWRDb2RlRGlyICE9PSBudWxsO1xuICB9XG5cbiAgcHVibGljIGR1bXBPYmplY3REZWZpbml0aW9uKGNsczogQ2xhc3NEYXRhLCBldmFsVGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2hvdWxkRHVtcENvbXBpbGVkQ29kZSgpKSB7XG4gICAgICBmcy53cml0ZUZpbGUocGF0aC5yZXNvbHZlKHRoaXMuZHVtcENvbXBpbGVkQ29kZURpciwgY2xzLmdldEV4dGVybmFsTmFtZSgpICsgXCJfb2JqZWN0LmR1bXBcIiksIGV2YWxUZXh0LCAoKSA9PiB7fSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGR1bXBCcmlkZ2VNZXRob2QobWV0aG9kU2lnOiBzdHJpbmcsIGV2YWxUZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zaG91bGREdW1wQ29tcGlsZWRDb2RlKCkpIHtcbiAgICAgIGZzLmFwcGVuZEZpbGUocGF0aC5yZXNvbHZlKHRoaXMuZHVtcENvbXBpbGVkQ29kZURpciwgXCJ2bXRhcmdldF9icmlkZ2VfbWV0aG9kcy5kdW1wXCIpLCBgJHttZXRob2RTaWd9OlxcbiR7ZXZhbFRleHR9XFxuXFxuYCwgKCkgPT4ge30pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBkdW1wcyBKVk0gc3RhdGUgdG8gYSBmaWxlLiBDdXJyZW50bHkgbGltaXRlZCB0byB0aHJlYWRcbiAgICogc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZHVtcFN0YXRlKGZpbGVuYW1lOiBzdHJpbmcsIGNiOiAoZXI6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGZzLmFwcGVuZEZpbGUoZmlsZW5hbWUsIHRoaXMudGhyZWFkUG9vbC5nZXRUaHJlYWRzKCkubWFwKCh0OiBKVk1UaHJlYWQpID0+IGBUaHJlYWQgJHt0LmdldFJlZigpfTpcXG5gICsgdC5nZXRQcmludGFibGVTdGFja1RyYWNlKCkpLmpvaW4oXCJcXG5cXG5cIiksIGNiKTtcbiAgfVxufVxuXG5leHBvcnQgPSBKVk07XG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBnTG9uZyA9IHJlcXVpcmUoJy4vZ0xvbmcnKTtcbmltcG9ydCBlbnVtcyA9IHJlcXVpcmUoJy4vZW51bXMnKTtcblxuLy8gZGVmYXVsdCBtb2R1bGU6IGxvZ2dpbmdcblxuLy8gdXNlZCBmb3IgZGVidWdnaW5nIHRoZSBzdGFjayBhbmQgbG9jYWwgdmFyaWFibGVzXG5leHBvcnQgZnVuY3Rpb24gZGVidWdfdmFyKGU6IGFueSk6IHN0cmluZyB7XG4gIGlmIChlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICchJztcbiAgfSBlbHNlIGlmIChlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gJ3VuZGVmJztcbiAgfSBlbHNlIGlmIChlLnJlZiAhPSBudWxsKSB7XG4gICAgcmV0dXJuIFwiKlwiICsgZS5yZWY7XG4gIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIGdMb25nKSB7XG4gICAgcmV0dXJuIGUgKyBcIkxcIjtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuLy8gdXNlZCBmb3IgZGVidWdnaW5nIHRoZSBzdGFjayBhbmQgbG9jYWwgdmFyaWFibGVzXG5leHBvcnQgZnVuY3Rpb24gZGVidWdfdmFycyhhcnI6IGFueVtdKTogc3RyaW5nW10ge1xuICByZXR1cm4gYXJyLm1hcDxzdHJpbmc+KGRlYnVnX3Zhcik7XG59XG5cbi8vIGxvZyBsZXZlbHNcbi8vIFRPRE86IHR1cm4gdGhpcyBpbnRvIGFuIGVudW0sIGlmIHBvc3NpYmxlXG5leHBvcnQgdmFyIFZUUkFDRSA9IDEwO1xuZXhwb3J0IHZhciBUUkFDRSA9IDk7XG5leHBvcnQgdmFyIERFQlVHID0gNTtcbmV4cG9ydCB2YXIgRVJST1IgPSAxO1xuZXhwb3J0IHZhciBsb2dfbGV2ZWwgPSBFUlJPUjtcblxuZnVuY3Rpb24gbG9nKGxldmVsOiBudW1iZXIsIG1zZ3M6IGFueVtdKTogdm9pZCB7XG4gIGlmIChsZXZlbCA8PSBsb2dfbGV2ZWwpIHtcbiAgICB2YXIgbXNnID0gbXNncy5qb2luKCcgJyk7XG4gICAgaWYgKGxldmVsID09IDEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZ0cmFjZSguLi5tc2dzOiBhbnlbXSk6IHZvaWQge1xuICBsb2coVlRSQUNFLCBtc2dzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNlKC4uLm1zZ3M6IGFueVtdKTogdm9pZCB7XG4gIGxvZyhUUkFDRSwgbXNncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1ZyguLi5tc2dzOiBhbnlbXSk6IHZvaWQge1xuICBsb2coREVCVUcsIG1zZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoLi4ubXNnczogYW55W10pOiB2b2lkIHtcbiAgbG9nKEVSUk9SLCBtc2dzKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmltcG9ydCBCeXRlU3RyZWFtID0gcmVxdWlyZSgnLi9CeXRlU3RyZWFtJyk7XG5pbXBvcnQgYXR0cmlidXRlcyA9IHJlcXVpcmUoJy4vYXR0cmlidXRlcycpO1xuaW1wb3J0IEpWTSA9IHJlcXVpcmUoJy4vanZtJyk7XG5pbXBvcnQgQ29uc3RhbnRQb29sID0gcmVxdWlyZSgnLi9Db25zdGFudFBvb2wnKTtcbmltcG9ydCBDbGFzc0RhdGEgPSByZXF1aXJlKCcuL0NsYXNzRGF0YScpO1xuaW1wb3J0IHRocmVhZGluZyA9IHJlcXVpcmUoJy4vdGhyZWFkaW5nJyk7XG5pbXBvcnQgZ0xvbmcgPSByZXF1aXJlKCcuL2dMb25nJyk7XG5pbXBvcnQgQ2xhc3NMb2FkZXIgPSByZXF1aXJlKCcuL0NsYXNzTG9hZGVyJyk7XG5pbXBvcnQgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmltcG9ydCBlbnVtcyA9IHJlcXVpcmUoJy4vZW51bXMnKTtcbmltcG9ydCBNb25pdG9yID0gcmVxdWlyZSgnLi9Nb25pdG9yJyk7XG5pbXBvcnQgU3RyaW5nT3V0cHV0U3RyZWFtID0gcmVxdWlyZSgnLi9TdHJpbmdPdXRwdXRTdHJlYW0nKTtcbmltcG9ydCBKVk1UeXBlcyA9IHJlcXVpcmUoJy4uL2luY2x1ZGVzL0pWTVR5cGVzJyk7XG5pbXBvcnQgZ2xvYmFsID0gcmVxdWlyZSgnLi9nbG9iYWwnKTtcblxuZGVjbGFyZSB2YXIgUkVMRUFTRTogYm9vbGVhbjtcbmlmICh0eXBlb2YgUkVMRUFTRSA9PT0gJ3VuZGVmaW5lZCcpIGdsb2JhbC5SRUxFQVNFID0gZmFsc2U7XG5cbnZhciB0cmFwcGVkX21ldGhvZHM6IHsgW2Nsc05hbWU6IHN0cmluZ106IHsgW21ldGhvZE5hbWU6IHN0cmluZ106IEZ1bmN0aW9uIH0gfSA9IHtcbiAgJ2phdmEvbGFuZy9yZWYvUmVmZXJlbmNlJzoge1xuICAgIC8vIE5PUCwgYmVjYXVzZSB3ZSBkb24ndCBkbyBvdXIgb3duIEdDIGFuZCBhbHNvIHRoaXMgc3RhcnRzIGEgdGhyZWFkPyE/IT8hXG4gICAgJzxjbGluaXQ+KClWJzogZnVuY3Rpb24gKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCk6IHZvaWQgeyB9XG4gIH0sXG4gICdqYXZhL2xhbmcvU3lzdGVtJzoge1xuICAgICdsb2FkTGlicmFyeShMamF2YS9sYW5nL1N0cmluZzspVic6IGZ1bmN0aW9uICh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGxpYk5hbWU6IEpWTVR5cGVzLmphdmFfbGFuZ19TdHJpbmcpOiB2b2lkIHtcbiAgICAgIC8vIFNvbWUgbGlicmFyaWVzIHRlc3QgaWYgbmF0aXZlIGxpYnJhcmllcyBhcmUgYXZhaWxhYmxlLFxuICAgICAgLy8gYW5kIGV4cGVjdCBhbiBleGNlcHRpb24gaWYgdGhleSBhcmUgbm90LlxuICAgICAgLy8gTGlzdCBhbGwgb2YgdGhlIG5hdGl2ZSBsaWJyYXJpZXMgd2Ugc3VwcG9ydC5cbiAgICAgIHZhciBsaWIgPSBsaWJOYW1lLnRvU3RyaW5nKCk7XG4gICAgICBzd2l0Y2ggKGxpYikge1xuICAgICAgICBjYXNlICd6aXAnOlxuICAgICAgICBjYXNlICduZXQnOlxuICAgICAgICBjYXNlICduaW8nOlxuICAgICAgICBjYXNlICdhd3QnOlxuICAgICAgICBjYXNlICdmb250bWFuYWdlcic6XG4gICAgICAgIGNhc2UgJ21hbmFnZW1lbnQnOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvVW5zYXRpc2ZpZWRMaW5rRXJyb3I7JywgYG5vICR7bGlifSBpbiBqYXZhLmxpYnJhcnkucGF0aGApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2phdmEvbGFuZy9UZXJtaW5hdG9yJzoge1xuICAgICdzZXR1cCgpVic6IGZ1bmN0aW9uICh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQpOiB2b2lkIHtcbiAgICAgIC8vIFhYWDogV2Ugc2hvdWxkIHByb2JhYmx5IGZpeCB0aGlzOyB3ZSBzdXBwb3J0IHRocmVhZHMgbm93LlxuICAgICAgLy8gSGlzdG9yaWNhbGx5OiBOT1AnZCBiZWNhdXNlIHdlIGRpZG4ndCBzdXBwb3J0IHRocmVhZHMuXG4gICAgfVxuICB9LFxuICAnamF2YS9uaW8vY2hhcnNldC9DaGFyc2V0JDMnOiB7XG4gICAgLy8gdGhpcyBpcyB0cmFwcGVkIGFuZCBOT1AnZWQgZm9yIHNwZWVkXG4gICAgJ3J1bigpTGphdmEvbGFuZy9PYmplY3Q7JzogZnVuY3Rpb24gKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgamF2YVRoaXM6IEpWTVR5cGVzLmphdmFfbmlvX2NoYXJzZXRfQ2hhcnNldCQzKTogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gICdzdW4vbmlvL2ZzL0RlZmF1bHRGaWxlU3lzdGVtUHJvdmlkZXInOiB7XG4gICAgLy8gT3BlbkpESyBkb2Vzbid0IGtub3cgd2hhdCB0aGUgXCJEb3BwaW9cIiBwbGF0Zm9ybSBpcy4gVGVsbCBpdCB0byB1c2UgdGhlIExpbnV4IGZpbGUgc3lzdGVtLlxuICAgICdjcmVhdGUoKUxqYXZhL25pby9maWxlL3NwaS9GaWxlU3lzdGVtUHJvdmlkZXI7JzogZnVuY3Rpb24odGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkKTogdm9pZCB7XG4gICAgICB0aHJlYWQuc2V0U3RhdHVzKGVudW1zLlRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HKTtcbiAgICAgIHZhciBkZnNwOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLnN1bl9uaW9fZnNfRGVmYXVsdEZpbGVTeXN0ZW1Qcm92aWRlcj4gPSA8YW55PiB0aHJlYWQuZ2V0QnNDbCgpLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnTHN1bi9uaW8vZnMvRGVmYXVsdEZpbGVTeXN0ZW1Qcm92aWRlcjsnKSxcbiAgICAgICBkZnNwQ2xzOiB0eXBlb2YgSlZNVHlwZXMuc3VuX25pb19mc19EZWZhdWx0RmlsZVN5c3RlbVByb3ZpZGVyID0gPGFueT4gZGZzcC5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpO1xuICAgICAgZGZzcENsc1snY3JlYXRlUHJvdmlkZXIoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL25pby9maWxlL3NwaS9GaWxlU3lzdGVtUHJvdmlkZXI7J10odGhyZWFkLCBbdGhyZWFkLmdldEpWTSgpLmludGVyblN0cmluZygnc3VuLm5pby5mcy5MaW51eEZpbGVTeXN0ZW1Qcm92aWRlcicpXSwgdXRpbC5mb3J3YXJkUmVzdWx0KHRocmVhZCkpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VHJhcHBlZE1ldGhvZChjbHNOYW1lOiBzdHJpbmcsIG1ldGhTaWc6IHN0cmluZyk6IEZ1bmN0aW9uIHtcbiAgY2xzTmFtZSA9IHV0aWwuZGVzY3JpcHRvcjJ0eXBlc3RyKGNsc05hbWUpO1xuICBpZiAodHJhcHBlZF9tZXRob2RzLmhhc093blByb3BlcnR5KGNsc05hbWUpICYmIHRyYXBwZWRfbWV0aG9kc1tjbHNOYW1lXS5oYXNPd25Qcm9wZXJ0eShtZXRoU2lnKSkge1xuICAgIHJldHVybiB0cmFwcGVkX21ldGhvZHNbY2xzTmFtZV1bbWV0aFNpZ107XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogU2hhcmVkIGZ1bmN0aW9uYWxpdHkgYmV0d2VlbiBNZXRob2QgYW5kIEZpZWxkIG9iamVjdHMsIGFzIHRoZXkgYXJlXG4gKiByZXByZXNlbnRlZCBzaW1pbGFybHkgaW4gY2xhc3MgZmlsZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdE1ldGhvZEZpZWxkIHtcbiAgLyoqXG4gICAqIFRoZSBkZWNsYXJpbmcgY2xhc3Mgb2YgdGhpcyBtZXRob2Qgb3IgZmllbGQuXG4gICAqL1xuICBwdWJsaWMgY2xzOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+O1xuICAvKipcbiAgICogVGhlIG1ldGhvZCAvIGZpZWxkJ3MgaW5kZXggaW4gaXRzIGRlZmluaW5nIGNsYXNzJ3MgbWV0aG9kL2ZpZWxkIGFycmF5LlxuICAgKi9cbiAgcHVibGljIHNsb3Q6IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgLyBmaWVsZCdzIGZsYWdzIChlLmcuIHN0YXRpYykuXG4gICAqL1xuICBwdWJsaWMgYWNjZXNzRmxhZ3M6IHV0aWwuRmxhZ3M7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZmllbGQsIHdpdGhvdXQgdGhlIGRlc2NyaXB0b3Igb3Igb3duaW5nIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBtZXRob2QvZmllbGQncyB0eXBlIGRlc2NyaXB0b3IuXG4gICAqIGUuZy46XG4gICAqIHB1YmxpYyBTdHJpbmcgZm9vOyA9PiBMamF2YS9sYW5nL1N0cmluZztcbiAgICogcHVibGljIHZvaWQgZm9vKFN0cmluZyBiYXIpOyA9PiAoTGphdmEvbGFuZy9TdHJpbmc7KVZcbiAgICovXG4gIHB1YmxpYyByYXdEZXNjcmlwdG9yOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbnkgYXR0cmlidXRlcyBvbiB0aGlzIG1ldGhvZCBvciBmaWVsZC5cbiAgICovXG4gIHB1YmxpYyBhdHRyczogYXR0cmlidXRlcy5JQXR0cmlidXRlW107XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBmaWVsZCBvciBtZXRob2Qgb2JqZWN0IGZyb20gcmF3IGNsYXNzIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbHM6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIGNvbnN0YW50UG9vbDogQ29uc3RhbnRQb29sLkNvbnN0YW50UG9vbCwgc2xvdDogbnVtYmVyLCBieXRlU3RyZWFtOiBCeXRlU3RyZWFtKSB7XG4gICAgdGhpcy5jbHMgPSBjbHM7XG4gICAgdGhpcy5zbG90ID0gc2xvdDtcbiAgICB0aGlzLmFjY2Vzc0ZsYWdzID0gbmV3IHV0aWwuRmxhZ3MoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSk7XG4gICAgdGhpcy5uYW1lID0gKDxDb25zdGFudFBvb2wuQ29uc3RVVEY4PiBjb25zdGFudFBvb2wuZ2V0KGJ5dGVTdHJlYW0uZ2V0VWludDE2KCkpKS52YWx1ZTtcbiAgICB0aGlzLnJhd0Rlc2NyaXB0b3IgPSAoPENvbnN0YW50UG9vbC5Db25zdFVURjg+IGNvbnN0YW50UG9vbC5nZXQoYnl0ZVN0cmVhbS5nZXRVaW50MTYoKSkpLnZhbHVlO1xuICAgIHRoaXMuYXR0cnMgPSBhdHRyaWJ1dGVzLm1ha2VBdHRyaWJ1dGVzKGJ5dGVTdHJlYW0sIGNvbnN0YW50UG9vbCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZyk6IGF0dHJpYnV0ZXMuSUF0dHJpYnV0ZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cnNbaV07XG4gICAgICBpZiAoYXR0ci5nZXROYW1lKCkgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGdldEF0dHJpYnV0ZXMobmFtZTogc3RyaW5nKTogYXR0cmlidXRlcy5JQXR0cmlidXRlW10ge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci5nZXROYW1lKCkgPT09IG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGFydGljdWxhciB0eXBlIG9mIGFubm90YXRpb24gYXMgYSBKVk0gYnl0ZSBhcnJheS4gUmV0dXJucyBudWxsXG4gICAqIGlmIHRoZSBhbm5vdGF0aW9uIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEFubm90YXRpb25UeXBlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgbmFtZTogc3RyaW5nKTogSlZNVHlwZXMuSlZNQXJyYXk8bnVtYmVyPiB7XG4gICAgdmFyIGFubm90YXRpb24gPSA8eyByYXdCeXRlczogQnVmZmVyIH0+IDxhbnk+IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChhbm5vdGF0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJ5dGVBcnJDb25zID0gKDxDbGFzc0RhdGEuQXJyYXlDbGFzc0RhdGE8bnVtYmVyPj4gdGhyZWFkLmdldEJzQ2woKS5nZXRJbml0aWFsaXplZENsYXNzKHRocmVhZCwgJ1tCJykpLmdldENvbnN0cnVjdG9yKHRocmVhZCksXG4gICAgICBydiA9IG5ldyBieXRlQXJyQ29ucyh0aHJlYWQsIDApO1xuXG4gICAgLy8gVE9ETzogQ29udmVydCB0byB0eXBlZCBhcnJheS5cbiAgICB2YXIgaTogbnVtYmVyLCBsZW4gPSBhbm5vdGF0aW9uLnJhd0J5dGVzLmxlbmd0aCwgYXJyID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBhbm5vdGF0aW9uLnJhd0J5dGVzLnJlYWRJbnQ4KGkpO1xuICAgIH1cbiAgICBydi5hcnJheSA9IGFycjtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvLyBUbyBzYXRpYXRlIFR5cGVTY3JpcHQuIENvbnNpZGVyIGl0IGFuICdhYnN0cmFjdCcgbWV0aG9kLlxuICBwdWJsaWMgcGFyc2VEZXNjcmlwdG9yKHJhd19kZXNjcmlwdG9yOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkIGVycm9yLlwiKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmllbGQgZXh0ZW5kcyBBYnN0cmFjdE1ldGhvZEZpZWxkIHtcbiAgLyoqXG4gICAqIFRoZSBmaWVsZCdzIGZ1bGwgbmFtZSwgd2hpY2ggaW5jbHVkZXMgdGhlIGRlZmluaW5nIGNsYXNzXG4gICAqIChlLmcuIGphdmEvbGFuZy9TdHJpbmcvdmFsdWUpLlxuICAgKi9cbiAgcHVibGljIGZ1bGxOYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY2xzOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wsIHNsb3Q6IG51bWJlciwgYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSkge1xuICAgIHN1cGVyKGNscywgY29uc3RhbnRQb29sLCBzbG90LCBieXRlU3RyZWFtKTtcbiAgICB0aGlzLmZ1bGxOYW1lID0gYCR7dXRpbC5kZXNjcmlwdG9yMnR5cGVzdHIoY2xzLmdldEludGVybmFsTmFtZSgpKX0vJHt0aGlzLm5hbWV9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBjYiB3aXRoIHRoZSByZWZsZWN0ZWRGaWVsZCBpZiBpdCBzdWNjZWVkcy4gQ2FsbHMgY2Igd2l0aCBudWxsIGlmIGl0XG4gICAqIGZhaWxzLlxuICAgKi9cbiAgcHVibGljIHJlZmxlY3Rvcih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNiOiAocmVmbGVjdGVkRmllbGQ6IEpWTVR5cGVzLmphdmFfbGFuZ19yZWZsZWN0X0ZpZWxkKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdmFyIHNpZ25hdHVyZUF0dHIgPSA8YXR0cmlidXRlcy5TaWduYXR1cmU+IHRoaXMuZ2V0QXR0cmlidXRlKFwiU2lnbmF0dXJlXCIpLFxuICAgICAganZtID0gdGhyZWFkLmdldEpWTSgpLFxuICAgICAgYnNDbCA9IHRocmVhZC5nZXRCc0NsKCk7XG4gICAgdmFyIGNyZWF0ZU9iaiA9ICh0eXBlT2JqOiBKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3MpOiBKVk1UeXBlcy5qYXZhX2xhbmdfcmVmbGVjdF9GaWVsZCA9PiB7XG4gICAgICB2YXIgZmllbGRDbHMgPSA8Q2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfcmVmbGVjdF9GaWVsZD4+IGJzQ2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsICdMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7JyksXG4gICAgICAgIGZpZWxkT2JqID0gbmV3IChmaWVsZENscy5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpKSh0aHJlYWQpO1xuXG4gICAgICBmaWVsZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvRmllbGQvY2xhenonXSA9IHRoaXMuY2xzLmdldENsYXNzT2JqZWN0KHRocmVhZCk7XG4gICAgICBmaWVsZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvRmllbGQvbmFtZSddID0ganZtLmludGVyblN0cmluZyh0aGlzLm5hbWUpO1xuICAgICAgZmllbGRPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L0ZpZWxkL3R5cGUnXSA9IHR5cGVPYmo7XG4gICAgICBmaWVsZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvRmllbGQvbW9kaWZpZXJzJ10gPSB0aGlzLmFjY2Vzc0ZsYWdzLmdldFJhd0J5dGUoKTtcbiAgICAgIGZpZWxkT2JqWydqYXZhL2xhbmcvcmVmbGVjdC9GaWVsZC9zbG90J10gPSB0aGlzLnNsb3Q7XG4gICAgICBmaWVsZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvRmllbGQvc2lnbmF0dXJlJ10gPSBzaWduYXR1cmVBdHRyICE9PSBudWxsID8gdXRpbC5pbml0U3RyaW5nKGJzQ2wsIHNpZ25hdHVyZUF0dHIuc2lnKSA6IG51bGw7XG4gICAgICBmaWVsZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvRmllbGQvYW5ub3RhdGlvbnMnXSA9IHRoaXMuZ2V0QW5ub3RhdGlvblR5cGUodGhyZWFkLCAnUnVudGltZVZpc2libGVBbm5vdGF0aW9ucycpO1xuXG4gICAgICByZXR1cm4gZmllbGRPYmo7XG4gICAgfTtcbiAgICAvLyBPdXIgZmllbGQncyB0eXBlIG1heSBub3QgYmUgbG9hZGVkLCBzbyB3ZSBhc3luY2hyb25vdXNseSBsb2FkIGl0IGhlcmUuXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgY2FuIHNwZWVkIHVwIHJlZmxlY3Rpb24gYnkgaGF2aW5nIGEgc3luY2hyb25vdXNfcmVmbGVjdG9yXG4gICAgLy8gbWV0aG9kIHRoYXQgd2UgY2FuIHRyeSBmaXJzdCwgYW5kIHdoaWNoIG1heSBmYWlsLlxuICAgIHRoaXMuY2xzLmdldExvYWRlcigpLnJlc29sdmVDbGFzcyh0aHJlYWQsIHRoaXMucmF3RGVzY3JpcHRvciwgKGNkYXRhOiBDbGFzc0RhdGEuQ2xhc3NEYXRhKSA9PiB7XG4gICAgICBpZiAoY2RhdGEgIT0gbnVsbCkge1xuICAgICAgICBjYihjcmVhdGVPYmooY2RhdGEuZ2V0Q2xhc3NPYmplY3QodGhyZWFkKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldERlZmF1bHRGaWVsZFZhbHVlKCk6IHN0cmluZyB7XG4gICAgdmFyIGRlc2MgPSB0aGlzLnJhd0Rlc2NyaXB0b3I7XG4gICAgaWYgKGRlc2MgPT09ICdKJykgcmV0dXJuICdnTG9uZ1plcm8nO1xuICAgIHZhciBjID0gZGVzY1swXTtcbiAgICBpZiAoYyA9PT0gJ1snIHx8IGMgPT09ICdMJykgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gJzAnO1xuICB9XG5cbiAgLyoqXG4gICAqIE91dHB1dHMgYSBKYXZhU2NyaXB0IGZpZWxkIGFzc2lnbm1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAqL1xuICBwdWJsaWMgb3V0cHV0SmF2YVNjcmlwdEZpZWxkKGpzQ29uc05hbWU6IHN0cmluZywgb3V0cHV0U3RyZWFtOiBTdHJpbmdPdXRwdXRTdHJlYW0pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hY2Nlc3NGbGFncy5pc1N0YXRpYygpKSB7XG4gICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoYCR7anNDb25zTmFtZX1bXCIke3V0aWwucmVlc2NhcGVKVk1OYW1lKHRoaXMuZnVsbE5hbWUpfVwiXSA9IGNscy5fZ2V0SW5pdGlhbFN0YXRpY0ZpZWxkVmFsdWUodGhyZWFkLCBcIiR7dXRpbC5yZWVzY2FwZUpWTU5hbWUodGhpcy5uYW1lKX1cIik7XFxuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFN0cmVhbS53cml0ZShgdGhpc1tcIiR7dXRpbC5yZWVzY2FwZUpWTU5hbWUodGhpcy5mdWxsTmFtZSl9XCJdID0gJHt0aGlzLmdldERlZmF1bHRGaWVsZFZhbHVlKCl9O1xcbmApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWV0aG9kIGV4dGVuZHMgQWJzdHJhY3RNZXRob2RGaWVsZCB7XG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kJ3MgcGFyYW1ldGVycywgaWYgYW55LCBpbiBkZXNjcmlwdG9yIGZvcm0uXG4gICAqL1xuICBwdWJsaWMgcGFyYW1ldGVyVHlwZXM6IHN0cmluZ1tdO1xuICAvKipcbiAgICogVGhlIG1ldGhvZCdzIHJldHVybiB0eXBlIGluIGRlc2NyaXB0b3IgZm9ybS5cbiAgICovXG4gIHB1YmxpYyByZXR1cm5UeXBlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kJ3Mgc2lnbmF0dXJlLCBlLmcuIGJhcigpVlxuICAgKi9cbiAgcHVibGljIHNpZ25hdHVyZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIG1ldGhvZCdzIHNpZ25hdHVyZSwgaW5jbHVkaW5nIGRlZmluaW5nIGNsYXNzOyBlLmcuIGphdmEvbGFuZy9TdHJpbmcvYmFyKClWXG4gICAqL1xuICBwdWJsaWMgZnVsbFNpZ25hdHVyZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBKVk0gd29yZHMgcmVxdWlyZWQgdG8gc3RvcmUgdGhlIHBhcmFtZXRlcnMgKGUuZy4gbG9uZ3MvZG91YmxlcyB0YWtlIHVwIDIgd29yZHMpLlxuICAgKiBEb2VzIG5vdCBpbmNsdWRlIHRoZSBcInRoaXNcIiBhcmd1bWVudCB0byBub24tc3RhdGljIGZ1bmN0aW9ucy5cbiAgICovXG4gIHByaXZhdGUgcGFyYW1ldGVyV29yZHM6IG51bWJlcjtcbiAgLyoqXG4gICAqIENvZGUgaXMgZWl0aGVyIGEgZnVuY3Rpb24sIG9yIGEgQ29kZUF0dHJpYnV0ZS5cbiAgICogVE9ETzogRGlmZmVyZW50aWF0ZSBiZXR3ZWVuIE5hdGl2ZU1ldGhvZCBvYmplY3RzIGFuZCBCeXRlY29kZU1ldGhvZCBvYmplY3RzLlxuICAgKi9cbiAgcHJpdmF0ZSBjb2RlOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoY2xzOiBDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+LCBjb25zdGFudFBvb2w6IENvbnN0YW50UG9vbC5Db25zdGFudFBvb2wsIHNsb3Q6IG51bWJlciwgYnl0ZVN0cmVhbTogQnl0ZVN0cmVhbSkge1xuICAgIHN1cGVyKGNscywgY29uc3RhbnRQb29sLCBzbG90LCBieXRlU3RyZWFtKTtcbiAgICB2YXIgcGFyc2VkRGVzY3JpcHRvciA9IHV0aWwuZ2V0VHlwZXModGhpcy5yYXdEZXNjcmlwdG9yKSwgaTogbnVtYmVyLFxuICAgICAgcDogc3RyaW5nO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdGhpcy5uYW1lICsgdGhpcy5yYXdEZXNjcmlwdG9yO1xuICAgIHRoaXMuZnVsbFNpZ25hdHVyZSA9IGAke3V0aWwuZGVzY3JpcHRvcjJ0eXBlc3RyKHRoaXMuY2xzLmdldEludGVybmFsTmFtZSgpKX0vJHt0aGlzLnNpZ25hdHVyZX1gO1xuICAgIHRoaXMucmV0dXJuVHlwZSA9IHBhcnNlZERlc2NyaXB0b3IucG9wKCk7XG4gICAgdGhpcy5wYXJhbWV0ZXJUeXBlcyA9IHBhcnNlZERlc2NyaXB0b3I7XG4gICAgdGhpcy5wYXJhbWV0ZXJXb3JkcyA9IHBhcnNlZERlc2NyaXB0b3IubGVuZ3RoO1xuXG4gICAgLy8gRG91YmxlIGNvdW50IGRvdWJsZXMgLyBsb25ncy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wYXJhbWV0ZXJUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcCA9IHRoaXMucGFyYW1ldGVyVHlwZXNbaV07XG4gICAgICBpZiAocCA9PT0gJ0QnIHx8IHAgPT09ICdKJykge1xuICAgICAgICB0aGlzLnBhcmFtZXRlcldvcmRzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSAnY29kZScgcHJvcGVydHkuXG4gICAgdmFyIGNsc05hbWUgPSB0aGlzLmNscy5nZXRJbnRlcm5hbE5hbWUoKTtcbiAgICBpZiAoZ2V0VHJhcHBlZE1ldGhvZChjbHNOYW1lLCB0aGlzLnNpZ25hdHVyZSkgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29kZSA9IGdldFRyYXBwZWRNZXRob2QoY2xzTmFtZSwgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgdGhpcy5hY2Nlc3NGbGFncy5zZXROYXRpdmUodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjY2Vzc0ZsYWdzLmlzTmF0aXZlKCkpIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hdHVyZS5pbmRleE9mKCdyZWdpc3Rlck5hdGl2ZXMoKVYnLCAwKSA8IDAgJiYgdGhpcy5zaWduYXR1cmUuaW5kZXhPZignaW5pdElEcygpVicsIDApIDwgMCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdmVyc2lvbiBvZiB0aGUgbmF0aXZlIG1ldGhvZCBhdHRlbXB0cyB0byBmZXRjaCBpdHNlbGYgYW5kXG4gICAgICAgIC8vIHJld3JpdGUgaXRzZWxmLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGZ1bmN0aW9uKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCkge1xuICAgICAgICAgIC8vIFRyeSB0byBmZXRjaCB0aGUgbmF0aXZlIG1ldGhvZC5cbiAgICAgICAgICB2YXIganZtID0gdGhyZWFkLmdldEpWTSgpLFxuICAgICAgICAgICAgYyA9IGp2bS5nZXROYXRpdmUoY2xzTmFtZSwgc2VsZi5zaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChjID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9VbnNhdGlzZmllZExpbmtFcnJvcjsnLCBgTmF0aXZlIG1ldGhvZCAnJHtzZWxmLmdldEZ1bGxTaWduYXR1cmUoKX0nIG5vdCBpbXBsZW1lbnRlZC5cXG5QbGVhc2UgZml4IG9yIGZpbGUgYSBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL3BsYXNtYS11bWFzcy9kb3BwaW8vaXNzdWVzYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuY29kZSA9IGM7XG4gICAgICAgICAgICByZXR1cm4gYy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0dWIgb3V0IGluaXRJRHMgYW5kIHJlZ2lzdGVyTmF0aXZlcy5cbiAgICAgICAgdGhpcy5jb2RlID0gKCkgPT4geyB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuYWNjZXNzRmxhZ3MuaXNBYnN0cmFjdCgpKSB7XG4gICAgICB0aGlzLmNvZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnQ29kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG1ldGhvZCBpcyBhIGRlZmF1bHQgbWV0aG9kLlxuICAgKiBBIGRlZmF1bHQgbWV0aG9kIGlzIGEgcHVibGljIG5vbi1hYnN0cmFjdCBpbnN0YW5jZSBtZXRob2QsIHRoYXRcbiAgICogaXMsIGEgbm9uLXN0YXRpYyBtZXRob2Qgd2l0aCBhIGJvZHksIGRlY2xhcmVkIGluIGFuIGludGVyZmFjZVxuICAgKiB0eXBlLlxuICAgKi9cbiAgcHVibGljIGlzRGVmYXVsdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuYWNjZXNzRmxhZ3MuaXNQdWJsaWMoKSAmJiAhdGhpcy5hY2Nlc3NGbGFncy5pc0Fic3RyYWN0KCkgJiYgIXRoaXMuYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSAmJiB0aGlzLmNscy5hY2Nlc3NGbGFncy5pc0ludGVyZmFjZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRGdWxsU2lnbmF0dXJlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMuY2xzLmdldEV4dGVybmFsTmFtZSgpfS4ke3RoaXMubmFtZX0ke3RoaXMucmF3RGVzY3JpcHRvcn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHBhcnRpY3VsYXIgbWV0aG9kIHNob3VsZCBiZSBoaWRkZW4gaW4gc3RhY2sgZnJhbWVzLlxuICAgKiBVc2VkIGJ5IE9wZW5KREsncyBsYW1iZGEgaW1wbGVtZW50YXRpb24gdG8gaGlkZSBsYW1iZGEgYm9pbGVycGxhdGUuXG4gICAqL1xuICBwdWJsaWMgaXNIaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgdmFyIHJ2YTogYXR0cmlidXRlcy5SdW50aW1lVmlzaWJsZUFubm90YXRpb25zID0gPGFueT4gdGhpcy5nZXRBdHRyaWJ1dGUoJ1J1bnRpbWVWaXNpYmxlQW5ub3RhdGlvbnMnKTtcbiAgICByZXR1cm4gcnZhICE9PSBudWxsICYmIHJ2YS5pc0hpZGRlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBwYXJ0aWN1bGFyIG1ldGhvZCBoYXMgdGhlIENhbGxlclNlbnNpdGl2ZSBhbm5vdGF0aW9uLlxuICAgKi9cbiAgcHVibGljIGlzQ2FsbGVyU2Vuc2l0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHZhciBydmE6IGF0dHJpYnV0ZXMuUnVudGltZVZpc2libGVBbm5vdGF0aW9ucyA9IDxhbnk+IHRoaXMuZ2V0QXR0cmlidXRlKCdSdW50aW1lVmlzaWJsZUFubm90YXRpb25zJyk7XG4gICAgcmV0dXJuIHJ2YSAhPT0gbnVsbCAmJiBydmEuaXNDYWxsZXJTZW5zaXRpdmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgbWFjaGluZSB3b3JkcyAoMzItYml0IHdvcmRzKSByZXF1aXJlZCB0byBzdG9yZSB0aGVcbiAgICogcGFyYW1ldGVycyB0byB0aGlzIGZ1bmN0aW9uLiBJbmNsdWRlcyBhZGRpbmcgaW4gYSBtYWNoaW5lIHdvcmQgZm9yICd0aGlzJ1xuICAgKiBmb3Igbm9uLXN0YXRpYyBmdW5jdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFyYW1Xb3JkU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRlcldvcmRzO1xuICB9XG5cbiAgcHVibGljIGdldENvZGVBdHRyaWJ1dGUoKTogYXR0cmlidXRlcy5Db2RlIHtcbiAgICBhc3NlcnQoIXRoaXMuYWNjZXNzRmxhZ3MuaXNOYXRpdmUoKSAmJiAhdGhpcy5hY2Nlc3NGbGFncy5pc0Fic3RyYWN0KCkpO1xuICAgIHJldHVybiB0aGlzLmNvZGU7XG4gIH1cblxuICBwdWJsaWMgZ2V0TmF0aXZlRnVuY3Rpb24oKTogRnVuY3Rpb24ge1xuICAgIGFzc2VydCh0aGlzLmFjY2Vzc0ZsYWdzLmlzTmF0aXZlKCkgJiYgdHlwZW9mICh0aGlzLmNvZGUpID09PSAnZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gdGhpcy5jb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFsbCBvZiB0aGUgY2xhc3NlcyByZWZlcmVuY2VkIHRocm91Z2ggdGhpcyBtZXRob2QuIFJlcXVpcmVkIGluXG4gICAqIG9yZGVyIHRvIGNyZWF0ZSBpdHMgcmVmbGVjdGlvbiBvYmplY3QuXG4gICAqL1xuICBwcml2YXRlIF9yZXNvbHZlUmVmZXJlbmNlZENsYXNzZXModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjYjogKGNsYXNzZXM6IHtbIGNsYXNzTmFtZTogc3RyaW5nIF06IENsYXNzRGF0YS5DbGFzc0RhdGF9KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgLy8gU3RhcnQgd2l0aCB0aGUgcmV0dXJuIHR5cGUgKyBwYXJhbWV0ZXIgdHlwZXMgKyByZWZsZWN0aW9uIG9iamVjdCB0eXBlcy5cbiAgICB2YXIgdG9SZXNvbHZlOiBzdHJpbmdbXSA9IHRoaXMucGFyYW1ldGVyVHlwZXMuY29uY2F0KHRoaXMucmV0dXJuVHlwZSksXG4gICAgICBjb2RlOiBhdHRyaWJ1dGVzLkNvZGUgPSB0aGlzLmNvZGUsXG4gICAgICBleGNlcHRpb25BdHRyaWJ1dGUgPSA8YXR0cmlidXRlcy5FeGNlcHRpb25zPiB0aGlzLmdldEF0dHJpYnV0ZShcIkV4Y2VwdGlvbnNcIik7XG4gICAgLy8gRXhjZXB0aW9uIGhhbmRsZXIgdHlwZXMuXG4gICAgaWYgKCF0aGlzLmFjY2Vzc0ZsYWdzLmlzTmF0aXZlKCkgJiYgIXRoaXMuYWNjZXNzRmxhZ3MuaXNBYnN0cmFjdCgpICYmIGNvZGUuZXhjZXB0aW9uSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdG9SZXNvbHZlLnB1c2goJ0xqYXZhL2xhbmcvVGhyb3dhYmxlOycpOyAvLyBNaW1pYyBuYXRpdmUgSmF2YSAoaW4gY2FzZSA8YW55PiBpcyB0aGUgb25seSBoYW5kbGVyKS5cbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIDxhbnk+IGhhbmRsZXJzLlxuICAgICAgdG9SZXNvbHZlID0gdG9SZXNvbHZlLmNvbmNhdChjb2RlLmV4Y2VwdGlvbkhhbmRsZXJzLmZpbHRlcigoaGFuZGxlcikgPT4gaGFuZGxlci5jYXRjaFR5cGUgIT09ICc8YW55PicpLm1hcCgoaGFuZGxlcikgPT4gaGFuZGxlci5jYXRjaFR5cGUpKTtcbiAgICB9XG4gICAgLy8gUmVzb2x2ZSBjaGVja2VkIGV4Y2VwdGlvbiB0eXBlcy5cbiAgICBpZiAoZXhjZXB0aW9uQXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICB0b1Jlc29sdmUgPSB0b1Jlc29sdmUuY29uY2F0KGV4Y2VwdGlvbkF0dHJpYnV0ZS5leGNlcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLmNscy5nZXRMb2FkZXIoKS5yZXNvbHZlQ2xhc3Nlcyh0aHJlYWQsIHRvUmVzb2x2ZSwgKGNsYXNzZXM6IHtbY2xhc3NOYW1lOiBzdHJpbmddOiBDbGFzc0RhdGEuQ2xhc3NEYXRhfSkgPT4ge1xuICAgICAgLy8gVXNlIGJvb3RzdHJhcCBjbGFzc2xvYWRlciBmb3IgcmVmbGVjdGlvbiBjbGFzc2VzLlxuICAgICAgdGhyZWFkLmdldEJzQ2woKS5yZXNvbHZlQ2xhc3Nlcyh0aHJlYWQsIFsnTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsnLCAnTGphdmEvbGFuZy9yZWZsZWN0L0NvbnN0cnVjdG9yOyddLCAoY2xhc3NlczI6IHtbY2xhc3NOYW1lOiBzdHJpbmddOiBDbGFzc0RhdGEuQ2xhc3NEYXRhfSkgPT4ge1xuICAgICAgICBpZiAoY2xhc3NlcyA9PT0gbnVsbCB8fCBjbGFzc2VzMiA9PT0gbnVsbCkge1xuICAgICAgICAgIGNiKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsYXNzZXNbJ0xqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2Q7J10gPSBjbGFzc2VzMlsnTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsnXTtcbiAgICAgICAgICBjbGFzc2VzWydMamF2YS9sYW5nL3JlZmxlY3QvQ29uc3RydWN0b3I7J10gPSBjbGFzc2VzMlsnTGphdmEvbGFuZy9yZWZsZWN0L0NvbnN0cnVjdG9yOyddO1xuICAgICAgICAgIGNiKGNsYXNzZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWZsZWN0aW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgcmVmbGVjdG9yKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2I6IChyZWZsZWN0ZWRNZXRob2Q6IEpWTVR5cGVzLmphdmFfbGFuZ19yZWZsZWN0X0V4ZWN1dGFibGUpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB2YXIgYnNDbCA9IHRocmVhZC5nZXRCc0NsKCksXG4gICAgICAvLyBHcmFiIHRoZSBjbGFzc2VzIHJlcXVpcmVkIHRvIGNvbnN0cnVjdCB0aGUgbmVlZGVkIGFycmF5cy5cbiAgICAgIGNsYXp6QXJyYXkgPSAoPENsYXNzRGF0YS5BcnJheUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3M+PiBic0NsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCAnW0xqYXZhL2xhbmcvQ2xhc3M7JykpLmdldENvbnN0cnVjdG9yKHRocmVhZCksXG4gICAgICBqdm0gPSB0aHJlYWQuZ2V0SlZNKCksXG4gICAgICAvLyBHcmFiIHRoZSBuZWVkZWQgYXR0cmlidXRlcy5cbiAgICAgIHNpZ25hdHVyZUF0dHIgPSA8YXR0cmlidXRlcy5TaWduYXR1cmU+IHRoaXMuZ2V0QXR0cmlidXRlKFwiU2lnbmF0dXJlXCIpLFxuICAgICAgZXhjZXB0aW9uQXR0ciA9IDxhdHRyaWJ1dGVzLkV4Y2VwdGlvbnM+IHRoaXMuZ2V0QXR0cmlidXRlKFwiRXhjZXB0aW9uc1wiKTtcblxuICAgIC8vIFJldHJpZXZlIGFsbCBvZiB0aGUgcmVxdWlyZWQgY2xhc3MgcmVmZXJlbmNlcy5cbiAgICB0aGlzLl9yZXNvbHZlUmVmZXJlbmNlZENsYXNzZXModGhyZWFkLCAoY2xhc3NlczogeyBbY2xhc3NOYW1lOiBzdHJpbmcgXTogQ2xhc3NEYXRhLkNsYXNzRGF0YSB9KSA9PiB7XG4gICAgICBpZiAoY2xhc3NlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnN0cnVjdCB0aGUgbmVlZGVkIG9iamVjdHMgZm9yIHRoZSByZWZsZWN0aW9uIG9iamVjdC5cbiAgICAgIHZhciBjbGF6eiA9IHRoaXMuY2xzLmdldENsYXNzT2JqZWN0KHRocmVhZCksXG4gICAgICAgIG5hbWUgPSBqdm0uaW50ZXJuU3RyaW5nKHRoaXMubmFtZSksXG4gICAgICAgIHBhcmFtZXRlclR5cGVzID0gbmV3IGNsYXp6QXJyYXkodGhyZWFkLCAwKSxcbiAgICAgICAgcmV0dXJuVHlwZSA9IGNsYXNzZXNbdGhpcy5yZXR1cm5UeXBlXS5nZXRDbGFzc09iamVjdCh0aHJlYWQpLFxuICAgICAgICBleGNlcHRpb25UeXBlcyA9IG5ldyBjbGF6ekFycmF5KHRocmVhZCwgMCksXG4gICAgICAgIG1vZGlmaWVycyA9IHRoaXMuYWNjZXNzRmxhZ3MuZ2V0UmF3Qnl0ZSgpLFxuICAgICAgICBzaWduYXR1cmUgPSBzaWduYXR1cmVBdHRyICE9PSBudWxsID8ganZtLmludGVyblN0cmluZyhzaWduYXR1cmVBdHRyLnNpZykgOiBudWxsO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSBjbGFzcyBhcnJheXMuXG4gICAgICBwYXJhbWV0ZXJUeXBlcy5hcnJheSA9IHRoaXMucGFyYW1ldGVyVHlwZXMubWFwKChwdHlwZTogc3RyaW5nKSA9PiBjbGFzc2VzW3B0eXBlXS5nZXRDbGFzc09iamVjdCh0aHJlYWQpKTtcbiAgICAgIGlmIChleGNlcHRpb25BdHRyICE9PSBudWxsKSB7XG4gICAgICAgIGV4Y2VwdGlvblR5cGVzLmFycmF5ID0gZXhjZXB0aW9uQXR0ci5leGNlcHRpb25zLm1hcCgoZVR5cGU6IHN0cmluZykgPT4gY2xhc3Nlc1tlVHlwZV0uZ2V0Q2xhc3NPYmplY3QodGhyZWFkKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5hbWUgPT09ICc8aW5pdD4nKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yIG9iamVjdC5cbiAgICAgICAgdmFyIGNvbnNDb25zID0gKDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19yZWZsZWN0X0NvbnN0cnVjdG9yPj4gY2xhc3Nlc1snTGphdmEvbGFuZy9yZWZsZWN0L0NvbnN0cnVjdG9yOyddKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpLFxuICAgICAgICAgIGNvbnNPYmogPSBuZXcgY29uc0NvbnModGhyZWFkKTtcbiAgICAgICAgY29uc09ialsnamF2YS9sYW5nL3JlZmxlY3QvQ29uc3RydWN0b3IvY2xhenonXSA9IGNsYXp6O1xuICAgICAgICBjb25zT2JqWydqYXZhL2xhbmcvcmVmbGVjdC9Db25zdHJ1Y3Rvci9wYXJhbWV0ZXJUeXBlcyddID0gcGFyYW1ldGVyVHlwZXM7XG4gICAgICAgIGNvbnNPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L0NvbnN0cnVjdG9yL2V4Y2VwdGlvblR5cGVzJ10gPSBleGNlcHRpb25UeXBlcztcbiAgICAgICAgY29uc09ialsnamF2YS9sYW5nL3JlZmxlY3QvQ29uc3RydWN0b3IvbW9kaWZpZXJzJ10gPSBtb2RpZmllcnM7XG4gICAgICAgIGNvbnNPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L0NvbnN0cnVjdG9yL3Nsb3QnXSA9IHRoaXMuc2xvdDtcbiAgICAgICAgY29uc09ialsnamF2YS9sYW5nL3JlZmxlY3QvQ29uc3RydWN0b3Ivc2lnbmF0dXJlJ10gPSBzaWduYXR1cmU7XG4gICAgICAgIGNvbnNPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L0NvbnN0cnVjdG9yL2Fubm90YXRpb25zJ10gPSB0aGlzLmdldEFubm90YXRpb25UeXBlKHRocmVhZCwgJ1J1bnRpbWVWaXNpYmxlQW5ub3RhdGlvbnMnKTtcbiAgICAgICAgY29uc09ialsnamF2YS9sYW5nL3JlZmxlY3QvQ29uc3RydWN0b3IvcGFyYW1ldGVyQW5ub3RhdGlvbnMnXSA9IHRoaXMuZ2V0QW5ub3RhdGlvblR5cGUodGhyZWFkLCAnUnVudGltZVZpc2libGVQYXJhbWV0ZXJBbm5vdGF0aW9ucycpO1xuICAgICAgICBjYihjb25zT2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ldGhvZCBvYmplY3QuXG4gICAgICAgIHZhciBtZXRob2RDb25zID0gKDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19yZWZsZWN0X01ldGhvZD4+ICBjbGFzc2VzWydMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOyddKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpLFxuICAgICAgICAgIG1ldGhvZE9iaiA9IG5ldyBtZXRob2RDb25zKHRocmVhZCk7XG4gICAgICAgIG1ldGhvZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kL2NsYXp6J10gPSBjbGF6ejtcbiAgICAgICAgbWV0aG9kT2JqWydqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QvbmFtZSddID0gbmFtZTtcbiAgICAgICAgbWV0aG9kT2JqWydqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QvcGFyYW1ldGVyVHlwZXMnXSA9IHBhcmFtZXRlclR5cGVzO1xuICAgICAgICBtZXRob2RPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L01ldGhvZC9yZXR1cm5UeXBlJ10gPSByZXR1cm5UeXBlO1xuICAgICAgICBtZXRob2RPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L01ldGhvZC9leGNlcHRpb25UeXBlcyddID0gZXhjZXB0aW9uVHlwZXM7XG4gICAgICAgIG1ldGhvZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kL21vZGlmaWVycyddID0gbW9kaWZpZXJzO1xuICAgICAgICBtZXRob2RPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L01ldGhvZC9zbG90J10gPSB0aGlzLnNsb3Q7XG4gICAgICAgIG1ldGhvZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kL3NpZ25hdHVyZSddID0gc2lnbmF0dXJlO1xuICAgICAgICBtZXRob2RPYmpbJ2phdmEvbGFuZy9yZWZsZWN0L01ldGhvZC9hbm5vdGF0aW9ucyddID0gdGhpcy5nZXRBbm5vdGF0aW9uVHlwZSh0aHJlYWQsICdSdW50aW1lVmlzaWJsZUFubm90YXRpb25zJyk7XG4gICAgICAgIG1ldGhvZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kL2Fubm90YXRpb25EZWZhdWx0J10gPSB0aGlzLmdldEFubm90YXRpb25UeXBlKHRocmVhZCwgJ0Fubm90YXRpb25EZWZhdWx0Jyk7XG4gICAgICAgIG1ldGhvZE9ialsnamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kL3BhcmFtZXRlckFubm90YXRpb25zJ10gPSB0aGlzLmdldEFubm90YXRpb25UeXBlKHRocmVhZCwgJ1J1bnRpbWVWaXNpYmxlUGFyYW1ldGVyQW5ub3RhdGlvbnMnKTtcbiAgICAgICAgY2IobWV0aG9kT2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgaW50byBhIGZvcm0gc3VpdGFibGUgZm9yIGEgbmF0aXZlXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGUgSlZNIHVzZXMgdHdvIHBhcmFtZXRlciBzbG90cyBmb3IgZG91YmxlIGFuZCBsb25nIHZhbHVlcywgc2luY2UgdGhleVxuICAgKiBjb25zaXN0IG9mIHR3byBKVk0gbWFjaGluZSB3b3JkcyAoMzItYml0cykuIERvcHBpbyBzdG9yZXMgdGhlIGVudGlyZSB2YWx1ZVxuICAgKiBpbiBvbmUgc2xvdCwgYW5kIHN0b3JlcyBhIE5VTEwgaW4gdGhlIHNlY29uZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzdHJpcHMgb3V0IHRoZXNlIE5VTExzIHNvIHRoZSBhcmd1bWVudHMgYXJlIGluIGEgbW9yZVxuICAgKiBjb25zaXN0ZW50IGZvcm0uIFRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uIHdpdGhvdXRcbiAgICogdGhlc2UgTlVMTCB2YWx1ZXMuIEl0IGFsc28gYWRkcyB0aGUgJ3RocmVhZCcgb2JqZWN0IHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICogYXJndW1lbnRzIGFycmF5LlxuICAgKi9cbiAgcHVibGljIGNvbnZlcnRBcmdzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgcGFyYW1zOiBhbnlbXSk6IGFueVtdIHtcbiAgICBpZiAodGhpcy5pc1NpZ25hdHVyZVBvbHltb3JwaGljKCkpIHtcbiAgICAgIC8vIFRoZXNlIGRvbid0IG5lZWQgYW55IGNvbnZlcnNpb24sIGFuZCBoYXZlIGFyYml0cmFyeSBhcmd1bWVudHMuXG4gICAgICAvLyBKdXN0IGFwcGVuZCB0aGUgdGhyZWFkIG9iamVjdC5cbiAgICAgIHBhcmFtcy51bnNoaWZ0KHRocmVhZCk7XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICB2YXIgY29udmVydGVkQXJncyA9IFt0aHJlYWRdLCBhcmdJZHggPSAwLCBpOiBudW1iZXI7XG4gICAgaWYgKCF0aGlzLmFjY2Vzc0ZsYWdzLmlzU3RhdGljKCkpIHtcbiAgICAgIGNvbnZlcnRlZEFyZ3MucHVzaChwYXJhbXNbMF0pO1xuICAgICAgYXJnSWR4ID0gMTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGFyYW1ldGVyVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gdGhpcy5wYXJhbWV0ZXJUeXBlc1tpXTtcbiAgICAgIGNvbnZlcnRlZEFyZ3MucHVzaChwYXJhbXNbYXJnSWR4XSk7XG4gICAgICBhcmdJZHggKz0gKHAgPT09ICdKJyB8fCBwID09PSAnRCcpID8gMiA6IDE7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWRBcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2sgdGhpcyBwYXJ0aWN1bGFyIG1ldGhvZC5cbiAgICovXG4gIHB1YmxpYyBtZXRob2RMb2NrKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpOiBNb25pdG9yIHtcbiAgICBpZiAodGhpcy5hY2Nlc3NGbGFncy5pc1N0YXRpYygpKSB7XG4gICAgICAvLyBTdGF0aWMgbWV0aG9kcyBsb2NrIHRoZSBjbGFzcy5cbiAgICAgIHJldHVybiB0aGlzLmNscy5nZXRDbGFzc09iamVjdCh0aHJlYWQpLmdldE1vbml0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9uLXN0YXRpYyBtZXRob2RzIGxvY2sgdGhlIGluc3RhbmNlLlxuICAgICAgcmV0dXJuICg8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4gZnJhbWUubG9jYWxzWzBdKS5nZXRNb25pdG9yKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgaXMgYSBzaWduYXR1cmUgcG9seW1vcnBoaWMgbWV0aG9kLlxuICAgKiBGcm9tIFMyLjk6XG4gICAqIEEgbWV0aG9kIGlzIHNpZ25hdHVyZSBwb2x5bW9ycGhpYyBpZiBhbmQgb25seSBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGhvbGQgOlxuICAgKiAqIEl0IGlzIGRlY2xhcmVkIGluIHRoZSBqYXZhLmxhbmcuaW52b2tlLk1ldGhvZEhhbmRsZSBjbGFzcy5cbiAgICogKiBJdCBoYXMgYSBzaW5nbGUgZm9ybWFsIHBhcmFtZXRlciBvZiB0eXBlIE9iamVjdFtdLlxuICAgKiAqIEl0IGhhcyBhIHJldHVybiB0eXBlIG9mIE9iamVjdC5cbiAgICogKiBJdCBoYXMgdGhlIEFDQ19WQVJBUkdTIGFuZCBBQ0NfTkFUSVZFIGZsYWdzIHNldC5cbiAgICovXG4gIHB1YmxpYyBpc1NpZ25hdHVyZVBvbHltb3JwaGljKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNscy5nZXRJbnRlcm5hbE5hbWUoKSA9PT0gJ0xqYXZhL2xhbmcvaW52b2tlL01ldGhvZEhhbmRsZTsnICYmXG4gICAgICB0aGlzLmFjY2Vzc0ZsYWdzLmlzTmF0aXZlKCkgJiYgdGhpcy5hY2Nlc3NGbGFncy5pc1ZhckFyZ3MoKSAmJlxuICAgICAgdGhpcy5yYXdEZXNjcmlwdG9yID09PSAnKFtMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7JztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgTWVtYmVyTmFtZS9pbnZva2VkeW5hbWljIEphdmFTY3JpcHQgXCJicmlkZ2UgbWV0aG9kXCIgdGhhdFxuICAgKiBlbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIHJlcXVpcmVkIHRvIGNhbGwgdGhpcyBwYXJ0aWN1bGFyIG1ldGhvZC5cbiAgICovXG4gIHB1YmxpYyBnZXRWTVRhcmdldEJyaWRnZU1ldGhvZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHJlZktpbmQ6IG51bWJlcik6ICh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGRlc2NyaXB0b3I6IHN0cmluZywgYXJnczogYW55W10sIGNiPzogKGU/OiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlLCBydj86IGFueSkgPT4gdm9pZCkgPT4gdm9pZCB7XG4gICAgLy8gVE9ETzogQ291bGQgY2FjaGUgdGhlc2UgaW4gdGhlIE1ldGhvZCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICB2YXIgb3V0U3RyZWFtID0gbmV3IFN0cmluZ091dHB1dFN0cmVhbSgpLFxuICAgICAgdmlydHVhbERpc3BhdGNoID0gIShyZWZLaW5kID09PSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLklOVk9LRVNUQVRJQyB8fCByZWZLaW5kID09PSBlbnVtcy5NZXRob2RIYW5kbGVSZWZlcmVuY2VLaW5kLklOVk9LRVNQRUNJQUwpO1xuICAgIG91dFN0cmVhbS53cml0ZShgZnVuY3Rpb24gX2NyZWF0ZSh0aHJlYWQsIGNscywgdXRpbCkge1xcbmApO1xuICAgIGlmICh0aGlzLmFjY2Vzc0ZsYWdzLmlzU3RhdGljKCkpIHtcbiAgICAgIGFzc2VydCghdmlydHVhbERpc3BhdGNoLCBcIkNhbid0IGhhdmUgc3RhdGljIHZpcnR1YWwgZGlzcGF0Y2guXCIpO1xuICAgICAgb3V0U3RyZWFtLndyaXRlKGAgIHZhciBqc0NvbnMgPSBjbHMuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcXG5gKTtcbiAgICB9XG4gICAgb3V0U3RyZWFtLndyaXRlKGAgIGZ1bmN0aW9uIGJyaWRnZU1ldGhvZCh0aHJlYWQsIGRlc2NyaXB0b3IsIGFyZ3MsIGNiKSB7XFxuYCk7XG4gICAgaWYgKCF0aGlzLmFjY2Vzc0ZsYWdzLmlzU3RhdGljKCkpIHtcbiAgICAgIG91dFN0cmVhbS53cml0ZShgICAgIHZhciBvYmogPSBhcmdzLnNoaWZ0KCk7XFxuYCk7XG4gICAgICBvdXRTdHJlYW0ud3JpdGUoYCAgICBpZiAob2JqID09PSBudWxsKSB7IHJldHVybiB0aHJlYWQudGhyb3dOZXdFeGNlcHRpb24oJ0xqYXZhL2xhbmcvTnVsbFBvaW50ZXJFeGNlcHRpb247JywgJycpOyB9XFxuYCk7XG4gICAgICBvdXRTdHJlYW0ud3JpdGUoYCAgICBvYmpbXCIke3V0aWwucmVlc2NhcGVKVk1OYW1lKHZpcnR1YWxEaXNwYXRjaCA/IHRoaXMuc2lnbmF0dXJlIDogdGhpcy5mdWxsU2lnbmF0dXJlKX1cIl0odGhyZWFkLCBgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0U3RyZWFtLndyaXRlKGAgICAganNDb25zW1wiJHt1dGlsLnJlZXNjYXBlSlZNTmFtZSh0aGlzLmZ1bGxTaWduYXR1cmUpfVwiXSh0aHJlYWQsIGApO1xuICAgIH1cbiAgICAvLyBUT0RPOiBJcyBpdCBldmVyIGFwcHJvcHJpYXRlIHRvIGJveCBhcmd1bWVudHMgZm9yIHZhcmFyZ3MgZnVuY3Rpb25zPyBJdCBhcHBlYXJzIG5vdC5cbiAgICBvdXRTdHJlYW0ud3JpdGUoYGFyZ3NgKTtcbiAgICBvdXRTdHJlYW0ud3JpdGUoYCwgY2IpO1xuICB9XG4gIHJldHVybiBicmlkZ2VNZXRob2Q7XG59XG5fY3JlYXRlYCk7XG5cbiAgICB2YXIgZXZhbFRleHQgPSBvdXRTdHJlYW0uZmx1c2goKTtcbiAgICBpZiAodHlwZW9mIFJFTEVBU0UgPT09ICd1bmRlZmluZWQnICYmIHRocmVhZCAhPT0gbnVsbCAmJiB0aHJlYWQuZ2V0SlZNKCkuc2hvdWxkRHVtcENvbXBpbGVkQ29kZSgpKSB7XG4gICAgICB0aHJlYWQuZ2V0SlZNKCkuZHVtcEJyaWRnZU1ldGhvZCh0aGlzLmZ1bGxTaWduYXR1cmUsIGV2YWxUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2YWwoZXZhbFRleHQpKHRocmVhZCwgdGhpcy5jbHMsIHV0aWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBKYXZhU2NyaXB0IGNvZGUgZm9yIHRoaXMgcGFydGljdWxhciBtZXRob2QuXG4gICAqIFRPRE86IE1vdmUgbG9jayBsb2dpYyBhbmQgc3VjaCBpbnRvIHRoaXMgZnVuY3Rpb24hIEFuZCBvdGhlciBzcGVjaWFsaXphdGlvbi5cbiAgICogVE9ETzogU2lnbmF0dXJlIHBvbHltb3JwaGljIGZ1bmN0aW9ucy4uLj9cbiAgICovXG4gIHB1YmxpYyBvdXRwdXRKYXZhU2NyaXB0RnVuY3Rpb24oanNDb25zTmFtZTogc3RyaW5nLCBvdXRTdHJlYW06IFN0cmluZ091dHB1dFN0cmVhbSwgbm9uVmlydHVhbE9ubHk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIHZhciBpOiBudW1iZXI7XG4gICAgaWYgKHRoaXMuYWNjZXNzRmxhZ3MuaXNTdGF0aWMoKSkge1xuICAgICAgb3V0U3RyZWFtLndyaXRlKGAke2pzQ29uc05hbWV9W1wiJHt1dGlsLnJlZXNjYXBlSlZNTmFtZSh0aGlzLmZ1bGxTaWduYXR1cmUpfVwiXSA9ICR7anNDb25zTmFtZX1bXCIke3V0aWwucmVlc2NhcGVKVk1OYW1lKHRoaXMuc2lnbmF0dXJlKX1cIl0gPSBgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFub25WaXJ0dWFsT25seSkge1xuICAgICAgICBvdXRTdHJlYW0ud3JpdGUoYCR7anNDb25zTmFtZX0ucHJvdG90eXBlW1wiJHt1dGlsLnJlZXNjYXBlSlZNTmFtZSh0aGlzLnNpZ25hdHVyZSl9XCJdID0gYCk7XG4gICAgICB9XG4gICAgICBvdXRTdHJlYW0ud3JpdGUoYCR7anNDb25zTmFtZX0ucHJvdG90eXBlW1wiJHt1dGlsLnJlZXNjYXBlSlZNTmFtZSh0aGlzLmZ1bGxTaWduYXR1cmUpfVwiXSA9IGApO1xuICAgIH1cbiAgICAvLyBjYiBjaGVjayBpcyBib2lsZXJwbGF0ZSwgcmVxdWlyZWQgZm9yIG5hdGl2ZXMgY2FsbGluZyBpbnRvIEpWTSBsYW5kLlxuICAgIG91dFN0cmVhbS53cml0ZShgKGZ1bmN0aW9uKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24odGhyZWFkLCBhcmdzLCBjYikge1xuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocmVhZC5zdGFjay5wdXNoKG5ldyBJbnRlcm5hbFN0YWNrRnJhbWUoY2IpKTtcbiAgICB9XG4gICAgdGhyZWFkLnN0YWNrLnB1c2gobmV3ICR7dGhpcy5hY2Nlc3NGbGFncy5pc05hdGl2ZSgpID8gXCJOYXRpdmVTdGFja0ZyYW1lXCIgOiBcIkJ5dGVjb2RlU3RhY2tGcmFtZVwifShtZXRob2QsIGApO1xuICAgIGlmICghdGhpcy5hY2Nlc3NGbGFncy5pc1N0YXRpYygpKSB7XG4gICAgICAvLyBOb24tc3RhdGljIGZ1bmN0aW9ucyBuZWVkIHRvIGFkZCB0aGUgaW1wbGljaXQgJ3RoaXMnIHZhcmlhYmxlIHRvIHRoZVxuICAgICAgLy8gbG9jYWwgdmFyaWFibGVzLlxuICAgICAgb3V0U3RyZWFtLndyaXRlKGBbdGhpc2ApO1xuICAgICAgLy8gR2l2ZSB0aGUgSlMgZW5naW5lIGhpbnRzIGFib3V0IHRoZSBzaXplLCB0eXBlLCBhbmQgY29udGVudHMgb2YgdGhlIGFycmF5XG4gICAgICAvLyBieSBtYWtpbmcgaXQgYSBsaXRlcmFsLlxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGFyYW1ldGVyV29yZHM7IGkrKykge1xuICAgICAgICBvdXRTdHJlYW0ud3JpdGUoYCwgYXJnc1ske2l9XWApO1xuICAgICAgfVxuICAgICAgb3V0U3RyZWFtLndyaXRlKGBdYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0YXRpYyBmdW5jdGlvbiBkb2Vzbid0IG5lZWQgdG8gbXV0YXRlIHRoZSBhcmd1bWVudHMuXG4gICAgICBpZiAodGhpcy5wYXJhbWV0ZXJXb3JkcyA+IDApIHtcbiAgICAgICAgb3V0U3RyZWFtLndyaXRlKGBhcmdzYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRTdHJlYW0ud3JpdGUoYFtdYCk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dFN0cmVhbS53cml0ZShgKSk7XG4gICAgdGhyZWFkLnNldFN0YXR1cygke2VudW1zLlRocmVhZFN0YXR1cy5SVU5OQUJMRX0pO1xuICB9O1xufSkoY2xzLmdldFNwZWNpZmljTWV0aG9kKFwiJHt1dGlsLnJlZXNjYXBlSlZNTmFtZSh0aGlzLmNscy5nZXRJbnRlcm5hbE5hbWUoKSl9XCIsIFwiJHt1dGlsLnJlZXNjYXBlSlZNTmFtZSh0aGlzLnNpZ25hdHVyZSl9XCIpKTtcXG5gKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb250YWlucyBKVk0gb3Bjb2RlIGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIEpWTSBpbnRlcnByZXRlci5cbiAqL1xuLy8gV2UgdXNlIHNuYWtlIGNhc2UgZm9yIHRoZSBvcGNvZGUgbmFtZXMgc28gdGhleSBtYXRjaCB0aGUgSlZNIHNwZWMuXG4vLyBBcyBmb3IgdHlwZWRlZjptZW1iZXJWYXJpYWJsZURlY2xhcmF0b3IsIHdlIGRpc2FibGUgdGhpcyBzbyB3ZSBjYW4gaGF2ZVxuLy8gbWVtYmVyIHZhcmlhYmxlIG9wY29kZXMgd2l0aG91dCBleHBsaWNpdGx5IHR5cGluZyB0aGVtIGFzIElPcGNvZGVJbXBsZW1lbnRhdGlvbi5cbi8qIHRzbGludDpkaXNhYmxlOnZhcmlhYmxlLW5hbWUgdHlwZWRlZjptZW1iZXJWYXJpYWJsZURlY2xhcmF0b3IgKi9cblwidXNlIHN0cmljdFwiO1xuaW1wb3J0IGdMb25nID0gcmVxdWlyZSgnLi9nTG9uZycpO1xuaW1wb3J0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmltcG9ydCBDb25zdGFudFBvb2wgPSByZXF1aXJlKCcuL0NvbnN0YW50UG9vbCcpO1xuaW1wb3J0IENsYXNzRGF0YSA9IHJlcXVpcmUoJy4vQ2xhc3NEYXRhJyk7XG5pbXBvcnQgdGhyZWFkaW5nID0gcmVxdWlyZSgnLi90aHJlYWRpbmcnKTtcbmltcG9ydCBDbGFzc0xvYWRlciA9IHJlcXVpcmUoJy4vQ2xhc3NMb2FkZXInKTtcbmltcG9ydCBlbnVtcyA9IHJlcXVpcmUoJy4vZW51bXMnKTtcbmltcG9ydCBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuaW1wb3J0IG1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcbmltcG9ydCBKVk1UeXBlcyA9IHJlcXVpcmUoJy4uL2luY2x1ZGVzL0pWTVR5cGVzJyk7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBpbmRpdmlkdWFsIG9wY29kZSBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSU9wY29kZUltcGxlbWVudGF0aW9uIHtcbiAgKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU/OiBCdWZmZXIpOiB2b2lkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbjogQ2hlY2tzIGlmIG9iamVjdCBpcyBudWxsLiBUaHJvd3MgYSBOdWxsUG9pbnRlckV4Y2VwdGlvblxuICogaWYgaXQgaXMuXG4gKiBAcmV0dXJuIFRydWUgaWYgdGhlIG9iamVjdCBpcyBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIG9iajogYW55KTogYm9vbGVhbiB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRocm93RXhjZXB0aW9uKHRocmVhZCwgZnJhbWUsICdMamF2YS9sYW5nL051bGxQb2ludGVyRXhjZXB0aW9uOycsICcnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uOiBQb3BzIG9mZiB0d28gaXRlbXMsIHJldHVybnMgdGhlIHNlY29uZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvcDIob3BTdGFjazogYW55W10pOiBhbnkge1xuICAvLyBJZ25vcmUgTlVMTC5cbiAgb3BTdGFjay5wb3AoKTtcbiAgcmV0dXJuIG9wU3RhY2sucG9wKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ1BJdGVtKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNwSXRlbTogQ29uc3RhbnRQb29sLklDb25zdGFudFBvb2xJdGVtKTogdm9pZCB7XG4gIHRocmVhZC5zZXRTdGF0dXMoZW51bXMuVGhyZWFkU3RhdHVzLkFTWU5DX1dBSVRJTkcpO1xuICBjcEl0ZW0ucmVzb2x2ZSh0aHJlYWQsIGZyYW1lLmdldExvYWRlcigpLCBmcmFtZS5tZXRob2QuY2xzLCAoc3RhdHVzOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKHN0YXR1cykge1xuICAgICAgdGhyZWFkLnNldFN0YXR1cyhlbnVtcy5UaHJlYWRTdGF0dXMuUlVOTkFCTEUpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUNsYXNzRnJvbUNsYXNzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNsczogQ2xhc3NEYXRhLkNsYXNzRGF0YSk6IHZvaWQge1xuICB0aHJlYWQuc2V0U3RhdHVzKGVudW1zLlRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HKTtcbiAgY2xzLmluaXRpYWxpemUodGhyZWFkLCAoY2RhdGE6IENsYXNzRGF0YS5DbGFzc0RhdGEpID0+IHtcbiAgICBpZiAoY2RhdGEgIT0gbnVsbCkge1xuICAgICAgdGhyZWFkLnNldFN0YXR1cyhlbnVtcy5UaHJlYWRTdGF0dXMuUlVOTkFCTEUpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xuICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbjogUGF1c2VzIHRoZSB0aHJlYWQgYW5kIGluaXRpYWxpemVzIGEgY2xhc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQ2xhc3ModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY2xzUmVmOiBDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2UpOiB2b2lkIHtcbiAgdGhyZWFkLnNldFN0YXR1cyhlbnVtcy5UaHJlYWRTdGF0dXMuQVNZTkNfV0FJVElORyk7XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZShjbHM6IENsYXNzRGF0YS5DbGFzc0RhdGEpIHtcbiAgICBjbHMuaW5pdGlhbGl6ZSh0aHJlYWQsIChjZGF0YTogQ2xhc3NEYXRhLkNsYXNzRGF0YSkgPT4ge1xuICAgICAgaWYgKGNkYXRhICE9IG51bGwpIHtcbiAgICAgICAgdGhyZWFkLnNldFN0YXR1cyhlbnVtcy5UaHJlYWRTdGF0dXMuUlVOTkFCTEUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFjbHNSZWYuaXNSZXNvbHZlZCgpKSB7XG4gICAgY2xzUmVmLnJlc29sdmUodGhyZWFkLCBmcmFtZS5nZXRMb2FkZXIoKSwgZnJhbWUubWV0aG9kLmNscywgKHN0YXR1czogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBpbml0aWFsaXplKGNsc1JlZi5jbHMpO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsaXplKGNsc1JlZi5jbHMpO1xuICB9XG4gIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG59XG5cbi8qKlxuICogSW50ZXJydXB0cyB0aGUgY3VycmVudCBtZXRob2QncyBleGVjdXRpb24gYW5kIHRocm93cyBhbiBleGNlcHRpb24uXG4gKlxuICogTk9URTogVGhpcyBkb2VzICpub3QqIGludGVycnVwdCBKYXZhU2NyaXB0IGNvbnRyb2wgZmxvdywgc28gYW55IG9wY29kZVxuICogY2FsbGluZyB0aGlzIGZ1bmN0aW9uIG11c3QgKnJldHVybiogYW5kIG5vdCBkbyBhbnl0aGluZyBlbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dFeGNlcHRpb248VCBleHRlbmRzIEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGU+KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNsc05hbWU6IHN0cmluZywgbXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgdGhyZWFkLnRocm93TmV3RXhjZXB0aW9uPFQ+KGNsc05hbWUsIG1zZyk7XG4gIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG59XG5cbmV4cG9ydCB2YXIgQXJyYXlUeXBlcyA6IHtbdDogbnVtYmVyXTogc3RyaW5nOyB9ID0ge1xuICA0OiAnWicsIDU6ICdDJywgNjogJ0YnLCA3OiAnRCcsIDg6ICdCJywgOTogJ1MnLCAxMDogJ0knLCAxMTogJ0onXG59O1xuXG4vKipcbiAqIENvbnRhaW5zIGRlZmluaXRpb25zIGZvciBhbGwgSlZNIG9wY29kZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGNvZGVzIHtcbiAgLyogMzItYml0IGFycmF5IGxvYWQgb3Bjb2RlcyAqL1xuXG4gIC8qKlxuICAgKiAzMi1iaXQgYXJyYXkgbG9hZCBvcGNvZGVcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIF9hbG9hZF8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLFxuICAgICAgaWR4ID0gb3BTdGFjay5wb3AoKSxcbiAgICAgIG9iaiA9IDxKVk1UeXBlcy5KVk1BcnJheTxhbnk+PiBvcFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXNOdWxsKHRocmVhZCwgZnJhbWUsIG9iaikpIHtcbiAgICAgIHZhciBsZW4gPSBvYmouYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IGxlbikge1xuICAgICAgICB0aHJvd0V4Y2VwdGlvbih0aHJlYWQsIGZyYW1lLCAnTGphdmEvbGFuZy9BcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb247JywgYCR7aWR4fSBub3QgaW4gbGVuZ3RoICR7bGVufSBhcnJheSBvZiB0eXBlICR7b2JqLmdldENsYXNzKCkuZ2V0SW50ZXJuYWxOYW1lKCl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcFN0YWNrLnB1c2gob2JqLmFycmF5W2lkeF0pO1xuICAgICAgICBmcmFtZS5wYysrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAnb2JqJyBpcyBOVUxMLiBpc051bGwgdGhyZXcgYW4gZXhjZXB0aW9uIGZvciB1cy5cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWFsb2FkID0gT3Bjb2Rlcy5fYWxvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZmFsb2FkID0gT3Bjb2Rlcy5fYWxvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgYWFsb2FkID0gT3Bjb2Rlcy5fYWxvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgYmFsb2FkID0gT3Bjb2Rlcy5fYWxvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgY2Fsb2FkID0gT3Bjb2Rlcy5fYWxvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgc2Fsb2FkID0gT3Bjb2Rlcy5fYWxvYWRfMzI7XG5cbiAgLyogNjQtYml0IGFycmF5IGxvYWQgb3Bjb2RlcyAqL1xuXG4gIC8qKlxuICAgKiA2NC1iaXQgYXJyYXkgbG9hZCBvcGNvZGUuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfYWxvYWRfNjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIGlkeCA9IG9wU3RhY2sucG9wKCksXG4gICAgICBvYmogPSA8SlZNVHlwZXMuSlZNQXJyYXk8YW55Pj4gb3BTdGFjay5wb3AoKTtcbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICB2YXIgbGVuID0gb2JqLmFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChpZHggPCAwIHx8IGlkeCA+PSBsZW4pIHtcbiAgICAgICAgdGhyb3dFeGNlcHRpb24odGhyZWFkLCBmcmFtZSwgJ0xqYXZhL2xhbmcvQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uOycsIGAke2lkeH0gbm90IGluIGxlbmd0aCAke2xlbn0gYXJyYXkgb2YgdHlwZSAke29iai5nZXRDbGFzcygpLmdldEludGVybmFsTmFtZSgpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BTdGFjay5wdXNoKG9iai5hcnJheVtpZHhdKTtcbiAgICAgICAgLy8gNjQtYml0IHZhbHVlLlxuICAgICAgICBvcFN0YWNrLnB1c2gobnVsbCk7XG4gICAgICAgIGZyYW1lLnBjKys7XG4gICAgICB9XG4gICAgfVxuICAgIC8vICdvYmonIGlzIE5VTEwuIGlzTnVsbCB0aHJldyBhbiBleGNlcHRpb24gZm9yIHVzLlxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkYWxvYWQgPSBPcGNvZGVzLl9hbG9hZF82NDtcbiAgcHVibGljIHN0YXRpYyBsYWxvYWQgPSBPcGNvZGVzLl9hbG9hZF82NDtcblxuICAvKiAzMi1iaXQgYXJyYXkgc3RvcmUgb3Bjb2RlcyAqL1xuXG4gIC8qKlxuICAgKiAzMi1iaXQgYXJyYXkgc3RvcmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfYXN0b3JlXzMyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2YWx1ZSA9IG9wU3RhY2sucG9wKCksXG4gICAgICBpZHggPSBvcFN0YWNrLnBvcCgpLFxuICAgICAgb2JqID0gPEpWTVR5cGVzLkpWTUFycmF5PGFueT4+IG9wU3RhY2sucG9wKCk7XG4gICAgaWYgKCFpc051bGwodGhyZWFkLCBmcmFtZSwgb2JqKSkge1xuICAgICAgdmFyIGxlbiA9IG9iai5hcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaWR4IDwgMCB8fCBpZHggPj0gbGVuKSB7XG4gICAgICAgIHRocm93RXhjZXB0aW9uKHRocmVhZCwgZnJhbWUsICdMamF2YS9sYW5nL0FycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjsnLCBgJHtpZHh9IG5vdCBpbiBsZW5ndGggJHtsZW59IGFycmF5IG9mIHR5cGUgJHtvYmouZ2V0Q2xhc3MoKS5nZXRJbnRlcm5hbE5hbWUoKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5hcnJheVtpZHhdID0gdmFsdWU7XG4gICAgICAgIGZyYW1lLnBjKys7XG4gICAgICB9XG4gICAgfVxuICAgIC8vICdvYmonIGlzIE5VTEwuIGlzTnVsbCB0aHJldyBhbiBleGNlcHRpb24gZm9yIHVzLlxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpYXN0b3JlID0gT3Bjb2Rlcy5fYXN0b3JlXzMyO1xuICBwdWJsaWMgc3RhdGljIGZhc3RvcmUgPSBPcGNvZGVzLl9hc3RvcmVfMzI7XG4gIHB1YmxpYyBzdGF0aWMgYWFzdG9yZSA9IE9wY29kZXMuX2FzdG9yZV8zMjtcbiAgcHVibGljIHN0YXRpYyBiYXN0b3JlID0gT3Bjb2Rlcy5fYXN0b3JlXzMyO1xuICBwdWJsaWMgc3RhdGljIGNhc3RvcmUgPSBPcGNvZGVzLl9hc3RvcmVfMzI7XG4gIHB1YmxpYyBzdGF0aWMgc2FzdG9yZSA9IE9wY29kZXMuX2FzdG9yZV8zMjtcblxuICAvKiA2NC1iaXQgYXJyYXkgc3RvcmUgb3Bjb2RlcyAqL1xuXG4gIC8qKlxuICAgKiA2NC1iaXQgYXJyYXkgc3RvcmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBfYXN0b3JlXzY0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2YWx1ZSA9IG9wU3RhY2sucG9wMigpLFxuICAgICAgaWR4ID0gb3BTdGFjay5wb3AoKSxcbiAgICAgIG9iaiA9IDxKVk1UeXBlcy5KVk1BcnJheTxhbnk+PiBvcFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXNOdWxsKHRocmVhZCwgZnJhbWUsIG9iaikpIHtcbiAgICAgIHZhciBsZW4gPSBvYmouYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGlkeCA8IDAgfHwgaWR4ID49IGxlbikge1xuICAgICAgICB0aHJvd0V4Y2VwdGlvbih0aHJlYWQsIGZyYW1lLCAnTGphdmEvbGFuZy9BcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb247JywgYCR7aWR4fSBub3QgaW4gbGVuZ3RoICR7bGVufSBhcnJheSBvZiB0eXBlICR7b2JqLmdldENsYXNzKCkuZ2V0SW50ZXJuYWxOYW1lKCl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmouYXJyYXlbaWR4XSA9IHZhbHVlO1xuICAgICAgICBmcmFtZS5wYysrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAnb2JqJyBpcyBOVUxMLiBpc051bGwgdGhyZXcgYW4gZXhjZXB0aW9uIGZvciB1cy5cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGFzdG9yZSA9IE9wY29kZXMuX2FzdG9yZV82NDtcbiAgcHVibGljIHN0YXRpYyBkYXN0b3JlID0gT3Bjb2Rlcy5fYXN0b3JlXzY0O1xuXG4gIC8qIDMyLWJpdCBjb25zdGFudHMgKi9cbiAgcHVibGljIHN0YXRpYyBhY29uc3RfbnVsbCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKG51bGwpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfY29uc3RfMF8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKDApO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfY29uc3RfMV8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKDEpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfY29uc3RfMl8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKDIpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGljb25zdF9tMSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKC0xKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpY29uc3RfMCA9IE9wY29kZXMuX2NvbnN0XzBfMzI7XG4gIHB1YmxpYyBzdGF0aWMgaWNvbnN0XzEgPSBPcGNvZGVzLl9jb25zdF8xXzMyO1xuICBwdWJsaWMgc3RhdGljIGljb25zdF8yID0gT3Bjb2Rlcy5fY29uc3RfMl8zMjtcblxuICBwdWJsaWMgc3RhdGljIGljb25zdF8zKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goMyk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWNvbnN0XzQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2sucHVzaCg0KTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpY29uc3RfNSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKDUpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZjb25zdF8wID0gT3Bjb2Rlcy5fY29uc3RfMF8zMjtcbiAgcHVibGljIHN0YXRpYyBmY29uc3RfMSA9IE9wY29kZXMuX2NvbnN0XzFfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZmNvbnN0XzIgPSBPcGNvZGVzLl9jb25zdF8yXzMyO1xuXG4gIC8qIDY0LWJpdCBjb25zdGFudHMgKi9cbiAgcHVibGljIHN0YXRpYyBsY29uc3RfMCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZ0xvbmcuWkVSTyk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGNvbnN0XzEodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2sucHVzaFdpdGhOdWxsKGdMb25nLk9ORSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZGNvbnN0XzAodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2sucHVzaFdpdGhOdWxsKDApO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGRjb25zdF8xKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2hXaXRoTnVsbCgxKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgLyogMzItYml0IGxvYWQgb3Bjb2RlcyAqL1xuICBwcml2YXRlIHN0YXRpYyBfbG9hZF8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGZyYW1lLm9wU3RhY2sucHVzaChmcmFtZS5sb2NhbHNbY29kZS5yZWFkVUludDgocGMgKyAxKV0pO1xuICAgIGZyYW1lLnBjICs9IDI7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfbG9hZF8wXzMyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goZnJhbWUubG9jYWxzWzBdKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2xvYWRfMV8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKGZyYW1lLmxvY2Fsc1sxXSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIF9sb2FkXzJfMzIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2sucHVzaChmcmFtZS5sb2NhbHNbMl0pO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfbG9hZF8zXzMyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goZnJhbWUubG9jYWxzWzNdKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpbG9hZCA9IE9wY29kZXMuX2xvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgaWxvYWRfMCA9IE9wY29kZXMuX2xvYWRfMF8zMjtcbiAgcHVibGljIHN0YXRpYyBpbG9hZF8xID0gT3Bjb2Rlcy5fbG9hZF8xXzMyO1xuICBwdWJsaWMgc3RhdGljIGlsb2FkXzIgPSBPcGNvZGVzLl9sb2FkXzJfMzI7XG4gIHB1YmxpYyBzdGF0aWMgaWxvYWRfMyA9IE9wY29kZXMuX2xvYWRfM18zMjtcbiAgcHVibGljIHN0YXRpYyBmbG9hZCA9IE9wY29kZXMuX2xvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZmxvYWRfMCA9IE9wY29kZXMuX2xvYWRfMF8zMjtcbiAgcHVibGljIHN0YXRpYyBmbG9hZF8xID0gT3Bjb2Rlcy5fbG9hZF8xXzMyO1xuICBwdWJsaWMgc3RhdGljIGZsb2FkXzIgPSBPcGNvZGVzLl9sb2FkXzJfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZmxvYWRfMyA9IE9wY29kZXMuX2xvYWRfM18zMjtcbiAgcHVibGljIHN0YXRpYyBhbG9hZCA9IE9wY29kZXMuX2xvYWRfMzI7XG4gIHB1YmxpYyBzdGF0aWMgYWxvYWRfMCA9IE9wY29kZXMuX2xvYWRfMF8zMjtcbiAgcHVibGljIHN0YXRpYyBhbG9hZF8xID0gT3Bjb2Rlcy5fbG9hZF8xXzMyO1xuICBwdWJsaWMgc3RhdGljIGFsb2FkXzIgPSBPcGNvZGVzLl9sb2FkXzJfMzI7XG4gIHB1YmxpYyBzdGF0aWMgYWxvYWRfMyA9IE9wY29kZXMuX2xvYWRfM18zMjtcblxuICAvKiA2NC1iaXQgbG9hZCBvcGNvZGVzICovXG4gIHByaXZhdGUgc3RhdGljIF9sb2FkXzY0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZnJhbWUubG9jYWxzW2NvZGUucmVhZFVJbnQ4KHBjICsgMSldKTtcbiAgICBmcmFtZS5wYyArPSAyO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2xvYWRfMF82NCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZnJhbWUubG9jYWxzWzBdKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2xvYWRfMV82NCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZnJhbWUubG9jYWxzWzFdKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2xvYWRfMl82NCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZnJhbWUubG9jYWxzWzJdKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2xvYWRfM182NCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZnJhbWUubG9jYWxzWzNdKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBsbG9hZCA9IE9wY29kZXMuX2xvYWRfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgbGxvYWRfMCA9IE9wY29kZXMuX2xvYWRfMF82NDtcbiAgcHVibGljIHN0YXRpYyBsbG9hZF8xID0gT3Bjb2Rlcy5fbG9hZF8xXzY0O1xuICBwdWJsaWMgc3RhdGljIGxsb2FkXzIgPSBPcGNvZGVzLl9sb2FkXzJfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgbGxvYWRfMyA9IE9wY29kZXMuX2xvYWRfM182NDtcbiAgcHVibGljIHN0YXRpYyBkbG9hZCA9IE9wY29kZXMuX2xvYWRfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgZGxvYWRfMCA9IE9wY29kZXMuX2xvYWRfMF82NDtcbiAgcHVibGljIHN0YXRpYyBkbG9hZF8xID0gT3Bjb2Rlcy5fbG9hZF8xXzY0O1xuICBwdWJsaWMgc3RhdGljIGRsb2FkXzIgPSBPcGNvZGVzLl9sb2FkXzJfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgZGxvYWRfMyA9IE9wY29kZXMuX2xvYWRfM182NDtcblxuICAvKiAzMi1iaXQgc3RvcmUgb3Bjb2RlcyAqL1xuICBwcml2YXRlIHN0YXRpYyBfc3RvcmVfMzIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICBmcmFtZS5sb2NhbHNbY29kZS5yZWFkVUludDgocGMgKyAxKV0gPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIGZyYW1lLnBjICs9IDI7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfc3RvcmVfMF8zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUubG9jYWxzWzBdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3N0b3JlXzFfMzIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLmxvY2Fsc1sxXSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIF9zdG9yZV8yXzMyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5sb2NhbHNbMl0gPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfc3RvcmVfM18zMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUubG9jYWxzWzNdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpc3RvcmUgPSBPcGNvZGVzLl9zdG9yZV8zMjtcbiAgcHVibGljIHN0YXRpYyBpc3RvcmVfMCA9IE9wY29kZXMuX3N0b3JlXzBfMzI7XG4gIHB1YmxpYyBzdGF0aWMgaXN0b3JlXzEgPSBPcGNvZGVzLl9zdG9yZV8xXzMyO1xuICBwdWJsaWMgc3RhdGljIGlzdG9yZV8yID0gT3Bjb2Rlcy5fc3RvcmVfMl8zMjtcbiAgcHVibGljIHN0YXRpYyBpc3RvcmVfMyA9IE9wY29kZXMuX3N0b3JlXzNfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZnN0b3JlID0gT3Bjb2Rlcy5fc3RvcmVfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZnN0b3JlXzAgPSBPcGNvZGVzLl9zdG9yZV8wXzMyO1xuICBwdWJsaWMgc3RhdGljIGZzdG9yZV8xID0gT3Bjb2Rlcy5fc3RvcmVfMV8zMjtcbiAgcHVibGljIHN0YXRpYyBmc3RvcmVfMiA9IE9wY29kZXMuX3N0b3JlXzJfMzI7XG4gIHB1YmxpYyBzdGF0aWMgZnN0b3JlXzMgPSBPcGNvZGVzLl9zdG9yZV8zXzMyO1xuICBwdWJsaWMgc3RhdGljIGFzdG9yZSA9IE9wY29kZXMuX3N0b3JlXzMyO1xuICBwdWJsaWMgc3RhdGljIGFzdG9yZV8wID0gT3Bjb2Rlcy5fc3RvcmVfMF8zMjtcbiAgcHVibGljIHN0YXRpYyBhc3RvcmVfMSA9IE9wY29kZXMuX3N0b3JlXzFfMzI7XG4gIHB1YmxpYyBzdGF0aWMgYXN0b3JlXzIgPSBPcGNvZGVzLl9zdG9yZV8yXzMyO1xuICBwdWJsaWMgc3RhdGljIGFzdG9yZV8zID0gT3Bjb2Rlcy5fc3RvcmVfM18zMjtcblxuICAvKiA2NC1iaXQgc3RvcmUgb3Bjb2RlcyAqL1xuICBwcml2YXRlIHN0YXRpYyBfc3RvcmVfNjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgb2Zmc2V0ID0gY29kZS5yZWFkVUludDgocGMgKyAxKTtcbiAgICAvLyBOVUxMXG4gICAgZnJhbWUubG9jYWxzW29mZnNldCArIDFdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlLlxuICAgIGZyYW1lLmxvY2Fsc1tvZmZzZXRdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYyArPSAyO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3N0b3JlXzBfNjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLmxvY2Fsc1sxXSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgZnJhbWUubG9jYWxzWzBdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3N0b3JlXzFfNjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLmxvY2Fsc1syXSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgZnJhbWUubG9jYWxzWzFdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3N0b3JlXzJfNjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLmxvY2Fsc1szXSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgZnJhbWUubG9jYWxzWzJdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3N0b3JlXzNfNjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLmxvY2Fsc1s0XSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgZnJhbWUubG9jYWxzWzNdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBsc3RvcmUgPSBPcGNvZGVzLl9zdG9yZV82NDtcbiAgcHVibGljIHN0YXRpYyBsc3RvcmVfMCA9IE9wY29kZXMuX3N0b3JlXzBfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgbHN0b3JlXzEgPSBPcGNvZGVzLl9zdG9yZV8xXzY0O1xuICBwdWJsaWMgc3RhdGljIGxzdG9yZV8yID0gT3Bjb2Rlcy5fc3RvcmVfMl82NDtcbiAgcHVibGljIHN0YXRpYyBsc3RvcmVfMyA9IE9wY29kZXMuX3N0b3JlXzNfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgZHN0b3JlID0gT3Bjb2Rlcy5fc3RvcmVfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgZHN0b3JlXzAgPSBPcGNvZGVzLl9zdG9yZV8wXzY0O1xuICBwdWJsaWMgc3RhdGljIGRzdG9yZV8xID0gT3Bjb2Rlcy5fc3RvcmVfMV82NDtcbiAgcHVibGljIHN0YXRpYyBkc3RvcmVfMiA9IE9wY29kZXMuX3N0b3JlXzJfNjQ7XG4gIHB1YmxpYyBzdGF0aWMgZHN0b3JlXzMgPSBPcGNvZGVzLl9zdG9yZV8zXzY0O1xuXG4gIC8qIE1pc2MuICovXG5cbiAgcHVibGljIHN0YXRpYyBzaXB1c2godGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goY29kZS5yZWFkSW50MTZCRShwYyArIDEpKTtcbiAgICBmcmFtZS5wYyArPSAzO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBiaXB1c2godGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goY29kZS5yZWFkSW50OChwYyArIDEpKTtcbiAgICBmcmFtZS5wYyArPSAyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwb3AodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2suZHJvcEZyb21Ub3AoMSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcG9wMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgLy8gaHR0cDovL2kuaW1ndXIuY29tL01pZUYwS0cuanBnXG4gICAgZnJhbWUub3BTdGFjay5kcm9wRnJvbVRvcCgyKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkdXAodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2suZHVwKCk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZHVwX3gxKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLmR1cF94MSgpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGR1cF94Mih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5kdXBfeDIoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkdXAyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLmR1cDIoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkdXAyX3gxKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLmR1cDJfeDEoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkdXAyX3gyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2MSA9IG9wU3RhY2sucG9wKCksXG4gICAgICB2MiA9IG9wU3RhY2sucG9wKCksXG4gICAgICB2MyA9IG9wU3RhY2sucG9wKCksXG4gICAgICB2NCA9IG9wU3RhY2sucG9wKCk7XG4gICAgb3BTdGFjay5wdXNoNih2MiwgdjEsIHY0LCB2MywgdjIsIHYxKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBzd2FwKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICBmcmFtZS5vcFN0YWNrLnN3YXAoKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgLyogTWF0aCBPcGNvZGVzICovXG4gIHB1YmxpYyBzdGF0aWMgaWFkZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaCgob3BTdGFjay5wb3AoKSArIG9wU3RhY2sucG9wKCkpIHwgMCk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGFkZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKG9wU3RhY2sucG9wMigpLmFkZChvcFN0YWNrLnBvcDIoKSkpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZhZGQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2godXRpbC53cmFwRmxvYXQob3BTdGFjay5wb3AoKSArIG9wU3RhY2sucG9wKCkpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkYWRkKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkgKyBvcFN0YWNrLnBvcDIoKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXN1Yih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaCgoLW9wU3RhY2sucG9wKCkgKyBvcFN0YWNrLnBvcCgpKSB8IDApO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZzdWIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2godXRpbC53cmFwRmxvYXQoLW9wU3RhY2sucG9wKCkgKyBvcFN0YWNrLnBvcCgpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZHN1Yih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKC1vcFN0YWNrLnBvcDIoKSArIG9wU3RhY2sucG9wMigpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBsc3ViKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkubmVnYXRlKCkuYWRkKG9wU3RhY2sucG9wMigpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaW11bCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaCgoPGFueT4gTWF0aCkuaW11bChvcFN0YWNrLnBvcCgpLCBvcFN0YWNrLnBvcCgpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbG11bCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKG9wU3RhY2sucG9wMigpLm11bHRpcGx5KG9wU3RhY2sucG9wMigpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZm11bCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaCh1dGlsLndyYXBGbG9hdChvcFN0YWNrLnBvcCgpICogb3BTdGFjay5wb3AoKSkpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGRtdWwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2hXaXRoTnVsbChvcFN0YWNrLnBvcDIoKSAqIG9wU3RhY2sucG9wMigpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpZGl2KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssIGI6IG51bWJlciA9IG9wU3RhY2sucG9wKCksIGE6IG51bWJlciA9IG9wU3RhY2sucG9wKCk7XG4gICAgaWYgKGIgPT09IDApIHtcbiAgICAgIHRocm93RXhjZXB0aW9uKHRocmVhZCwgZnJhbWUsICdMamF2YS9sYW5nL0FyaXRobWV0aWNFeGNlcHRpb247JywgJy8gYnkgemVybycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzcGVjOiBcImlmIHRoZSBkaXZpZGVuZCBpcyB0aGUgbmVnYXRpdmUgaW50ZWdlciBvZiBsYXJnZXN0IHBvc3NpYmxlIG1hZ25pdHVkZVxuICAgICAgLy8gZm9yIHRoZSBpbnQgdHlwZSwgYW5kIHRoZSBkaXZpc29yIGlzIC0xLCB0aGVuIG92ZXJmbG93IG9jY3VycywgYW5kIHRoZVxuICAgICAgLy8gcmVzdWx0IGlzIGVxdWFsIHRvIHRoZSBkaXZpZGVuZC5cIlxuICAgICAgaWYgKGEgPT09IGVudW1zLkNvbnN0YW50cy5JTlRfTUlOICYmIGIgPT09IC0xKSB7XG4gICAgICAgIG9wU3RhY2sucHVzaChhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wU3RhY2sucHVzaCgoYSAvIGIpIHwgMCk7XG4gICAgICB9XG4gICAgICBmcmFtZS5wYysrO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGRpdih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLFxuICAgICAgYjogZ0xvbmcgPSBvcFN0YWNrLnBvcDIoKSxcbiAgICAgIGE6IGdMb25nID0gb3BTdGFjay5wb3AyKCk7XG4gICAgaWYgKGIuaXNaZXJvKCkpIHtcbiAgICAgIHRocm93RXhjZXB0aW9uKHRocmVhZCwgZnJhbWUsICdMamF2YS9sYW5nL0FyaXRobWV0aWNFeGNlcHRpb247JywgJy8gYnkgemVybycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcFN0YWNrLnB1c2hXaXRoTnVsbChhLmRpdihiKSk7XG4gICAgICBmcmFtZS5wYysrO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZmRpdih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLFxuICAgICAgYTogbnVtYmVyID0gb3BTdGFjay5wb3AoKTtcbiAgICBvcFN0YWNrLnB1c2godXRpbC53cmFwRmxvYXQob3BTdGFjay5wb3AoKSAvIGEpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkZGl2KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2OiBudW1iZXIgPSBvcFN0YWNrLnBvcDIoKTtcbiAgICBvcFN0YWNrLnB1c2hXaXRoTnVsbChvcFN0YWNrLnBvcDIoKSAvIHYpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlyZW0odGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIGI6IG51bWJlciA9IG9wU3RhY2sucG9wKCksXG4gICAgICBhOiBudW1iZXIgPSBvcFN0YWNrLnBvcCgpO1xuICAgIGlmIChiID09PSAwKSB7XG4gICAgICB0aHJvd0V4Y2VwdGlvbih0aHJlYWQsIGZyYW1lLCAnTGphdmEvbGFuZy9Bcml0aG1ldGljRXhjZXB0aW9uOycsICcvIGJ5IHplcm8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BTdGFjay5wdXNoKGEgJSBiKTtcbiAgICAgIGZyYW1lLnBjKys7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBscmVtKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBiOiBnTG9uZyA9IG9wU3RhY2sucG9wMigpLFxuICAgICAgYTogZ0xvbmcgPSBvcFN0YWNrLnBvcDIoKTtcbiAgICBpZiAoYi5pc1plcm8oKSkge1xuICAgICAgdGhyb3dFeGNlcHRpb24odGhyZWFkLCBmcmFtZSwgJ0xqYXZhL2xhbmcvQXJpdGhtZXRpY0V4Y2VwdGlvbjsnLCAnLyBieSB6ZXJvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKGEubW9kdWxvKGIpKTtcbiAgICAgIGZyYW1lLnBjKys7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcmVtKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBiOiBudW1iZXIgPSBvcFN0YWNrLnBvcCgpO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcCgpICUgYik7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZHJlbSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLFxuICAgICAgYjogbnVtYmVyID0gb3BTdGFjay5wb3AyKCk7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkgJSBiKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpbmVnKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoKC1vcFN0YWNrLnBvcCgpIHwgMCk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbG5lZyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKG9wU3RhY2sucG9wMigpLm5lZ2F0ZSgpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmbmVnKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoKC1vcFN0YWNrLnBvcCgpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkbmVnKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwoLW9wU3RhY2sucG9wMigpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgLyogQml0d2lzZSBPcGVyYXRpb25zICovXG5cbiAgcHVibGljIHN0YXRpYyBpc2hsKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBzOiBudW1iZXIgPSBvcFN0YWNrLnBvcCgpO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcCgpIDw8IHMpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGxzaGwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIHM6IG51bWJlciA9IG9wU3RhY2sucG9wKCk7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkuc2hpZnRMZWZ0KGdMb25nLmZyb21JbnQocykpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpc2hyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBzOiBudW1iZXIgPSBvcFN0YWNrLnBvcCgpO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcCgpID4+IHMpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGxzaHIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIHM6IG51bWJlciA9IG9wU3RhY2sucG9wKCk7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkuc2hpZnRSaWdodChnTG9uZy5mcm9tSW50KHMpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXVzaHIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIHM6IG51bWJlciA9IG9wU3RhY2sucG9wKCk7XG4gICAgb3BTdGFjay5wdXNoKChvcFN0YWNrLnBvcCgpID4+PiBzKSB8IDApO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGx1c2hyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBzOiBudW1iZXIgPSBvcFN0YWNrLnBvcCgpO1xuICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKG9wU3RhY2sucG9wMigpLnNoaWZ0UmlnaHRVbnNpZ25lZChnTG9uZy5mcm9tSW50KHMpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWFuZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcCgpICYgb3BTdGFjay5wb3AoKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGFuZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKG9wU3RhY2sucG9wMigpLmFuZChvcFN0YWNrLnBvcDIoKSkpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlvcih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcCgpIHwgb3BTdGFjay5wb3AoKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbG9yKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkub3Iob3BTdGFjay5wb3AyKCkpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpeG9yKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoKG9wU3RhY2sucG9wKCkgXiBvcFN0YWNrLnBvcCgpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBseG9yKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkueG9yKG9wU3RhY2sucG9wMigpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWluYyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBpZHggPSBjb2RlLnJlYWRVSW50OChwYyArIDEpLFxuICAgICAgdmFsID0gY29kZS5yZWFkSW50OChwYyArIDIpO1xuICAgIGZyYW1lLmxvY2Fsc1tpZHhdID0gKGZyYW1lLmxvY2Fsc1tpZHhdICsgdmFsKSB8IDA7XG4gICAgZnJhbWUucGMgKz0gMztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaTJsKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwoZ0xvbmcuZnJvbUludChvcFN0YWNrLnBvcCgpKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaTJmKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICAvLyBOT1A7IHdlIHJlcHJlc2VudCBpbnRzIGFzIGZsb2F0cyBhbnl3YXkuXG4gICAgLy8gQHRvZG8gV2hhdCBhYm91dCBxdWFudGl0aWVzIHVuZXhwcmVzc2FibGUgYXMgZmxvYXRzP1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGkyZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKG51bGwpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGwyaSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcDIoKS50b0ludCgpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBsMmYodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2gob3BTdGFjay5wb3AyKCkudG9OdW1iZXIoKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbDJkKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoV2l0aE51bGwob3BTdGFjay5wb3AyKCkudG9OdW1iZXIoKSk7XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZjJpKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wdXNoKHV0aWwuZmxvYXQyaW50KG9wU3RhY2sucG9wKCkpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmMmwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2hXaXRoTnVsbChnTG9uZy5mcm9tTnVtYmVyKG9wU3RhY2sucG9wKCkpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmMmQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLm9wU3RhY2sucHVzaChudWxsKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkMmkodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2godXRpbC5mbG9hdDJpbnQob3BTdGFjay5wb3AyKCkpKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkMmwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIGRfdmFsOiBudW1iZXIgPSBvcFN0YWNrLnBvcDIoKTtcbiAgICBpZiAoZF92YWwgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgb3BTdGFjay5wdXNoV2l0aE51bGwoZ0xvbmcuTUFYX1ZBTFVFKTtcbiAgICB9IGVsc2UgaWYgKGRfdmFsID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKGdMb25nLk1JTl9WQUxVRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wU3RhY2sucHVzaFdpdGhOdWxsKGdMb25nLmZyb21OdW1iZXIoZF92YWwpKTtcbiAgICB9XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZDJmKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2s7XG4gICAgb3BTdGFjay5wb3AoKTtcbiAgICBvcFN0YWNrLnB1c2godXRpbC53cmFwRmxvYXQob3BTdGFjay5wb3AoKSkpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGkyYih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaCgob3BTdGFjay5wb3AoKSA8PCAyNCkgPj4gMjQpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGkyYyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrO1xuICAgIG9wU3RhY2sucHVzaChvcFN0YWNrLnBvcCgpICYgMHhGRkZGKTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpMnModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaztcbiAgICBvcFN0YWNrLnB1c2goKG9wU3RhY2sucG9wKCkgPDwgMTYpID4+IDE2KTtcbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBsY21wKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2MjogZ0xvbmcgPSBvcFN0YWNrLnBvcDIoKTtcbiAgICBvcFN0YWNrLnB1c2gob3BTdGFjay5wb3AyKCkuY29tcGFyZSh2MikpO1xuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZjbXBsKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2MiA9IG9wU3RhY2sucG9wKCksXG4gICAgICB2MSA9IG9wU3RhY2sucG9wKCk7XG4gICAgaWYgKHYxID09PSB2Mikge1xuICAgICAgb3BTdGFjay5wdXNoKDApO1xuICAgIH0gZWxzZSBpZiAodjEgPiB2Mikge1xuICAgICAgb3BTdGFjay5wdXNoKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2MSA8IHYyLCBhbmQgaWYgdjEgb3IgdjIgaXMgTmFOLlxuICAgICAgb3BTdGFjay5wdXNoKC0xKTtcbiAgICB9XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZmNtcGcodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIHYyID0gb3BTdGFjay5wb3AoKSxcbiAgICAgIHYxID0gb3BTdGFjay5wb3AoKTtcbiAgICBpZiAodjEgPT09IHYyKSB7XG4gICAgICBvcFN0YWNrLnB1c2goMCk7XG4gICAgfSBlbHNlIGlmICh2MSA8IHYyKSB7XG4gICAgICBvcFN0YWNrLnB1c2goLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2MSA+IHYyLCBhbmQgaWYgdjEgb3IgdjIgaXMgTmFOLlxuICAgICAgb3BTdGFjay5wdXNoKDEpO1xuICAgIH1cbiAgICBmcmFtZS5wYysrO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkY21wbCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLFxuICAgICAgdjIgPSBvcFN0YWNrLnBvcDIoKSxcbiAgICAgIHYxID0gb3BTdGFjay5wb3AyKCk7XG4gICAgaWYgKHYxID09PSB2Mikge1xuICAgICAgb3BTdGFjay5wdXNoKDApO1xuICAgIH0gZWxzZSBpZiAodjEgPiB2Mikge1xuICAgICAgb3BTdGFjay5wdXNoKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2MSA8IHYyLCBhbmQgaWYgdjEgb3IgdjIgaXMgTmFOLlxuICAgICAgb3BTdGFjay5wdXNoKC0xKTtcbiAgICB9XG4gICAgZnJhbWUucGMrKztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZGNtcGcodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIHYyID0gb3BTdGFjay5wb3AyKCksXG4gICAgICB2MSA9IG9wU3RhY2sucG9wMigpO1xuICAgIGlmICh2MSA9PT0gdjIpIHtcbiAgICAgIG9wU3RhY2sucHVzaCgwKTtcbiAgICB9IGVsc2UgaWYgKHYxIDwgdjIpIHtcbiAgICAgIG9wU3RhY2sucHVzaCgtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHYxID4gdjIsIGFuZCBpZiB2MSBvciB2MiBpcyBOYU4uXG4gICAgICBvcFN0YWNrLnB1c2goMSk7XG4gICAgfVxuICAgIGZyYW1lLnBjKys7XG4gIH1cblxuICAvKiBVbmFyeSBicmFuY2ggb3Bjb2RlcyAqL1xuICBwdWJsaWMgc3RhdGljIGlmZXEodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICBpZiAoZnJhbWUub3BTdGFjay5wb3AoKSA9PT0gMCkge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZuZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGlmIChmcmFtZS5vcFN0YWNrLnBvcCgpICE9PSAwKSB7XG4gICAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQxNkJFKHBjICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpZmx0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgaWYgKGZyYW1lLm9wU3RhY2sucG9wKCkgPCAwKSB7XG4gICAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQxNkJFKHBjICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpZmdlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgaWYgKGZyYW1lLm9wU3RhY2sucG9wKCkgPj0gMCkge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZndCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGlmIChmcmFtZS5vcFN0YWNrLnBvcCgpID4gMCkge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZsZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGlmIChmcmFtZS5vcFN0YWNrLnBvcCgpIDw9IDApIHtcbiAgICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDE2QkUocGMgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUucGMgKz0gMztcbiAgICB9XG4gIH1cblxuICAvKiBCaW5hcnkgYnJhbmNoIG9wY29kZXMgKi9cbiAgcHVibGljIHN0YXRpYyBpZl9pY21wZXEodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgdjIgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIHZhciB2MSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgaWYgKHYxID09PSB2Mikge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZfaWNtcG5lKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIHYyID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICB2YXIgdjEgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIGlmICh2MSAhPT0gdjIpIHtcbiAgICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDE2QkUocGMgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUucGMgKz0gMztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlmX2ljbXBsdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciB2MiA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgdmFyIHYxID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBpZiAodjEgPCB2Mikge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZfaWNtcGdlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIHYyID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICB2YXIgdjEgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIGlmICh2MSA+PSB2Mikge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZfaWNtcGd0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIHYyID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICB2YXIgdjEgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIGlmICh2MSA+IHYyKSB7XG4gICAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQxNkJFKHBjICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpZl9pY21wbGUodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgdjIgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIHZhciB2MSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgaWYgKHYxIDw9IHYyKSB7XG4gICAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQxNkJFKHBjICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpZl9hY21wZXEodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgdjIgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIHZhciB2MSA9IGZyYW1lLm9wU3RhY2sucG9wKCk7XG4gICAgaWYgKHYxID09PSB2Mikge1xuICAgICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWZfYWNtcG5lKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIHYyID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICB2YXIgdjEgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgIGlmICh2MSAhPT0gdjIpIHtcbiAgICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDE2QkUocGMgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUucGMgKz0gMztcbiAgICB9XG4gIH1cblxuICAvKiBKdW1wIG9wY29kZXMgKi9cbiAgcHVibGljIHN0YXRpYyBnb3RvKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgZnJhbWUucGMgKz0gY29kZS5yZWFkSW50MTZCRShwYyArIDEpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBqc3IodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goZnJhbWUucGMgKyAzKTtcbiAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQxNkJFKHBjICsgMSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJldCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGZyYW1lLnBjID0gZnJhbWUubG9jYWxzW2NvZGUucmVhZFVJbnQ4KHBjICsgMSldO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyB0YWJsZXN3aXRjaCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBsZXQgcGMgPSBmcmFtZS5wYztcbiAgICAvLyBJZ25vcmUgcGFkZGluZyBieXRlcy4gVGhlICsxIGlzIHRvIHNraXAgdGhlIG9wY29kZSBieXRlLlxuICAgIHBjICs9ICgoNCAtIChwYyArIDEpICUgNCkgJSA0KSArIDE7XG4gICAgdmFyIGRlZmF1bHRPZmZzZXQgPSBjb2RlLnJlYWRJbnQzMkJFKHBjKSxcbiAgICAgIGxvdyA9IGNvZGUucmVhZEludDMyQkUocGMgKyA0KSxcbiAgICAgIGhpZ2ggPSBjb2RlLnJlYWRJbnQzMkJFKHBjICsgOCksXG4gICAgICBvZmZzZXQgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKG9mZnNldCA+PSBsb3cgJiYgb2Zmc2V0IDw9IGhpZ2gpIHtcbiAgICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDMyQkUocGMgKyAxMiArICgob2Zmc2V0IC0gbG93KSAqIDQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUucGMgKz0gZGVmYXVsdE9mZnNldDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGxvb2t1cHN3aXRjaCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBsZXQgcGMgPSBmcmFtZS5wYztcbiAgICAvLyBTa2lwIHBhZGRpbmcgYnl0ZXMuIFRoZSArMSBpcyB0byBza2lwIHRoZSBvcGNvZGUgYnl0ZS5cbiAgICBwYyArPSAoKDQgLSAocGMgKyAxKSAlIDQpICUgNCkgKyAxO1xuICAgIHZhciBkZWZhdWx0T2Zmc2V0ID0gY29kZS5yZWFkSW50MzJCRShwYyksXG4gICAgICBuUGFpcnMgPSBjb2RlLnJlYWRJbnQzMkJFKHBjICsgNCksXG4gICAgICBpOiBudW1iZXIsXG4gICAgICB2OiBudW1iZXIgPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuXG4gICAgcGMgKz0gODtcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBhaXJzOyBpKyspIHtcbiAgICAgIGlmIChjb2RlLnJlYWRJbnQzMkJFKHBjKSA9PT0gdikge1xuICAgICAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQzMkJFKHBjICsgNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBjICs9IDg7XG4gICAgfVxuICAgIC8vIE5vIG1hdGNoIGZvdW5kLlxuICAgIGZyYW1lLnBjICs9IGRlZmF1bHRPZmZzZXQ7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJldHVybih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUucmV0dXJuVG9UaHJlYWRMb29wID0gdHJ1ZTtcbiAgICBpZiAoZnJhbWUubWV0aG9kLmFjY2Vzc0ZsYWdzLmlzU3luY2hyb25pemVkKCkpIHtcbiAgICAgIC8vIG1vbml0b3JleGl0XG4gICAgICBpZiAoIWZyYW1lLm1ldGhvZC5tZXRob2RMb2NrKHRocmVhZCwgZnJhbWUpLmV4aXQodGhyZWFkKSkge1xuICAgICAgICAvLyBtb25pdG9yZXhpdCB0aHJldyBhbiBleGNlcHRpb24uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyZWFkLmFzeW5jUmV0dXJuKCk7XG4gIH1cblxuICAvKiAzMi1iaXQgcmV0dXJuIGJ5dGVjb2RlcyAqL1xuXG4gIHByaXZhdGUgc3RhdGljIF9yZXR1cm5fMzIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG4gICAgaWYgKGZyYW1lLm1ldGhvZC5hY2Nlc3NGbGFncy5pc1N5bmNocm9uaXplZCgpKSB7XG4gICAgICAvLyBtb25pdG9yZXhpdFxuICAgICAgaWYgKCFmcmFtZS5tZXRob2QubWV0aG9kTG9jayh0aHJlYWQsIGZyYW1lKS5leGl0KHRocmVhZCkpIHtcbiAgICAgICAgLy8gbW9uaXRvcmV4aXQgdGhyZXcgYW4gZXhjZXB0aW9uLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocmVhZC5hc3luY1JldHVybihmcmFtZS5vcFN0YWNrLmJvdHRvbSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaXJldHVybiA9IE9wY29kZXMuX3JldHVybl8zMjtcbiAgcHVibGljIHN0YXRpYyBmcmV0dXJuID0gT3Bjb2Rlcy5fcmV0dXJuXzMyO1xuICBwdWJsaWMgc3RhdGljIGFyZXR1cm4gPSBPcGNvZGVzLl9yZXR1cm5fMzI7XG5cbiAgLyogNjQtYml0IHJldHVybiBvcGNvZGVzICovXG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3JldHVybl82NCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUucmV0dXJuVG9UaHJlYWRMb29wID0gdHJ1ZTtcbiAgICBpZiAoZnJhbWUubWV0aG9kLmFjY2Vzc0ZsYWdzLmlzU3luY2hyb25pemVkKCkpIHtcbiAgICAgIC8vIG1vbml0b3JleGl0XG4gICAgICBpZiAoIWZyYW1lLm1ldGhvZC5tZXRob2RMb2NrKHRocmVhZCwgZnJhbWUpLmV4aXQodGhyZWFkKSkge1xuICAgICAgICAvLyBtb25pdG9yZXhpdCB0aHJldyBhbiBleGNlcHRpb24uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyZWFkLmFzeW5jUmV0dXJuKGZyYW1lLm9wU3RhY2suYm90dG9tKCksIG51bGwpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBscmV0dXJuID0gT3Bjb2Rlcy5fcmV0dXJuXzY0O1xuICBwdWJsaWMgc3RhdGljIGRyZXR1cm4gPSBPcGNvZGVzLl9yZXR1cm5fNjQ7XG5cbiAgcHVibGljIHN0YXRpYyBnZXRzdGF0aWModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgZmllbGRJbmZvID0gPENvbnN0YW50UG9vbC5GaWVsZFJlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGFzc2VydChmaWVsZEluZm8uZ2V0VHlwZSgpID09PSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5GSUVMRFJFRik7XG4gICAgaWYgKGZpZWxkSW5mby5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIC8vIEdldCB0aGUgKmFjdHVhbCogY2xhc3MgdGhhdCBvd25zIHRoaXMgZmllbGQuXG4gICAgICAvLyBUaGlzIG1heSBub3QgYmUgaW5pdGlhbGl6ZWQgaWYgaXQncyBhbiBpbnRlcmZhY2UsIHNvIHdlIG5lZWQgdG8gY2hlY2suXG4gICAgICB2YXIgZmllbGRPd25lckNscyA9IGZpZWxkSW5mby5maWVsZC5jbHM7XG4gICAgICBpZiAoZmllbGRPd25lckNscy5pc0luaXRpYWxpemVkKHRocmVhZCkpIHtcbiAgICAgICAgLy8gT3Bjb2RlIGlzIHJlYWR5IHRvIGV4ZWN1dGUhIFJld3JpdGUgdG8gYSAnZmFzdCcgdmVyc2lvbixcbiAgICAgICAgLy8gYW5kIHJ1biB0aGUgZmFzdCB2ZXJzaW9uLlxuICAgICAgICBpZiAoZmllbGRJbmZvLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yID09PSAnSicgfHwgZmllbGRJbmZvLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yID09PSAnRCcpIHtcbiAgICAgICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLkdFVFNUQVRJQ19GQVNUNjQsIHBjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLkdFVFNUQVRJQ19GQVNUMzIsIHBjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFzaCB0aGUgcmVzdWx0IG9mIGZpZWxkIGxvb2t1cC5cbiAgICAgICAgZmllbGRJbmZvLmZpZWxkT3duZXJDb25zdHJ1Y3RvciA9IGZpZWxkT3duZXJDbHMuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2xhc3MgYW5kIHJlcnVuIG9wY29kZVxuICAgICAgICBpbml0aWFsaXplQ2xhc3NGcm9tQ2xhc3ModGhyZWFkLCBmcmFtZSwgZmllbGRPd25lckNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc29sdmUgdGhlIGZpZWxkLlxuICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBmaWVsZEluZm8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhc3QgdmVyc2lvbiBvZiBnZXRzdGF0aWMgdGhhdCBhc3N1bWVzIHRoYXQgcmVsZXZhbnQgY2xhc3NlcyBhcmVcbiAgICogaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIFJldHJpZXZlcyBhIDMyLWJpdCB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0c3RhdGljX2Zhc3QzMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoKGZpZWxkSW5mby5maWVsZE93bmVyQ29uc3RydWN0b3JbZmllbGRJbmZvLmZ1bGxGaWVsZE5hbWVdKTtcbiAgICBmcmFtZS5wYyArPSAzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZmFzdCB2ZXJzaW9uIG9mIGdldHN0YXRpYyB0aGF0IGFzc3VtZXMgdGhhdCByZWxldmFudCBjbGFzc2VzIGFyZVxuICAgKiBpbml0aWFsaXplZC5cbiAgICpcbiAgICogUmV0cmlldmVzIGEgNjQtYml0IHZhbHVlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRzdGF0aWNfZmFzdDY0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGZpZWxkSW5mbyA9IDxDb25zdGFudFBvb2wuRmllbGRSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKTtcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2hXaXRoTnVsbChmaWVsZEluZm8uZmllbGRPd25lckNvbnN0cnVjdG9yW2ZpZWxkSW5mby5mdWxsRmllbGROYW1lXSk7XG4gICAgZnJhbWUucGMgKz0gMztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcHV0c3RhdGljKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGZpZWxkSW5mbyA9IDxDb25zdGFudFBvb2wuRmllbGRSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKTtcbiAgICBhc3NlcnQoZmllbGRJbmZvLmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRklFTERSRUYpO1xuXG4gICAgaWYgKGZpZWxkSW5mby5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIC8vIEdldCB0aGUgKmFjdHVhbCogY2xhc3MgdGhhdCBvd25zIHRoaXMgZmllbGQuXG4gICAgICAvLyBUaGlzIG1heSBub3QgYmUgaW5pdGlhbGl6ZWQgaWYgaXQncyBhbiBpbnRlcmZhY2UsIHNvIHdlIG5lZWQgdG8gY2hlY2suXG4gICAgICB2YXIgZmllbGRPd25lckNscyA9IGZpZWxkSW5mby5maWVsZC5jbHM7XG4gICAgICBpZiAoZmllbGRPd25lckNscy5pc0luaXRpYWxpemVkKHRocmVhZCkpIHtcbiAgICAgICAgLy8gT3Bjb2RlIGlzIHJlYWR5IHRvIGV4ZWN1dGUhIFJld3JpdGUgdG8gYSAnZmFzdCcgdmVyc2lvbixcbiAgICAgICAgLy8gYW5kIHJ1biB0aGUgZmFzdCB2ZXJzaW9uLlxuICAgICAgICBpZiAoZmllbGRJbmZvLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yID09PSAnSicgfHwgZmllbGRJbmZvLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yID09PSAnRCcpIHtcbiAgICAgICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLlBVVFNUQVRJQ19GQVNUNjQsIHBjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLlBVVFNUQVRJQ19GQVNUMzIsIHBjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFzaCB0aGUgcmVzdWx0IG9mIGZpZWxkIGxvb2t1cC5cbiAgICAgICAgZmllbGRJbmZvLmZpZWxkT3duZXJDb25zdHJ1Y3RvciA9IGZpZWxkT3duZXJDbHMuZ2V0Q29uc3RydWN0b3IodGhyZWFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2xhc3MgYW5kIHJlcnVuIG9wY29kZVxuICAgICAgICBpbml0aWFsaXplQ2xhc3NGcm9tQ2xhc3ModGhyZWFkLCBmcmFtZSwgZmllbGRPd25lckNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc29sdmUgdGhlIGZpZWxkLlxuICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBmaWVsZEluZm8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZhc3QgdmVyc2lvbiBvZiBwdXRzdGF0aWMgdGhhdCBhc3N1bWVzIHRoYXQgcmVsZXZhbnQgY2xhc3NlcyBhcmVcbiAgICogaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIFB1dHMgYSAzMi1iaXQgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHB1dHN0YXRpY19mYXN0MzIodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgZmllbGRJbmZvID0gPENvbnN0YW50UG9vbC5GaWVsZFJlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGZpZWxkSW5mby5maWVsZE93bmVyQ29uc3RydWN0b3JbZmllbGRJbmZvLmZ1bGxGaWVsZE5hbWVdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBmcmFtZS5wYyArPSAzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZmFzdCB2ZXJzaW9uIG9mIHB1dHN0YXRpYyB0aGF0IGFzc3VtZXMgdGhhdCByZWxldmFudCBjbGFzc2VzIGFyZVxuICAgKiBpbml0aWFsaXplZC5cbiAgICpcbiAgICogUHV0cyBhIDY0LWJpdCB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcHV0c3RhdGljX2Zhc3Q2NCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG4gICAgZmllbGRJbmZvLmZpZWxkT3duZXJDb25zdHJ1Y3RvcltmaWVsZEluZm8uZnVsbEZpZWxkTmFtZV0gPSBmcmFtZS5vcFN0YWNrLnBvcDIoKTtcbiAgICBmcmFtZS5wYyArPSAzO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRmaWVsZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSksXG4gICAgICBsb2FkZXIgPSBmcmFtZS5nZXRMb2FkZXIoKSxcbiAgICAgIG9iaiA9IGZyYW1lLm9wU3RhY2sudG9wKCk7XG4gICAgYXNzZXJ0KGZpZWxkSW5mby5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkZJRUxEUkVGKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgb2JqZWN0IGlzIG51bGw7IGlmIHdlIGRvIG5vdCBkbyB0aGlzIGJlZm9yZSBnZXRfY2xhc3MsIHRoZW5cbiAgICAvLyB3ZSBtaWdodCB0cnkgdG8gZ2V0IGEgY2xhc3MgdGhhdCB3ZSBoYXZlIG5vdCBpbml0aWFsaXplZCFcbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICAvLyBjbHMgaXMgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGUgaW5oZXJpdGFuY2UgaGllcmFyY2h5IG9mIG9iaiwgc28gaXQgbXVzdCBiZVxuICAgICAgLy8gaW5pdGlhbGl6ZWQuIEhvd2V2ZXIsIGl0IG1heSBub3QgYmUgbG9hZGVkIGluIHRoZSBjdXJyZW50IGNsYXNzJ3NcbiAgICAgIC8vIENsYXNzTG9hZGVyLi4uXG4gICAgICBpZiAoZmllbGRJbmZvLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZEluZm8uZmllbGQ7XG4gICAgICAgIGlmIChmaWVsZC5yYXdEZXNjcmlwdG9yID09ICdKJyB8fCBmaWVsZC5yYXdEZXNjcmlwdG9yID09ICdEJykge1xuICAgICAgICAgIGNvZGUud3JpdGVVSW50OChlbnVtcy5PcENvZGUuR0VURklFTERfRkFTVDY0LCBwYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS53cml0ZVVJbnQ4KGVudW1zLk9wQ29kZS5HRVRGSUVMRF9GQVNUMzIsIHBjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXJ1biBvcGNvZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgZmllbGRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldGZpZWxkX2Zhc3QzMih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSksXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjaywgb2JqOiBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0ID0gb3BTdGFjay5wb3AoKTtcbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICBvcFN0YWNrLnB1c2goKDxhbnk+IG9iailbZmllbGRJbmZvLmZ1bGxGaWVsZE5hbWVdKTtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXRmaWVsZF9mYXN0NjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgZmllbGRJbmZvID0gPENvbnN0YW50UG9vbC5GaWVsZFJlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpLFxuICAgICAgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssIG9iajogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCA9IG9wU3RhY2sucG9wKCk7XG4gICAgaWYgKCFpc051bGwodGhyZWFkLCBmcmFtZSwgb2JqKSkge1xuICAgICAgb3BTdGFjay5wdXNoV2l0aE51bGwoKDxhbnk+IG9iailbZmllbGRJbmZvLmZ1bGxGaWVsZE5hbWVdKTtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwdXRmaWVsZCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSksXG4gICAgICBsb2FkZXIgPSBmcmFtZS5nZXRMb2FkZXIoKSxcbiAgICAgIGlzTG9uZyA9IGZpZWxkSW5mby5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvciA9PSAnSicgfHwgZmllbGRJbmZvLm5hbWVBbmRUeXBlSW5mby5kZXNjcmlwdG9yID09ICdEJyxcbiAgICAgIG9iaiA9IGZyYW1lLm9wU3RhY2suZnJvbVRvcChpc0xvbmcgPyAyIDogMSk7XG4gICAgYXNzZXJ0KGZpZWxkSW5mby5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkZJRUxEUkVGKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgbnVsbDsgaWYgd2UgZG8gbm90IGRvIHRoaXMgYmVmb3JlIGdldF9jbGFzcywgdGhlblxuICAgIC8vIHdlIG1pZ2h0IHRyeSB0byBnZXQgYSBjbGFzcyB0aGF0IHdlIGhhdmUgbm90IGluaXRpYWxpemVkIVxuICAgIGlmICghaXNOdWxsKHRocmVhZCwgZnJhbWUsIG9iaikpIHtcbiAgICAgIC8vIGNscyBpcyBndWFyYW50ZWVkIHRvIGJlIGluIHRoZSBpbmhlcml0YW5jZSBoaWVyYXJjaHkgb2Ygb2JqLCBzbyBpdCBtdXN0IGJlXG4gICAgICAvLyBpbml0aWFsaXplZC4gSG93ZXZlciwgaXQgbWF5IG5vdCBiZSBsb2FkZWQgaW4gdGhlIGN1cnJlbnQgY2xhc3Mnc1xuICAgICAgLy8gQ2xhc3NMb2FkZXIuLi5cbiAgICAgIGlmIChmaWVsZEluZm8uaXNSZXNvbHZlZCgpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkSW5mby5maWVsZDtcbiAgICAgICAgaWYgKGlzTG9uZykge1xuICAgICAgICAgIGNvZGUud3JpdGVVSW50OChlbnVtcy5PcENvZGUuUFVURklFTERfRkFTVDY0LCBwYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS53cml0ZVVJbnQ4KGVudW1zLk9wQ29kZS5QVVRGSUVMRF9GQVNUMzIsIHBjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFzaCB0aGUgcmVzb2x2ZWQgZnVsbCBmaWVsZCBuYW1lLlxuICAgICAgICBmaWVsZEluZm8uZnVsbEZpZWxkTmFtZSA9IGAke3V0aWwuZGVzY3JpcHRvcjJ0eXBlc3RyKGZpZWxkLmNscy5nZXRJbnRlcm5hbE5hbWUoKSl9LyR7ZmllbGRJbmZvLm5hbWVBbmRUeXBlSW5mby5uYW1lfWA7XG4gICAgICAgIC8vIFJlcnVuIG9wY29kZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBmaWVsZEluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgcHV0ZmllbGRfZmFzdDMyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLFxuICAgICAgdmFsID0gb3BTdGFjay5wb3AoKSxcbiAgICAgIG9iajogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCA9IG9wU3RhY2sucG9wKCksXG4gICAgICBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG5cbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICAoPGFueT4gb2JqKVtmaWVsZEluZm8uZnVsbEZpZWxkTmFtZV0gPSB2YWw7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgICAvLyBOUEUgaGFzIGJlZW4gdGhyb3duLlxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBwdXRmaWVsZF9mYXN0NjQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB2YWwgPSBvcFN0YWNrLnBvcDIoKSxcbiAgICAgIG9iajogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCA9IG9wU3RhY2sucG9wKCksXG4gICAgICBmaWVsZEluZm8gPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG5cbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICAoPGFueT4gb2JqKVtmaWVsZEluZm8uZnVsbEZpZWxkTmFtZV0gPSB2YWw7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH1cbiAgICAvLyBOUEUgaGFzIGJlZW4gdGhyb3duLlxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpbnZva2V2aXJ0dWFsKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIG1ldGhvZFJlZmVyZW5jZSA9IDxDb25zdGFudFBvb2wuTWV0aG9kUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG5cbiAgICAvLyBFbnN1cmUgcmVmZXJlbmNlZCBjbGFzcyBpcyBsb2FkZWQgaW4gdGhlIGN1cnJlbnQgY2xhc3Nsb2FkZXIuXG4gICAgLy8gRXZlbiB0aG91Z2ggd2UgZG9uJ3QgdXNlIHRoaXMgY2xhc3MgZm9yIGFueXRoaW5nLCBhbmQgd2Uga25vdyB0aGF0IGl0XG4gICAgLy8gbXVzdCBiZSBsb2FkZWQgYmVjYXVzZSBpdCBpcyBpbiB0aGUgb2JqZWN0J3MgaW5oZXJpdGFuY2UgaGllcmFyY2h5LFxuICAgIC8vIGl0IG5lZWRzIHRvIGJlIHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgY2xhc3Nsb2FkZXIuXG4gICAgaWYgKG1ldGhvZFJlZmVyZW5jZS5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIHZhciBtID0gbWV0aG9kUmVmZXJlbmNlLm1ldGhvZDtcbiAgICAgIGlmIChtLmlzU2lnbmF0dXJlUG9seW1vcnBoaWMoKSkge1xuICAgICAgICBzd2l0Y2ggKG0ubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2ludm9rZUJhc2ljJzpcbiAgICAgICAgICAgIGNvZGUud3JpdGVVSW50OChlbnVtcy5PcENvZGUuSU5WT0tFQkFTSUMsIHBjKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ludm9rZSc6XG4gICAgICAgICAgY2FzZSAnaW52b2tlRXhhY3QnOlxuICAgICAgICAgICAgY29kZS53cml0ZVVJbnQ4KGVudW1zLk9wQ29kZS5JTlZPS0VIQU5ETEUsIHBjKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvd0V4Y2VwdGlvbih0aHJlYWQsIGZyYW1lLCAnTGphdmEvbGFuZy9BYnN0cmFjdE1ldGhvZEVycm9yOycsIGBJbnZhbGlkIHNpZ25hdHVyZSBwb2x5bW9ycGhpYyBtZXRob2Q6ICR7bS5jbHMuZ2V0RXh0ZXJuYWxOYW1lKCl9LiR7bS5uYW1lfWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUud3JpdGVVSW50OChlbnVtcy5PcENvZGUuSU5WT0tFVklSVFVBTF9GQVNULCBwYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgbWV0aG9kUmVmZXJlbmNlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGludm9rZWludGVyZmFjZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBtZXRob2RSZWZlcmVuY2UgPSA8Q29uc3RhbnRQb29sLkludGVyZmFjZU1ldGhvZFJlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGlmIChtZXRob2RSZWZlcmVuY2UuaXNSZXNvbHZlZCgpKSB7XG4gICAgICBpZiAobWV0aG9kUmVmZXJlbmNlLm1ldGhvZC5jbHMuaXNJbml0aWFsaXplZCh0aHJlYWQpKSB7XG4gICAgICAgIC8vIFJld3JpdGUgdG8gZmFzdCBhbmQgcmVydW4uXG4gICAgICAgIGNvZGUud3JpdGVVSW50OChlbnVtcy5PcENvZGUuSU5WT0tFSU5URVJGQUNFX0ZBU1QsIHBjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgb3VyIGNsYXNzIGFuZCByZXJ1biBvcGNvZGUuXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgZXhpc3RhbmNlIG9mIGFuIG9iamVjdCBvZiBhbiBpbnRlcmZhY2UgdHlwZSBkb2VzICpub3QqXG4gICAgICAgIC8vIG1lYW4gdGhhdCB0aGUgaW50ZXJmYWNlIGlzIGluaXRpYWxpemVkIVxuICAgICAgICBpbml0aWFsaXplQ2xhc3ModGhyZWFkLCBmcmFtZSwgbWV0aG9kUmVmZXJlbmNlLmNsYXNzSW5mbyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgbWV0aG9kUmVmZXJlbmNlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGludm9rZWR5bmFtaWModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgY2FsbFNpdGVTcGVjaWZpZXIgPSA8Q29uc3RhbnRQb29sLkludm9rZUR5bmFtaWM+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKTtcbiAgICB0aHJlYWQuc2V0U3RhdHVzKGVudW1zLlRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HKTtcbiAgICBjYWxsU2l0ZVNwZWNpZmllci5jb25zdHJ1Y3RDYWxsU2l0ZU9iamVjdCh0aHJlYWQsIGZyYW1lLmdldExvYWRlcigpLCBmcmFtZS5tZXRob2QuY2xzLCBwYywgKHN0YXR1czogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBhc3NlcnQodHlwZW9mKGNhbGxTaXRlU3BlY2lmaWVyLmdldENhbGxTaXRlT2JqZWN0KHBjKVswXS52bXRhcmdldCkgPT09ICdmdW5jdGlvbicsIFwiTWV0aG9kTmFtZSBzaG91bGQgYmUgcmVzb2x2ZWQuLi5cIik7XG4gICAgICAgIGNvZGUud3JpdGVVSW50OChlbnVtcy5PcENvZGUuSU5WT0tFRFlOQU1JQ19GQVNULCBwYyk7XG4gICAgICAgIC8vIFJlc3VtZSBhbmQgcmVydW4gZmFzdCBvcGNvZGUuXG4gICAgICAgIHRocmVhZC5zZXRTdGF0dXMoZW51bXMuVGhyZWFkU3RhdHVzLlJVTk5BQkxFKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFhYWDogQWN0dWFsbHkgcGVyZm9ybSBzdXBlcmNsYXNzIG1ldGhvZCBsb29rdXAuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGludm9rZXNwZWNpYWwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgbWV0aG9kUmVmZXJlbmNlID0gPENvbnN0YW50UG9vbC5NZXRob2RSZWZlcmVuY2UgfCBDb25zdGFudFBvb2wuSW50ZXJmYWNlTWV0aG9kUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG4gICAgaWYgKG1ldGhvZFJlZmVyZW5jZS5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIC8vIFJld3JpdGUgYW5kIHJlcnVuLlxuICAgICAgY29kZS53cml0ZVVJbnQ4KGVudW1zLk9wQ29kZS5JTlZPS0VOT05WSVJUVUFMX0ZBU1QsIHBjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBtZXRob2RSZWZlcmVuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaW52b2tlc3RhdGljKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIG1ldGhvZFJlZmVyZW5jZSA9IDxDb25zdGFudFBvb2wuTWV0aG9kUmVmZXJlbmNlIHwgQ29uc3RhbnRQb29sLkludGVyZmFjZU1ldGhvZFJlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGlmIChtZXRob2RSZWZlcmVuY2UuaXNSZXNvbHZlZCgpKSB7XG4gICAgICB2YXIgbSA9IG1ldGhvZFJlZmVyZW5jZS5tZXRob2Q7XG4gICAgICBpZiAobS5jbHMuaXNJbml0aWFsaXplZCh0aHJlYWQpKSB7XG4gICAgICAgIHZhciBuZXdPcGNvZGU6IGVudW1zLk9wQ29kZSA9IGVudW1zLk9wQ29kZS5JTlZPS0VTVEFUSUNfRkFTVDtcbiAgICAgICAgaWYgKG1ldGhvZFJlZmVyZW5jZS5tZXRob2QuaXNTaWduYXR1cmVQb2x5bW9ycGhpYygpKSB7XG4gICAgICAgICAgc3dpdGNoIChtZXRob2RSZWZlcmVuY2UubWV0aG9kLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmtUb0ludGVyZmFjZSc6XG4gICAgICAgICAgICBjYXNlICdsaW5rVG9WaXJ0dWFsJzpcbiAgICAgICAgICAgICAgbmV3T3Bjb2RlID0gZW51bXMuT3BDb2RlLkxJTktUT1ZJUlRVQUw7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGlua1RvU3RhdGljJzpcbiAgICAgICAgICAgIGNhc2UgJ2xpbmtUb1NwZWNpYWwnOlxuICAgICAgICAgICAgICBuZXdPcGNvZGUgPSBlbnVtcy5PcENvZGUuTElOS1RPU1BFQ0lBTDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiU2hvdWxkIGJlIGltcG9zc2libGUuXCIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV3cml0ZSBhbmQgcmVydW4uXG4gICAgICAgIGNvZGUud3JpdGVVSW50OChuZXdPcGNvZGUsIHBjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxpemVDbGFzc0Zyb21DbGFzcyh0aHJlYWQsIGZyYW1lLCBtLmNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgbWV0aG9kUmVmZXJlbmNlKTtcbiAgICB9XG4gIH1cblxuICAvLy8gRmFzdCBpbnZva2Ugb3Bjb2Rlcy5cblxuICBwdWJsaWMgc3RhdGljIGludm9rZW5vbnZpcnR1YWxfZmFzdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBtZXRob2RSZWZlcmVuY2UgPSA8Q29uc3RhbnRQb29sLk1ldGhvZFJlZmVyZW5jZSB8IENvbnN0YW50UG9vbC5JbnRlcmZhY2VNZXRob2RSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKSxcbiAgICAgIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLCBwYXJhbVNpemUgPSBtZXRob2RSZWZlcmVuY2UucGFyYW1Xb3JkU2l6ZSxcbiAgICAgIG9iajogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCA9IG9wU3RhY2suZnJvbVRvcChwYXJhbVNpemUpLFxuICAgICAgYXJncyA9IG9wU3RhY2suc2xpY2VGcm9tVG9wKHBhcmFtU2l6ZSk7XG5cbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICBvcFN0YWNrLmRyb3BGcm9tVG9wKHBhcmFtU2l6ZSArIDEpO1xuICAgICAgYXNzZXJ0KHR5cGVvZiAoPGFueT4gb2JqKVttZXRob2RSZWZlcmVuY2UuZnVsbFNpZ25hdHVyZV0gPT09ICdmdW5jdGlvbicsIGBSZXNvbHZlZCBtZXRob2QgJHttZXRob2RSZWZlcmVuY2UuZnVsbFNpZ25hdHVyZX0gaXNuJ3QgZGVmaW5lZD8hYCwgdGhyZWFkKTtcbiAgICAgICg8YW55PiBvYmopW21ldGhvZFJlZmVyZW5jZS5mdWxsU2lnbmF0dXJlXSh0aHJlYWQsIGFyZ3MpO1xuICAgICAgZnJhbWUucmV0dXJuVG9UaHJlYWRMb29wID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGludm9rZXN0YXRpY19mYXN0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIG1ldGhvZFJlZmVyZW5jZSA9IDxDb25zdGFudFBvb2wuTWV0aG9kUmVmZXJlbmNlIHwgQ29uc3RhbnRQb29sLkludGVyZmFjZU1ldGhvZFJlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpLFxuICAgICAgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssIHBhcmFtU2l6ZSA9IG1ldGhvZFJlZmVyZW5jZS5wYXJhbVdvcmRTaXplLFxuICAgICAgYXJncyA9IG9wU3RhY2suc2xpY2VGcm9tVG9wKHBhcmFtU2l6ZSk7XG4gICAgb3BTdGFjay5kcm9wRnJvbVRvcChwYXJhbVNpemUpO1xuICAgIGFzc2VydChtZXRob2RSZWZlcmVuY2UuanNDb25zdHJ1Y3RvciAhPSBudWxsLCBcImpzQ29uc3RydWN0b3IgaXMgbWlzc2luZz8hXCIpO1xuICAgIGFzc2VydCh0eXBlb2YobWV0aG9kUmVmZXJlbmNlLmpzQ29uc3RydWN0b3JbbWV0aG9kUmVmZXJlbmNlLmZ1bGxTaWduYXR1cmVdKSA9PT0gJ2Z1bmN0aW9uJywgXCJSZXNvbHZlZCBtZXRob2QgaXNuJ3QgZGVmaW5lZD8hXCIpO1xuICAgIG1ldGhvZFJlZmVyZW5jZS5qc0NvbnN0cnVjdG9yW21ldGhvZFJlZmVyZW5jZS5mdWxsU2lnbmF0dXJlXSh0aHJlYWQsIGFyZ3MpO1xuICAgIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGludm9rZXZpcnR1YWxfZmFzdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBtZXRob2RSZWZlcmVuY2UgPSA8Q29uc3RhbnRQb29sLk1ldGhvZFJlZmVyZW5jZSB8IENvbnN0YW50UG9vbC5JbnRlcmZhY2VNZXRob2RSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKSxcbiAgICAgIGNvdW50ID0gbWV0aG9kUmVmZXJlbmNlLnBhcmFtV29yZFNpemUsXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIG9iajogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdCA9IG9wU3RhY2suZnJvbVRvcChjb3VudCk7XG4gICAgaWYgKCFpc051bGwodGhyZWFkLCBmcmFtZSwgb2JqKSkge1xuICAgICAgLy8gVXNlIHRoZSBjbGFzcyBvZiB0aGUgKm9iamVjdCouXG4gICAgICBhc3NlcnQodHlwZW9mICg8YW55PiBvYmopW21ldGhvZFJlZmVyZW5jZS5zaWduYXR1cmVdID09PSAnZnVuY3Rpb24nLCBgUmVzb2x2ZWQgbWV0aG9kICR7bWV0aG9kUmVmZXJlbmNlLnNpZ25hdHVyZX0gaXNuJ3QgZGVmaW5lZD8hYCk7XG4gICAgICAoPGFueT4gb2JqKVttZXRob2RSZWZlcmVuY2Uuc2lnbmF0dXJlXSh0aHJlYWQsIG9wU3RhY2suc2xpY2VGcm9tVG9wKGNvdW50KSk7XG4gICAgICBvcFN0YWNrLmRyb3BGcm9tVG9wKGNvdW50ICsgMSk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBPYmplY3QgaXMgTlVMTDsgTlBFIGhhcyBiZWVuIHRocm93bi5cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaW52b2tlaW50ZXJmYWNlX2Zhc3QgPSBPcGNvZGVzLmludm9rZXZpcnR1YWxfZmFzdDtcblxuICBwdWJsaWMgc3RhdGljIGludm9rZWR5bmFtaWNfZmFzdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBjYWxsU2l0ZVNwZWNpZmllciA9IDxDb25zdGFudFBvb2wuSW52b2tlRHluYW1pYz4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpLFxuICAgICAgY3NvID0gY2FsbFNpdGVTcGVjaWZpZXIuZ2V0Q2FsbFNpdGVPYmplY3QocGMpLFxuICAgICAgYXBwZW5kaXggPSBjc29bMV0sXG4gICAgICBmY24gPSBjc29bMF0udm10YXJnZXQsXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjaywgcGFyYW1TaXplID0gY2FsbFNpdGVTcGVjaWZpZXIucGFyYW1Xb3JkU2l6ZSxcbiAgICAgIGFyZ3MgPSBvcFN0YWNrLnNsaWNlRnJvbVRvcChwYXJhbVNpemUpO1xuXG4gICAgb3BTdGFjay5kcm9wRnJvbVRvcChwYXJhbVNpemUpO1xuICAgIGlmIChhcHBlbmRpeCAhPT0gbnVsbCkge1xuICAgICAgYXJncy5wdXNoKGFwcGVuZGl4KTtcbiAgICB9XG4gICAgZmNuKHRocmVhZCwgbnVsbCwgYXJncyk7XG4gICAgZnJhbWUucmV0dXJuVG9UaHJlYWRMb29wID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGNvZGUgZm9yIE1ldGhvZEhhbmRsZS5pbnZva2UgYW5kIE1ldGhvZEhhbmRsZS5pbnZva2VFeGFjdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaW52b2tlaGFuZGxlKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIG1ldGhvZFJlZmVyZW5jZSA9IDxDb25zdGFudFBvb2wuTWV0aG9kUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSksXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIGZjbiA9IG1ldGhvZFJlZmVyZW5jZS5tZW1iZXJOYW1lLnZtdGFyZ2V0LFxuICAgICAgLy8gQWRkIGluIDEgZm9yIHRoZSBtZXRob2QgaGFuZGxlIGl0c2VsZi5cbiAgICAgIHBhcmFtU2l6ZSA9IG1ldGhvZFJlZmVyZW5jZS5wYXJhbVdvcmRTaXplICsgMSxcbiAgICAgIGFwcGVuZGl4ID0gbWV0aG9kUmVmZXJlbmNlLmFwcGVuZGl4LFxuICAgICAgYXJncyA9IG9wU3RhY2suc2xpY2VGcm9tVG9wKHBhcmFtU2l6ZSk7XG5cbiAgICBpZiAoYXBwZW5kaXggIT09IG51bGwpIHtcbiAgICAgIGFyZ3MucHVzaChhcHBlbmRpeCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc051bGwodGhyZWFkLCBmcmFtZSwgYXJnc1swXSkpIHtcbiAgICAgIG9wU3RhY2suZHJvcEZyb21Ub3AocGFyYW1TaXplKTtcbiAgICAgIC8vIGZjbiB3aWxsIGhhbmRsZSBpbnZva2luZyAndGhpcycgYW5kIHN1Y2guXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGNhbiBiZSB2YXJhcmdzLCBwYXNzIGluIHBhcmFtZXRlciB0eXBlcyB0byB0aGUgZnVuY3Rpb24uXG4gICAgICBmY24odGhyZWFkLCBudWxsLCBhcmdzKTtcbiAgICAgIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wY29kZSBmb3IgTWV0aG9kSGFuZGxlLmludm9rZUJhc2ljLlxuICAgKiBVbmxpa2UgaW52b2tlL2ludm9rZUV4YWN0LCBpbnZva2VCYXNpYyBkb2VzIG5vdCBjYWxsIGEgZ2VuZXJhdGVkIGJ5dGVjb2RlXG4gICAqIG1ldGhvZC4gSXQgY2FsbHMgdGhlIHZtdGFyZ2V0IGVtYmVkZGVkIGluIHRoZSBNZXRob2RIYW5kbGVyIGRpcmVjdGx5LlxuICAgKiBUaGlzIGNhbiBjYXVzZSBjcmFzaGVzIHdpdGggbWFsZm9ybWVkIGNhbGxzLCB0aHVzIGl0IGlzIG9ubHkgYWNjZXNzc2libGVcbiAgICogdG8gdHJ1c3RlZCBKREsgY29kZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgaW52b2tlYmFzaWModGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgbWV0aG9kUmVmZXJlbmNlID0gPENvbnN0YW50UG9vbC5NZXRob2RSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKSxcbiAgICAgIHBhcmFtU2l6ZSA9IG1ldGhvZFJlZmVyZW5jZS5nZXRQYXJhbVdvcmRTaXplKCksXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIG9iajogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RIYW5kbGUgPSBvcFN0YWNrLmZyb21Ub3AocGFyYW1TaXplKSxcbiAgICAgIC8vIE5lZWQgdG8gaW5jbHVkZSB0aGUgTWV0aG9kSGFuZGxlIGluIHRoZSBhcmd1bWVudHMgdG8gdm10YXJnZXQuIHZtdGFyZ2V0XG4gICAgICAvLyB3aWxsIGFwcHJvcHJpYXRlbHkgaW52b2tlIGl0LlxuICAgICAgYXJncyA9IG9wU3RhY2suc2xpY2VGcm9tVG9wKHBhcmFtU2l6ZSArIDEpLFxuICAgICAgbG1iZGFGb3JtOiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX0xhbWJkYUZvcm0sXG4gICAgICBtbjogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZW1iZXJOYW1lLFxuICAgICAgbTogbWV0aG9kcy5NZXRob2Q7XG5cbiAgICAvLyBvYmogaXMgYSBNZXRob2RIYW5kbGUuXG4gICAgaWYgKCFpc051bGwodGhyZWFkLCBmcmFtZSwgb2JqKSkge1xuICAgICAgb3BTdGFjay5kcm9wRnJvbVRvcChwYXJhbVNpemUgKyAxKTtcbiAgICAgIGxtYmRhRm9ybSA9IG9ialsnamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGUvZm9ybSddO1xuICAgICAgbW4gPSBsbWJkYUZvcm1bJ2phdmEvbGFuZy9pbnZva2UvTGFtYmRhRm9ybS92bWVudHJ5J107XG4gICAgICBhc3NlcnQobW4udm10YXJnZXQgIT09IG51bGwgJiYgbW4udm10YXJnZXQgIT09IHVuZGVmaW5lZCwgXCJ2bXRhcmdldCBtdXN0IGJlIGRlZmluZWRcIik7XG4gICAgICBtbi52bXRhcmdldCh0aHJlYWQsIG1ldGhvZFJlZmVyZW5jZS5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvciwgYXJncyk7XG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbHNvIHVzZWQgZm9yIGxpbmtUb1N0YXRpYy5cbiAgICogVE9ETzogRGUtY29uZmxhdGUgdGhlIHR3by5cbiAgICogVE9ETzogVmFyYXJncyBmdW5jdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxpbmt0b3NwZWNpYWwodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgbWV0aG9kUmVmZXJlbmNlID0gPENvbnN0YW50UG9vbC5NZXRob2RSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKSxcbiAgICAgIG9wU3RhY2sgPSBmcmFtZS5vcFN0YWNrLCBwYXJhbVNpemUgPSBtZXRob2RSZWZlcmVuY2UucGFyYW1Xb3JkU2l6ZSxcbiAgICAgIC8vIEZpbmFsIGFyZ3VtZW50IGlzIHRoZSByZWxldmFudCBNZW1iZXJOYW1lLiBGdW5jdGlvbiBhcmdzIGFyZSByaWdodFxuICAgICAgLy8gYmVmb3JlIGl0LlxuICAgICAgYXJncyA9IG9wU3RhY2suc2xpY2VGcm9tVG9wKHBhcmFtU2l6ZSksXG4gICAgICBtZW1iZXJOYW1lOiBKVk1UeXBlcy5qYXZhX2xhbmdfaW52b2tlX01lbWJlck5hbWUgPSBhcmdzLnBvcCgpLFxuICAgICAgLy8gVE9ETzogVXNlIHBhcnNlZCBkZXNjcmlwdG9yLlxuICAgICAgZGVzYyA9IG1ldGhvZFJlZmVyZW5jZS5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvcjtcblxuICAgIGlmICghaXNOdWxsKHRocmVhZCwgZnJhbWUsIG1lbWJlck5hbWUpKSB7XG4gICAgICBvcFN0YWNrLmRyb3BGcm9tVG9wKHBhcmFtU2l6ZSk7XG4gICAgICBhc3NlcnQobWVtYmVyTmFtZS5nZXRDbGFzcygpLmdldEludGVybmFsTmFtZSgpID09PSBcIkxqYXZhL2xhbmcvaW52b2tlL01lbWJlck5hbWU7XCIpO1xuICAgICAgLy8gcGFyYW1ldGVyVHlwZXMgZm9yIGZ1bmN0aW9uIGFyZSB0aGUgc2FtZSBhcyB0aGUgbWV0aG9kIHJlZmVyZW5jZSwgYnV0IHdpdGhvdXQgdGhlIHRyYWlsaW5nIE1lbWJlck5hbWUuXG4gICAgICAvLyBUT0RPOiBVc2UgcGFyc2VkIGRlc2NyaXB0b3IsIGF2b2lkIHJlLWRvaW5nIHdvcmsgaGVyZS5cbiAgICAgIG1lbWJlck5hbWUudm10YXJnZXQodGhyZWFkLCBkZXNjLnJlcGxhY2UoXCJMamF2YS9sYW5nL2ludm9rZS9NZW1iZXJOYW1lOylcIiwgXCIpXCIpLCBhcmdzKTtcbiAgICAgIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gWFhYOiBWYXJhcmdzIGZ1bmN0aW9ucy4gV2UncmUgc3VwcG9zZWQgdG8gYm94IGFyZ3MgaWYgdGFyZ2V0IGlzIHZhcmFyZ3MuXG4gIHB1YmxpYyBzdGF0aWMgbGlua3RvdmlydHVhbCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBtZXRob2RSZWZlcmVuY2UgPSA8Q29uc3RhbnRQb29sLk1ldGhvZFJlZmVyZW5jZSB8IENvbnN0YW50UG9vbC5JbnRlcmZhY2VNZXRob2RSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKSxcbiAgICAgIHBhcmFtU2l6ZSA9IG1ldGhvZFJlZmVyZW5jZS5wYXJhbVdvcmRTaXplLFxuICAgICAgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBhcmdzID0gb3BTdGFjay5zbGljZUZyb21Ub3AocGFyYW1TaXplKSxcbiAgICAgIC8vIEZpbmFsIGFyZ3VtZW50IGlzIHRoZSByZWxldmFudCBNZW1iZXJOYW1lLiBGdW5jdGlvbiBhcmdzIGFyZSByaWdodFxuICAgICAgLy8gYmVmb3JlIGl0LlxuICAgICAgbWVtYmVyTmFtZTogSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZW1iZXJOYW1lID0gYXJncy5wb3AoKSxcbiAgICAgIGRlc2MgPSBtZXRob2RSZWZlcmVuY2UubmFtZUFuZFR5cGVJbmZvLmRlc2NyaXB0b3I7XG5cbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBtZW1iZXJOYW1lKSkge1xuICAgICAgb3BTdGFjay5kcm9wRnJvbVRvcChwYXJhbVNpemUpO1xuICAgICAgYXNzZXJ0KG1lbWJlck5hbWUuZ2V0Q2xhc3MoKS5nZXRJbnRlcm5hbE5hbWUoKSA9PT0gXCJMamF2YS9sYW5nL2ludm9rZS9NZW1iZXJOYW1lO1wiKTtcbiAgICAgIC8vIHBhcmFtZXRlclR5cGVzIGZvciBmdW5jdGlvbiBhcmUgdGhlIHNhbWUgYXMgdGhlIG1ldGhvZCByZWZlcmVuY2UsIGJ1dCB3aXRob3V0IHRoZSB0cmFpbGluZyBNZW1iZXJOYW1lLlxuICAgICAgbWVtYmVyTmFtZS52bXRhcmdldCh0aHJlYWQsIGRlc2MucmVwbGFjZShcIkxqYXZhL2xhbmcvaW52b2tlL01lbWJlck5hbWU7KVwiLCBcIilcIiksIGFyZ3MpO1xuICAgICAgZnJhbWUucmV0dXJuVG9UaHJlYWRMb29wID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGJyZWFrcG9pbnQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHRocm93RXhjZXB0aW9uKHRocmVhZCwgZnJhbWUsIFwiTGphdmEvbGFuZy9FcnJvcjtcIiwgXCJicmVha3BvaW50IG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIG5ldyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBjbGFzc1JlZiA9IDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKTtcbiAgICBpZiAoY2xhc3NSZWYuaXNSZXNvbHZlZCgpKSB7XG4gICAgICB2YXIgY2xzID0gY2xhc3NSZWYuY2xzO1xuICAgICAgaWYgKGNscy5pc0luaXRpYWxpemVkKHRocmVhZCkpIHtcbiAgICAgICAgY29kZS53cml0ZVVJbnQ4KGVudW1zLk9wQ29kZS5ORVdfRkFTVCwgcGMpO1xuICAgICAgICAvLyBSZXR1cm4gdG8gdGhyZWFkLCByZXJ1biBvcGNvZGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplQ2xhc3NGcm9tQ2xhc3ModGhyZWFkLCBmcmFtZSwgY2xzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBjbGFzc1JlZik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBuZXdfZmFzdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBjbGFzc1JlZiA9IDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKTtcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2gobmV3IGNsYXNzUmVmLmNsc0NvbnN0cnVjdG9yKHRocmVhZCkpO1xuICAgIGZyYW1lLnBjICs9IDM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIG5ld2FycmF5KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgLy8gVE9ETzogU3Rhc2ggYWxsIG9mIHRoZXNlIGFycmF5IHR5cGVzIGR1cmluZyBKVk0gc3RhcnR1cC5cbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICB0eXBlID0gXCJbXCIgKyBBcnJheVR5cGVzW2NvZGUucmVhZFVJbnQ4KHBjICsgMSldLFxuICAgICAgY2xzID0gPENsYXNzRGF0YS5BcnJheUNsYXNzRGF0YTxhbnk+PiBmcmFtZS5nZXRMb2FkZXIoKS5nZXRJbml0aWFsaXplZENsYXNzKHRocmVhZCwgdHlwZSksXG4gICAgICBsZW5ndGggPSBvcFN0YWNrLnBvcCgpO1xuICAgIGlmIChsZW5ndGggPj0gMCkge1xuICAgICAgb3BTdGFjay5wdXNoKG5ldyAoY2xzLmdldENvbnN0cnVjdG9yKHRocmVhZCkpKHRocmVhZCwgbGVuZ3RoKSk7XG4gICAgICBmcmFtZS5wYyArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0V4Y2VwdGlvbih0aHJlYWQsIGZyYW1lLCAnTGphdmEvbGFuZy9OZWdhdGl2ZUFycmF5U2l6ZUV4Y2VwdGlvbjsnLCBgVHJpZWQgdG8gaW5pdCAke3R5cGV9IGFycmF5IHdpdGggbGVuZ3RoICR7bGVuZ3RofWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYW5ld2FycmF5KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGNsYXNzUmVmID0gPENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGlmIChjbGFzc1JlZi5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIC8vIFJld3JpdGUgYW5kIHJlcnVuLlxuICAgICAgY29kZS53cml0ZVVJbnQ4KGVudW1zLk9wQ29kZS5BTkVXQVJSQVlfRkFTVCwgcGMpO1xuICAgICAgY2xhc3NSZWYuYXJyYXlDbGFzcyA9IDxDbGFzc0RhdGEuQXJyYXlDbGFzc0RhdGE8YW55Pj4gZnJhbWUuZ2V0TG9hZGVyKCkuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsIGBbJHtjbGFzc1JlZi5jbHMuZ2V0SW50ZXJuYWxOYW1lKCl9YCk7XG4gICAgICBjbGFzc1JlZi5hcnJheUNsYXNzQ29uc3RydWN0b3IgPSBjbGFzc1JlZi5hcnJheUNsYXNzLmdldENvbnN0cnVjdG9yKHRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgY2xhc3NSZWYpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYW5ld2FycmF5X2Zhc3QodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBjbGFzc1JlZiA9IDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKSxcbiAgICAgIGxlbmd0aCA9IG9wU3RhY2sucG9wKCk7XG5cbiAgICBpZiAobGVuZ3RoID49IDApIHtcbiAgICAgIG9wU3RhY2sucHVzaChuZXcgY2xhc3NSZWYuYXJyYXlDbGFzc0NvbnN0cnVjdG9yKHRocmVhZCwgbGVuZ3RoKSk7XG4gICAgICBmcmFtZS5wYyArPSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0V4Y2VwdGlvbih0aHJlYWQsIGZyYW1lLCAnTGphdmEvbGFuZy9OZWdhdGl2ZUFycmF5U2l6ZUV4Y2VwdGlvbjsnLCBgVHJpZWQgdG8gaW5pdCAke2NsYXNzUmVmLmFycmF5Q2xhc3MuZ2V0SW50ZXJuYWxOYW1lKCl9IGFycmF5IHdpdGggbGVuZ3RoICR7bGVuZ3RofWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYXJyYXlsZW5ndGgodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBvcFN0YWNrID0gZnJhbWUub3BTdGFjaywgb2JqOiBKVk1UeXBlcy5KVk1BcnJheTxhbnk+ID0gb3BTdGFjay5wb3AoKTtcbiAgICBpZiAoIWlzTnVsbCh0aHJlYWQsIGZyYW1lLCBvYmopKSB7XG4gICAgICBvcFN0YWNrLnB1c2gob2JqLmFycmF5Lmxlbmd0aCk7XG4gICAgICBmcmFtZS5wYysrO1xuICAgIH1cbiAgICAvLyBvYmogaXMgTlVMTC4gaXNOdWxsIHRocmV3IGFuIGV4Y2VwdGlvbiBmb3IgdXMuXG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGF0aHJvdyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgdGhyZWFkLnRocm93RXhjZXB0aW9uKGZyYW1lLm9wU3RhY2sucG9wKCkpO1xuICAgIGZyYW1lLnJldHVyblRvVGhyZWFkTG9vcCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNoZWNrY2FzdCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIHZhciBjbGFzc1JlZiA9IDxDb25zdGFudFBvb2wuQ2xhc3NSZWZlcmVuY2U+IGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50MTZCRShwYyArIDEpKTtcbiAgICBpZiAoY2xhc3NSZWYuaXNSZXNvbHZlZCgpKSB7XG4gICAgICAvLyBSZXdyaXRlIHRvIGZhc3QgdmVyc2lvbiwgYW5kIHJlLWV4ZWN1dGUuXG4gICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLkNIRUNLQ0FTVF9GQVNULCBwYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgY2xhc3NSZWYpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY2hlY2tjYXN0X2Zhc3QodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgY2xhc3NSZWYgPSA8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSksXG4gICAgICBjbHMgPSBjbGFzc1JlZi5jbHMsXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIG86IEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3QgPSBvcFN0YWNrLnRvcCgpO1xuICAgIGlmICgobyAhPSBudWxsKSAmJiAhby5nZXRDbGFzcygpLmlzQ2FzdGFibGUoY2xzKSkge1xuICAgICAgdmFyIHRhcmdldENsYXNzID0gY2xzLmdldEV4dGVybmFsTmFtZSgpO1xuICAgICAgdmFyIGNhbmRpZGF0ZUNsYXNzID0gby5nZXRDbGFzcygpLmdldEV4dGVybmFsTmFtZSgpO1xuICAgICAgdGhyb3dFeGNlcHRpb24odGhyZWFkLCBmcmFtZSwgJ0xqYXZhL2xhbmcvQ2xhc3NDYXN0RXhjZXB0aW9uOycsIGAke2NhbmRpZGF0ZUNsYXNzfSBjYW5ub3QgYmUgY2FzdCB0byAke3RhcmdldENsYXNzfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdWNjZXNzIVxuICAgICAgZnJhbWUucGMgKz0gMztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGluc3RhbmNlb2YodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgY2xhc3NSZWYgPSA8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG4gICAgaWYgKGNsYXNzUmVmLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgLy8gUmV3cml0ZSBhbmQgcmVydW4uXG4gICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLklOU1RBTkNFT0ZfRkFTVCwgcGMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGZXRjaCBjbGFzcyBhbmQgcmVydW4gb3Bjb2RlLlxuICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBjbGFzc1JlZik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBpbnN0YW5jZW9mX2Zhc3QodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgY2xhc3NSZWYgPSA8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSksXG4gICAgICBjbHMgPSBjbGFzc1JlZi5jbHMsXG4gICAgICBvcFN0YWNrID0gZnJhbWUub3BTdGFjayxcbiAgICAgIG8gPSA8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4gb3BTdGFjay5wb3AoKTtcbiAgICBvcFN0YWNrLnB1c2gobyAhPT0gbnVsbCA/IChvLmdldENsYXNzKCkuaXNDYXN0YWJsZShjbHMpID8gMSA6IDApIDogMCk7XG4gICAgZnJhbWUucGMgKz0gMztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbW9uaXRvcmVudGVyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUpIHtcbiAgICB2YXIgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssIG1vbml0b3JPYmo6IEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3QgPSBvcFN0YWNrLnBvcCgpLFxuICAgICAgbW9uaXRvckVudGVyZWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIFtOb3RlOiBUaHJlYWQgaXMgbm93IGluIHRoZSBSVU5OQUJMRSBzdGF0ZS5dXG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUgUEMuXG4gICAgICAgIGZyYW1lLnBjKys7XG4gICAgICB9O1xuXG4gICAgaWYgKCFtb25pdG9yT2JqLmdldE1vbml0b3IoKS5lbnRlcih0aHJlYWQsIG1vbml0b3JFbnRlcmVkKSkge1xuICAgICAgLy8gT3Bjb2RlIGZhaWxlZC4gbW9uaXRvckVudGVyZWQgd2lsbCBiZSBydW4gb25jZSB3ZSBvd24gdGhlIG1vbml0b3IuXG4gICAgICAvLyBUaGUgdGhyZWFkIGlzIG5vdyBpbiB0aGUgQkxPQ0tFRCBzdGF0ZS4gVGVsbCB0aGUgZnJhbWUgdG8gcmV0dXJuIHRvXG4gICAgICAvLyB0aGUgdGhyZWFkIGxvb3AuXG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb25pdG9yRW50ZXJlZCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbW9uaXRvcmV4aXQodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSkge1xuICAgIHZhciBtb25pdG9yT2JqOiBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0ID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICBpZiAobW9uaXRvck9iai5nZXRNb25pdG9yKCkuZXhpdCh0aHJlYWQpKSB7XG4gICAgICBmcmFtZS5wYysrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb25pdG9yZXhpdCBmYWlsZWQsIGFuZCB0aHJldyBhbiBleGNlcHRpb24uXG4gICAgICBmcmFtZS5yZXR1cm5Ub1RocmVhZExvb3AgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbXVsdGlhbmV3YXJyYXkodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgY2xhc3NSZWYgPSA8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPiBmcmFtZS5tZXRob2QuY2xzLmNvbnN0YW50UG9vbC5nZXQoY29kZS5yZWFkVUludDE2QkUocGMgKyAxKSk7XG4gICAgaWYgKGNsYXNzUmVmLmlzUmVzb2x2ZWQoKSkge1xuICAgICAgLy8gUmV3cml0ZSBhbmQgcmVydW4uXG4gICAgICBjb2RlLndyaXRlVUludDgoZW51bXMuT3BDb2RlLk1VTFRJQU5FV0FSUkFZX0ZBU1QsIHBjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZUNQSXRlbSh0aHJlYWQsIGZyYW1lLCBjbGFzc1JlZik7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBtdWx0aWFuZXdhcnJheV9mYXN0KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGNsYXNzUmVmID0gPENvbnN0YW50UG9vbC5DbGFzc1JlZmVyZW5jZT4gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpLFxuICAgICAgb3BTdGFjayA9IGZyYW1lLm9wU3RhY2ssXG4gICAgICBkaW0gPSBjb2RlLnJlYWRVSW50OChwYyArIDMpLFxuICAgICAgaTogbnVtYmVyLFxuICAgICAgLy8gQXJndW1lbnRzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pLCBkaW1TaXplOiBudW1iZXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGltOyBpKyspIHtcbiAgICAgIGRpbVNpemUgPSBvcFN0YWNrLnBvcCgpO1xuICAgICAgYXJnc1tkaW0gLSBpIC0gMV0gPSBkaW1TaXplO1xuICAgICAgaWYgKGRpbVNpemUgPCAwKSB7XG4gICAgICAgIHRocm93RXhjZXB0aW9uKHRocmVhZCwgZnJhbWUsICdMamF2YS9sYW5nL05lZ2F0aXZlQXJyYXlTaXplRXhjZXB0aW9uOycsIGBUcmllZCB0byBpbml0ICR7Y2xhc3NSZWYuY2xzLmdldEludGVybmFsTmFtZSgpfSBhcnJheSB3aXRoIGEgZGltZW5zaW9uIG9mIGxlbmd0aCAke2RpbVNpemV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb3BTdGFjay5wdXNoKG5ldyAoY2xhc3NSZWYuY2xzLmdldENvbnN0cnVjdG9yKHRocmVhZCkpKHRocmVhZCwgYXJncykpO1xuICAgIGZyYW1lLnBjICs9IDQ7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlmbnVsbCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGlmIChmcmFtZS5vcFN0YWNrLnBvcCgpID09IG51bGwpIHtcbiAgICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDE2QkUocGMgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUucGMgKz0gMztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGlmbm9ubnVsbCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGlmIChmcmFtZS5vcFN0YWNrLnBvcCgpICE9IG51bGwpIHtcbiAgICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDE2QkUocGMgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUucGMgKz0gMztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdvdG9fdyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBCdWZmZXIpIHtcbiAgICBjb25zdCBwYyA9IGZyYW1lLnBjO1xuICAgIGZyYW1lLnBjICs9IGNvZGUucmVhZEludDMyQkUocGMgKyAxKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMganNyX3codGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICBmcmFtZS5vcFN0YWNrLnB1c2goZnJhbWUucGMgKyA1KTtcbiAgICBmcmFtZS5wYyArPSBjb2RlLnJlYWRJbnQzMkJFKHBjICsgMSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIG5vcCh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGZyYW1lOiB0aHJlYWRpbmcuQnl0ZWNvZGVTdGFja0ZyYW1lKSB7XG4gICAgZnJhbWUucGMgKz0gMTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGRjKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGNvbnN0YW50ID0gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQ4KHBjICsgMSkpO1xuICAgIGlmIChjb25zdGFudC5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIGFzc2VydCgoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGNvbnN0YW50LmdldFR5cGUoKSkge1xuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuU1RSSU5HOlxuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuQ0xBU1M6XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5NRVRIT0RfSEFORExFOlxuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX1RZUEU6XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5JTlRFR0VSOlxuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KSgpLCBgQ29uc3RhbnQgcG9vbCBpdGVtICR7ZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGVbY29uc3RhbnQuZ2V0VHlwZSgpXX0gaXMgbm90IGFwcHJvcHJpYXRlIGZvciBMREMuYCk7XG4gICAgICBmcmFtZS5vcFN0YWNrLnB1c2goY29uc3RhbnQuZ2V0Q29uc3RhbnQodGhyZWFkKSk7XG4gICAgICBmcmFtZS5wYyArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlQ1BJdGVtKHRocmVhZCwgZnJhbWUsIGNvbnN0YW50KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGxkY193KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGNvbnN0YW50ID0gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGlmIChjb25zdGFudC5pc1Jlc29sdmVkKCkpIHtcbiAgICAgIGFzc2VydCgoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGNvbnN0YW50LmdldFR5cGUoKSkge1xuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuU1RSSU5HOlxuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuQ0xBU1M6XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5NRVRIT0RfSEFORExFOlxuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuTUVUSE9EX1RZUEU6XG4gICAgICAgICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5JTlRFR0VSOlxuICAgICAgICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KSgpLCBgQ29uc3RhbnQgcG9vbCBpdGVtICR7ZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGVbY29uc3RhbnQuZ2V0VHlwZSgpXX0gaXMgbm90IGFwcHJvcHJpYXRlIGZvciBMRENfVy5gKTtcbiAgICAgIGZyYW1lLm9wU3RhY2sucHVzaChjb25zdGFudC5nZXRDb25zdGFudCh0aHJlYWQpKTtcbiAgICAgIGZyYW1lLnBjICs9IDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDUEl0ZW0odGhyZWFkLCBmcmFtZSwgY29uc3RhbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgbGRjMl93KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgZnJhbWU6IHRocmVhZGluZy5CeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHBjID0gZnJhbWUucGM7XG4gICAgdmFyIGNvbnN0YW50ID0gZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpO1xuICAgIGFzc2VydChjb25zdGFudC5nZXRUeXBlKCkgPT09IGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLkxPTkdcbiAgICAgIHx8IGNvbnN0YW50LmdldFR5cGUoKSA9PT0gZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRE9VQkxFLFxuICAgICAgYEludmFsaWQgbGRjX3cgY29uc3RhbnQgcG9vbCB0eXBlOiAke2VudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlW2NvbnN0YW50LmdldFR5cGUoKV19YCk7XG4gICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoKDxDb25zdGFudFBvb2wuQ29uc3RMb25nIHwgQ29uc3RhbnRQb29sLkNvbnN0RG91YmxlPiBjb25zdGFudCkudmFsdWUpO1xuICAgIGZyYW1lLnBjICs9IDM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHdpZGUodGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBmcmFtZTogdGhyZWFkaW5nLkJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogQnVmZmVyKSB7XG4gICAgY29uc3QgcGMgPSBmcmFtZS5wYztcbiAgICB2YXIgaW5kZXggPSBjb2RlLnJlYWRVSW50MTZCRShwYyArIDIpO1xuICAgIC8vIEluY3JlbWVudCBQQyBiZWZvcmUgc3dpdGNoIHRvIGF2b2lkIGlzc3VlIHdoZXJlIHJldCBjaGFuY2VzIFBDIGFuZCB3ZVxuICAgIC8vIGVycm9uZW91c2x5IGluY3JlbWVudCB0aGUgUEMgZnVydGhlci5cbiAgICBmcmFtZS5wYyArPSA0O1xuICAgIHN3aXRjaCAoY29kZS5yZWFkVUludDgocGMgKyAxKSkge1xuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSUxPQUQ6XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5GTE9BRDpcbiAgICAgIGNhc2UgZW51bXMuT3BDb2RlLkFMT0FEOlxuICAgICAgICBmcmFtZS5vcFN0YWNrLnB1c2goZnJhbWUubG9jYWxzW2luZGV4XSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuTExPQUQ6XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5ETE9BRDpcbiAgICAgICAgZnJhbWUub3BTdGFjay5wdXNoV2l0aE51bGwoZnJhbWUubG9jYWxzW2luZGV4XSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSVNUT1JFOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuRlNUT1JFOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuQVNUT1JFOlxuICAgICAgICBmcmFtZS5sb2NhbHNbaW5kZXhdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5MU1RPUkU6XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5EU1RPUkU6XG4gICAgICAgIC8vIE5VTExcbiAgICAgICAgZnJhbWUubG9jYWxzW2luZGV4ICsgMV0gPSBmcmFtZS5vcFN0YWNrLnBvcCgpO1xuICAgICAgICAvLyBUaGUgYWN0dWFsIHZhbHVlLlxuICAgICAgICBmcmFtZS5sb2NhbHNbaW5kZXhdID0gZnJhbWUub3BTdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5SRVQ6XG4gICAgICAgIGZyYW1lLnBjID0gZnJhbWUubG9jYWxzW2luZGV4XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5JSU5DOlxuICAgICAgICB2YXIgdmFsdWUgPSBjb2RlLnJlYWRJbnQxNkJFKHBjICsgNCk7XG4gICAgICAgIGZyYW1lLmxvY2Fsc1tpbmRleF0gPSAoZnJhbWUubG9jYWxzW2luZGV4XSArIHZhbHVlKSB8IDA7XG4gICAgICAgIC8vIHdpZGUgaWluYyBoYXMgMiBleHRyYSBieXRlcy5cbiAgICAgICAgZnJhbWUucGMgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhc3NlcnQoZmFsc2UsIGBVbmtub3duIHdpZGUgb3Bjb2RlOiAke2NvZGUucmVhZFVJbnQ4KHBjICsgMSl9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdmFyIExvb2t1cFRhYmxlOiBJT3Bjb2RlSW1wbGVtZW50YXRpb25bXSA9IG5ldyBBcnJheSgweGZmKTtcbi8vIFB1dCBpbiBmdW5jdGlvbiBjbG9zdXJlIHRvIHByZXZlbnQgc2NvcGUgcG9sbHV0aW9uLlxuKCgpID0+IHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAweGZmOyBpKyspIHtcbiAgICBpZiAoZW51bXMuT3BDb2RlLmhhc093blByb3BlcnR5KFwiXCIgKyBpKSkge1xuICAgICAgTG9va3VwVGFibGVbaV0gPSAoPGFueT4gT3Bjb2RlcylbZW51bXMuT3BDb2RlW2ldLnRvTG93ZXJDYXNlKCldO1xuICAgICAgYXNzZXJ0KExvb2t1cFRhYmxlW2ldICE9IG51bGwsIGBNaXNzaW5nIGltcGxlbWVudGF0aW9uIG9mIG9wY29kZSAke2VudW1zLk9wQ29kZVtpXX1gKTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCJleHBvcnQgY29uc3QgZW51bSBQYXJzZVR5cGUge1xuICAvLyBBIHNpbXBsZSBmbGFnLCBlLmcuIC1oZWxwXG4gIEZMQUcsXG4gIC8vIEFuIG9wdGlvbiB0aGF0IGNvbnRhaW5zIGEgdmFsdWUgc3BlY2lmaWVkIHdpdGggY29sb24gc3ludGF4LCBlLmcuXG4gIC8vIC1lYTpteVBrZy4uLi5cbiAgQ09MT05fVkFMVUVfU1lOVEFYLFxuICAvLyBBbiBvcHRpb24gdGhhdCBjYW4gc3BlY2lmaWVkIGFzIGEgZmxhZywgb3Igd2l0aCBhIHZhbHVlLlxuICBDT0xPTl9WQUxVRV9PUl9GTEFHX1NZTlRBWCxcbiAgLy8gQW4gb3B0aW9uIHRoYXQgY29udGFpbnMgYSB2YWx1ZSBzcGVjaWZpZWQgaW4gYSBub3JtYWwgZmFzaGlvbiwgZS5nLlxuICAvLyAtY3AgLlxuICAvLyBUaGVzZSByZXF1aXJlIHRoYXQgYSB2YWx1ZSBiZSBzZXQuXG4gIE5PUk1BTF9WQUxVRV9TWU5UQVgsXG4gIC8vIEFuIG9wdGlvbiBzcGVjaWZpZWQgYXMgYSBtYXAsIGUuZy4gdGhlIG9wdGlvbiAnRCc6IC1Ea2V5PXZhbHVlXG4gIC8vIFRoZXNlIGNhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMuXG4gIE1BUF9TWU5UQVhcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXNjcmlwdGlvbiB7XG4gIFtwcmVmaXg6IHN0cmluZ106IERlc2NyaXB0aW9uQ2F0ZWdvcnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXNjcmlwdGlvbkNhdGVnb3J5IHtcbiAgW29wdGlvbk5hbWU6IHN0cmluZ106IE9wdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb24ge1xuICAvLyBEZXNjcmliZXMgdGhlIG9wdGlvbi4gVXNlZCBmb3IgaGVscCB0ZXh0LlxuICBkZXNjPzogc3RyaW5nO1xuICAvLyBEZXNjcmliZXMgaG93IHRoZSBvcHRpb24gc2hvdWxkIGJlIHBhcnNlZC4gRGVmYXVsdHMgdG8gJ0ZMQUcnLlxuICB0eXBlPzogUGFyc2VUeXBlXG4gIC8vIEZvciBvcHRpb25zIHRoYXQgdGFrZSBhbiBvcHRpb25hbCB2YWx1ZSwgYW4gZXhhbXBsZSBvZiB0aGUgb3B0aW9uLlxuICAvLyBVc2VkIGZvciBoZWxwIHRleHQuXG4gIG9wdERlc2M/OiBzdHJpbmc7XG4gIC8vIERlc2NyaWJlcyBhIHNob3J0IGFsaWFzIGZvciB0aGUgb3B0aW9uLlxuICBhbGlhcz86IHN0cmluZztcbiAgLy8gQWZ0ZXIgcGFyc2luZyB0aGlzIG9wdGlvbiwgc3RvcCBwYXJzaW5nLiBUaGUgcmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBzaG91bGQgYmUgcGFzc2VkIGluIHJhdy5cbiAgc3RvcFBhcnNpbmc/OiBib29sZWFuO1xuICAvLyBbSU5URVJOQUwgT05MWV1cbiAgcHJlZml4Pzogc3RyaW5nO1xuICAvLyBbSU5URVJOQUwgT05MWV1cbiAgbmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYXdQcmVmaXhQYXJzZVJlc3VsdCB7XG4gIFtvcHRpb25OYW1lOiBzdHJpbmddOiBib29sZWFuIHwgc3RyaW5nIHwge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9XG59XG5cbi8vIFVzYWdlLlxuXG5leHBvcnQgY2xhc3MgUHJlZml4UGFyc2VSZXN1bHQge1xuICBwcml2YXRlIF9yZXN1bHQ6IFJhd1ByZWZpeFBhcnNlUmVzdWx0O1xuICBwcml2YXRlIF91bnBhcnNlZEFyZ3M6IHN0cmluZ1tdO1xuICBjb25zdHJ1Y3RvcihyZXN1bHQ6IFJhd1ByZWZpeFBhcnNlUmVzdWx0LCB1bnBhcnNlZEFyZ3M6IHN0cmluZ1tdID0gW10pIHtcbiAgICB0aGlzLl9yZXN1bHQgPSByZXN1bHQ7XG4gICAgdGhpcy5fdW5wYXJzZWRBcmdzID0gdW5wYXJzZWRBcmdzO1xuICB9XG5cbiAgcHVibGljIHVucGFyc2VkQXJncygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3VucGFyc2VkQXJncztcbiAgfVxuXG4gIHB1YmxpYyBmbGFnKG5hbWU6IHN0cmluZywgZGVmYXVsdFZhbDogYm9vbGVhbik6IGJvb2xlYW4ge1xuICAgIGxldCB2YWwgPSB0aGlzLl9yZXN1bHRbbmFtZV07XG4gICAgaWYgKHR5cGVvZih2YWwpID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiA8Ym9vbGVhbj4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbDtcbiAgfVxuXG4gIHB1YmxpYyBzdHJpbmdPcHRpb24obmFtZTogc3RyaW5nLCBkZWZhdWx0VmFsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCB2YWwgPSB0aGlzLl9yZXN1bHRbbmFtZV07XG4gICAgaWYgKHR5cGVvZih2YWwpID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIDxzdHJpbmc+IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWw7XG4gIH1cblxuICBwdWJsaWMgbWFwT3B0aW9uKG5hbWU6IHN0cmluZyk6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSB7XG4gICAgbGV0IHZhbCA9IHRoaXMuX3Jlc3VsdFtuYW1lXTtcbiAgICBpZiAodHlwZW9mKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gPHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfT4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZVJlc3VsdCB7XG4gIFtwcmVmaXg6IHN0cmluZ106IFByZWZpeFBhcnNlUmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRPcHROYW1lKHByZWZpeDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcHJlZml4ICE9PSAnZGVmYXVsdCcgPyBgJHtwcmVmaXh9JHtuYW1lfWAgOiBuYW1lXG59XG5cbi8qKlxuICogSGFuZGxlcyBwYXJzaW5nIGZvciBhIHNwZWNpZmljIG9wdGlvbnMgY29uZmlndXJhdGlvbi5cbiAqIFBhcnNlcyBKYXZhLXN0eWxlIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHRpb25QYXJzZXIge1xuICBwcml2YXRlIF9wYXJzZU1hcDoge1tvcHROYW1lOiBzdHJpbmddOiBPcHRpb259ID0ge307XG4gIHByaXZhdGUgX3ByZWZpeGVzOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIF9tYXBBcmdzOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIF9yYXdEZXNjOiBEZXNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihkZXNjOiBEZXNjcmlwdGlvbikge1xuICAgIHRoaXMuX3Jhd0Rlc2MgPSBkZXNjO1xuICAgIHRoaXMuX3ByZWZpeGVzID0gT2JqZWN0LmtleXMoZGVzYyk7XG4gICAgdGhpcy5fcHJlZml4ZXMuZm9yRWFjaCgocHJlZml4KSA9PiB7XG4gICAgICBsZXQgb3B0cyA9IGRlc2NbcHJlZml4XTtcbiAgICAgIGxldCBvcHROYW1lcyA9IE9iamVjdC5rZXlzKG9wdHMpO1xuICAgICAgb3B0TmFtZXMuc2xpY2UoMCkuZm9yRWFjaCgob3B0TmFtZSkgPT4ge1xuICAgICAgICBsZXQgb3B0aW9uID0gb3B0c1tvcHROYW1lXTtcbiAgICAgICAgaWYgKCFvcHRpb24udHlwZSkge1xuICAgICAgICAgIG9wdGlvbi50eXBlID0gUGFyc2VUeXBlLkZMQUc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbi50eXBlID09PSBQYXJzZVR5cGUuTUFQX1NZTlRBWCkge1xuICAgICAgICAgIC8vIEFTU1VNUFRJT046IFRoZXNlIGRvIG5vdCBoYXZlIGFsaWFzZXMuXG4gICAgICAgICAgdGhpcy5fbWFwQXJncy5wdXNoKG9wdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbi5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIG9wdGlvbi5uYW1lID0gb3B0TmFtZTtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBbZ2V0T3B0TmFtZShwcmVmaXgsIG9wdE5hbWUpXSA9IG9wdGlvbjtcbiAgICAgICAgaWYgKG9wdGlvbi5hbGlhcykge1xuICAgICAgICAgIG9wdE5hbWVzLnB1c2gob3B0aW9uLmFsaWFzKTtcbiAgICAgICAgICB0aGlzLl9wYXJzZU1hcFtnZXRPcHROYW1lKHByZWZpeCwgb3B0aW9uLmFsaWFzKV0gPSBvcHRpb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gYXJndW1lbnRzLiBUaHJvd3MgYW4gZXhjZXB0aW9uIG9uIHBhcnNpbmcgZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBwYXJzZShhcmd2OiBzdHJpbmdbXSk6IFBhcnNlUmVzdWx0IHtcbiAgICBsZXQgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IFJhd1ByZWZpeFBhcnNlUmVzdWx0fSA9IHt9LFxuICAgICAgcHRyOiBudW1iZXIgPSAwLFxuICAgICAgbGVuOiBudW1iZXI7XG5cbiAgICB0aGlzLl9wcmVmaXhlcy5mb3JFYWNoKChwcmVmaXgpID0+IHJlc3VsdFtwcmVmaXhdID0ge30pO1xuXG4gICAgYXJndiA9IGFyZ3YubWFwKChhcmcpID0+IGFyZy50cmltKCkpLmZpbHRlcigoYXJnKSA9PiBhcmcgIT09ICcnKTtcbiAgICBsZW4gPSBhcmd2Lmxlbmd0aDtcblxuICAgIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICAgIHZhciBhcmcgPSBhcmd2W3B0cl07XG4gICAgICBpZiAoYXJnWzBdID09PSAnLScpIHtcbiAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEpO1xuICAgICAgICB2YXIgb3B0OiBPcHRpb247XG4gICAgICAgIGlmIChvcHQgPSB0aGlzLl9wYXJzZU1hcFthcmddKSB7XG4gICAgICAgICAgc3dpdGNoIChvcHQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQYXJzZVR5cGUuRkxBRzpcbiAgICAgICAgICAgIGNhc2UgUGFyc2VUeXBlLkNPTE9OX1ZBTFVFX09SX0ZMQUdfU1lOVEFYOlxuICAgICAgICAgICAgICByZXN1bHRbb3B0LnByZWZpeF1bb3B0Lm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBhcnNlVHlwZS5OT1JNQUxfVkFMVUVfU1lOVEFYOlxuICAgICAgICAgICAgY2FzZSBQYXJzZVR5cGUuQ09MT05fVkFMVUVfU1lOVEFYOlxuICAgICAgICAgICAgICBwdHIrKztcbiAgICAgICAgICAgICAgaWYgKHB0ciA8IGxlbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtvcHQucHJlZml4XVtvcHQubmFtZV0gPSBhcmd2W3B0cl07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAtJHthcmd9IHJlcXVpcmVzIGFuIGFyZ3VtZW50LmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQYXJzZVR5cGUuTUFQX1NZTlRBWDpcbiAgICAgICAgICAgICAgLy8gTk9QLlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEludmFsaWQuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSU5URVJOQUwgRVJST1I6IEludmFsaWQgcGFyc2UgdHlwZSBmb3IgLSR7YXJnfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbWFwQXJncy5maWx0ZXIoKG1hcEFyZykgPT4ge1xuICAgICAgICAgIGlmIChhcmcuc2xpY2UoMCwgbWFwQXJnLmxlbmd0aCkgPT09IG1hcEFyZykge1xuICAgICAgICAgICAgb3B0ID0gdGhpcy5fcGFyc2VNYXBbbWFwQXJnXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBBU1NVTVBUSU9OOiBNYXAgYXJncyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAgICAgIC8vIEFyZ3VtZW50IGlzIC17bWFwQXJnfWtleT12YWx1ZVxuICAgICAgICAgIC8vIElmIG5vIHZhbHVlLCBzZXQgdG8gJycuXG4gICAgICAgICAgbGV0IG1hcHBpbmcgPSBhcmcuc2xpY2Uob3B0Lm5hbWUubGVuZ3RoKSxcbiAgICAgICAgICAgIG1hcCA9IDx7W25hbWU6IHN0cmluZ106IHN0cmluZ30+IHJlc3VsdFtvcHQucHJlZml4XVtvcHQubmFtZV07XG4gICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IHJlc3VsdFtvcHQucHJlZml4XVtvcHQubmFtZV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGVxSWR4ID0gbWFwcGluZy5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgaWYgKGVxSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgbWFwW21hcHBpbmcuc2xpY2UoMCwgZXFJZHgpXSA9IG1hcHBpbmcuc2xpY2UoZXFJZHggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwW21hcHBpbmddID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnLmluZGV4T2YoJzonKSAhPT0gLTEgJiYgKG9wdCA9IHRoaXMuX3BhcnNlTWFwW2FyZy5zbGljZSgwLCBhcmcuaW5kZXhPZignOicpKV0pKSB7XG4gICAgICAgICAgLy8gQ29sb24gb3B0aW9uLlxuICAgICAgICAgIGlmIChvcHQudHlwZSA9PT0gUGFyc2VUeXBlLkNPTE9OX1ZBTFVFX1NZTlRBWCB8fCBvcHQudHlwZSA9PT0gUGFyc2VUeXBlLkNPTE9OX1ZBTFVFX09SX0ZMQUdfU1lOVEFYKSB7XG4gICAgICAgICAgICByZXN1bHRbb3B0LnByZWZpeF1bb3B0Lm5hbWVdID0gYXJnLnNsaWNlKGFyZy5pbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIG9wdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG9wdGlvbjogLSR7YXJnfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBvcHRpb246IC0ke2FyZ31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuc3RvcFBhcnNpbmcpIHtcbiAgICAgICAgICBwdHIrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQWR2YW5jZSB0byBuZXh0IHZhbHVlLlxuICAgICAgcHRyKys7XG4gICAgfVxuICAgIC8vIHB0ciBpcyBhdCByYXcgYXJncyB0byBwcm9ncmFtIC8gSlZNLlxuICAgIGxldCB1bnBhcnNlZEFyZ3MgPSBhcmd2LnNsaWNlKHB0ciksXG4gICAgICBydjogUGFyc2VSZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goKHByZWZpeCkgPT4ge1xuICAgICAgcnZbcHJlZml4XSA9IG5ldyBQcmVmaXhQYXJzZVJlc3VsdChyZXN1bHRbcHJlZml4XSwgdW5wYXJzZWRBcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGhlbHAgdGV4dCBmb3IgdGhlIGdpdmVuIHByZWZpeGVkIG9wdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgaGVscChwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIF9zaG93SGVscCh0aGlzLl9yYXdEZXNjW3ByZWZpeF0sIHByZWZpeCA9PT0gJ2RlZmF1bHQnID8gJycgOiBwcmVmaXgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50Q29sKHZhbHVlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIpOiBzdHJpbmcge1xuICB2YXIgcnYgPSB2YWx1ZTtcbiAgdmFyIHBhZGRpbmcgPSB3aWR0aCAtIHZhbHVlLmxlbmd0aDtcbiAgd2hpbGUgKHBhZGRpbmctLSA+IDApIHtcbiAgICBydiArPSAnICc7XG4gIH1cbiAgcmV0dXJuIHJ2O1xufVxuXG5mdW5jdGlvbiBfc2hvd0hlbHAoY2F0ZWdvcnk6IERlc2NyaXB0aW9uQ2F0ZWdvcnksIHByZWZpeDogc3RyaW5nKTogc3RyaW5nIHtcbiAgdmFyIGNvbWJpbmVkS2V5cyA6IHtbazpzdHJpbmddOk9wdGlvbn0gPSB7fTtcbiAgdmFyIGtleUNvbFdpZHRoID0gMTM7XG4gIE9iamVjdC5rZXlzKGNhdGVnb3J5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICB2YXIgb3B0ID0gY2F0ZWdvcnlba2V5XTtcbiAgICAvLyBJZ25vcmVkIGluIGhlbHAgdGV4dC5cbiAgICBpZiAob3B0LnN0b3BQYXJzaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlzID0gW2tleV07XG4gICAgaWYgKG9wdC5hbGlhcyAhPSBudWxsKSB7XG4gICAgICBrZXlzLnB1c2gob3B0LmFsaWFzKTtcbiAgICB9XG5cbiAgICBsZXQgY2tleTogc3RyaW5nO1xuICAgIGlmIChvcHQub3B0RGVzYykge1xuICAgICAgY2tleSA9IGtleXMubWFwKChrZXk6IHN0cmluZykgPT4gYC0ke3ByZWZpeH0ke2tleX0ke29wdC5vcHREZXNjfWApLmpvaW4oXCJcXG5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNrZXkgPSBrZXlzLm1hcCgoa2V5OiBzdHJpbmcpID0+IGAtJHtwcmVmaXh9JHtrZXl9YCkuam9pbignIHwgJyk7XG4gICAgfVxuICAgIGNvbWJpbmVkS2V5c1tja2V5XSA9IG9wdDtcbiAgfSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhjb21iaW5lZEtleXMpLm1hcCgoa2V5KSA9PiB7XG4gICAgbGV0IG9wdGlvbiA9IGNvbWJpbmVkS2V5c1trZXldO1xuICAgIGlmIChvcHRpb24ub3B0RGVzYykge1xuICAgICAgbGV0IGNvbHMgPSBrZXkuc3BsaXQoJ1xcbicpO1xuICAgICAgbGV0IHJ2ID0gY29scy5tYXAoKHJvdykgPT4gIGAgICAgJHtyb3d9YCk7XG4gICAgICAvLyBNdWx0aWxpbmUuXG4gICAgICByZXR1cm4gYCR7cnYuam9pbignXFxuJyl9XFxuICAgICAgICAgICAgICAgICAgJHtvcHRpb24uZGVzY31gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sVGV4dCA9IHByaW50Q29sKGtleSwga2V5Q29sV2lkdGgpO1xuICAgICAgaWYgKGNvbFRleHQubGVuZ3RoID09PSBrZXlDb2xXaWR0aCkge1xuICAgICAgICByZXR1cm4gYCAgICAke2NvbFRleHR9ICR7b3B0aW9uLmRlc2N9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgICAgICR7Y29sVGV4dH1cXG4gICAgICAgICAgICAgICAgICAke29wdGlvbi5kZXNjfWA7XG4gICAgICB9XG4gICAgfVxuICB9KS5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuIiwiaW1wb3J0IHtUaHJlYWRTdGF0dXN9IGZyb20gJy4vZW51bXMnO1xuaW1wb3J0IHtKVk1UaHJlYWR9IGZyb20gJy4vdGhyZWFkaW5nJztcbmltcG9ydCBhc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG4vKipcbiAqIE1hbmFnZXMgcGFya2VkIHRocmVhZHMgYW5kIHRoZWlyIGNhbGxiYWNrcy5cbiAqL1xuY2xhc3MgUGFya2VyIHtcbiAgcHJpdmF0ZSBfcGFya0NvdW50czogeyBbdGhyZWFkUmVmOiBudW1iZXJdOiBudW1iZXIgfSA9IHt9O1xuICBwcml2YXRlIF9wYXJrQ2FsbGJhY2tzOiB7IFt0aHJlYWRSZWY6IG51bWJlcl06ICgpID0+IHZvaWQgfSA9IHt9O1xuXG4gIHB1YmxpYyBwYXJrKHRocmVhZDogSlZNVGhyZWFkLCBjYjogKCkgPT4gdm9pZCkge1xuICAgIHZhciByZWYgPSB0aHJlYWQuZ2V0UmVmKCk7XG4gICAgYXNzZXJ0KCF0aGlzLl9wYXJrQ2FsbGJhY2tzW3JlZl0gJiYgdGhyZWFkLmdldFN0YXR1cygpICE9PSBUaHJlYWRTdGF0dXMuUEFSS0VELCBgVGhyZWFkICR7cmVmfSBpcyBkb3VibHkgcGFya2VkPyBTaG91bGQgYmUgaW1wb3NzaWJsZS5gKTtcbiAgICB0aGlzLl9wYXJrQ2FsbGJhY2tzW3JlZl0gPSBjYjtcbiAgICB0aGlzLl9tdXRhdGVQYXJrQ291bnQodGhyZWFkLCAxKTtcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRoZSB0aHJlYWQgd2FzIGluc3RhbnRseSB1bnBhcmtlZCBkdWUgdG8gYSBwcmV2aW91c2x5XG4gICAgLy8gdW5iYWxhbmNpbmcgcGFyay5cbiAgICBpZiAodGhpcy5pc1BhcmtlZCh0aHJlYWQpKSB7XG4gICAgICB0aHJlYWQuc2V0U3RhdHVzKFRocmVhZFN0YXR1cy5QQVJLRUQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1bnBhcmsodGhyZWFkOiBKVk1UaHJlYWQpOiB2b2lkIHtcbiAgICB0aGlzLl9tdXRhdGVQYXJrQ291bnQodGhyZWFkLCAtMSk7XG4gIH1cblxuICBwdWJsaWMgY29tcGxldGVseVVucGFyayh0aHJlYWQ6IEpWTVRocmVhZCk6IHZvaWQge1xuICAgIHZhciByZWYgPSB0aHJlYWQuZ2V0UmVmKCksIGNvdW50ID0gdGhpcy5fcGFya0NvdW50c1tyZWZdO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fbXV0YXRlUGFya0NvdW50KHRocmVhZCwgLWNvdW50KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9tdXRhdGVQYXJrQ291bnQodGhyZWFkOiBKVk1UaHJlYWQsIGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcbiAgICB2YXIgcmVmID0gdGhyZWFkLmdldFJlZigpLCBjYjogKCkgPT4gdm9pZDtcbiAgICAvLyBJbml0aWFsaXplIHBhcmsgY291bnQuXG4gICAgaWYgKCF0aGlzLl9wYXJrQ291bnRzW3JlZl0pIHtcbiAgICAgIHRoaXMuX3BhcmtDb3VudHNbcmVmXSA9IDA7XG4gICAgfVxuICAgIGlmICgwID09PSAodGhpcy5fcGFya0NvdW50c1tyZWZdICs9IGRlbHRhKSkge1xuICAgICAgYXNzZXJ0KCEhdGhpcy5fcGFya0NhbGxiYWNrc1tyZWZdLCBgQmFsYW5jaW5nIHVucGFyayBmb3IgdGhyZWFkICR7cmVmfSB3aXRoIG5vIGNhbGxiYWNrPyBTaG91bGQgYmUgaW1wb3NzaWJsZS5gKTtcbiAgICAgIGNiID0gdGhpcy5fcGFya0NhbGxiYWNrc1tyZWZdO1xuXG4gICAgICAvLyBDbGVhbnVwLlxuICAgICAgZGVsZXRlIHRoaXMuX3BhcmtDb3VudHNbcmVmXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJrQ2FsbGJhY2tzW3JlZl07XG5cbiAgICAgIC8vIEF2b2lkIHNpdHVhdGlvbnMgd2hlcmUgYSB0ZXJtaW5hdGVkIHRocmVhZCdzIHRpbWVvdXQgd2FrZXMgdXBcbiAgICAgIC8vIGFuZCB0cmllcyB0byByZXZpdmUgaXRzIHRocmVhZC5cbiAgICAgIGlmICh0aHJlYWQuZ2V0U3RhdHVzKCkgPT09IFRocmVhZFN0YXR1cy5QQVJLRUQpIHtcbiAgICAgICAgdGhyZWFkLnNldFN0YXR1cyhUaHJlYWRTdGF0dXMuQVNZTkNfV0FJVElORyk7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzUGFya2VkKHRocmVhZDogSlZNVGhyZWFkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGFya0NvdW50c1t0aHJlYWQuZ2V0UmVmKCldO1xuICB9XG59XG5cbmV4cG9ydCA9IFBhcmtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IEpWTSA9IHJlcXVpcmUoJy4vanZtJyk7XG5pbXBvcnQgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuaW1wb3J0IGRpZmZsaWIgPSByZXF1aXJlKCcuL2RpZmZsaWInKTtcbmltcG9ydCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuaW1wb3J0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmltcG9ydCBpbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XG5pbXBvcnQgbG9nZ2luZyA9IHJlcXVpcmUoJy4vbG9nZ2luZycpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgb3JpZ2luYWxFcnJvcj86IGFueTtcbiAgZmF0YWw/OiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBtYWtlVGVzdGluZ0Vycm9yKG1zZzogc3RyaW5nLCBvcmlnRXJyPzogYW55LCBmYXRhbD86IGJvb2xlYW4pOiBUZXN0aW5nRXJyb3Ige1xuICB2YXIgZXJyID0gPFRlc3RpbmdFcnJvcj4gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5vcmlnaW5hbEVycm9yID0gb3JpZ0VycjtcbiAgZXJyLmZhdGFsID0gZmF0YWw7XG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogQ2FwdHVyZXMgc3Rkb3V0L3N0ZGVyci5cbiAqIEB0b2RvIERvIHRoaXMgdGhlIHByb3BlciBOb2RlIHdheSBvbmNlIEJGUyBpcyBtb3JlIGNvbXBsaWFudC5cbiAqL1xuY2xhc3MgT3V0cHV0Q2FwdHVyZXIge1xuICBwcml2YXRlIF9zdGRvdXRXcml0ZSA9IHByb2Nlc3Muc3Rkb3V0LndyaXRlO1xuICBwcml2YXRlIF9zdGRlcnJXcml0ZSA9IHByb2Nlc3Muc3RkZXJyLndyaXRlO1xuICBwcml2YXRlIF9kYXRhOiBzdHJpbmcgPSBcIlwiO1xuICBwcml2YXRlIF9pc0NhcHR1cmluZyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZGVidWdXcml0ZShzdHI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX3N0ZG91dFdyaXRlLmFwcGx5KHByb2Nlc3Muc3Rkb3V0LCBbc3RyLCAndXRmOCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbiBjYXB0dXJpbmcgb3V0cHV0LlxuICAgKi9cbiAgcHVibGljIHN0YXJ0KGNsZWFyPzogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9pc0NhcHR1cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbHJlYWR5IGNhcHR1cmluZy5gKTtcbiAgICB9XG4gICAgdGhpcy5faXNDYXB0dXJpbmcgPSB0cnVlO1xuICAgIGlmIChjbGVhcikge1xuICAgICAgdGhpcy5fZGF0YSA9IFwiXCI7XG4gICAgfVxuICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlID0gcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSAoZGF0YTogYW55LCBhcmcyPzogYW55LCBhcmczPzogYW55KTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBCdWZmZXIuXG4gICAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kYXRhICs9IGRhdGE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgY2FwdHVyaW5nIG91dHB1dC5cbiAgICovXG4gIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5faXNDYXB0dXJpbmcpIHtcbiAgICAgIC8vIE1heSBiZSBjYWxsZWQgdHdpY2Ugd2hlbiB0aGVyZSdzIGEgY2F0YXN0cm9waGljIGVycm9yLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0NhcHR1cmluZyA9IGZhbHNlO1xuICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlID0gdGhpcy5fc3RkZXJyV3JpdGU7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUgPSB0aGlzLl9zdGRvdXRXcml0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgY2FwdHVyZWQgb3V0cHV0LlxuICAgKiBAcGFyYW0gY2xlYXIgQ2xlYXIgdGhlIGNhcHR1cmVkIG91dHB1dC5cbiAgICovXG4gIHB1YmxpYyBnZXRPdXRwdXQoY2xlYXI/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgaWYgKGNsZWFyKSB7XG4gICAgICB0aGlzLl9kYXRhID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuLyoqXG4gKiBEb3BwaW8gdGVzdGluZyBvcHRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RPcHRpb25zIGV4dGVuZHMgaW50ZXJmYWNlcy5KVk1PcHRpb25zIHtcbiAgLyoqXG4gICAqIENsYXNzZXMgdG8gdGVzdC4gRWFjaCBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gICAqIC0gZm9vLmJhci5CYXpcbiAgICogLSBmb28vYmFyL0JhelxuICAgKi9cbiAgdGVzdENsYXNzZXM/OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIHVuaXQgdGVzdCwgd2hlcmUgd2UgY29tcGFyZSBEb3BwaW8ncyBvdXRwdXQgdG8gdGhlIG5hdGl2ZVxuICogSlZNLlxuICovXG5leHBvcnQgY2xhc3MgRG9wcGlvVGVzdCB7XG4gIC8qKlxuICAgKiBUZXN0IHJ1bm5lciBvcHRpb25zLlxuICAgKi9cbiAgcHJpdmF0ZSBvcHRzOiBUZXN0T3B0aW9ucztcbiAgLyoqXG4gICAqIFRoZSBjbGFzcyB0byB0ZXN0LlxuICAgKi9cbiAgcHVibGljIGNsczogc3RyaW5nO1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZmlsZSByZWNvcmRpbmcgdGhlIG91dHB1dCBmcm9tIHRoZSBuYXRpdmUgSlZNLlxuICAgKi9cbiAgcHJpdmF0ZSBvdXRGaWxlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgb3V0cHV0IGNhcHR1cmVyIGZvciB0aGlzIHRlc3QuXG4gICAqL1xuICBwcml2YXRlIG91dHB1dENhcHR1cmVyOiBPdXRwdXRDYXB0dXJlciA9IG5ldyBPdXRwdXRDYXB0dXJlcigpO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IFRlc3RPcHRpb25zLCBjbHM6IHN0cmluZykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgaWYgKGNscy5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAvLyBDb252ZXJ0IGZvby5iYXIuQmF6ID0+IGZvby9iYXIvQmF6XG4gICAgICBjbHMgPSB1dGlsLmRlc2NyaXB0b3IydHlwZXN0cih1dGlsLmludF9jbGFzc25hbWUoY2xzKSk7XG4gICAgfVxuICAgIHRoaXMuY2xzID0gY2xzO1xuICAgIHRoaXMub3V0RmlsZSA9IHBhdGgucmVzb2x2ZShvcHRzLmRvcHBpb0hvbWVQYXRoLCBjbHMpICsgXCIucnVub3V0XCI7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBKVk0gZm9yIHRoZSB0ZXN0LlxuICAgKi9cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RKVk0oY2I6IChlcnI6IGFueSwganZtPzogSlZNKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgbmV3IEpWTSg8YW55PiB1dGlsLm1lcmdlKEpWTS5nZXREZWZhdWx0T3B0aW9ucyh0aGlzLm9wdHMuZG9wcGlvSG9tZVBhdGgpLCB0aGlzLm9wdHMsIHtcbiAgICAgIGNsYXNzcGF0aDogW3RoaXMub3B0cy5kb3BwaW9Ib21lUGF0aF0sXG4gICAgICBlbmFibGVBc3NlcnRpb25zOiB0cnVlLFxuICAgICAgZW5hYmxlU3lzdGVtQXNzZXJ0aW9uczogdHJ1ZVxuICAgIH0pLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgdW5pdCB0ZXN0LlxuICAgKi9cbiAgcHVibGljIHJ1bihyZWdpc3Rlckdsb2JhbEVycm9yVHJhcDogKGNiOiAoZXJyOiBFcnJvcikgPT4gdm9pZCkgPT4gdm9pZCwgY2I6IChlcnI6IEVycm9yLCBhY3R1YWw/OiBzdHJpbmcsIGV4cGVjdGVkPzogc3RyaW5nLCBkaWZmPzogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgdmFyIG91dHB1dENhcHR1cmVyID0gdGhpcy5vdXRwdXRDYXB0dXJlciwgX2p2bTogSlZNID0gbnVsbCwgdGVybWluYXRlZDogYm9vbGVhbiA9IGZhbHNlLCBqdm1Db25zdHJ1Y3RIYXNGaW5pc2hlZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgaGFzRmluaXNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICByZWdpc3Rlckdsb2JhbEVycm9yVHJhcCgoZXJyKSA9PiB7XG4gICAgICBpZiAoX2p2bSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9qdm0uaGFsdCgxKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcXG5cXG5BZGRpdGlvbmFsbHksIHRlc3QgcnVubmVyIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGhhbHQgdGhlIEpWTTogJHtlfSR7ZS5zdGFjayA/IGBcXG5cXG4ke2Uuc3RhY2t9YCA6ICcnfVxcblxcbk9yaWdpbmFsIGVycm9yJ3Mgc3RhY2sgdHJhY2U6YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0cHV0Q2FwdHVyZXIuc3RvcCgpO1xuICAgICAgY2IobWFrZVRlc3RpbmdFcnJvcihgVW5jYXVnaHQgZXJyb3IuIEFib3J0aW5nIGZ1cnRoZXIgdGVzdHMuXFxuXFx0JHtlcnJ9JHtlcnIuc3RhY2sgPyBgXFxuXFxuJHtlcnIuc3RhY2t9YCA6IGBgfWAsIGVyciwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb25zdHJ1Y3RKVk0oKGVycjogYW55LCBqdm0/OiBKVk0pID0+IHtcbiAgICAgIF9qdm0gPSBqdm07XG4gICAgICBpZiAodGVybWluYXRlZCkge1xuICAgICAgICAvLyBBbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChqdm1Db25zdHJ1Y3RIYXNGaW5pc2hlZCkge1xuICAgICAgICByZXR1cm4gY2IobWFrZVRlc3RpbmdFcnJvcihgY29uc3RydWN0SlZNIHJldHVybmVkIHR3aWNlLiBBYm9ydGluZyBmdXJ0aGVyIHRlc3RzLmAsIG51bGwsIHRydWUpKTtcbiAgICAgIH1cbiAgICAgIGp2bUNvbnN0cnVjdEhhc0ZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihtYWtlVGVzdGluZ0Vycm9yKGBDb3VsZCBub3QgY29uc3RydWN0IEpWTTpcXG4ke2Vycn1gLCBlcnIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dENhcHR1cmVyLnN0YXJ0KHRydWUpO1xuICAgICAgICBqdm0ucnVuQ2xhc3ModGhpcy5jbHMsIFtdLCAoc3RhdHVzOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBpZiAodGVybWluYXRlZCkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBoYW5kbGVkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRDYXB0dXJlci5zdG9wKCk7XG4gICAgICAgICAgaWYoaGFzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihtYWtlVGVzdGluZ0Vycm9yKGBKVk0gdHJpZ2dlcmVkIGNvbXBsZXRpb24gY2FsbGJhY2sgdHdpY2UuIEFib3J0aW5nIGZ1cnRoZXIgdGVzdHMuYCwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXNGaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgYWN0dWFsID0gb3V0cHV0Q2FwdHVyZXIuZ2V0T3V0cHV0KHRydWUpO1xuICAgICAgICAgIGZzLnJlYWRGaWxlKHRoaXMub3V0RmlsZSwgeyBlbmNvZGluZzogJ3V0ZjgnIH0sIChlcnI6IGFueSwgZXhwZWN0ZWQ/OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2IobWFrZVRlc3RpbmdFcnJvcihgQ291bGQgbm90IHJlYWQgcnVub3V0IGZpbGU6XFxuJHtlcnJ9YCwgZXJyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZlRleHQgPSBkaWZmKGFjdHVhbCwgZXhwZWN0ZWQpLCBlcnJNc2c6IHN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChkaWZmVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVyck1zZyA9IGBPdXRwdXQgZG9lcyBub3QgbWF0Y2ggbmF0aXZlIEpWTS5gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNiKGVyck1zZyA/IG1ha2VUZXN0aW5nRXJyb3IoZXJyTXNnKSA6IG51bGwsIGFjdHVhbCwgZXhwZWN0ZWQsIGRpZmZUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2NhdGUgYWxsIG9mIERvcHBpbydzIHRlc3QgY2xhc3NlcywgYW5kIHBhc3MgdGhlbSB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZpbmRUZXN0Q2xhc3Nlcyhkb3BwaW9EaXI6IHN0cmluZywgY2I6IChmaWxlczogc3RyaW5nW10pID0+IHZvaWQpOiB2b2lkIHtcbiAgdmFyIHRlc3REaXIgPSBwYXRoLnJlc29sdmUoZG9wcGlvRGlyLCBwYXRoLmpvaW4oJ2NsYXNzZXMnLCAndGVzdCcpKTtcbiAgZnMucmVhZGRpcih0ZXN0RGlyLCAoZXJyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZmlsZXMuZmlsdGVyKChmaWxlKSA9PiBwYXRoLmV4dG5hbWUoZmlsZSkgPT09ICcuamF2YScpXG4gICAgICAgICAgICAgIC5tYXAoKGZpbGUpID0+IHBhdGguam9pbignY2xhc3NlcycsJ3Rlc3QnLCBwYXRoLmJhc2VuYW1lKGZpbGUsICcuamF2YScpKSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmV0cmlldmUgYWxsIG9mIHRoZSB1bml0IHRlc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVzdHMob3B0czogVGVzdE9wdGlvbnMsIGNiOiAodGVzdHM6IERvcHBpb1Rlc3RbXSkgPT4gdm9pZCk6IHZvaWQge1xuICB2YXIgdGVzdENsYXNzZXMgPSBvcHRzLnRlc3RDbGFzc2VzLFxuICAgIHRlc3RzOiBEb3BwaW9UZXN0W107XG4gIGlmICh0ZXN0Q2xhc3NlcyA9PSBudWxsIHx8IHRlc3RDbGFzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIG5vIHRlc3QgY2xhc3NlcyBhcmUgc3BlY2lmaWVkLCBnZXQgQUxMIHRoZSB0ZXN0cyFcbiAgICBmaW5kVGVzdENsYXNzZXMob3B0cy5kb3BwaW9Ib21lUGF0aCwgKHRlc3RDbGFzc2VzKSA9PiB7XG4gICAgICBvcHRzLnRlc3RDbGFzc2VzID0gdGVzdENsYXNzZXM7XG4gICAgICBnZXRUZXN0cyhvcHRzLCBjYik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2IodGVzdENsYXNzZXMubWFwKCh0ZXN0Q2xhc3M6IHN0cmluZyk6IERvcHBpb1Rlc3QgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBEb3BwaW9UZXN0KG9wdHMsIHRlc3RDbGFzcyk7XG4gICAgfSkpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZvcm1hdHRlZCBkaWZmIGJldHdlZW4gZG9wcGlvT3V0IGFuZCBuYXRpdmVPdXQuXG4gKiBSZXR1cm5zIE5VTEwgaWYgdGhlIHN0cmluZ3MgYXJlIGlkZW50aWNhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoZG9wcGlvT3V0OiBzdHJpbmcsIG5hdGl2ZU91dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gQHRvZG8gUm9idXN0IHRvIFdpbmRvd3MgbGluZSBicmVha3MhXG4gIHZhciBkb3BwaW9MaW5lcyA9IGRvcHBpb091dC5zcGxpdCgvXFxuLyksXG4gICAganZtTGluZXMgPSBuYXRpdmVPdXQuc3BsaXQoL1xcbi8pLFxuICAgIGRpZmY6IHN0cmluZ1tdID0gZGlmZmxpYi50ZXh0X2RpZmYoZG9wcGlvTGluZXMsIGp2bUxpbmVzLCAyKTtcbiAgaWYgKGRpZmYubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAnRG9wcGlvIHwgSmF2YVxcbicgKyBkaWZmLmpvaW4oJ1xcbicpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJ1biB0aGUgc3BlY2lmaWVkIHRlc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuVGVzdHMob3B0czogVGVzdE9wdGlvbnMsIHF1aWV0OiBib29sZWFuLCBjb250aW51ZUFmdGVyRmFpbHVyZTogYm9vbGVhbiwgaGlkZURpZmZzOiBib29sZWFuLFxuICByZWdpc3Rlckdsb2JhbEVycm9yVHJhcDogKGNiOiAoZXJyOiBFcnJvcikgPT4gdm9pZCkgPT4gdm9pZCwgY2I6IChlcnI/OiBUZXN0aW5nRXJyb3IpID0+IHZvaWQpOiB2b2lkIHtcbiAgZnVuY3Rpb24gcHJpbnQoc3RyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXF1aWV0KSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHIpO1xuICAgIH1cbiAgfVxuXG4gIGdldFRlc3RzKG9wdHMsICh0ZXN0cykgPT4ge1xuICAgIHV0aWwuYXN5bmNGb3JFYWNoKHRlc3RzLCAodGVzdDogRG9wcGlvVGVzdCwgbmV4dFRlc3Q6IChlcnI/OiBhbnkpID0+IHZvaWQpID0+IHtcbiAgICAgIHZhciBoYXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgcHJpbnQoYFske3Rlc3QuY2xzfV06IFJ1bm5pbmcuLi4gYCk7XG4gICAgICB0ZXN0LnJ1bihyZWdpc3Rlckdsb2JhbEVycm9yVHJhcCwgKGVycjogVGVzdGluZ0Vycm9yLCBhY3R1YWw/OiBzdHJpbmcsIGV4cGVjdGVkPzogc3RyaW5nLCBkaWZmPzogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgIWhpZGVEaWZmcyAmJiBkaWZmKSB7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxcbiR7ZGlmZn1gXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcHJpbnQoYGZhaWwuXFxuXFx0JHtlcnIubWVzc2FnZX1cXG5gKTtcbiAgICAgICAgICBpZiAoZXJyLm9yaWdpbmFsRXJyb3IgJiYgZXJyLm9yaWdpbmFsRXJyb3Iuc3RhY2spIHtcbiAgICAgICAgICAgIHByaW50KGAke2Vyci5zdGFja31cXG5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250aW51ZUFmdGVyRmFpbHVyZSB8fCAoPFRlc3RpbmdFcnJvcj4gZXJyKVsnZmF0YWwnXSkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgRmFpbGVkICR7dGVzdC5jbHN9OiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICBuZXh0VGVzdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0VGVzdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludChgcGFzcy5cXG5gKTtcbiAgICAgICAgICBuZXh0VGVzdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBjYik7XG4gIH0pO1xufVxuIiwiaW1wb3J0IENsYXNzRGF0YSA9IHJlcXVpcmUoJy4vQ2xhc3NEYXRhJyk7XG5pbXBvcnQgQ2xhc3NMb2FkZXIgPSByZXF1aXJlKCcuL0NsYXNzTG9hZGVyJyk7XG5pbXBvcnQgbWV0aG9kcyA9IHJlcXVpcmUoJy4vbWV0aG9kcycpO1xuaW1wb3J0IGVudW1zID0gcmVxdWlyZSgnLi9lbnVtcycpO1xuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5pbXBvcnQgZ0xvbmcgPSByZXF1aXJlKCcuL2dMb25nJyk7XG5pbXBvcnQgb3Bjb2RlcyA9IHJlcXVpcmUoJy4vb3Bjb2RlcycpO1xuaW1wb3J0IGF0dHJpYnV0ZXMgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZXMnKTtcbmltcG9ydCBsb2dnaW5nID0gcmVxdWlyZSgnLi9sb2dnaW5nJyk7XG5pbXBvcnQgSlZNID0gcmVxdWlyZSgnLi9qdm0nKTtcbmltcG9ydCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5pbXBvcnQgQ29uc3RhbnRQb29sID0gcmVxdWlyZSgnLi9Db25zdGFudFBvb2wnKTtcbmltcG9ydCBKVk1UeXBlcyA9IHJlcXVpcmUoJy4uL2luY2x1ZGVzL0pWTVR5cGVzJyk7XG5pbXBvcnQgTW9uaXRvciA9IHJlcXVpcmUoJy4vTW9uaXRvcicpO1xuaW1wb3J0IFRocmVhZFN0YXR1cyA9IGVudW1zLlRocmVhZFN0YXR1cztcbmltcG9ydCB7ZGVmYXVsdCBhcyBUaHJlYWRQb29sLCBUaHJlYWR9IGZyb20gJy4vdGhyZWFkcG9vbCc7XG5pbXBvcnQgZ2xvYmFsID0gcmVxdWlyZSgnLi9nbG9iYWwnKTtcblxuZGVjbGFyZSB2YXIgUkVMRUFTRTogYm9vbGVhbjtcbmlmICh0eXBlb2YgUkVMRUFTRSA9PT0gJ3VuZGVmaW5lZCcpIGdsb2JhbC5SRUxFQVNFID0gZmFsc2U7XG5cbnZhciBkZWJ1ZyA9IGxvZ2dpbmcuZGVidWcsIHZ0cmFjZSA9IGxvZ2dpbmcudnRyYWNlLCB0cmFjZSA9IGxvZ2dpbmcudHJhY2UsXG4gIC8vIFRoZSBudW1iZXIgb2YgbWV0aG9kIHJlc3VtZXMgd2Ugc2hvdWxkIGFsbG93IGJlZm9yZSB5aWVsZGluZyBmb3JcbiAgLy8gcmVzcG9uc2l2ZW5lc3MuIFVwZGF0ZWQgdXNpbmcgYSBjdW11bGF0aXZlIG1vdmluZyBhdmVyYWdlIHRvIGVuc3VyZVxuICAvLyBEb3BwaW8gaXMgcmVzcG9uc2l2ZS5cbiAgbWF4TWV0aG9kUmVzdW1lczogbnVtYmVyID0gMTAwMDAsXG4gIC8vIFRoZSBudW1iZXIgb2YgbWV0aG9kIHJlc3VtZXMgdW50aWwgRG9wcGlvIHNob3VsZCB5aWVsZCBhZ2Fpbi5cbiAgbWV0aG9kUmVzdW1lc0xlZnQ6IG51bWJlciA9IG1heE1ldGhvZFJlc3VtZXMsXG4gIC8vIFVzZWQgZm9yIHRoZSBDTUEuXG4gIG51bVNhbXBsZXM6IG51bWJlciA9IDE7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN0YWNrIGZyYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElTdGFja0ZyYW1lIHtcbiAgLyoqXG4gICAqIFJ1bnMgb3IgcmVzdW1lcyB0aGUgbWV0aG9kLCBhcyBjb25maWd1cmVkLlxuICAgKi9cbiAgcnVuOiAodGhyZWFkOiBKVk1UaHJlYWQpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSBtZXRob2QgdG8gcmVzdW1lIGFmdGVyIGEgbWV0aG9kIGNhbGwuXG4gICAqIEBydiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG1ldGhvZCBjYWxsLCBpZiBhcHBsaWNhYmxlLlxuICAgKiBAcnYyIFRoZSBzZWNvbmQgcmV0dXJuIHZhbHVlLCB3aGljaCB3aWxsIGFsd2F5cyBiZSBudWxsIGlmIGFwcGxpY2FibGUuXG4gICAqL1xuICBzY2hlZHVsZVJlc3VtZTogKHRocmVhZDogSlZNVGhyZWFkLCBydj86IGFueSwgcnYyPzogYW55KSA9PiB2b2lkO1xuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBtZXRob2QgY2FuIGhhbmRsZSB0aGUgZ2l2ZW4gZXhjZXB0aW9uLiBJZiBzbyxcbiAgICogY29uZmlndXJlcyB0aGUgc3RhY2sgZnJhbWUgdG8gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgbWV0aG9kIGNhbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICovXG4gIHNjaGVkdWxlRXhjZXB0aW9uOiAodGhyZWFkOiBKVk1UaHJlYWQsIGU6IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUpID0+IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGlzIHN0YWNrIGZyYW1lJ3MgdHlwZS5cbiAgICovXG4gIHR5cGU6IGVudW1zLlN0YWNrRnJhbWVUeXBlO1xuICAvKipcbiAgICogUmV0cmlldmUgYSBzdGFjayB0cmFjZSBmcmFtZSBmcm9tIHRoaXMgc3RhY2sgdHJhY2UuIElmIHRoaXMgc3RhY2sgZnJhbWVcbiAgICogc2hvdWxkIG5vdCBiZSBsYW5ndWFnZS12aXNpYmxlLCByZXR1cm4gbnVsbC5cbiAgICovXG4gIGdldFN0YWNrVHJhY2VGcmFtZSgpOiBJU3RhY2tUcmFjZUZyYW1lO1xuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGNsYXNzbG9hZGVyIGZvciB0aGlzIG1ldGhvZC5cbiAgICovXG4gIGdldExvYWRlcigpOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFByZUFsbG9jYXRlZFN0YWNrIHtcbiAgcHJpdmF0ZSBzdG9yZTogYW55W107XG4gIHByaXZhdGUgY3VycjogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3Rvcihpbml0aWFsU2l6ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBBcnJheShpbml0aWFsU2l6ZSk7XG4gIH1cblxuICBwdXNoKHg6IGFueSkge1xuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyKytdID0geDtcbiAgfVxuXG4gIHB1c2hXaXRoTnVsbCh4OiBhbnkpIHtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3Vycl0gPSB4O1xuXG4gICAgLy8gWFhYOiBBbHRob3VnaCBzZXR0aW5nIGBudWxsYCBpcyByZXF1aXJlZCBpbiB0aGVvcnksIGl0IGhhcyBubyBmdW5jdGlvbmFsIGltcGFjdCBpbiBwcmFjdGljZS5cbiAgICAvLyBQZXJmb3JtYW5jZSBpcyBpbXByb3ZlZCB3aGVuIGNvbW1lbnRlZC5cbiAgICAvLyB0aGlzLnN0b3JlW3RoaXMuY3VyciArIDFdID0gbnVsbDtcblxuICAgIHRoaXMuY3VyciArPSAyO1xuICB9XG5cbiAgcHVzaDYoeDogYW55LCB5OiBhbnksIHo6IGFueSwgejE6IGFueSwgejI6IGFueSwgejM6IGFueSkge1xuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyKytdID0geDtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VycisrXSA9IHk7XG4gICAgdGhpcy5zdG9yZVt0aGlzLmN1cnIrK10gPSB6O1xuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyKytdID0gejE7XG4gICAgdGhpcy5zdG9yZVt0aGlzLmN1cnIrK10gPSB6MjtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VycisrXSA9IHozO1xuICB9XG5cbiAgc3dhcCgpIHtcbiAgICBjb25zdCB0bXAgPSB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDFdO1xuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyIC0gMV0gPSB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDJdO1xuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyIC0gMl0gPSB0bXA7XG4gIH1cblxuICBkdXAoKSB7XG4gICAgdGhpcy5zdG9yZVt0aGlzLmN1cnJdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAxXTtcbiAgICB0aGlzLmN1cnIrKztcbiAgfVxuXG4gIGR1cDIoKSB7XG4gICAgdGhpcy5zdG9yZVt0aGlzLmN1cnJdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAyXTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciArIDFdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAxXTtcbiAgICB0aGlzLmN1cnIgKz0gMjtcbiAgfVxuXG4gIGR1cF94MSgpIHtcbiAgICBjb25zdCB2MSA9IHRoaXMuc3RvcmVbdGhpcy5jdXJyIC0gMV07XG5cbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDFdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAyXTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3Vycl0gPSB2MTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDJdID0gdjE7XG5cbiAgICB0aGlzLmN1cnIrKztcbiAgfVxuXG4gIGR1cF94MigpIHtcbiAgICBjb25zdCB2MSA9IHRoaXMuc3RvcmVbdGhpcy5jdXJyIC0gMV07XG5cbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDFdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAyXTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDJdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAzXTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3Vycl0gPSB2MTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDNdID0gdjE7XG5cbiAgICB0aGlzLmN1cnIrKztcbiAgfVxuXG4gIGR1cDJfeDEoKSB7XG4gICAgY29uc3QgdjEgPSB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDFdO1xuICAgIGNvbnN0IHYyID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAyXTtcblxuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyXSA9IHYyO1xuICAgIHRoaXMuc3RvcmVbdGhpcy5jdXJyICsgMV0gPSB2MTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDFdID0gdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAzXTtcbiAgICB0aGlzLnN0b3JlW3RoaXMuY3VyciAtIDJdID0gdjE7XG4gICAgdGhpcy5zdG9yZVt0aGlzLmN1cnIgLSAzXSA9IHYyO1xuXG4gICAgdGhpcy5jdXJyICs9IDI7XG4gIH1cblxuICBwb3AoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZVstLXRoaXMuY3Vycl07XG4gIH1cblxuICBwb3AyKCk6IGFueSB7XG4gICAgdGhpcy5jdXJyIC09IDI7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVbdGhpcy5jdXJyXTtcbiAgfVxuXG4gIGJvdHRvbSgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlWzBdO1xuICB9XG5cbiAgdG9wKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVbdGhpcy5jdXJyIC0gMV07XG4gIH1cblxuICBmcm9tVG9wKG46IG51bWJlcik6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmVbdGhpcy5jdXJyIC0gKG4gKyAxKV07XG4gIH1cblxuICBzbGljZUZyb21Cb3R0b20objogbnVtYmVyKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5zbGljZShuLCB0aGlzLmN1cnIpO1xuICB9XG5cbiAgc2xpY2VGcm9tVG9wKG46IG51bWJlcik6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuc2xpY2UodGhpcy5jdXJyIC0gbiwgdGhpcy5jdXJyKTtcbiAgfVxuXG4gIGRyb3BGcm9tVG9wKG46IG51bWJlcikge1xuICAgIHRoaXMuY3VyciAtPSBuO1xuICB9XG5cbiAgZ2V0UmF3KCk6IGFueVtdIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5zbGljZSgwLCB0aGlzLmN1cnIpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jdXJyID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdGFjayBmcmFtZSBmb3IgYSBieXRlY29kZSBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlY29kZVN0YWNrRnJhbWUgaW1wbGVtZW50cyBJU3RhY2tGcmFtZSB7XG4gIHB1YmxpYyBwYzogbnVtYmVyID0gMDtcbiAgcHVibGljIGxvY2FsczogYW55W107XG4gIHB1YmxpYyBvcFN0YWNrOiBQcmVBbGxvY2F0ZWRTdGFjaztcbiAgcHVibGljIHJldHVyblRvVGhyZWFkTG9vcDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgbG9ja2VkTWV0aG9kTG9jazogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgbWV0aG9kOiBtZXRob2RzLk1ldGhvZDtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGJ5dGVjb2RlIG1ldGhvZCdzIHN0YWNrIGZyYW1lLlxuICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBieXRlY29kZSBtZXRob2QgdG8gcnVuLlxuICAgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGJ5dGVjb2RlIG1ldGhvZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1ldGhvZDogbWV0aG9kcy5NZXRob2QsIGFyZ3M6IGFueVtdKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgYXNzZXJ0KCFtZXRob2QuYWNjZXNzRmxhZ3MuaXNOYXRpdmUoKSwgJ0Nhbm5vdCBydW4gYSBuYXRpdmUgbWV0aG9kIHVzaW5nIGEgQnl0ZWNvZGVTdGFja0ZyYW1lLicpO1xuICAgIC8vIEB0b2RvIFRoaXMgc2hvdWxkIGJlIGEgcnVudGltZSBlcnJvciwgc2luY2UgcmVmbGVjdGlvbiBjYW4gY2F1c2UgeW91IHRvXG4gICAgLy8gdHJ5IHRvIGRvIHRoaXMuXG4gICAgYXNzZXJ0KCFtZXRob2QuYWNjZXNzRmxhZ3MuaXNBYnN0cmFjdCgpLCAnQ2Fubm90IHJ1biBhbiBhYnN0cmFjdCBtZXRob2QhJyk7XG4gICAgdGhpcy5sb2NhbHMgPSBhcmdzO1xuICAgIHRoaXMub3BTdGFjayA9IG5ldyBQcmVBbGxvY2F0ZWRTdGFjayhtZXRob2QuZ2V0Q29kZUF0dHJpYnV0ZSgpLmdldE1heFN0YWNrKCkpO1xuICB9XG5cbiAgcHVibGljIHJ1bih0aHJlYWQ6IEpWTVRocmVhZCk6IHZvaWQge1xuICAgIHZhciBtZXRob2QgPSB0aGlzLm1ldGhvZCwgY29kZSA9IHRoaXMubWV0aG9kLmdldENvZGVBdHRyaWJ1dGUoKS5nZXRDb2RlKCksXG4gICAgICBvcGNvZGVUYWJsZSA9IG9wY29kZXMuTG9va3VwVGFibGU7XG4gICAgaWYgKCFSRUxFQVNFICYmIGxvZ2dpbmcubG9nX2xldmVsID49IGxvZ2dpbmcuVFJBQ0UpIHtcbiAgICAgIGlmICh0aGlzLnBjID09PSAwKSB7XG4gICAgICAgIHRyYWNlKGBcXG5UJHt0aHJlYWQuZ2V0UmVmKCl9IEQke3RocmVhZC5nZXRTdGFja1RyYWNlKCkubGVuZ3RofSBSdW5uaW5nICR7dGhpcy5tZXRob2QuZ2V0RnVsbFNpZ25hdHVyZSgpfSBbQnl0ZWNvZGVdOmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhY2UoYFxcblQke3RocmVhZC5nZXRSZWYoKX0gRCR7dGhyZWFkLmdldFN0YWNrVHJhY2UoKS5sZW5ndGh9IFJlc3VtaW5nICR7dGhpcy5tZXRob2QuZ2V0RnVsbFNpZ25hdHVyZSgpfToke3RoaXMucGN9IFtCeXRlY29kZV06YCk7XG4gICAgICB9XG4gICAgICB2dHJhY2UoYCAgUzogWyR7bG9nZ2luZy5kZWJ1Z192YXJzKHRoaXMub3BTdGFjay5nZXRSYXcoKSl9XSwgTDogWyR7bG9nZ2luZy5kZWJ1Z192YXJzKHRoaXMubG9jYWxzKX1dYCk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZC5hY2Nlc3NGbGFncy5pc1N5bmNocm9uaXplZCgpICYmICF0aGlzLmxvY2tlZE1ldGhvZExvY2spIHtcbiAgICAgIC8vIFdlIGFyZSBzdGFydGluZyBhIHN5bmNocm9uaXplZCBtZXRob2QhIFRoZXNlIG11c3QgaW1wbGljaXRseSBlbnRlclxuICAgICAgLy8gdGhlaXIgcmVzcGVjdGl2ZSBsb2Nrcy5cbiAgICAgIHRoaXMubG9ja2VkTWV0aG9kTG9jayA9IG1ldGhvZC5tZXRob2RMb2NrKHRocmVhZCwgdGhpcykuZW50ZXIodGhyZWFkLCAoKSA9PiB7XG4gICAgICAgIC8vIExvY2sgc3VjY2VlZGVkLiBTZXQgdGhlIGZsYWcgc28gd2UgZG9uJ3QgYXR0ZW1wdCB0byByZWFjcXVpcmUgaXRcbiAgICAgICAgLy8gd2hlbiB0aGlzIG1ldGhvZCByZXJ1bnMuXG4gICAgICAgIHRoaXMubG9ja2VkTWV0aG9kTG9jayA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5sb2NrZWRNZXRob2RMb2NrKSB7XG4gICAgICAgIC8vIEZhaWxlZC4gVGhyZWFkIGlzIGF1dG9tYXRpY2FsbHkgYmxvY2tlZC4gUmV0dXJuLlxuICAgICAgICBhc3NlcnQodGhyZWFkLmdldFN0YXR1cygpID09PSBUaHJlYWRTdGF0dXMuQkxPQ0tFRCwgXCJGYWlsZWQgdG8gZW50ZXIgYSBtb25pdG9yLiBUaHJlYWQgbXVzdCBiZSBCTE9DS0VELlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IHRoZSByZXR1cm5Ub1RocmVhZExvb3Agc3dpdGNoLiBUaGUgY3VycmVudCB2YWx1ZSBpcyBsZWZ0b3ZlclxuICAgIC8vIGZyb20gdGhlIHByZXZpb3VzIHRpbWUgdGhpcyBtZXRob2Qgd2FzIHJ1biwgYW5kIGlzIG1lYW5pbmdsZXNzLlxuICAgIHRoaXMucmV0dXJuVG9UaHJlYWRMb29wID0gZmFsc2U7XG5cbiAgICAvLyBSdW4gdW50aWwgd2UgZ2V0IHRoZSBzaWduYWwgdG8gcmV0dXJuIHRvIHRoZSB0aHJlYWQgbG9vcC5cbiAgICB3aGlsZSAoIXRoaXMucmV0dXJuVG9UaHJlYWRMb29wKSB7XG4gICAgICB2YXIgb3AgPSBjb2RlLnJlYWRVSW50OCh0aGlzLnBjKTtcbiAgICAgIGlmICghUkVMRUFTRSAmJiBsb2dnaW5nLmxvZ19sZXZlbCA9PT0gbG9nZ2luZy5WVFJBQ0UpIHtcbiAgICAgICAgdnRyYWNlKGAgICR7dGhpcy5wY30gJHthbm5vdGF0ZU9wY29kZShvcCwgdGhpcywgY29kZSwgdGhpcy5wYyl9YCk7XG4gICAgICB9XG4gICAgICBvcGNvZGVUYWJsZVtvcF0odGhyZWFkLCB0aGlzLCBjb2RlKTtcbiAgICAgIGlmICghUkVMRUFTRSAmJiAhdGhpcy5yZXR1cm5Ub1RocmVhZExvb3AgJiYgbG9nZ2luZy5sb2dfbGV2ZWwgPT09IGxvZ2dpbmcuVlRSQUNFKSB7XG4gICAgICAgIHZ0cmFjZShgICAgIFM6IFske2xvZ2dpbmcuZGVidWdfdmFycyh0aGlzLm9wU3RhY2suZ2V0UmF3KCkpfV0sIEw6IFske2xvZ2dpbmcuZGVidWdfdmFycyh0aGlzLmxvY2Fscyl9XWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzY2hlZHVsZVJlc3VtZSh0aHJlYWQ6IEpWTVRocmVhZCwgcnY/OiBhbnksIHJ2Mj86IGFueSk6IHZvaWQge1xuICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgb3Bjb2RlLlxuICAgIHZhciBwcmV2T3AgPSB0aGlzLm1ldGhvZC5nZXRDb2RlQXR0cmlidXRlKCkuZ2V0Q29kZSgpLnJlYWRVSW50OCh0aGlzLnBjKTtcbiAgICBzd2l0Y2ggKHByZXZPcCkge1xuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFSU5URVJGQUNFOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFSU5URVJGQUNFX0ZBU1Q6XG4gICAgICAgIHRoaXMucGMgKz0gNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5JTlZPS0VTUEVDSUFMOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFU1RBVElDOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFVklSVFVBTDpcbiAgICAgIGNhc2UgZW51bXMuT3BDb2RlLklOVk9LRVNUQVRJQ19GQVNUOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFTk9OVklSVFVBTF9GQVNUOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFVklSVFVBTF9GQVNUOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFSEFORExFOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuSU5WT0tFQkFTSUM6XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5MSU5LVE9TUEVDSUFMOlxuICAgICAgY2FzZSBlbnVtcy5PcENvZGUuTElOS1RPVklSVFVBTDpcbiAgICAgIGNhc2UgZW51bXMuT3BDb2RlLklOVk9LRURZTkFNSUM6XG4gICAgICBjYXNlIGVudW1zLk9wQ29kZS5JTlZPS0VEWU5BTUlDX0ZBU1Q6XG4gICAgICAgIHRoaXMucGMgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBTaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgUmVzdW1pbmcgZnJvbSBhIG5vbi1pbnZva2Ugb3Bjb2RlISBPcGNvZGU6ICR7ZW51bXMuT3BDb2RlW3ByZXZPcF19IFske3ByZXZPcH1dYCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChydiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wU3RhY2sucHVzaChydik7XG4gICAgfVxuICAgIGlmIChydjIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcFN0YWNrLnB1c2gocnYyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgbWV0aG9kIGNhbiBoYW5kbGUgdGhlIHNwZWNpZmllZCBleGNlcHRpb24gJ2UnLlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXQgY2FuLCBvciBpZiBpdCBuZWVkcyB0byBhc3luY2hyb25vdXNseSByZXNvbHZlIHNvbWVcbiAgICogY2xhc3Nlcy5cbiAgICpcbiAgICogSW4gdGhlIGxhdHRlciBjYXNlLCBzY2hlZHVsZUV4Y2VwdGlvbiB3aWxsIGhhbmRsZSByZXRocm93aW5nIHRoZSBleGNlcHRpb25cbiAgICogaW4gdGhlIGV2ZW50IHRoYXQgaXQgY2FuJ3QgYWN0dWFsbHkgaGFuZGxlIGl0LlxuICAgKi9cbiAgcHVibGljIHNjaGVkdWxlRXhjZXB0aW9uKHRocmVhZDogSlZNVGhyZWFkLCBlOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlKTogYm9vbGVhbiB7XG4gICAgdmFyIGNvZGVBdHRyID0gdGhpcy5tZXRob2QuZ2V0Q29kZUF0dHJpYnV0ZSgpLFxuICAgICAgcGMgPSB0aGlzLnBjLCBtZXRob2QgPSB0aGlzLm1ldGhvZCxcbiAgICAgIC8vIFNURVAgMTogU2VlIGlmIHdlIGNhbiBmaW5kIGFuIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIHRoaXMgZXhjZXB0aW9uIVxuICAgICAgZXhjZXB0aW9uSGFuZGxlcnMgPSBjb2RlQXR0ci5leGNlcHRpb25IYW5kbGVycyxcbiAgICAgIGVjbHMgPSBlLmdldENsYXNzKCksIGhhbmRsZXI6IGF0dHJpYnV0ZXMuRXhjZXB0aW9uSGFuZGxlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2VwdGlvbkhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZWggPSBleGNlcHRpb25IYW5kbGVyc1tpXTtcbiAgICAgIGlmIChlaC5zdGFydFBDIDw9IHBjICYmIHBjIDwgZWguZW5kUEMpIHtcbiAgICAgICAgaWYgKGVoLmNhdGNoVHlwZSA9PT0gXCI8YW55PlwiKSB7XG4gICAgICAgICAgaGFuZGxlciA9IGVoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCByZXNvbHZlZENhdGNoVHlwZSA9IG1ldGhvZC5jbHMuZ2V0TG9hZGVyKCkuZ2V0UmVzb2x2ZWRDbGFzcyhlaC5jYXRjaFR5cGUpO1xuICAgICAgICAgIGlmIChyZXNvbHZlZENhdGNoVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZWNscy5pc0Nhc3RhYmxlKHJlc29sdmVkQ2F0Y2hUeXBlKSkge1xuICAgICAgICAgICAgICBoYW5kbGVyID0gZWg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBU1lOQyBQQVRIOiBXZSdsbCBuZWVkIHRvIGFzeW5jaHJvbm91c2x5IHJlc29sdmUgdGhlc2UgaGFuZGxlcnMuXG4gICAgICAgICAgICBkZWJ1ZyhgJHttZXRob2QuZ2V0RnVsbFNpZ25hdHVyZSgpfSBuZWVkcyB0byByZXNvbHZlIHNvbWUgZXhjZXB0aW9uIHR5cGVzLi4uYCk7XG4gICAgICAgICAgICBsZXQgaGFuZGxlckNsYXNzZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2VwdGlvbkhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxldCBoYW5kbGVyID0gZXhjZXB0aW9uSGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgIGlmIChoYW5kbGVyLmNhdGNoVHlwZSAhPT0gXCI8YW55PlwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckNsYXNzZXMucHVzaChoYW5kbGVyLmNhdGNoVHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKGAke21ldGhvZC5nZXRGdWxsU2lnbmF0dXJlKCl9OiBIYXMgdG8gcmVzb2x2ZSBleGNlcHRpb24gY2xhc3Nlcy4gRGVmZXJyaW5nIHNjaGVkdWxpbmcuLi5gKTtcbiAgICAgICAgICAgIHRocmVhZC5zZXRTdGF0dXMoVGhyZWFkU3RhdHVzLkFTWU5DX1dBSVRJTkcpO1xuICAgICAgICAgICAgbWV0aG9kLmNscy5nZXRMb2FkZXIoKS5yZXNvbHZlQ2xhc3Nlcyh0aHJlYWQsIGhhbmRsZXJDbGFzc2VzLCAoY2xhc3NlczogeyBbbmFtZTogc3RyaW5nXTogQ2xhc3NEYXRhLkNsYXNzRGF0YTsgfSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2xhc3NlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKGAke21ldGhvZC5nZXRGdWxsU2lnbmF0dXJlKCl9OiBSZXRocm93aW5nIGV4Y2VwdGlvbiB0byBoYW5kbGUhYCk7XG4gICAgICAgICAgICAgICAgLy8gUmV0aHJvdyB0aGUgZXhjZXB0aW9uIHRvIHRyaWdnZXIgc2NoZWR1bGVFeGNlcHRpb24gYWdhaW4uXG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gSWYgdGhlIENsYXNzTG9hZGVyIHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gRml4IHdvdWxkIGJlIHRvIHN5bmMgY2hlY2tcbiAgICAgICAgICAgICAgICAvLyBpZiBjbGFzcyBmYWlsZWQgdG8gbG9hZCBwcmV2aW91c2x5LlxuICAgICAgICAgICAgICAgIHRocmVhZC50aHJvd0V4Y2VwdGlvbihlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUZWxsIHRoZSB0aHJlYWQgd2UnbGwgaGFuZGxlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU1RFUCAyOiBFaXRoZXIgY29udGludWUgb24gaWYgd2UgY291bGQgbm90IGZpbmQgYW4gYXBwcm9wcmlhdGUgaGFuZGxlcixcbiAgICAvLyBvciBzZXQgdXAgdGhlIHN0YWNrIGZvciBhcHByb3ByaWF0ZSByZXN1bXB0aW9uLlxuICAgIGlmIChoYW5kbGVyICE9IG51bGwpIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBoYW5kbGVyLlxuICAgICAgZGVidWcoYCR7bWV0aG9kLmdldEZ1bGxTaWduYXR1cmUoKX06IENhdWdodCAke2UuZ2V0Q2xhc3MoKS5nZXRJbnRlcm5hbE5hbWUoKX0gYXMgc3ViY2xhc3Mgb2YgJHtoYW5kbGVyLmNhdGNoVHlwZX1gKTtcblxuICAgICAgLy8gY2xlYXIgb3V0IGFueXRoaW5nIG9uIHRoZSBzdGFjazsgaXQgd2FzIG1hZGUgZHVyaW5nIHRoZSB0cnkgYmxvY2tcbiAgICAgIHRoaXMub3BTdGFjay5jbGVhcigpO1xuICAgICAgdGhpcy5vcFN0YWNrLnB1c2goZSk7XG5cbiAgICAgIHRoaXMucGMgPSBoYW5kbGVyLmhhbmRsZXJQQztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhYnJ1cHQgbWV0aG9kIGludm9jYXRpb24gY29tcGxldGlvblxuICAgICAgZGVidWcoYCR7bWV0aG9kLmdldEZ1bGxTaWduYXR1cmUoKX06IERpZCBub3QgY2F0Y2ggJHtlLmdldENsYXNzKCkuZ2V0SW50ZXJuYWxOYW1lKCl9LmApO1xuICAgICAgLy8gU1RFUCAzOiBTeW5jaHJvbml6ZWQgbWV0aG9kPyBFeGl0IGZyb20gdGhlIG1ldGhvZCdzIG1vbml0b3IuXG4gICAgICBpZiAobWV0aG9kLmFjY2Vzc0ZsYWdzLmlzU3luY2hyb25pemVkKCkpIHtcbiAgICAgICAgbWV0aG9kLm1ldGhvZExvY2sodGhyZWFkLCB0aGlzKS5leGl0KHRocmVhZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsYXNzbG9hZGVyIGZvciB0aGUgc3RhY2sgZnJhbWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9hZGVyKCk6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2QuY2xzLmdldExvYWRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgdHlwZSBvZiB0aGlzIHN0YWNrIGZyYW1lLlxuICAgKi9cbiAgcHVibGljIHR5cGU6IGVudW1zLlN0YWNrRnJhbWVUeXBlID0gZW51bXMuU3RhY2tGcmFtZVR5cGUuQllURUNPREU7XG5cbiAgcHVibGljIGdldFN0YWNrVHJhY2VGcmFtZSgpOiBJU3RhY2tUcmFjZUZyYW1lIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgIHBjOiB0aGlzLnBjLFxuICAgICAgc3RhY2s6IHRoaXMub3BTdGFjay5zbGljZUZyb21Cb3R0b20oMCksXG4gICAgICBsb2NhbHM6IHRoaXMubG9jYWxzLnNsaWNlKDApXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBuYXRpdmUgbWV0aG9kJ3Mgc3RhY2sgZnJhbWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYXRpdmVTdGFja0ZyYW1lIGltcGxlbWVudHMgSVN0YWNrRnJhbWUge1xuICBwcml2YXRlIG5hdGl2ZU1ldGhvZDogRnVuY3Rpb247XG4gIHB1YmxpYyBtZXRob2Q6IG1ldGhvZHMuTWV0aG9kO1xuICBwcml2YXRlIGFyZ3M6IGFueVtdO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmF0aXZlIG1ldGhvZCdzIHN0YWNrIGZyYW1lLlxuICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBuYXRpdmUgbWV0aG9kIHRvIHJ1bi5cbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBuYXRpdmUgbWV0aG9kLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWV0aG9kOiBtZXRob2RzLk1ldGhvZCwgYXJnczogYW55W10pIHtcbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIGFzc2VydChtZXRob2QuYWNjZXNzRmxhZ3MuaXNOYXRpdmUoKSk7XG4gICAgdGhpcy5uYXRpdmVNZXRob2QgPSBtZXRob2QuZ2V0TmF0aXZlRnVuY3Rpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgbmF0aXZlIG1ldGhvZC5cbiAgICogTk9URTogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAqL1xuICBwdWJsaWMgcnVuKHRocmVhZDogSlZNVGhyZWFkKTogdm9pZCB7XG4gICAgdHJhY2UoYFxcblQke3RocmVhZC5nZXRSZWYoKX0gRCR7dGhyZWFkLmdldFN0YWNrVHJhY2UoKS5sZW5ndGh9IFJ1bm5pbmcgJHt0aGlzLm1ldGhvZC5nZXRGdWxsU2lnbmF0dXJlKCl9IFtOYXRpdmVdOmApO1xuICAgIHZhciBydjogYW55ID0gdGhpcy5uYXRpdmVNZXRob2QuYXBwbHkobnVsbCwgdGhpcy5tZXRob2QuY29udmVydEFyZ3ModGhyZWFkLCB0aGlzLmFyZ3MpKTtcbiAgICAvLyBFbnN1cmUgdGhyZWFkIGlzIHJ1bm5pbmcsIGFuZCB3ZSBhcmUgdGhlIHJ1bm5pbmcgbWV0aG9kLlxuICAgIGlmICh0aHJlYWQuZ2V0U3RhdHVzKCkgPT09IFRocmVhZFN0YXR1cy5SVU5OQUJMRSAmJiB0aHJlYWQuY3VycmVudE1ldGhvZCgpID09PSB0aGlzLm1ldGhvZCkge1xuICAgICAgLy8gTm9ybWFsIG5hdGl2ZSBtZXRob2QgZXhpdC5cbiAgICAgIHZhciByZXR1cm5UeXBlID0gdGhpcy5tZXRob2QucmV0dXJuVHlwZTtcbiAgICAgIHN3aXRjaCAocmV0dXJuVHlwZSkge1xuICAgICAgICBjYXNlICdKJzpcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgLy8gVHdvIHN0YWNrIHJldHVybiB2YWx1ZXMgZm9yIG1ldGhvZHMgdGhhdCByZXR1cm4gYSBsb25nIG9yIGEgZG91YmxlLlxuICAgICAgICAgIHRocmVhZC5hc3luY1JldHVybihydiwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIC8vIENvbnZlcnQgdG8gYSBudW1iZXIuXG4gICAgICAgICAgdGhyZWFkLmFzeW5jUmV0dXJuKHJ2ID8gMSA6IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocmVhZC5hc3luY1JldHVybihydik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE4vQVxuICAgKi9cbiAgcHVibGljIHNjaGVkdWxlUmVzdW1lKHRocmVhZDogSlZNVGhyZWFkLCBydj86IGFueSwgcnYyPzogYW55KTogdm9pZCB7XG4gICAgLy8gTk9QXG4gIH1cblxuICAvKipcbiAgICogTm90IHJlbGV2YW50OyB0aGUgZmlyc3QgZXhlY3V0aW9uIGJsb2NrIG9mIGEgbmF0aXZlIG1ldGhvZCB3aWxsIG5ldmVyXG4gICAqIHJlY2VpdmUgYW4gZXhjZXB0aW9uLlxuICAgKi9cbiAgcHVibGljIHNjaGVkdWxlRXhjZXB0aW9uKHRocmVhZDogSlZNVGhyZWFkLCBlOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHR5cGU6IGVudW1zLlN0YWNrRnJhbWVUeXBlID0gZW51bXMuU3RhY2tGcmFtZVR5cGUuTkFUSVZFO1xuXG4gIHB1YmxpYyBnZXRTdGFja1RyYWNlRnJhbWUoKTogSVN0YWNrVHJhY2VGcmFtZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICBwYzogLTEsXG4gICAgICBzdGFjazogW10sXG4gICAgICBsb2NhbHM6IFtdXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGFzc2xvYWRlciBmb3IgdGhlIHN0YWNrIGZyYW1lLlxuICAgKi9cbiAgcHVibGljIGdldExvYWRlcigpOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kLmNscy5nZXRMb2FkZXIoKTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsU3RhY2tGcmFtZXMgYXJlIHVzZWQgYnkgdGhlIEpWTSB0byBsYXVuY2ggSlZNIGZ1bmN0aW9ucyB0aGF0XG4gKiBldmVudHVhbGx5IGNhbGwgYmFjayBpbnRvIEphdmFTY3JpcHQgY29kZSB3aGVuIHRoZXkgY29tcGxldGUgb3IgdGhyb3cgYVxuICogZmF0YWwgZXhjZXB0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTdGFja0ZyYW1lIGltcGxlbWVudHMgSVN0YWNrRnJhbWUge1xuICBwcml2YXRlIGlzRXhjZXB0aW9uOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdmFsOiBhbnk7XG4gIHByaXZhdGUgY2I6IChlPzogSlZNVHlwZXMuamF2YV9sYW5nX1Rocm93YWJsZSwgcnY/OiBhbnkpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjYiBDYWxsYmFjayBmdW5jdGlvbi4gQ2FsbGVkIHdpdGggYW4gZXhjZXB0aW9uIGlmIG9uZSBvY2N1cnMsIG9yXG4gICAqICAgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBjYWxsZWQgbWV0aG9kLCBpZiByZWxldmFudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNiOiAoZT86IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIHJ2PzogYW55KSA9PiB2b2lkKSB7XG4gICAgdGhpcy5jYiA9IGNiO1xuICB9XG5cbiAgcHVibGljIHJ1bih0aHJlYWQ6IEpWTVRocmVhZCk6IHZvaWQge1xuICAgIC8vIFBvcCBteXNlbGYgb2ZmIG9mIHRoZSBzdGFjay5cbiAgICB0aHJlYWQuZnJhbWVQb3AoKTtcbiAgICAvLyBQYXVzZSB0aGUgdGhyZWFkIGJlZm9yZSByZXR1cm5pbmcgaW50byBuYXRpdmUgSmF2YVNjcmlwdCBjb2RlLlxuICAgIHRocmVhZC5zZXRTdGF0dXMoVGhyZWFkU3RhdHVzLkFTWU5DX1dBSVRJTkcpO1xuICAgIGlmICh0aGlzLmlzRXhjZXB0aW9uKSB7XG4gICAgICB0aGlzLmNiKHRoaXMudmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYihudWxsLCB0aGlzLnZhbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgdGhlIEphdmFTY3JpcHQgY29kZSB0aGF0IGNyZWF0ZWQgdGhpcyBzdGFjayBmcmFtZS5cbiAgICovXG4gIHB1YmxpYyBzY2hlZHVsZVJlc3VtZSh0aHJlYWQ6IEpWTVRocmVhZCwgcnY/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmlzRXhjZXB0aW9uID0gZmFsc2U7XG4gICAgdGhpcy52YWwgPSBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHRoZSBKYXZhU2NyaXB0IGNvZGUgdGhhdCBjcmVhdGVkIHRoaXMgc3RhY2sgZnJhbWUgd2l0aCB0aGUgZ2l2ZW5cbiAgICogZXhjZXB0aW9uLlxuICAgKi9cbiAgcHVibGljIHNjaGVkdWxlRXhjZXB0aW9uKHRocmVhZDogSlZNVGhyZWFkLCBlOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlKTogYm9vbGVhbiB7XG4gICAgdGhpcy5pc0V4Y2VwdGlvbiA9IHRydWU7XG4gICAgdGhpcy52YWwgPSBlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHR5cGU6IGVudW1zLlN0YWNrRnJhbWVUeXBlID0gZW51bXMuU3RhY2tGcmFtZVR5cGUuSU5URVJOQUw7XG5cbiAgcHVibGljIGdldFN0YWNrVHJhY2VGcmFtZSgpOiBJU3RhY2tUcmFjZUZyYW1lIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGxhbmd1YWdlIHZpc2libGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgZ2V0TG9hZGVyKCk6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBzdGFjayBmcmFtZXMgaGF2ZSBubyBsb2FkZXIuXCIpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN0YWNrVHJhY2VGcmFtZSB7XG4gIG1ldGhvZDogbWV0aG9kcy5NZXRob2Q7XG4gIHBjOiBudW1iZXI7XG4gIHN0YWNrOiBhbnlbXTtcbiAgbG9jYWxzOiBhbnlbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIEpWTSB0aHJlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBKVk1UaHJlYWQgaW1wbGVtZW50cyBUaHJlYWQge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyB0aHJlYWQsIGZyb20gdGhlIEpWTSBsZXZlbC5cbiAgICovXG4gIHByaXZhdGUgc3RhdHVzOiBUaHJlYWRTdGF0dXMgPSBUaHJlYWRTdGF0dXMuTkVXO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FsbCBzdGFjay5cbiAgICovXG4gIHByaXZhdGUgc3RhY2s6IElTdGFja0ZyYW1lW10gPSBbXTtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhpcyB0aHJlYWQgaGFzIGJlZW4gaW50ZXJydXB0ZWQuIEl0J3MgYSBKVk0gdGhpbmcuXG4gICAqL1xuICBwcml2YXRlIGludGVycnVwdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIElmIHRoZSB0aHJlYWQgaXMgV0FJVElORywgQkxPQ0tFRCwgb3IgVElNRURfV0FJVElORywgdGhpcyBmaWVsZCBob2xkcyB0aGVcbiAgICogbW9uaXRvciB0aGF0IGlzIGludm9sdmVkLlxuICAgKi9cbiAgcHJpdmF0ZSBtb25pdG9yOiBNb25pdG9yID0gbnVsbDtcbiAgcHJpdmF0ZSBic0NsOiBDbGFzc0xvYWRlci5Cb290c3RyYXBDbGFzc0xvYWRlcjtcbiAgcHJpdmF0ZSB0cG9vbDogVGhyZWFkUG9vbDxKVk1UaHJlYWQ+O1xuICBwcml2YXRlIGp2bVRocmVhZE9iajogSlZNVHlwZXMuamF2YV9sYW5nX1RocmVhZDtcbiAgcHJpdmF0ZSBqdm06IEpWTTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgSlZNIHRocmVhZC4gU3RhcnRzIHRoZSB0aHJlYWQgaW4gdGhlIE5FVyBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGp2bTogSlZNLCB0cG9vbDogVGhyZWFkUG9vbDxKVk1UaHJlYWQ+LCB0aHJlYWRPYmo6IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJlYWQpIHtcbiAgICB0aGlzLmp2bSA9IGp2bTtcbiAgICB0aGlzLmJzQ2wgPSBqdm0uZ2V0Qm9vdHN0cmFwQ2xhc3NMb2FkZXIoKTtcbiAgICB0aGlzLnRwb29sID0gdHBvb2w7XG4gICAgdGhpcy5qdm1UaHJlYWRPYmogPSB0aHJlYWRPYmo7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBKVk0gdGhyZWFkIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyB0aHJlYWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0SlZNT2JqZWN0KCk6IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJlYWQge1xuICAgIHJldHVybiB0aGlzLmp2bVRocmVhZE9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIHRocmVhZCBhIGRhZW1vbj9cbiAgICovXG4gIHB1YmxpYyBpc0RhZW1vbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5qdm1UaHJlYWRPYmpbJ2phdmEvbGFuZy9UaHJlYWQvZGFlbW9uJ10gIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmlvcml0eSBvZiB0aGlzIHRocmVhZC5cbiAgICovXG4gIHB1YmxpYyBnZXRQcmlvcml0eSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmp2bVRocmVhZE9ialsnamF2YS9sYW5nL1RocmVhZC9wcmlvcml0eSddO1xuICB9XG5cbiAgLyoqXG4gICAqIFhYWDogVXNlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyB0byBzZXQgdGhlIGZpcnN0IHRocmVhZCdzIFRocmVhZCBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc2V0SlZNT2JqZWN0KG9iajogSlZNVHlwZXMuamF2YV9sYW5nX1RocmVhZCk6IHZvaWQge1xuICAgIG9ialsnamF2YS9sYW5nL1RocmVhZC90aHJlYWRTdGF0dXMnXSA9IHRoaXMuanZtVGhyZWFkT2JqWydqYXZhL2xhbmcvVGhyZWFkL3RocmVhZFN0YXR1cyddO1xuICAgIHRoaXMuanZtVGhyZWFkT2JqID0gb2JqO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmVmZXJlbmNlIG51bWJlciBmb3IgdGhpcyB0aHJlYWQuXG4gICAqL1xuICBwdWJsaWMgZ2V0UmVmKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuanZtVGhyZWFkT2JqLnJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHRocmVhZCdzIGludGVycnVwdGVkIGZsYWcgaXMgc2V0LlxuICAgKi9cbiAgcHVibGljIGlzSW50ZXJydXB0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJydXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgbWV0aG9kLiBSZXR1cm5zIE5VTEwgaWYgc3RhY2sgaXMgZW1wdHkuXG4gICAqL1xuICBwdWJsaWMgY3VycmVudE1ldGhvZCgpOiBtZXRob2RzLk1ldGhvZCB7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaywgaWR4ID0gc3RhY2subGVuZ3RoLCBtZXRob2Q6IG1ldGhvZHMuTWV0aG9kO1xuICAgIHdoaWxlICgtLWlkeCA+PSAwKSB7XG4gICAgICBtZXRob2QgPSBzdGFja1tpZHhdLmdldFN0YWNrVHJhY2VGcmFtZSgpLm1ldGhvZDtcbiAgICAgIGlmIChtZXRob2QgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IG9yIHVuc2V0IHRoaXMgdGhyZWFkJ3MgaW50ZXJydXB0ZWQgZmxhZy5cbiAgICovXG4gIHB1YmxpYyBzZXRJbnRlcnJ1cHRlZChpbnRlcnJ1cHRlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuaW50ZXJydXB0ZWQgPSBpbnRlcnJ1cHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgYm9vdHN0cmFwIGNsYXNzbG9hZGVyLlxuICAgKi9cbiAgcHVibGljIGdldEJzQ2woKTogQ2xhc3NMb2FkZXIuQm9vdHN0cmFwQ2xhc3NMb2FkZXIge1xuICAgIHJldHVybiB0aGlzLmJzQ2w7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjbGFzc2xvYWRlciBmb3IgdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9hZGVyKCk6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyIHtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdLmdldExvYWRlcigpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENyYXdsIHN0YWNrIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgbG9hZGVyID0gdGhpcy5zdGFja1tsZW4gLSBpXS5nZXRMb2FkZXIoKTtcbiAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgbG9hZGVyLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBvcnRzICYgaW5pdGlhbGl6ZXMgdGhlIGdpdmVuIEphdmEgY2xhc3Mgb3IgY2xhc3Nlcy4gUmV0dXJucyB0aGUgSmF2YVNjcmlwdFxuICAgKiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjbGFzcyAtLSBlLmcuIGNvbnRhaW5zIHN0YXRpYyBtZXRob2RzXG4gICAqIGFuZCBmaWVsZHMuXG4gICAqXG4gICAqIElmIG11bHRpcGxlIG5hbWVzIGFyZSBzcGVjaWZpZWQsIGl0IHJldHVybnMgYW4gYXJyYXkgb2YgY2xhc3Mgb2JqZWN0cy5cbiAgICpcbiAgICogSWYgdGhlcmUgaXMgYW4gZXJyb3IgcmVzb2x2aW5nIG9yIGluaXRpYWxpemluZyBhbnkgY2xhc3MsIGl0IHdpbGxcbiAgICogdGhyb3cgYW4gZXhjZXB0aW9uIHdpdGhvdXQgaW52b2tpbmcgeW91ciBjYWxsYmFjay5cbiAgICovXG4gIHB1YmxpYyBpbXBvcnQ8VD4obmFtZTogc3RyaW5nLCBjYjogKHJ2PzogVCkgPT4gdm9pZCwgZXhwbGljaXQ/OiBib29sZWFuKTogdm9pZDtcbiAgcHVibGljIGltcG9ydDxUPihuYW1lczogc3RyaW5nW10sIGNiOiAocnY/OiBUKSA9PiB2b2lkLCBleHBsaWNpdD86IGJvb2xlYW4pOiB2b2lkO1xuICBwdWJsaWMgaW1wb3J0PFQ+KG5hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgY2I6IChydj86IFQpID0+IHZvaWQsIGV4cGxpY2l0OiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmdldExvYWRlcigpO1xuICAgIHRoaXMuc2V0U3RhdHVzKFRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lcykpIHtcbiAgICAgIGxldCBydjogQ2xhc3NEYXRhLklKVk1Db25zdHJ1Y3Rvcjxhbnk+W10gPSBbXTtcbiAgICAgIHV0aWwuYXN5bmNGb3JFYWNoKG5hbWVzLCAobmFtZSwgbmV4dEl0ZW0pID0+IHtcbiAgICAgICAgdGhpcy5faW1wb3J0KG5hbWUsIGxvYWRlciwgKGNvbnMpID0+IHtcbiAgICAgICAgICBydi5wdXNoKGNvbnMpO1xuICAgICAgICAgIG5leHRJdGVtKCk7XG4gICAgICAgIH0sIGV4cGxpY2l0KTtcbiAgICAgIH0sIChlPzogYW55KSA9PiB7XG4gICAgICAgIGNiKDxUPiA8YW55PiBydik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW1wb3J0KG5hbWVzLCBsb2FkZXIsIDxhbnk+IGNiLCBleHBsaWNpdCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaW1wb3J0KG5hbWU6IHN0cmluZywgbG9hZGVyOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgY2I6IChydj86IENsYXNzRGF0YS5JSlZNQ29uc3RydWN0b3I8YW55PikgPT4gdm9pZCwgZXhwbGljaXQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQgY2xzID0gPENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8YW55Pj4gbG9hZGVyLmdldEluaXRpYWxpemVkQ2xhc3ModGhpcywgbmFtZSk7XG4gICAgaWYgKGNscykge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNiKGNscy5nZXRDb25zdHJ1Y3Rvcih0aGlzKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXIuaW5pdGlhbGl6ZUNsYXNzKHRoaXMsIG5hbWUsIChjZGF0YTogQ2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxhbnk+KSA9PiB7XG4gICAgICAgIGlmIChjZGF0YSkge1xuICAgICAgICAgIGNiKGNkYXRhLmdldENvbnN0cnVjdG9yKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSwgZXhwbGljaXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgSlZNIGluc3RhbnRpYXRpb24gdGhhdCB0aGlzIHRocmVhZCBiZWxvbmdzIHRvLlxuICAgKi9cbiAgcHVibGljIGdldEpWTSgpOiBKVk0ge1xuICAgIHJldHVybiB0aGlzLmp2bTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgdGhyZWFkIHBvb2wgdGhhdCB0aGlzIHRocmVhZCBiZWxvbmdzIHRvLlxuICAgKi9cbiAgcHVibGljIGdldFRocmVhZFBvb2woKTogVGhyZWFkUG9vbDxKVk1UaHJlYWQ+IHtcbiAgICByZXR1cm4gdGhpcy50cG9vbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgc3RhY2sgdHJhY2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhY2tUcmFjZSgpOiBJU3RhY2tUcmFjZUZyYW1lW10ge1xuICAgIHZhciB0cmFjZTogSVN0YWNrVHJhY2VGcmFtZVtdID0gW10sIGk6IG51bWJlcixcbiAgICAgIGZyYW1lOiBJU3RhY2tUcmFjZUZyYW1lO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFtZSA9IHRoaXMuc3RhY2tbaV0uZ2V0U3RhY2tUcmFjZUZyYW1lKCk7XG4gICAgICBpZiAoZnJhbWUgIT0gbnVsbCkge1xuICAgICAgICB0cmFjZS5wdXNoKGZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFtERUJVR10gUmV0dXJuIGEgcHJpbnRhYmxlIHN0cmluZyBvZiB0aGUgdGhyZWFkJ3MgY3VycmVudCBzdGFjayB0cmFjZS5cbiAgICovXG4gIHB1YmxpYyBnZXRQcmludGFibGVTdGFja1RyYWNlKCk6IHN0cmluZyB7XG4gICAgdmFyIHJ2OiBzdHJpbmcgPSBcIlwiO1xuICAgIHRoaXMuZ2V0U3RhY2tUcmFjZSgpLnJldmVyc2UoKS5mb3JFYWNoKCh0cmFjZTogSVN0YWNrVHJhY2VGcmFtZSkgPT4ge1xuICAgICAgcnYgKz0gYFxcdGF0ICR7dXRpbC5leHRfY2xhc3NuYW1lKHRyYWNlLm1ldGhvZC5jbHMuZ2V0SW50ZXJuYWxOYW1lKCkpfTo6JHt0cmFjZS5tZXRob2QubmFtZX0oYDtcbiAgICAgIGlmICh0cmFjZS5wYyA+PSAwKSB7XG4gICAgICAgIC8vIEJ5dGVjb2RlIG1ldGhvZFxuICAgICAgICB2YXIgY29kZSA9IHRyYWNlLm1ldGhvZC5nZXRDb2RlQXR0cmlidXRlKCk7XG4gICAgICAgIHZhciB0YWJsZSA9IDxhdHRyaWJ1dGVzLkxpbmVOdW1iZXJUYWJsZT4gY29kZS5nZXRBdHRyaWJ1dGUoJ0xpbmVOdW1iZXJUYWJsZScpO1xuICAgICAgICB2YXIgc3JjQXR0ciA9IDxhdHRyaWJ1dGVzLlNvdXJjZUZpbGU+IHRyYWNlLm1ldGhvZC5jbHMuZ2V0QXR0cmlidXRlKCdTb3VyY2VGaWxlJyk7XG4gICAgICAgIGlmIChzcmNBdHRyICE9IG51bGwpIHtcbiAgICAgICAgICBydiArPSBzcmNBdHRyLmZpbGVuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2ICs9ICd1bmtub3duJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFibGUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gdGFibGUuZ2V0TGluZU51bWJlcih0cmFjZS5wYyk7XG4gICAgICAgICAgcnYgKz0gYDoke2xpbmVOdW1iZXJ9YDtcbiAgICAgICAgICBydiArPSBgIEJ5dGVjb2RlIG9mZnNldDogJHt0cmFjZS5wY31gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOYXRpdmUgbWV0aG9kLlxuICAgICAgICBydiArPSBcIm5hdGl2ZVwiO1xuICAgICAgfVxuICAgICAgcnYgKz0gXCIpXFxuXCI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aHJlYWQncyBtYWluIGV4ZWN1dGlvbiBsb29wLiBFdmVyeXRoaW5nIHN0YXJ0cyBoZXJlIVxuICAgKlxuICAgKiBTSE9VTEQgT05MWSBCRSBJTlZPS0VEIEJZIFRIRSBTQ0hFRFVMRVIuXG4gICAqL1xuICBwdWJsaWMgcnVuKCk6IHZvaWQge1xuICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2ssXG4gICAgICBzdGFydFRpbWU6IG51bWJlciA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBSZXNldCBjb3VudGVyLiBUaHJlYWRzIGFsd2F5cyBzdGFydCBmcm9tIGEgZnJlc2ggc3RhY2sgLyB5aWVsZC5cbiAgICBtZXRob2RSZXN1bWVzTGVmdCA9IG1heE1ldGhvZFJlc3VtZXM7XG4gICAgd2hpbGUgKHRoaXMuc3RhdHVzID09PSBUaHJlYWRTdGF0dXMuUlVOTkFCTEUgJiYgc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2YgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghUkVMRUFTRSkge1xuICAgICAgICBpZiAoc2YudHlwZSA9PT0gZW51bXMuU3RhY2tGcmFtZVR5cGUuQllURUNPREUgJiYgdGhpcy5qdm0uc2hvdWxkVnRyYWNlKCg8Qnl0ZWNvZGVTdGFja0ZyYW1lPiBzZikubWV0aG9kLmZ1bGxTaWduYXR1cmUpKSB7XG4gICAgICAgICAgdmFyIG9sZExldmVsID0gbG9nZ2luZy5sb2dfbGV2ZWw7XG4gICAgICAgICAgbG9nZ2luZy5sb2dfbGV2ZWwgPSBsb2dnaW5nLlZUUkFDRTtcbiAgICAgICAgICBzZi5ydW4odGhpcyk7XG4gICAgICAgICAgbG9nZ2luZy5sb2dfbGV2ZWwgPSBvbGRMZXZlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZi5ydW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNmLnJ1bih0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmICgtLW1ldGhvZFJlc3VtZXNMZWZ0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIC8vIEVzdGltYXRlZCBudW1iZXIgb2YgbWV0aG9kcyB3ZSBjYW4gcmVzdW1lIGJlZm9yZSBuZWVkaW5nIHRvIHlpZWxkLlxuICAgICAgICBjb25zdCBlc3RNYXhNZXRob2RSZXN1bWVzID0gKChtYXhNZXRob2RSZXN1bWVzIC8gZHVyYXRpb24pICogdGhpcy5qdm0uZ2V0UmVzcG9uc2l2ZW5lc3MoKSkgfCAwO1xuICAgICAgICAvLyBVcGRhdGUgQ01BLlxuICAgICAgICBtYXhNZXRob2RSZXN1bWVzID0gKChlc3RNYXhNZXRob2RSZXN1bWVzICsgbnVtU2FtcGxlcyAqIG1heE1ldGhvZFJlc3VtZXMpIC8gKG51bVNhbXBsZXMgKyAxKSkgfCAwO1xuICAgICAgICBpZiAobWF4TWV0aG9kUmVzdW1lcyA8PSAwKSB7XG4gICAgICAgICAgLy8gU2FuaXR5IGNoZWNrLiBTaG91bGQgbmV2ZXIgcmVhbGx5IG9jY3VyLlxuICAgICAgICAgIG1heE1ldGhvZFJlc3VtZXMgPSAxMDtcbiAgICAgICAgfVxuICAgICAgICB2dHJhY2UoYFQke3RoaXMuZ2V0UmVmKCl9IFF1YW50dW0gb3Zlci4gTWV0aG9kIHJlc3VtZXM6IE1heCAke21heE1ldGhvZFJlc3VtZXN9IEVzdCAke2VzdE1heE1ldGhvZFJlc3VtZXN9IFNhbXBsZXMgJHtudW1TYW1wbGVzfWApO1xuICAgICAgICBudW1TYW1wbGVzKys7XG4gICAgICAgIC8vIFRlbGwgdGhlIHNjaGVkdWxlciB0aGF0IG91ciBxdWFudHVtIGlzIG92ZXIuXG4gICAgICAgIHRoaXMudHBvb2wucXVhbnR1bU92ZXIodGhpcyk7XG4gICAgICAgIC8vIEJyZWFrIG91dCBvZiB3aGlsZSBsb29wLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBUaGlzIHRocmVhZCBoYXMgZmluaXNoZWQhXG4gICAgICB0aGlzLnNldFN0YXR1cyhUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFtERUJVR10gUGVyZm9ybXMgYSBzYW5pdHkgY2hlY2sgb24gdGhlIHRocmVhZC5cbiAgICovXG4gIHByaXZhdGUgc2FuaXR5Q2hlY2soKTogYm9vbGVhbiB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXR1cykge1xuICAgICAgY2FzZSBUaHJlYWRTdGF0dXMuTkVXOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLlJVTk5BQkxFOlxuICAgICAgICBhc3NlcnQodGhpcy5zdGFjay5sZW5ndGggPiAwLCAnQSBydW5uYWJsZSB0aHJlYWQgbXVzdCBub3QgaGF2ZSBhbiBlbXB0eSBzdGFjay4nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFRocmVhZFN0YXR1cy5USU1FRF9XQUlUSU5HOlxuICAgICAgICBhc3NlcnQodGhpcy5tb25pdG9yICE9IG51bGwgJiYgdGhpcy5tb25pdG9yLmlzVGltZWRXYWl0aW5nKHRoaXMpLCAnQSB0aW1lZCB3YWl0aW5nIHRocmVhZCBtdXN0IGJlIHdhaXRpbmcgb24gYSBtb25pdG9yLicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLldBSVRJTkc6XG4gICAgICAgIGFzc2VydCh0aGlzLm1vbml0b3IgIT0gbnVsbCAmJiB0aGlzLm1vbml0b3IuaXNXYWl0aW5nKHRoaXMpLCBcIkEgd2FpdGluZyB0aHJlYWQgbXVzdCBiZSB3YWl0aW5nIG9uIGEgbW9uaXRvci5cIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBUaHJlYWRTdGF0dXMuQkxPQ0tFRDpcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLlVOSU5URVJSVVBUQUJMWV9CTE9DS0VEOlxuICAgICAgICBhc3NlcnQodGhpcy5tb25pdG9yICE9IG51bGwgJiYgdGhpcy5tb25pdG9yLmlzQmxvY2tlZCh0aGlzKSwgXCJBIGJsb2NrZWQgdGhyZWFkIG11c3QgYmUgYmxvY2tlZCBvbiBhIG1vbml0b3JcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBUaHJlYWRTdGF0dXMuQVNZTkNfV0FJVElORzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFRocmVhZFN0YXR1cy5URVJNSU5BVEVEOlxuICAgICAgICBhc3NlcnQodGhpcy5zdGFjay5sZW5ndGggPT09IDAsIFwiQSB0ZXJtaW5hdGVkIHRocmVhZCBtdXN0IGhhdmUgYW4gZW1wdHkgc3RhY2suXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLlBBUktFRDpcbiAgICAgICAgYXNzZXJ0KHRoaXMuanZtLmdldFBhcmtlcigpLmlzUGFya2VkKHRoaXMpLCBcIkEgcGFya2VkIHRocmVhZCBtdXN0IGJlIHBhcmtlZC5cIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gSW52YWxpZCBUaHJlYWRTdGF0dXMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IHNldFN0YXR1cy5cbiAgICogVXBkYXRlcyBib3RoIHRoZSBKVk1UaHJlYWQgb2JqZWN0IGFuZCB0aGlzIG9iamVjdC5cbiAgICovXG4gIHByaXZhdGUgcmF3U2V0U3RhdHVzKG5ld1N0YXR1czogVGhyZWFkU3RhdHVzKTogdm9pZCB7XG4gICAgdmFyIGp2bU5ld1N0YXR1czogbnVtYmVyID0gMCwgb2xkU3RhdHVzID0gdGhpcy5zdGF0dXM7XG5cbiAgICBpZiAobG9nZ2luZy5sb2dfbGV2ZWwgPT09IGxvZ2dpbmcuVlRSQUNFKSB7XG4gICAgICB2dHJhY2UoYFxcblQke3RoaXMuZ2V0UmVmKCl9ICR7VGhyZWFkU3RhdHVzW29sZFN0YXR1c119ID0+ICR7VGhyZWFkU3RhdHVzW25ld1N0YXR1c119YCk7XG4gICAgfVxuICAgIGFzc2VydCh2YWxpZGF0ZVRocmVhZFRyYW5zaXRpb24ob2xkU3RhdHVzLCBuZXdTdGF0dXMpLCBgSW52YWxpZCB0aHJlYWQgdHJhbnNpdGlvbjogJHtUaHJlYWRTdGF0dXNbb2xkU3RhdHVzXX0gPT4gJHtUaHJlYWRTdGF0dXNbbmV3U3RhdHVzXX1gKTtcblxuICAgIHRoaXMuc3RhdHVzID0gbmV3U3RhdHVzO1xuICAgIC8vIE1hcCBvdXIgc3RhdHVzIHZhbHVlIGJhY2sgdG8gSlZNJ3MgdGhyZWFkU3RhdHVzIHZhbHVlLlxuICAgIC8vIEVuc3VyZXMgdGhhdCBKVk0gY29kZSBjYW4gaW50cm9zcGVjdCBvbiBvdXIgdGhyZWFkcy5cbiAgICBzd2l0Y2ggKG5ld1N0YXR1cykge1xuICAgICAgY2FzZSBUaHJlYWRTdGF0dXMuTkVXOlxuICAgICAgICBqdm1OZXdTdGF0dXMgfD0gZW51bXMuSlZNVElUaHJlYWRTdGF0ZS5BTElWRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRocmVhZFN0YXR1cy5SVU5OQUJMRTpcbiAgICAgICAganZtTmV3U3RhdHVzIHw9IGVudW1zLkpWTVRJVGhyZWFkU3RhdGUuUlVOTkFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUaHJlYWRTdGF0dXMuQkxPQ0tFRDpcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLlVOSU5URVJSVVBUQUJMWV9CTE9DS0VEOlxuICAgICAgICBqdm1OZXdTdGF0dXMgfD0gZW51bXMuSlZNVElUaHJlYWRTdGF0ZS5CTE9DS0VEX09OX01PTklUT1JfRU5URVI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUaHJlYWRTdGF0dXMuV0FJVElORzpcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLkFTWU5DX1dBSVRJTkc6XG4gICAgICBjYXNlIFRocmVhZFN0YXR1cy5QQVJLRUQ6XG4gICAgICAgIGp2bU5ld1N0YXR1cyB8PSBlbnVtcy5KVk1USVRocmVhZFN0YXRlLldBSVRJTkdfSU5ERUZJTklURUxZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLlRJTUVEX1dBSVRJTkc6XG4gICAgICAgIGp2bU5ld1N0YXR1cyB8PSBlbnVtcy5KVk1USVRocmVhZFN0YXRlLldBSVRJTkdfV0lUSF9USU1FT1VUO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVGhyZWFkU3RhdHVzLlRFUk1JTkFURUQ6XG4gICAgICAgIGp2bU5ld1N0YXR1cyB8PSBlbnVtcy5KVk1USVRocmVhZFN0YXRlLlRFUk1JTkFURUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAganZtTmV3U3RhdHVzID0gZW51bXMuSlZNVElUaHJlYWRTdGF0ZS5SVU5OQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5qdm1UaHJlYWRPYmpbJ2phdmEvbGFuZy9UaHJlYWQvdGhyZWFkU3RhdHVzJ10gPSBqdm1OZXdTdGF0dXM7XG4gICAgdGhpcy50cG9vbC5zdGF0dXNDaGFuZ2UodGhpcywgb2xkU3RhdHVzLCB0aGlzLnN0YXR1cyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdGhlIHRocmVhZCBmcm9tIG9uZSBzdGF0ZSB0byB0aGUgbmV4dC5cbiAgICogQ29udGFpbnMgSlZNLXNwZWNpZmljIHRocmVhZCBsb2dpYy5cbiAgICovXG4gIHB1YmxpYyBzZXRTdGF0dXMoc3RhdHVzOiBUaHJlYWRTdGF0dXMsIG1vbml0b3I6IE1vbml0b3IgPSBudWxsKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICAgIGxldCBvbGRTdGF0dXMgPSB0aGlzLnN0YXR1cztcblxuICAgICAgLy8gVXBkYXRlIHRoZSBtb25pdG9yLlxuICAgICAgdGhpcy5tb25pdG9yID0gbW9uaXRvcjtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gVGhyZWFkU3RhdHVzLlRFUk1JTkFURUQpIHtcbiAgICAgICAgLy8gQWN0dWFsbHkgY2hhbmdlIHN0YXRlLlxuICAgICAgICB0aGlzLnJhd1NldFN0YXR1cyhzdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FsbCBleGl0KCkgZmlyc3QuXG4gICAgICAgIHRoaXMuZXhpdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBjdXJyZW50IHN0YXRlIChkZWJ1ZyBidWlsZHMgb25seSlcbiAgICAgIGFzc2VydCh0aGlzLnNhbml0eUNoZWNrKCksIGBJbnZhbGlkIHRocmVhZCBzdGF0dXMuYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdGhyZWFkIGZpbmlzaGVzIGV4ZWN1dGluZy5cbiAgICovXG4gIHByaXZhdGUgZXhpdCgpOiB2b2lkIHtcbiAgICB2YXIgbW9uaXRvcjogTW9uaXRvciA9IHRoaXMuanZtVGhyZWFkT2JqLmdldE1vbml0b3IoKTtcbiAgICBpZiAobW9uaXRvci5pc0Jsb2NrZWQodGhpcykgfHwgbW9uaXRvci5nZXRPd25lcigpID09PSB0aGlzIHx8IHRoaXMuc3RhdHVzID09PSBUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRCkge1xuICAgICAgLy8gVGhyZWFkIGlzIGFscmVhZHkgc2h1dHRpbmcgZG93bi5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIERlLXNjaGVkdWxlIHRocmVhZC5cbiAgICAgIHRoaXMuc2V0U3RhdHVzKFRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HKTtcbiAgICAgIC8vIE9ubHkgYXBwbGljYWJsZSBpZiBpdCdzIG5vdCBhbiBlYXJseSBkZWF0aCwgZS5nLiBiZWZvcmUgVk0gYm9vdHVwLlxuICAgICAgaWYgKHRoaXMuanZtLmhhc1ZNQm9vdGVkKCkpIHtcbiAgICAgICAgdHJhY2UoYFQke3RoaXMuZ2V0UmVmKCl9IEV4aXRpbmcuYCk7XG4gICAgICAgIHZhciBwaGFzZTIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0cmFjZShgVCR7dGhpcy5nZXRSZWYoKX0gRW50ZXJlZCBleGl0IG1vbml0b3IuYCk7XG4gICAgICAgICAgICAvLyBFeGl0LlxuICAgICAgICAgICAgdGhpcy5qdm1UaHJlYWRPYmpbXCJleGl0KClWXCJdKHRoaXMsIG51bGwsIChlPykgPT4ge1xuICAgICAgICAgICAgICAvLyBOb3RpZnkgZXZlcnlvbmUuXG4gICAgICAgICAgICAgIG1vbml0b3Iubm90aWZ5QWxsKHRoaXMpO1xuICAgICAgICAgICAgICAvLyBFeGl0IG1vbml0b3IuXG4gICAgICAgICAgICAgIG1vbml0b3IuZXhpdCh0aGlzKTtcbiAgICAgICAgICAgICAgdHJhY2UoYFQke3RoaXMuZ2V0UmVmKCl9IFRlcm1pbmF0ZWQuYCk7XG4gICAgICAgICAgICAgIC8vIEFjdHVhbGx5IGJlY29tZSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICB0aGlzLnJhd1NldFN0YXR1cyhUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjcXVpcmUgdGhlIG1vbml0b3IgYXNzb2NpYXRlZCB3aXRoIG91ciBKYXZhT2JqZWN0LlxuICAgICAgICBpZiAobW9uaXRvci5lbnRlcih0aGlzLCBwaGFzZTIpKSB7XG4gICAgICAgICAgcGhhc2UyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNlKGBUJHt0aGlzLmdldFJlZigpfSBOb3QgZXhpdGluZzsgVk0gaXMgc3RpbGwgYm9vdGluZy5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgYXJlIHRoaW5ncyBvbiB0aGUgc3RhY2suIFRoaXMgZXhpdCBpcyBvY2N1cmluZyBiZWZvcmUgdGhlIHN0YWNrIGhhcyBlbXB0aWVkLlxuICAgICAgLy8gQ2xlYXIgdGhlIHN0YWNrLCBzZXQgdG8gdGVybWluYXRlZC5cbiAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHRyYWNlKGBUJHt0aGlzLmdldFJlZigpfSBUZXJtaW5hdGVkLmApO1xuICAgICAgdGhpcy5yYXdTZXRTdGF0dXMoVGhyZWFkU3RhdHVzLlRFUk1JTkFURUQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgcHJpb3JpdHkgb2YgdGhlIHRocmVhZCBjaGFuZ2VzLlxuICAgKiBTaG91bGQgb25seSBiZSBjYWxsZWQgYnkgamF2YS5sYW5nLnNldFByaW9yaXR5MC5cbiAgICovXG4gIHB1YmxpYyBzaWduYWxQcmlvcml0eUNoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLnRwb29sLnByaW9yaXR5Q2hhbmdlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9uaXRvciB0aGF0IHRoaXMgdGhyZWFkIGlzIHdhaXRpbmcgb3IgYmxvY2tlZCBvbi5cbiAgICovXG4gIHB1YmxpYyBnZXRNb25pdG9yQmxvY2soKTogTW9uaXRvciB7XG4gICAgcmV0dXJuIHRoaXMubW9uaXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRocmVhZCdzIGN1cnJlbnQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhdHVzKCk6IFRocmVhZFN0YXR1cyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZnJvbSB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gcmV0dXJuIHZhbHVlLlxuICAgKiBVc2VkIGJ5IGFzeW5jaHJvbm91cyBuYXRpdmUgbWV0aG9kcy5cbiAgICpcbiAgICogQ2F1c2VzIHRoZSBmb2xsb3dpbmcgc3RhdGUgdHJhbnNpdGlvbjpcbiAgICogKiBSVU5OSU5HID0+IFJVTk5BQkxFXG4gICAqICogUlVOTkFCTEUgPT4gUlVOTkFCTEVcbiAgICogKiBBU1lOQ19XQUlUSU5HID0+IFJVTk5BQkxFXG4gICAqXG4gICAqIEl0IGlzIG5vdCB2YWxpZCB0byBjYWxsIHRoaXMgbWV0aG9kIGlmIHRoZSB0aHJlYWQgaXMgaW4gYW55IG90aGVyIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jUmV0dXJuKCk6IHZvaWQ7XG4gIHB1YmxpYyBhc3luY1JldHVybihydjogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIGFzeW5jUmV0dXJuKHJ2OiBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0KTogdm9pZDtcbiAgcHVibGljIGFzeW5jUmV0dXJuKHJ2OiBudW1iZXIsIHJ2MjogYW55KTogdm9pZDtcbiAgcHVibGljIGFzeW5jUmV0dXJuKHJ2OiBnTG9uZywgcnYyOiBhbnkpOiB2b2lkO1xuICBwdWJsaWMgYXN5bmNSZXR1cm4ocnY/OiBhbnksIHJ2Mj86IGFueSk6IHZvaWQge1xuICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgYXNzZXJ0KHRoaXMuc3RhdHVzID09PSBUaHJlYWRTdGF0dXMuUlVOTkFCTEUgfHwgdGhpcy5zdGF0dXMgPT09IFRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HKTtcbiAgICBhc3NlcnQodHlwZW9mIChydikgIT09ICdib29sZWFuJyAmJiBydjIgPT0gbnVsbCk7XG4gICAgLy8gUG9wIG9mZiB0aGUgY3VycmVudCBtZXRob2QuXG4gICAgdmFyIGZyYW1lID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGZyYW1lLnR5cGUgIT0gZW51bXMuU3RhY2tGcmFtZVR5cGUuSU5URVJOQUwpIHtcbiAgICAgIHZhciBmcmFtZUNhc3QgPSA8Qnl0ZWNvZGVTdGFja0ZyYW1lPiBmcmFtZTtcbiAgICAgIGlmIChmcmFtZS50eXBlID09PSBlbnVtcy5TdGFja0ZyYW1lVHlwZS5CWVRFQ09ERSkge1xuICAgICAgICAvLyBUaGlzIGxpbmUgd2lsbCBiZSBwcmVjZWRlZCBieSBhIGxpbmUgdGhhdCBwcmludHMgdGhlIG1ldGhvZCwgc28gY2FuIGJlIHNob3J0IG4nIHN3ZWV0LlxuICAgICAgICB0cmFjZShgICBSZXR1cm5pbmc6ICR7bG9nZ2luZy5kZWJ1Z192YXIocnYpfWApO1xuICAgICAgfVxuXG4gICAgICB0cmFjZShgXFxuVCR7dGhpcy5nZXRSZWYoKX0gRCR7dGhpcy5nZXRTdGFja1RyYWNlKCkubGVuZ3RoICsgMX0gUmV0dXJuaW5nIHZhbHVlIGZyb20gJHtmcmFtZUNhc3QubWV0aG9kLmdldEZ1bGxTaWduYXR1cmUoKX0gWyR7ZnJhbWVDYXN0Lm1ldGhvZC5hY2Nlc3NGbGFncy5pc05hdGl2ZSgpID8gJ05hdGl2ZScgOiAnQnl0ZWNvZGUnfV06ICR7bG9nZ2luZy5kZWJ1Z192YXIocnYpfWApO1xuICAgICAgYXNzZXJ0KHZhbGlkYXRlUmV0dXJuVmFsdWUodGhpcywgZnJhbWVDYXN0Lm1ldGhvZCxcbiAgICAgICAgZnJhbWVDYXN0Lm1ldGhvZC5yZXR1cm5UeXBlLCB0aGlzLmJzQ2wsXG4gICAgICAgIGZyYW1lQ2FzdC5tZXRob2QuY2xzLmdldExvYWRlcigpLCBydiwgcnYyKSwgYEludmFsaWQgcmV0dXJuIHZhbHVlIGZvciBtZXRob2QgJHtmcmFtZUNhc3QubWV0aG9kLmdldEZ1bGxTaWduYXR1cmUoKX1gKTtcbiAgICB9XG4gICAgLy8gVGVsbCB0aGUgdG9wIG9mIHRoZSBzdGFjayB0aGF0IHRoaXMgUlYgaXMgd2FpdGluZyBmb3IgaXQuXG4gICAgdmFyIGlkeDogbnVtYmVyID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAvLyBJZiBpZHggaXMgMCwgdGhlbiB0aGUgdGhyZWFkIHdpbGwgVEVSTUlOQVRFIG5leHQgdGltZSBpdCBlbnRlcnMgaXRzIG1haW5cbiAgICAvLyBsb29wLlxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgc3RhY2tbaWR4XS5zY2hlZHVsZVJlc3VtZSh0aGlzLCBydiwgcnYyKTtcbiAgICB9XG5cbiAgICAvLyBUaHJlYWQgc3RhdGUgdHJhbnNpdGlvbi5cbiAgICB0aGlzLnNldFN0YXR1cyhUaHJlYWRTdGF0dXMuUlVOTkFCTEUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHMgdGhlIHRvcCBzdGFja2ZyYW1lIG9mZiBvZiB0aGUgY2FsbCBzdGFjay5cbiAgICogV0FSTklORzogU0hPVUxEIE9OTFkgQkUgQ0FMTEVEIEJZIEludGVybmFsU3RhY2tGcmFtZS5ydW4oKSFcbiAgICovXG4gIHB1YmxpYyBmcmFtZVBvcCgpOiB2b2lkIHtcbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyB0aGUgZ2l2ZW4gSlZNIGV4Y2VwdGlvbi4gQ2F1c2VzIHRoZSB0aHJlYWQgdG8gdW53aW5kIHRoZSBzdGFjayB1bnRpbFxuICAgKiBpdCBjYW4gZmluZCBhIHN0YWNrIGZyYW1lIHRoYXQgY2FuIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgKlxuICAgKiBDYXVzZXMgdGhlIGZvbGxvd2luZyBzdGF0ZSB0cmFuc2l0aW9uOlxuICAgKiAqIFJVTk5JTkcgPT4gUlVOTkFCTEVcbiAgICogKiBSVU5OQUJMRSA9PiBSVU5OQUJMRVxuICAgKiAqIEFTWU5DX1dBSVRJTkcgPT4gUlVOTkFCTEVcbiAgICpcbiAgICogT3IsIGlmIHRoZSBleGNlcHRpb24gaXMgdW5jYXVnaHQsIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRyYW5zaXRpb25zOlxuICAgKiAqIFJVTk5JTkcgPT4gVEVSTUlOQVRFRFxuICAgKiAqIFJVTk5BQkxFID0+IFRFUk1JTkFURURcbiAgICogKiBBU1lOQ19XQUlUSU5HID0+IFRFUk1JTkFURURcbiAgICpcbiAgICogSXQgaXMgbm90IHZhbGlkIHRvIGNhbGwgdGhpcyBtZXRob2QgaWYgdGhlIHRocmVhZCBpcyBpbiBhbnkgb3RoZXIgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgdGhyb3dFeGNlcHRpb24oZXhjZXB0aW9uOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlKTogdm9pZCB7XG4gICAgYXNzZXJ0KHRoaXMuc3RhdHVzID09PSBUaHJlYWRTdGF0dXMuUlVOTkFCTEUgfHwgdGhpcy5zdGF0dXMgPT09IFRocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HLFxuICAgICAgYFRyaWVkIHRvIHRocm93IGV4Y2VwdGlvbiB3aGlsZSB0aHJlYWQgd2FzIGluIHN0YXRlICR7VGhyZWFkU3RhdHVzW3RoaXMuc3RhdHVzXX1gKTtcbiAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrLCBpZHg6IG51bWJlciA9IHN0YWNrLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBTdGFjayBtYXkgYWN0dWFsbHkgYmUgZW1wdHksIHNvIGd1YXJkIGFnYWluc3QgdGhpcy5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIC8vIEFuIGludGVybmFsIHN0YWNrIGZyYW1lIGNhbm5vdCBwcm9jZXNzIGl0cyBvd24gdGhyb3duIGV4Y2VwdGlvbi5cbiAgICAgIGlmIChzdGFja1tpZHhdLnR5cGUgPT09IGVudW1zLlN0YWNrRnJhbWVUeXBlLklOVEVSTkFMKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBpZHgtLTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBhIHN0YWNrIGZyYW1lIHRoYXQgY2FuIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgLy8gU2V0IG91ciBzdGF0dXMgKmJlZm9yZSogc2NoZWR1bGluZyB0aGUgZXhjZXB0aW9uLiBTb21lIGV4Y2VwdGlvbiBoYW5kbGVyc1xuICAgICAgLy8gbWF5IHdhbnQgdG8gZG8gc29tZXRoaW5nIGFzeW5jaHJvbm91cyBiZWZvcmUgcmVzdW1pbmcgZXhlY3V0aW9uLlxuICAgICAgdGhpcy5zZXRTdGF0dXMoVGhyZWFkU3RhdHVzLlJVTk5BQkxFKTtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmICFzdGFja1tpZHhdLnNjaGVkdWxlRXhjZXB0aW9uKHRoaXMsIGV4Y2VwdGlvbikpIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGlkeC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFVuY2F1Z2h0IGV4Y2VwdGlvbiFcbiAgICAgIHRoaXMuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24oZXhjZXB0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGV4Y2VwdGlvbiBvYmplY3Qgb2YgdGhlIGdpdmVuIGNsYXNzIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBuYXRpdmUgSmF2YVNjcmlwdCBjb2RlLlxuICAgKiBAcGFyYW0gY2xzTmFtZSBOYW1lIG9mIHRoZSBjbGFzcyAoZS5nLiBcIkxqYXZhL2xhbmcvVGhyb3dhYmxlO1wiKVxuICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXhjZXB0aW9uLlxuICAgKi9cbiAgcHVibGljIHRocm93TmV3RXhjZXB0aW9uPFQgZXh0ZW5kcyBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlPihjbHNOYW1lOiBzdHJpbmcsIG1zZzogc3RyaW5nKSB7XG4gICAgdmFyIGNscyA9IDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPFQ+PiB0aGlzLmJzQ2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aGlzLCBjbHNOYW1lKSxcbiAgICAgIHRocm93RXhjZXB0aW9uID0gKCkgPT4ge1xuICAgICAgICB2YXIgZUNvbnMgPSBjbHMuZ2V0Q29uc3RydWN0b3IodGhpcyksXG4gICAgICAgICAgZSA9IG5ldyBlQ29ucyh0aGlzKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGV4Y2VwdGlvbiwgYW5kIHRocm93IGl0IHdoZW4gZG9uZS5cbiAgICAgICAgZVsnPGluaXQ+KExqYXZhL2xhbmcvU3RyaW5nOylWJ10odGhpcywgW3V0aWwuaW5pdFN0cmluZyh0aGlzLmJzQ2wsIG1zZyldLCAoZXJyPzogSlZNVHlwZXMuamF2YV9sYW5nX1Rocm93YWJsZSkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFeGNlcHRpb24oZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aHJvd0V4Y2VwdGlvbihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICBpZiAoY2xzICE9IG51bGwpIHtcbiAgICAgIC8vIE5vIGluaXRpYWxpemF0aW9uIHJlcXVpcmVkLlxuICAgICAgdGhyb3dFeGNlcHRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gcmVxdWlyZWQuXG4gICAgICB0aGlzLnNldFN0YXR1cyhUaHJlYWRTdGF0dXMuQVNZTkNfV0FJVElORyk7XG4gICAgICB0aGlzLmJzQ2wuaW5pdGlhbGl6ZUNsYXNzKHRoaXMsIGNsc05hbWUsIChjZGF0YTogQ2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxUPikgPT4ge1xuICAgICAgICBpZiAoY2RhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIGNscyA9IGNkYXRhO1xuICAgICAgICAgIHRocm93RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiB1bmNhdWdodCBleGNlcHRpb24gb24gYSB0aHJlYWQuXG4gICAqL1xuICBwdWJsaWMgaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24oZXhjZXB0aW9uOiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlKSB7XG4gICAgdGhpcy5qdm1UaHJlYWRPYmpbJ2Rpc3BhdGNoVW5jYXVnaHRFeGNlcHRpb24oTGphdmEvbGFuZy9UaHJvd2FibGU7KVYnXSh0aGlzLCBbZXhjZXB0aW9uXSk7XG4gIH1cblxuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgdGhpcy5qdm0gPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogW0RFQlVHXSBTdG9yZXMgYWxsIG9mIHRoZSB2YWxpZCB0aHJlYWQgdHJhbnNpdGlvbnMuXG4gKiBAdG9kbyBBbnkgd2F5IHRvIG1ha2UgdGhpcyBzbWFsbGVyP1xuICogQHRvZG8gTW92ZSBpbnRvICdkZWJ1ZycgbW9kdWxlIHRoYXQgd2UgTk9QIG91dCBpbiByZWxlYXNlIGJ1aWxkcy5cbiAqL1xuZXhwb3J0IHZhciB2YWxpZFRyYW5zaXRpb25zOiB7IFtvbGRTdGF0dXM6IG51bWJlcl06IHsgW25ld1N0YXR1czogbnVtYmVyXTogc3RyaW5nIH0gfSA9IHt9O1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuTkVXXSA9IHt9O1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuTkVXXVtUaHJlYWRTdGF0dXMuUlVOTkFCTEVdID0gXCJSdW5NZXRob2QgaW52b2tlZCBvbiBuZXcgdGhyZWFkXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5ORVddW1RocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HXSA9IFwiW0pWTSBib290dXAgb25seV0gSW50ZXJuYWwgb3BlcmF0aW9uIG9jY3VycyBvbiBuZXcgdGhyZWFkXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5ORVddW1RocmVhZFN0YXR1cy5URVJNSU5BVEVEXSA9IFwiW0pWTSBoYWx0MCBvbmx5XSBXaGVuIHRoZSBKVk0gc2h1dHMgZG93biwgaXQgdGVybWluYXRlcyBhbGwgdGhyZWFkcywgaW5jbHVkaW5nIHRob3NlIHRoYXQgaGF2ZSBuZXZlciBiZWVuIHJ1bi5cIjtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLkFTWU5DX1dBSVRJTkddID0ge307XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HXVtUaHJlYWRTdGF0dXMuUlVOTkFCTEVdID0gXCJBc3luYyBvcGVyYXRpb24gY29tcGxldGVzXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HXVtUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRF0gPSBcIlJ1bk1ldGhvZCBjb21wbGV0ZXMgYW5kIGNhbGxzdGFjayBpcyBlbXB0eVwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuQkxPQ0tFRF0gPSB7fTtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLkJMT0NLRURdW1RocmVhZFN0YXR1cy5SVU5OQUJMRV0gPSBcIkFjcXVpcmVzIG1vbml0b3IsIG9yIGlzIGludGVycnVwdGVkXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5CTE9DS0VEXVtUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRF0gPSBcIlRocmVhZCBpcyB0ZXJtaW5hdGVkIHdoaWxzdCBibG9ja2VkLlwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuUEFSS0VEXSA9IHt9O1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuUEFSS0VEXVtUaHJlYWRTdGF0dXMuQVNZTkNfV0FJVElOR10gPSBcIkJhbGFuY2luZyB1bnBhcmssIG9yIGlzIGludGVycnVwdGVkXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5QQVJLRURdW1RocmVhZFN0YXR1cy5URVJNSU5BVEVEXSA9IFwiVGhyZWFkIGlzIHRlcm1pbmF0ZWQgd2hpbHN0IHBhcmtlZC5cIjtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLlJVTk5BQkxFXSA9IHt9O1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuUlVOTkFCTEVdW1RocmVhZFN0YXR1cy5BU1lOQ19XQUlUSU5HXSA9IFwiVGhyZWFkIHBlcmZvcm1zIGFuIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0IG9wZXJhdGlvblwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuUlVOTkFCTEVdW1RocmVhZFN0YXR1cy5URVJNSU5BVEVEXSA9IFwiQ2FsbHN0YWNrIGlzIGVtcHR5XCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5SVU5OQUJMRV1bVGhyZWFkU3RhdHVzLkJMT0NLRURdID0gXCJUaHJlYWQgd2FpdHMgdG8gYWNxdWlyZSBtb25pdG9yXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5SVU5OQUJMRV1bVGhyZWFkU3RhdHVzLldBSVRJTkddID0gXCJUaHJlYWQgd2FpdHMgb24gbW9uaXRvciAoT2JqZWN0LndhaXQpXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5SVU5OQUJMRV1bVGhyZWFkU3RhdHVzLlRJTUVEX1dBSVRJTkddID0gXCJUaHJlYWQgd2FpdHMgb24gbW9uaXRvciB3aXRoIHRpbWVvdXQgKE9iamVjdC53YWl0KVwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuUlVOTkFCTEVdW1RocmVhZFN0YXR1cy5QQVJLRURdID0gXCJUaHJlYWQgcGFya3MgaXRzZWxmXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5URVJNSU5BVEVEXSA9IHt9O1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRF1bVGhyZWFkU3RhdHVzLk5FV10gPSBcIlRocmVhZCBpcyByZXN1cnJlY3RlZCBmb3IgcmUtdXNlXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5URVJNSU5BVEVEXVtUaHJlYWRTdGF0dXMuUlVOTkFCTEVdID0gXCJUaHJlYWQgaXMgcmVzdXJyZWN0ZWQgZm9yIHJlLXVzZVwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRF1bVGhyZWFkU3RhdHVzLkFTWU5DX1dBSVRJTkddID0gXCJbSlZNIEJvb3R1cF0gVGhyZWFkIGlzIHJlc3VycmVjdGVkIGZvciBpbnRlcm5hbCBvcGVyYXRpb25cIjtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLlRJTUVEX1dBSVRJTkddID0ge307XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5USU1FRF9XQUlUSU5HXVtUaHJlYWRTdGF0dXMuUlVOTkFCTEVdID0gXCJUaW1lciBleHBpcmVzLCBvciB0aHJlYWQgaXMgaW50ZXJydXB0ZWQsIGFuZCB0aHJlYWQgaW1tZWRpYXRlbHkgYWNxdWlyZXMgbG9ja1wiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuVElNRURfV0FJVElOR11bVGhyZWFkU3RhdHVzLlVOSU5URVJSVVBUQUJMWV9CTE9DS0VEXSA9IFwiVGhyZWFkIGlzIGludGVycnVwdGVkIG9yIG5vdGlmaWVkLCBvciB0aW1lciBleHBpcmVzLCBhbmQgbG9jayBhbHJlYWR5IG93bmVkXCI7XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5USU1FRF9XQUlUSU5HXVtUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRF0gPSBcIlRocmVhZCBpcyB0ZXJtaW5hdGVkIHdoaWxzdCB3YWl0aW5nLlwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuVU5JTlRFUlJVUFRBQkxZX0JMT0NLRURdID0ge307XG52YWxpZFRyYW5zaXRpb25zW1RocmVhZFN0YXR1cy5VTklOVEVSUlVQVEFCTFlfQkxPQ0tFRF1bVGhyZWFkU3RhdHVzLlJVTk5BQkxFXSA9IFwiVGhyZWFkIGFjcXVpcmVzIG1vbml0b3JcIjtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLlVOSU5URVJSVVBUQUJMWV9CTE9DS0VEXVtUaHJlYWRTdGF0dXMuVEVSTUlOQVRFRF0gPSBcIlRocmVhZCBpcyB0ZXJtaW5hdGVkIHdoaWxzdCBibG9ja2VkLlwiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuV0FJVElOR10gPSB7fTtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLldBSVRJTkddW1RocmVhZFN0YXR1cy5SVU5OQUJMRV0gPSBcIlRocmVhZCBpcyBpbnRlcnJ1cHRlZCwgYW5kIGltbWVkaWF0ZWx5IGFjcXVpcmVzIGxvY2tcIjtcbnZhbGlkVHJhbnNpdGlvbnNbVGhyZWFkU3RhdHVzLldBSVRJTkddW1RocmVhZFN0YXR1cy5VTklOVEVSUlVQVEFCTFlfQkxPQ0tFRF0gPSBcIlRocmVhZCBpcyBub3RpZmllZCBvciBpbnRlcnJ1cHRlZCwgYW5kIGRvZXMgbm90IGltbWVkaWF0ZWx5IGFjcXVpcmUgbG9ja1wiO1xudmFsaWRUcmFuc2l0aW9uc1tUaHJlYWRTdGF0dXMuV0FJVElOR11bVGhyZWFkU3RhdHVzLlRFUk1JTkFURURdID0gXCJUaHJlYWQgaXMgdGVybWluYXRlZCB3aGlsc3Qgd2FpdGluZy5cIjtcblxuLyoqXG4gKiBbREVCVUddIEVuc3VyZXMgdGhhdCBhIHRocmVhZCB0cmFuc2l0aW9uIGlzIGxlZ2FsLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRocmVhZFRyYW5zaXRpb24ob2xkU3RhdHVzOiBUaHJlYWRTdGF0dXMsIG5ld1N0YXR1czogVGhyZWFkU3RhdHVzKTogYm9vbGVhbiB7XG4gIHZhciBydiA9IHZhbGlkVHJhbnNpdGlvbnMuaGFzT3duUHJvcGVydHkoXCJcIiArIG9sZFN0YXR1cykgJiZcbiAgICB2YWxpZFRyYW5zaXRpb25zW29sZFN0YXR1c10uaGFzT3duUHJvcGVydHkoXCJcIiArIG5ld1N0YXR1cyk7XG4gIHJldHVybiBydjtcbn1cblxuLyoqXG4gKiBbREVCVUddIEFzc2VydHMgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBwYXNzZXMgYmFzaWMgc2FuaXR5XG4gKiBjaGVja3MuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUmV0dXJuVmFsdWUodGhyZWFkOiBKVk1UaHJlYWQsIG1ldGhvZDogbWV0aG9kcy5NZXRob2QsIHJldHVyblR5cGU6IHN0cmluZywgYnNDbDogQ2xhc3NMb2FkZXIuQm9vdHN0cmFwQ2xhc3NMb2FkZXIsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgcnYxOiBhbnksIHJ2MjogYW55KTogYm9vbGVhbiB7XG4gIC8vIGludm9rZUJhc2ljIGlzIHR5cGVkIHdpdGggYW4gT2JqZWN0IHJldHVybiB2YWx1ZSwgYnV0IGl0IGNhbiByZXR1cm4gYW55XG4gIC8vIGRhbW4gdHlwZSBpdCB3YW50cywgcHJpbWl0aXZlIG9yIG5vLlxuICBpZiAobWV0aG9kLmZ1bGxTaWduYXR1cmUgPT09IFwiamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGUvaW52b2tlQmFzaWMoW0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDtcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGNsczogQ2xhc3NEYXRhLkNsYXNzRGF0YTtcbiAgaWYgKHV0aWwuaXNfcHJpbWl0aXZlX3R5cGUocmV0dXJuVHlwZSkpIHtcbiAgICBzd2l0Y2ggKHJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ1onOiAvLyBCb29sZWFuXG4gICAgICAgIGFzc2VydChydjIgPT09IHVuZGVmaW5lZCwgXCJTZWNvbmQgcmV0dXJuIHZhbHVlIG11c3QgYmUgdW5kZWZpbmVkIGZvciBCb29sZWFuIHR5cGUuXCIpO1xuICAgICAgICBhc3NlcnQocnYxID09PSAxIHx8IHJ2MSA9PT0gMCwgXCJCb29sZWFucyBtdXN0IGJlIDAgb3IgMS5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQic6IC8vIEJ5dGVcbiAgICAgICAgYXNzZXJ0KHJ2MiA9PT0gdW5kZWZpbmVkLCBcIlNlY29uZCByZXR1cm4gdmFsdWUgbXVzdCBiZSB1bmRlZmluZWQgZm9yIEJ5dGUgdHlwZS5cIik7XG4gICAgICAgIGFzc2VydChydjEgPD0gMTI3ICYmIHJ2MSA+PSAtMTI4LCBgQnl0ZSB2YWx1ZSBmb3IgbWV0aG9kICR7bWV0aG9kLm5hbWV9IGlzIG91dCBvZiBib3VuZHM6ICR7cnYxfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICBhc3NlcnQocnYyID09PSB1bmRlZmluZWQsIFwiU2Vjb25kIHJldHVybiB2YWx1ZSBtdXN0IGJlIHVuZGVmaW5lZCBmb3IgQ2hhcmFjdGVyIHR5cGUuXCIpO1xuICAgICAgICBhc3NlcnQocnYxIDw9IDY1NTM1ICYmIHJ2MSA+PSAwLCBgQ2hhcmFjdGVyIHZhbHVlIGlzIG91dCBvZiBib3VuZHM6ICR7cnYxfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICBhc3NlcnQocnYyID09PSB1bmRlZmluZWQsIFwiU2Vjb25kIHJldHVybiB2YWx1ZSBtdXN0IGJlIHVuZGVmaW5lZCBmb3IgU2hvcnQgdHlwZS5cIik7XG4gICAgICAgIGFzc2VydChydjEgPD0gMzI3NjcgJiYgcnYxID49IC0zMjc2OCwgYFNob3J0IHZhbHVlIGlzIG91dCBvZiBib3VuZHM6ICR7cnYxfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0knOiAvLyBpbnRcbiAgICAgICAgYXNzZXJ0KHJ2MiA9PT0gdW5kZWZpbmVkLCBcIlNlY29uZCByZXR1cm4gdmFsdWUgbXVzdCBiZSB1bmRlZmluZWQgZm9yIEludCB0eXBlLlwiKTtcbiAgICAgICAgYXNzZXJ0KHJ2MSA8PSAyMTQ3NDgzNjQ3ICYmIHJ2MSA+PSAtMjE0NzQ4MzY0OCwgYEludCB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzOiAke3J2MX1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdKJzogLy8gbG9uZyAvLy05MjIzMzcyMDM2ODU0Nzc1ODA4IHRvIDkyMjMzNzIwMzY4NTQ3NzU4MDdcbiAgICAgICAgYXNzZXJ0KHJ2MiA9PT0gbnVsbCwgXCJTZWNvbmQgcmV0dXJuIHZhbHVlIG11c3QgYmUgTlVMTCBmb3IgTG9uZyB0eXBlLlwiKTtcbiAgICAgICAgYXNzZXJ0KCg8Z0xvbmc+IHJ2MSkubGVzc1RoYW5PckVxdWFsKGdMb25nLk1BWF9WQUxVRSkgJiYgKDxnTG9uZz4gcnYxKS5ncmVhdGVyVGhhbk9yRXF1YWwoZ0xvbmcuTUlOX1ZBTFVFKSwgYExvbmcgdmFsdWUgaXMgb3V0IG9mIGJvdW5kczogJHtydjF9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRic6IC8vIEZsb2F0XG4gICAgICAgIGFzc2VydChydjIgPT09IHVuZGVmaW5lZCwgXCJTZWNvbmQgcmV0dXJuIHZhbHVlIG11c3QgYmUgdW5kZWZpbmVkIGZvciBGbG9hdCB0eXBlLlwiKTtcbiAgICAgICAgLy8gTmFOICE9PSBOYU4sIHNvIHdlIGhhdmUgdG8gaGF2ZSBhIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgICAgICBhc3NlcnQodXRpbC53cmFwRmxvYXQocnYxKSA9PT0gcnYxIHx8IChpc05hTihydjEpICYmIGlzTmFOKHV0aWwud3JhcEZsb2F0KHJ2MSkpKSwgYEZsb2F0IHZhbHVlIGlzIG91dCBvZiBib3VuZHM6ICR7cnYxfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0QnOiAvLyBEb3VibGVcbiAgICAgICAgYXNzZXJ0KHJ2MiA9PT0gbnVsbCwgXCJTZWNvbmQgcmV0dXJuIHZhbHVlIG11c3QgYmUgTlVMTCBmb3IgRG91YmxlIHR5cGUuXCIpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIHJ2MSA9PT0gJ251bWJlcicsIGBJbnZhbGlkIGRvdWJsZSB2YWx1ZTogJHtydjF9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVic6XG4gICAgICAgIGFzc2VydChydjEgPT09IHVuZGVmaW5lZCAmJiBydjIgPT09IHVuZGVmaW5lZCwgXCJSZXR1cm4gdmFsdWVzIG11c3QgYmUgdW5kZWZpbmVkIGZvciBWb2lkIHR5cGVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh1dGlsLmlzX2FycmF5X3R5cGUocmV0dXJuVHlwZSkpIHtcbiAgICBhc3NlcnQocnYyID09PSB1bmRlZmluZWQsIFwiU2Vjb25kIHJldHVybiB2YWx1ZSBtdXN0IGJlIHVuZGVmaW5lZCBmb3IgYXJyYXkgdHlwZS5cIik7XG4gICAgYXNzZXJ0KHJ2MSA9PT0gbnVsbCB8fCAodHlwZW9mIHJ2MSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJ2MVsnZ2V0Q2xhc3MnXSA9PT0gJ2Z1bmN0aW9uJyksIGBJbnZhbGlkIGFycmF5IG9iamVjdDogJHtydjF9YCk7XG4gICAgaWYgKHJ2MSAhPSBudWxsKSB7XG4gICAgICBjbHMgPSBhc3NlcnRDbGFzc0luaXRpYWxpemVkT3JSZXNvbHZlZCh0aHJlYWQsIGNsLCByZXR1cm5UeXBlLCB0cnVlKTtcbiAgICAgIGFzc2VydChydjEuZ2V0Q2xhc3MoKS5pc0Nhc3RhYmxlKGNscyksIGBSZXR1cm4gdmFsdWUgb2YgdHlwZSAke3J2MS5nZXRDbGFzcygpLmdldEludGVybmFsTmFtZSgpfSB1bmFibGUgdG8gYmUgY2FzdCB0byByZXR1cm4gdHlwZSAke3JldHVyblR5cGV9LmApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQodXRpbC5pc19yZWZlcmVuY2VfdHlwZShyZXR1cm5UeXBlKSwgYEludmFsaWQgcmVmZXJlbmNlIHR5cGU6ICR7cmV0dXJuVHlwZX1gKTtcbiAgICBhc3NlcnQocnYyID09PSB1bmRlZmluZWQsIGBTZWNvbmQgcmV0dXJuIHZhbHVlIG11c3QgYmUgdW5kZWZpbmVkIGZvciByZWZlcmVuY2UgdHlwZS5gKTtcbiAgICAvLyBBbGwgb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBpbnN0YW5jZXMgb2YgamF2YS9sYW5nL09iamVjdC5cbiAgICBhc3NlcnQocnYxID09PSBudWxsIHx8IHJ2MSBpbnN0YW5jZW9mICg8Q2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0Pj4gYnNDbC5nZXRJbml0aWFsaXplZENsYXNzKHRocmVhZCwgJ0xqYXZhL2xhbmcvT2JqZWN0OycpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpLCBgUmVmZXJlbmNlIHJldHVybiB0eXBlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgT2JqZWN0OyB2YWx1ZTogJHtydjF9YCk7XG4gICAgaWYgKHJ2MSAhPSBudWxsKSB7XG4gICAgICBjbHMgPSBhc3NlcnRDbGFzc0luaXRpYWxpemVkT3JSZXNvbHZlZCh0aHJlYWQsIGNsLCByZXR1cm5UeXBlLCBmYWxzZSk7XG4gICAgICBpZiAoIWNscy5hY2Nlc3NGbGFncy5pc0ludGVyZmFjZSgpKSB7XG4gICAgICAgIC8vIFlvdSBjYW4gcmV0dXJuIGFuIGludGVyZmFjZSB0eXBlIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGl0LFxuICAgICAgICAvLyBzaW5jZSB0aGV5IGRvbid0IG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdW50aWwgeW91IHRyeSB0b1xuICAgICAgICAvLyBpbnZva2Ugb25lIG9mIHRoZWlyIG1ldGhvZHMuXG4gICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IGNoZWNrIGlmIHRoZSBjbGFzcyBpcyBpbiB0aGUgSU5JVElBTElaRUQgc3RhdGUsXG4gICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgaXQgaXMgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nXG4gICAgICAgIC8vIGluaXRpYWxpemVkLiBnZXRJbml0aWFsaXplZENsYXNzIGhhbmRsZXMgdGhpcyBzdWJ0bGV0eS5cbiAgICAgICAgYXNzZXJ0Q2xhc3NJbml0aWFsaXplZE9yUmVzb2x2ZWQodGhyZWFkLCBjbCwgcmV0dXJuVHlwZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBhc3NlcnQocnYxLmdldENsYXNzKCkuaXNDYXN0YWJsZShjbHMpLCBgVW5hYmxlIHRvIGNhc3QgJHtydjEuZ2V0Q2xhc3MoKS5nZXRJbnRlcm5hbE5hbWUoKX0gdG8gJHtyZXR1cm5UeXBlfS5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzSW5pdGlhbGl6ZWRPclJlc29sdmVkKHRocmVhZDogSlZNVGhyZWFkLCBjbDogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIHR5cGU6IHN0cmluZywgaW5pdGlhbGl6ZWQ6IGJvb2xlYW4pOiBDbGFzc0RhdGEuQ2xhc3NEYXRhIHtcbiAgdmFyIGNsczogQ2xhc3NEYXRhLkNsYXNzRGF0YSA9IG51bGw7XG4gIC8vIEJyZWFrIG91dCBvZiBsb29wIG9uY2UgY2xhc3MgaXMgZm91bmQuXG4gIHdoaWxlIChjbHMgPT09IG51bGwpIHtcbiAgICBjbHMgPSBpbml0aWFsaXplZCA/IGNsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCB0eXBlKSA6IGNsLmdldFJlc29sdmVkQ2xhc3ModHlwZSk7XG4gICAgaWYgKGNsLmdldExvYWRlck9iamVjdCgpICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2wuZ2V0TG9hZGVyT2JqZWN0KClbJ2phdmEvbGFuZy9DbGFzc0xvYWRlci9wYXJlbnQnXSA9PT0gbnVsbCkge1xuICAgICAgICBjbCA9IHRocmVhZC5nZXRCc0NsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbCA9IGNsLmdldExvYWRlck9iamVjdCgpWydqYXZhL2xhbmcvQ2xhc3NMb2FkZXIvcGFyZW50J10uJGxvYWRlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UganVzdCBjaGVja2VkIHRoZSBib290c3RyYXAgY2xhc3Nsb2FkZXIsIHNvIHdlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICBhc3NlcnQoY2xzICE9PSBudWxsLCBgVW5hYmxlIHRvIGdldCBpbml0aWFsaXplZCBjbGFzcyBmb3IgdHlwZSAke3R5cGV9LmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xzO1xufVxuXG5mdW5jdGlvbiBwcmludENvbnN0YW50UG9vbEl0ZW0oY3BpOiBDb25zdGFudFBvb2wuSUNvbnN0YW50UG9vbEl0ZW0pOiBzdHJpbmcge1xuICBzd2l0Y2ggKGNwaS5nZXRUeXBlKCkpIHtcbiAgICBjYXNlIGVudW1zLkNvbnN0YW50UG9vbEl0ZW1UeXBlLk1FVEhPRFJFRjpcbiAgICAgIHZhciBjcGlNUiA9IDxDb25zdGFudFBvb2wuTWV0aG9kUmVmZXJlbmNlPiBjcGk7XG4gICAgICByZXR1cm4gdXRpbC5leHRfY2xhc3NuYW1lKGNwaU1SLmNsYXNzSW5mby5uYW1lKSArIFwiLlwiICsgY3BpTVIuc2lnbmF0dXJlO1xuICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuSU5URVJGQUNFX01FVEhPRFJFRjpcbiAgICAgIHZhciBjcGlJTSA9IDxDb25zdGFudFBvb2wuSW50ZXJmYWNlTWV0aG9kUmVmZXJlbmNlPiBjcGk7XG4gICAgICByZXR1cm4gdXRpbC5leHRfY2xhc3NuYW1lKGNwaUlNLmNsYXNzSW5mby5uYW1lKSArIFwiLlwiICsgY3BpSU0uc2lnbmF0dXJlO1xuICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuRklFTERSRUY6XG4gICAgICB2YXIgY3BpRlIgPSA8Q29uc3RhbnRQb29sLkZpZWxkUmVmZXJlbmNlPiBjcGk7XG4gICAgICByZXR1cm4gdXRpbC5leHRfY2xhc3NuYW1lKGNwaUZSLmNsYXNzSW5mby5uYW1lKSArIFwiLlwiICsgY3BpRlIubmFtZUFuZFR5cGVJbmZvLm5hbWUgKyBcIjpcIiArIHV0aWwuZXh0X2NsYXNzbmFtZShjcGlGUi5uYW1lQW5kVHlwZUluZm8uZGVzY3JpcHRvcik7XG4gICAgY2FzZSBlbnVtcy5Db25zdGFudFBvb2xJdGVtVHlwZS5OQU1FX0FORF9UWVBFOlxuICAgICAgdmFyIGNwaU5BVCA9IDxDb25zdGFudFBvb2wuTmFtZUFuZFR5cGVJbmZvPiBjcGk7XG4gICAgICByZXR1cm4gY3BpTkFULm5hbWUgKyBcIjpcIiArIGNwaU5BVC5kZXNjcmlwdG9yO1xuICAgIGNhc2UgZW51bXMuQ29uc3RhbnRQb29sSXRlbVR5cGUuQ0xBU1M6XG4gICAgICB2YXIgY3BpQ2xhc3MgPSA8Q29uc3RhbnRQb29sLkNsYXNzUmVmZXJlbmNlPiBjcGk7XG4gICAgICByZXR1cm4gdXRpbC5leHRfY2xhc3NuYW1lKGNwaUNsYXNzLm5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbG9nZ2luZy5kZWJ1Z192YXIoKDxhbnk+IGNwaSkudmFsdWUpO1xuICB9XG59XG5cbi8vIFRPRE86IFByZWZpeCBiZWhpbmQgREVCVUcsIGNhY2hlIGxvd2VyY2FzZSBvcGNvZGUgbmFtZXMuXG5leHBvcnQgdmFyIE9wY29kZUxheW91dFByaW50ZXJzOiB7W2xheW91dEF0b206IG51bWJlcl06IChmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKSA9PiBzdHJpbmd9ID0ge307XG5PcGNvZGVMYXlvdXRQcmludGVyc1tlbnVtcy5PcGNvZGVMYXlvdXRUeXBlLk9QQ09ERV9PTkxZXSA9IChmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKSA9PiBlbnVtcy5PcENvZGVbY29kZS5yZWFkVUludDgocGMpXS50b0xvd2VyQ2FzZSgpO1xuT3Bjb2RlTGF5b3V0UHJpbnRlcnNbZW51bXMuT3Bjb2RlTGF5b3V0VHlwZS5DT05TVEFOVF9QT09MXSA9IChmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKSA9PiBlbnVtcy5PcENvZGVbY29kZS5yZWFkVUludDgocGMpXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgKyBwcmludENvbnN0YW50UG9vbEl0ZW0oZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpKTtcbk9wY29kZUxheW91dFByaW50ZXJzW2VudW1zLk9wY29kZUxheW91dFR5cGUuQ09OU1RBTlRfUE9PTF9VSU5UOF0gPSAoZnJhbWU6IEJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogTm9kZUJ1ZmZlciwgcGM6IG51bWJlcikgPT4gZW51bXMuT3BDb2RlW2NvZGUucmVhZFVJbnQ4KHBjKV0udG9Mb3dlckNhc2UoKSArIFwiIFwiICsgcHJpbnRDb25zdGFudFBvb2xJdGVtKGZyYW1lLm1ldGhvZC5jbHMuY29uc3RhbnRQb29sLmdldChjb2RlLnJlYWRVSW50OChwYyArIDEpKSk7XG5PcGNvZGVMYXlvdXRQcmludGVyc1tlbnVtcy5PcGNvZGVMYXlvdXRUeXBlLkNPTlNUQU5UX1BPT0xfQU5EX1VJTlQ4X1ZBTFVFXSA9IChmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKSA9PiBlbnVtcy5PcENvZGVbY29kZS5yZWFkVUludDgocGMpXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgKyBwcmludENvbnN0YW50UG9vbEl0ZW0oZnJhbWUubWV0aG9kLmNscy5jb25zdGFudFBvb2wuZ2V0KGNvZGUucmVhZFVJbnQxNkJFKHBjICsgMSkpKSArIFwiIFwiICsgY29kZS5yZWFkVUludDgocGMgKyAzKTtcbk9wY29kZUxheW91dFByaW50ZXJzW2VudW1zLk9wY29kZUxheW91dFR5cGUuVUlOVDhfVkFMVUVdID0gKGZyYW1lOiBCeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IE5vZGVCdWZmZXIsIHBjOiBudW1iZXIpID0+IGVudW1zLk9wQ29kZVtjb2RlLnJlYWRVSW50OChwYyldLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiArIGNvZGUucmVhZFVJbnQ4KHBjICsgMSk7XG5PcGNvZGVMYXlvdXRQcmludGVyc1tlbnVtcy5PcGNvZGVMYXlvdXRUeXBlLlVJTlQ4X0FORF9JTlQ4X1ZBTFVFXSA9IChmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKSA9PiBlbnVtcy5PcENvZGVbY29kZS5yZWFkVUludDgocGMpXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgKyBjb2RlLnJlYWRVSW50OChwYyArIDEpICsgXCIgXCIgKyBjb2RlLnJlYWRJbnQ4KHBjICsgMik7XG5PcGNvZGVMYXlvdXRQcmludGVyc1tlbnVtcy5PcGNvZGVMYXlvdXRUeXBlLklOVDhfVkFMVUVdID0gKGZyYW1lOiBCeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IE5vZGVCdWZmZXIsIHBjOiBudW1iZXIpID0+IGVudW1zLk9wQ29kZVtjb2RlLnJlYWRVSW50OChwYyldLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiArIGNvZGUucmVhZEludDgocGMgKyAxKTtcbk9wY29kZUxheW91dFByaW50ZXJzW2VudW1zLk9wY29kZUxheW91dFR5cGUuSU5UMTZfVkFMVUVdID0gKGZyYW1lOiBCeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IE5vZGVCdWZmZXIsIHBjOiBudW1iZXIpID0+IGVudW1zLk9wQ29kZVtjb2RlLnJlYWRVSW50OChwYyldLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiArIGNvZGUucmVhZEludDE2QkUocGMgKyAxKTtcbk9wY29kZUxheW91dFByaW50ZXJzW2VudW1zLk9wY29kZUxheW91dFR5cGUuSU5UMzJfVkFMVUVdID0gKGZyYW1lOiBCeXRlY29kZVN0YWNrRnJhbWUsIGNvZGU6IE5vZGVCdWZmZXIsIHBjOiBudW1iZXIpID0+IGVudW1zLk9wQ29kZVtjb2RlLnJlYWRVSW50OChwYyldLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiArIGNvZGUucmVhZEludDMyQkUocGMgKyAxKTtcbk9wY29kZUxheW91dFByaW50ZXJzW2VudW1zLk9wY29kZUxheW91dFR5cGUuQVJSQVlfVFlQRV0gPSAoZnJhbWU6IEJ5dGVjb2RlU3RhY2tGcmFtZSwgY29kZTogTm9kZUJ1ZmZlciwgcGM6IG51bWJlcikgPT4gZW51bXMuT3BDb2RlW2NvZGUucmVhZFVJbnQ4KHBjKV0udG9Mb3dlckNhc2UoKSArIFwiIFwiICsgb3Bjb2Rlcy5BcnJheVR5cGVzW2NvZGUucmVhZFVJbnQ4KHBjICsgMSldO1xuT3Bjb2RlTGF5b3V0UHJpbnRlcnNbZW51bXMuT3Bjb2RlTGF5b3V0VHlwZS5XSURFXSA9IChmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKSA9PiBlbnVtcy5PcENvZGVbY29kZS5yZWFkVUludDgocGMpXS50b0xvd2VyQ2FzZSgpO1xuXG5mdW5jdGlvbiBhbm5vdGF0ZU9wY29kZShvcDogbnVtYmVyLCBmcmFtZTogQnl0ZWNvZGVTdGFja0ZyYW1lLCBjb2RlOiBOb2RlQnVmZmVyLCBwYzogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIE9wY29kZUxheW91dFByaW50ZXJzW2VudW1zLk9wY29kZUxheW91dHNbb3BdXShmcmFtZSwgY29kZSwgcGMpO1xufVxuIiwiaW1wb3J0IHtUaHJlYWRTdGF0dXN9IGZyb20gJy4vZW51bXMnO1xuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5cbi8qKlxuICogR2VuZXJpYyBpbnRlcmZhY2UgZm9yIGEgdGhyZWFkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRocmVhZCB7XG4gIGdldFN0YXR1cygpOiBUaHJlYWRTdGF0dXM7XG4gIGlzRGFlbW9uKCk6IGJvb2xlYW47XG4gIGdldFByaW9yaXR5KCk6IG51bWJlcjtcbiAgc2V0U3RhdHVzKHN0YXR1czogVGhyZWFkU3RhdHVzKTogdm9pZDtcbiAgcnVuKCk6IHZvaWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB0aHJlYWQgc3RhdHVzIGluZGljYXRlcyB0aGF0IHRoZSB0aHJlYWQgaXMgc2NoZWR1bGVhYmxlLlxuICovXG5mdW5jdGlvbiBpc1J1bm5hYmxlKHN0YXR1czogVGhyZWFkU3RhdHVzKTogYm9vbGVhbiB7XG4gIHJldHVybiBzdGF0dXMgPT09IFRocmVhZFN0YXR1cy5SVU5OQUJMRTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgdGhyZWFkIHNjaGVkdWxpbmcgYWxnb3JpdGhtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZWR1bGVyPFQgZXh0ZW5kcyBUaHJlYWQ+IHtcbiAgLyoqXG4gICAqIFNjaGVkdWxlIHRoZSBnaXZlbiB0aHJlYWQgdG8gcnVuLlxuICAgKi9cbiAgc2NoZWR1bGVUaHJlYWQodGhyZWFkOiBUKTogdm9pZDtcbiAgLyoqXG4gICAqIFNpZ25hbCB0aGF0IHRoZSBnaXZlbiB0aHJlYWQncyBwcmlvcml0eSBoYXMgY2hhbmdlZC5cbiAgICovXG4gIHByaW9yaXR5Q2hhbmdlKHRocmVhZDogVCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBVbnNjaGVkdWxlIHRoZSBnaXZlbiB0aHJlYWQgdG8gcnVuLiBJdCBpcyByZW1vdmVkIGZyb21cbiAgICogdGhlIHNjaGVkdWxlcidzIHF1ZXVlLlxuICAgKi9cbiAgdW5zY2hlZHVsZVRocmVhZCh0aHJlYWQ6IFQpOiB2b2lkO1xuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRocmVhZC4gUmV0dXJucyBOVUxMIGlmXG4gICAqIG5vIHRocmVhZHMgYXJlIHJ1bm5pbmcuXG4gICAqL1xuICBnZXRSdW5uaW5nVGhyZWFkKCk6IFQ7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHRocmVhZCdzIHF1YW50dW0gaXMgb3Zlci5cbiAgICovXG4gIHF1YW50dW1PdmVyKHRocmVhZDogVCk6IHZvaWQ7XG59XG5cbi8qKlxuICogQSBXZWlnaHRlZCBSb3VuZCBSb2JpbiB0aHJlYWQgc2NoZWR1bGVyLlxuICovXG5jbGFzcyBXZWlnaHRlZFJvdW5kUm9iaW5TY2hlZHVsZXI8VCBleHRlbmRzIFRocmVhZD4gaW1wbGVtZW50cyBTY2hlZHVsZXI8VD4ge1xuICAvLyBOdW1iZXIgb2YgcXVhbnRhIGdpdmVuIHRvIHRoZSBjdXJyZW50IHRocmVhZC5cbiAgcHJpdmF0ZSBfY291bnQ6IG51bWJlciA9IDA7XG4gIC8vIFRoZSBxdWV1ZSBvZiB0aHJlYWRzLlxuICBwcml2YXRlIF9xdWV1ZTogVFtdID0gW107XG4gIC8vIFJlYWQgYnkgcnVuVGhyZWFkLiBVc2VkIGFzIGEgbG9jay5cbiAgcHJpdmF0ZSBfdGhyZWFkU2NoZWR1bGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIHNjaGVkdWxlVGhyZWFkKHRocmVhZDogVCk6IHZvaWQge1xuICAgIHRoaXMuX3F1ZXVlLnB1c2godGhyZWFkKTtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBUaGVyZSBhcmVuJ3QgYW55IHRocmVhZHMgcnVubmluZy4gUnVuIHRoaXMgdGhyZWFkLlxuICAgICAgdGhpcy5ydW5UaHJlYWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRoZSB0aHJlYWQgYXQgdGhlIGhlYWQgb2YgdGhlIHF1ZXVlLlxuICAgKi9cbiAgcHJpdmF0ZSBydW5UaHJlYWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3RocmVhZFNjaGVkdWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aHJlYWRTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBsZXQgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICAgIHRoaXMuX3RocmVhZFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IHRocmVhZCA9IHRoaXMuX3F1ZXVlWzBdO1xuICAgICAgICBhc3NlcnQodGhyZWFkLmdldFN0YXR1cygpID09PSBUaHJlYWRTdGF0dXMuUlVOTkFCTEUsIGBBdHRlbXB0ZWQgdG8gcnVuIG5vbi1ydW5uYWJsZSB0aHJlYWQuYCk7XG4gICAgICAgIHRocmVhZC5ydW4oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1bnNjaGVkdWxlVGhyZWFkKHRocmVhZDogVCk6IHZvaWQge1xuICAgIGxldCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGxldCBpc1J1bm5pbmdUaHJlYWQgPSBxdWV1ZVswXSA9PT0gdGhyZWFkO1xuICAgIGFzc2VydChxdWV1ZS5pbmRleE9mKHRocmVhZCkgPiAtMSwgYFRyaWVkIHRvIHVuc2NoZWR1bGUgdGhyZWFkIHRoYXQgd2FzIG5vdCBzY2hlZHVsZWQuYCk7XG4gICAgLy8gUmVtb3ZlIHRocmVhZCBmcm9tIHF1ZXVlLlxuICAgIGlmIChpc1J1bm5pbmdUaHJlYWQpIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCB0aHJlYWQuXG4gICAgICB0aGlzLnJ1blRocmVhZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZS5zcGxpY2UocXVldWUuaW5kZXhPZih0aHJlYWQpLCAxKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0UnVubmluZ1RocmVhZCgpOiBUIHtcbiAgICBsZXQgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcHJpb3JpdHlDaGFuZ2UodGhyZWFkOiBUKTogdm9pZCB7XG4gICAgLy8gTm90IGltcG9ydGFudCBmb3IgdGhlIGFsZ29yaXRobS4gV2UnbGwgcGljayB1cCB0aGUgY2hhbmdlXG4gICAgLy8gbmV4dCB0aW1lIHdlIHNjaGVkdWxlLlxuICB9XG5cbiAgcHVibGljIHF1YW50dW1PdmVyKHRocmVhZDogVCk6IHZvaWQge1xuICAgIGFzc2VydCh0aGlzLl9xdWV1ZVswXSA9PT0gdGhyZWFkLCBgQSBub24tcnVubmluZyB0aHJlYWQgaGFzIGFuIGV4cGlyZWQgcXVhbnR1bT9gKTtcbiAgICB0aGlzLl9jb3VudCsrO1xuICAgIGlmICh0aGlzLl9jb3VudCA+PSB0aHJlYWQuZ2V0UHJpb3JpdHkoKSB8fCB0aHJlYWQuZ2V0U3RhdHVzKCkgIT09IFRocmVhZFN0YXR1cy5SVU5OQUJMRSkge1xuICAgICAgLy8gTW92ZSB0byBiYWNrIG9mIHF1ZXVlLCByZXNldCBjb3VudC5cbiAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGhpcy5fcXVldWUuc2hpZnQoKSk7XG4gICAgfVxuICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IHRocmVhZC5cbiAgICB0aGlzLnJ1blRocmVhZCgpO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHRocmVhZCBwb29sLiBIYW5kbGVzIHNjaGVkdWxpbmcgZHV0aWVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaHJlYWRQb29sPFQgZXh0ZW5kcyBUaHJlYWQ+IHtcbiAgcHJpdmF0ZSB0aHJlYWRzOiBUW10gPSBbXTtcbiAgcHJpdmF0ZSBydW5uaW5nVGhyZWFkOiBUO1xuICBwcml2YXRlIHNjaGVkdWxlcjogU2NoZWR1bGVyPFQ+ID0gbmV3IFdlaWdodGVkUm91bmRSb2JpblNjaGVkdWxlcjxUPigpO1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIFRocmVhZFBvb2wgYmVjb21lcyBlbXB0eS4gVGhpcyBpcyB1c3VhbGx5IGEgc2lnbiB0aGF0XG4gICAqIGV4ZWN1dGlvbiBoYXMgZmluaXNoZWQuXG4gICAqXG4gICAqIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWUgaXQgc2lnbmFscyB0aGF0IHRoaXMgdGhyZWFkcG9vbCBjYW4gZnJlZSBpdHMgcmVzb3VyY2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBlbXB0eUNhbGxiYWNrOiAoKSA9PiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKGVtcHR5Q2FsbGJhY2s6ICgpID0+IGJvb2xlYW4pIHtcbiAgICB0aGlzLmVtcHR5Q2FsbGJhY2sgPSBlbXB0eUNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGFsbCBvZiB0aGUgdGhyZWFkcyBpbiB0aGUgdGhyZWFkIHBvb2wuXG4gICAqL1xuICBwdWJsaWMgZ2V0VGhyZWFkcygpOiBUW10ge1xuICAgIC8vIFJldHVybiBhIGNvcHkgb2Ygb3VyIGludGVybmFsIGFycmF5LlxuICAgIHJldHVybiB0aGlzLnRocmVhZHMuc2xpY2UoMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFueSByZW1haW5pbmcgdGhyZWFkcyBhcmUgbm9uLWRhZW1vbmljIGFuZCBjb3VsZCBiZSBydW5uYWJsZS5cbiAgICogSWYgbm90LCB3ZSBjYW4gdGVybWluYXRlIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogVGhpcyBjaGVjayBpcyBpbnZva2VkIGVhY2ggdGltZSBhIHRocmVhZCB0ZXJtaW5hdGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBhbnlOb25EYWVtb25pY1RocmVhZHMoKTogYm9vbGVhbiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRocmVhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB0ID0gdGhpcy50aHJlYWRzW2ldO1xuICAgICAgaWYgKHQuaXNEYWVtb24oKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0dXMgPSB0LmdldFN0YXR1cygpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gVGhyZWFkU3RhdHVzLk5FVyAmJlxuICAgICAgICAgIHN0YXR1cyAhPT0gVGhyZWFkU3RhdHVzLlRFUk1JTkFURUQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgdGhyZWFkVGVybWluYXRlZCh0aHJlYWQ6IFQpOiB2b2lkIHtcbiAgICB2YXIgaWR4OiBudW1iZXIgPSB0aGlzLnRocmVhZHMuaW5kZXhPZih0aHJlYWQpO1xuICAgIGFzc2VydChpZHggPj0gMCk7XG4gICAgLy8gUmVtb3ZlIHRoZSBzcGVjaWZpZWQgdGhyZWFkIGZyb20gdGhlIHRocmVhZHBvb2wuXG4gICAgdGhpcy50aHJlYWRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgaWYgKCF0aGlzLmFueU5vbkRhZW1vbmljVGhyZWFkcygpKSB7XG4gICAgICBjb25zdCBjbG9zZSA9IHRoaXMuZW1wdHlDYWxsYmFjaygpO1xuICAgICAgaWYgKGNsb3NlKSB7XG4gICAgICAgIHRoaXMuZW1wdHlDYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgdGhyZWFkJ3Mgc3RhdHVzIGNoYW5nZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdHVzQ2hhbmdlKHRocmVhZDogVCwgb2xkU3RhdHVzOiBUaHJlYWRTdGF0dXMsIG5ld1N0YXR1czogVGhyZWFkU3RhdHVzKTogdm9pZCB7XG4gICAgdmFyIHdhc1J1bm5hYmxlICA9IGlzUnVubmFibGUob2xkU3RhdHVzKSxcbiAgICAgIG5vd1J1bm5hYmxlID0gaXNSdW5uYWJsZShuZXdTdGF0dXMpO1xuXG4gICAgaWYgKG9sZFN0YXR1cyA9PT0gVGhyZWFkU3RhdHVzLk5FVyB8fCBvbGRTdGF0dXMgPT09IFRocmVhZFN0YXR1cy5URVJNSU5BVEVEKSB7XG4gICAgICBpZiAodGhpcy50aHJlYWRzLmluZGV4T2YodGhyZWFkKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy50aHJlYWRzLnB1c2godGhyZWFkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmZvcm0gc2NoZWR1bGluZyBhbGdvcml0aG0gaWYgdGhyZWFkIGNoYW5nZXMgZnJvbSBydW5uYWJsZSA9PiB1bnJ1bm5hYmxlLCBvciB1bnJ1bm5hYmxlID0+IHJ1bm5hYmxlLlxuICAgIGlmICh3YXNSdW5uYWJsZSAhPT0gbm93UnVubmFibGUpIHtcbiAgICAgIGlmICh3YXNSdW5uYWJsZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlci51bnNjaGVkdWxlVGhyZWFkKHRocmVhZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZVRocmVhZCh0aHJlYWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdTdGF0dXMgPT09IFRocmVhZFN0YXR1cy5URVJNSU5BVEVEKSB7XG4gICAgICB0aGlzLnRocmVhZFRlcm1pbmF0ZWQodGhyZWFkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0aHJlYWQncyBwcmlvcml0eSBjaGFuZ2VzLlxuICAgKi9cbiAgcHVibGljIHByaW9yaXR5Q2hhbmdlKHRocmVhZDogVCk6IHZvaWQge1xuICAgIHRoaXMuc2NoZWR1bGVyLnByaW9yaXR5Q2hhbmdlKHRocmVhZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSB0aHJlYWQncyBxdWFudHVtIGlzIG92ZXIuXG4gICAqL1xuICBwdWJsaWMgcXVhbnR1bU92ZXIodGhyZWFkOiBUKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlZHVsZXIucXVhbnR1bU92ZXIodGhyZWFkKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgZ0xvbmcgPSByZXF1aXJlKCcuL2dMb25nJyk7XG5pbXBvcnQgdGhyZWFkaW5nID0gcmVxdWlyZSgnLi90aHJlYWRpbmcnKTtcbmltcG9ydCBlbnVtcyA9IHJlcXVpcmUoJy4vZW51bXMnKTtcbmltcG9ydCBKVk1UeXBlcyA9IHJlcXVpcmUoJy4uL2luY2x1ZGVzL0pWTVR5cGVzJyk7XG5cbi8vIEZvciB0eXBlIGluZm9ybWF0aW9uXG5pbXBvcnQgQ2xhc3NMb2FkZXIgPSByZXF1aXJlKCcuL0NsYXNzTG9hZGVyJyk7XG5pbXBvcnQgQ2xhc3NEYXRhID0gcmVxdWlyZSgnLi9DbGFzc0RhdGEnKTtcblxuLyoqXG4gKiB1dGlsIGNvbnRhaW5zIHN0YXRlbGVzcyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGFyZSB1c2VkIGFyb3VuZCBEb3BwaW8nc1xuICogY29kZWJhc2UuXG4gKiBUT0RPOiBTZXBhcmF0ZSBnZW5lcmFsIEpTIHV0aWxpdHkgbWV0aG9kcyBmcm9tIEpWTSB1dGlsaXR5IG1ldGhvZHMuXG4gKi9cblxuLyoqXG4gKiBNZXJnZXMgb2JqZWN0IGxpdGVyYWxzIHRvZ2V0aGVyIGludG8gYSBuZXcgb2JqZWN0LiBFbXVsYXRlcyB1bmRlcnNjb3JlJ3MgbWVyZ2UgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSguLi5saXRlcmFsczoge1twcm9wOiBzdHJpbmddOiBhbnl9W10pOiB7W3Byb3A6IHN0cmluZ106IGFueX0ge1xuICB2YXIgbmV3T2JqZWN0OiB7W3Byb3A6IHN0cmluZ106IGFueX0gPSB7fTtcbiAgbGl0ZXJhbHMuZm9yRWFjaCgobGl0ZXJhbCkgPT4ge1xuICAgIE9iamVjdC5rZXlzKGxpdGVyYWwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBsaXRlcmFsW2tleV07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqZWN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJlX2luX2Jyb3dzZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiBwcm9jZXNzLnBsYXRmb3JtID09PSAnYnJvd3Nlcic7XG59XG5cbmV4cG9ydCB2YXIgdHlwZWRBcnJheXNTdXBwb3J0ZWQ6IGJvb2xlYW4gPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogQ29udmVydHMgSlZNIGludGVybmFsIG5hbWVzIGludG8gSlMtc2FmZSBuYW1lcy4gT25seSBmb3IgdXNlIHdpdGggcmVmZXJlbmNlXG4gKiB0eXBlcy5cbiAqIExqYXZhL2xhbmcvT2JqZWN0OyA9PiBqYXZhX2xhbmdfT2JqZWN0XG4gKiBMZm9vL0Jhcl9iYXo7ID0+IGZvb19CYXJfX2JhelxuICpcbiAqIElzIE5PVCBtZWFudCB0byBiZSB1bmFtYmlndW91cyFcbiAqXG4gKiBBbHNvIGhhbmRsZXMgdGhlIHNwZWNpYWwgY2hhcmFjdGVycyBkZXNjcmliZWQgaGVyZTpcbiAqIGh0dHBzOi8vYmxvZ3Mub3JhY2xlLmNvbS9qcm9zZS9lbnRyeS9zeW1ib2xpY19mcmVlZG9tX2luX3RoZV92bVxuICovXG5leHBvcnQgZnVuY3Rpb24ganZtTmFtZTJKU05hbWUoanZtTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgc3dpdGNoIChqdm1OYW1lWzBdKSB7XG4gICAgY2FzZSAnTCc6XG4gICAgICByZXR1cm4ganZtTmFtZS5zbGljZSgxLCBqdm1OYW1lLmxlbmd0aCAtIDEpLnJlcGxhY2UoL18vZywgJ19fJylcbiAgICAgICAgLy8gUmVtb3ZlIC8gcmVwbGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGludmFsaWQgZm9yIEpTIHN5bWJvbHMuXG4gICAgICAgIC5yZXBsYWNlKC9bXFwvLjskPD5cXFtcXF06XFxcXD1eLV0vZywgJ18nKTtcbiAgICBjYXNlICdbJzpcbiAgICAgIHJldHVybiBgQVJSXyR7anZtTmFtZTJKU05hbWUoanZtTmFtZS5zbGljZSgxKSl9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGp2bU5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZS1lc2NhcGVzIEpWTSBuYW1lcyBmb3IgZXZhbCdkIGNvZGUuIE90aGVyd2lzZSwgSmF2YVNjcmlwdCByZW1vdmVzIHRoZSBlc2NhcGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVlc2NhcGVKVk1OYW1lKGp2bU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBqdm1OYW1lLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyk7XG59XG5cbi8qKlxuICogQXBwbGllcyBhbiBhc3luYyBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBpbiBvcmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jRm9yRWFjaDxUPihcbiAgICAgIGxzdDogQXJyYXk8VD4sXG4gICAgICBmbjogKGVsZW06IFQsIG5leHRfaXRlbTogKGVycj86IGFueSkgPT4gdm9pZCkgPT4gdm9pZCxcbiAgICAgIGRvbmVfY2I6IChlcnI/OiBhbnkpID0+IHZvaWRcbiAgKTogdm9pZCB7XG4gIHZhciBpID0gLTE7XG4gIGZ1bmN0aW9uIHByb2Nlc3MoZXJyPzogYW55KTogdm9pZCB7XG4gICAgaWYgKGVycikge1xuICAgICAgZG9uZV9jYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA8IGxzdC5sZW5ndGgpIHtcbiAgICAgICAgZm4obHN0W2ldLCBwcm9jZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmVfY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJvY2VzcygpO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIHNwZWNpZmllZCB0YXNrcyBpbiBzZXJpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luY1Nlcmllcyh0YXNrczogeyhuZXh0OiAoZXJyPzogYW55KSA9PiB2b2lkKTogdm9pZH1bXSwgZG9uZUNiOiAoZXJyPzogYW55KSA9PiB2b2lkKSB7XG4gIHZhciBpID0gLTE7XG4gIGZ1bmN0aW9uIHByb2Nlc3MoZXJyPzogYW55KTogdm9pZCB7XG4gICAgaWYgKGVycikge1xuICAgICAgZG9uZUNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGlmIChpIDwgdGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHRhc2tzW2ldKHByb2Nlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZUNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByb2Nlc3MoKTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaW4gb3JkZXIgaW4gc2VyaWVzLlxuICogVGhlIGZpcnN0IGVsZW1lbnQgdGhhdCByZXR1cm5zIHN1Y2Nlc3MgaGFsdHMgdGhlIHByb2Nlc3MsIGFuZCB0cmlnZ2Vyc1xuICogZG9uZV9jYi4gSWYgbm8gZWxlbWVudHMgcmV0dXJuIHN1Y2Nlc3MsIGRvbmVfY2IgaXMgdHJpZ2dlcmVkIHdpdGggbm9cbiAqIGFyZ3VtZW50cy5cbiAqXG4gKiBJIHdyb3RlIHRoaXMgc3BlY2lmaWNhbGx5IGZvciBjbGFzc2xvYWRpbmcsIGJ1dCBpdCBtYXkgaGF2ZSB1c2VzIGVsc2V3aGVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jRmluZDxUPihcbiAgICBsc3Q6IEFycmF5PFQ+LFxuICAgIGZuOiAoZWxlbTogVCwgbmV4dEl0ZW06IChzdWNjZXNzOiBib29sZWFuKSA9PiB2b2lkKSA9PiB2b2lkLFxuICAgIGRvbmVfY2I6IChlbGVtPzogVCkgPT4gdm9pZFxuICApOiB2b2lkIHtcbiAgdmFyIGkgPSAtMTtcbiAgZnVuY3Rpb24gcHJvY2VzcyhzdWNjZXNzOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGRvbmVfY2IobHN0W2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgaWYgKGkgPCBsc3QubGVuZ3RoKSB7XG4gICAgICAgIGZuKGxzdFtpXSwgcHJvY2Vzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lX2NiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByb2Nlc3MoZmFsc2UpO1xufVxuXG5pZiAoISg8YW55PiBNYXRoKVsnaW11bCddKSB7XG4gICg8YW55PiBNYXRoKVsnaW11bCddID0gZnVuY3Rpb24oYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICAvLyBwb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9pbXVsXG4gICAgdmFyIGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICB2YXIgYWwgPSBhICYgMHhmZmZmO1xuICAgIHZhciBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgdmFyIGJsID0gYiAmIDB4ZmZmZjtcbiAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgLy8gdGhlIGZpbmFsIHwwIGNvbnZlcnRzIHRoZSB1bnNpZ25lZCB2YWx1ZSBpbnRvIGEgc2lnbmVkIHZhbHVlXG4gICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xuICB9O1xufVxuXG5pZiAoISg8YW55PiBNYXRoKVsnZXhwbTEnXSkge1xuICAoPGFueT4gTWF0aClbJ2V4cG0xJ10gPSBmdW5jdGlvbih4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDFlLTUpIHtcbiAgICAgIHJldHVybiB4ICsgMC41KngqeDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZXhwKHgpIC0gMS4wO1xuICAgIH1cbiAgfTtcbn1cblxuaWYgKCEoPGFueT4gTWF0aClbJ3NpbmgnXSl7XG4gICg8YW55PiBNYXRoKVsnc2luaCddID0gZnVuY3Rpb24oYTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICB2YXIgZXhwID0gTWF0aC5leHAoYSk7XG4gICAgcmV0dXJuIChleHAgLSAxIC8gZXhwKSAvIDI7XG4gIH1cbn1cblxuaWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXg/KSB7XG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciBuID0gMDtcbiAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG4gPSBOdW1iZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChuICE9IG4pIHsgLy8gc2hvcnRjdXQgZm9yIHZlcmlmeWluZyBpZiBpdCdzIE5hTlxuICAgICAgICBuID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobiAhPSAwICYmIG4gIT0gSW5maW5pdHkgJiYgbiAhPSAtSW5maW5pdHkpIHtcbiAgICAgICAgbiA9ICgobiA+IDAgPyAxIDogMCkgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuID49IGxlbikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgayA9IG4gPj0gMCA/IG4gOiBNYXRoLm1heChsZW4gLSBNYXRoLmFicyhuKSwgMCk7XG4gICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgaWYgKGsgaW4gdCAmJiB0W2tdID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFjY2Vzc2luZ0NscyBoYXMgcGVybWlzc2lvbiB0byBhIGZpZWxkIG9yIG1ldGhvZCB3aXRoIHRoZSBnaXZlblxuICogZmxhZ3Mgb24gb3duaW5nQ2xzLlxuICpcbiAqIE1vZGlmaWVyICAgIHwgQ2xhc3MgfCBQYWNrYWdlIHwgU3ViY2xhc3MgfCBXb3JsZFxuICog4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlCvigJTigJTigJTigJTigJTigJTigJTigJTigJQr4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlFxuICogcHVibGljICAgICAgfCAgeSAgICB8ICAgIHkgICAgfCAgICB5ICAgICB8ICAgeVxuICog4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlCvigJTigJTigJTigJTigJTigJTigJTigJTigJQr4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlFxuICogcHJvdGVjdGVkICAgfCAgeSAgICB8ICAgIHkgICAgfCAgICB5ICAgICB8ICAgblxuICog4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlCvigJTigJTigJTigJTigJTigJTigJTigJTigJQr4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlFxuICogbm8gbW9kaWZpZXIgfCAgeSAgICB8ICAgIHkgICAgfCAgICBuICAgICB8ICAgblxuICog4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlCvigJTigJTigJTigJTigJTigJTigJTigJTigJQr4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCU4oCUK+KAlOKAlOKAlOKAlOKAlOKAlOKAlFxuICogcHJpdmF0ZSAgICAgfCAgeSAgICB8ICAgIG4gICAgfCAgICBuICAgICB8ICAgblxuICpcbiAqIHk6IGFjY2Vzc2libGVcbiAqIG46IG5vdCBhY2Nlc3NpYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0FjY2VzcyhhY2Nlc3NpbmdDbHM6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIG93bmluZ0NsczogQ2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiwgYWNjZXNzRmxhZ3M6IEZsYWdzKTogYm9vbGVhbiB7XG4gIGlmIChhY2Nlc3NGbGFncy5pc1B1YmxpYygpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYWNjZXNzRmxhZ3MuaXNQcm90ZWN0ZWQoKSkge1xuICAgIHJldHVybiBhY2Nlc3NpbmdDbHMuZ2V0UGFja2FnZU5hbWUoKSA9PT0gb3duaW5nQ2xzLmdldFBhY2thZ2VOYW1lKCkgfHwgYWNjZXNzaW5nQ2xzLmlzU3ViY2xhc3Mob3duaW5nQ2xzKTtcbiAgfSBlbHNlIGlmIChhY2Nlc3NGbGFncy5pc1ByaXZhdGUoKSkge1xuICAgIHJldHVybiBhY2Nlc3NpbmdDbHMgPT09IG93bmluZ0NscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWNjZXNzaW5nQ2xzLmdldFBhY2thZ2VOYW1lKCkgPT09IG93bmluZ0Nscy5nZXRQYWNrYWdlTmFtZSgpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1bmNhdGVzIGEgZmxvYXRpbmcgcG9pbnQgaW50byBhbiBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvYXQyaW50KGE6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChhID4gZW51bXMuQ29uc3RhbnRzLklOVF9NQVgpIHtcbiAgICByZXR1cm4gZW51bXMuQ29uc3RhbnRzLklOVF9NQVg7XG4gIH0gZWxzZSBpZiAoYSA8IGVudW1zLkNvbnN0YW50cy5JTlRfTUlOKSB7XG4gICAgcmV0dXJuIGVudW1zLkNvbnN0YW50cy5JTlRfTUlOO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhIHwgMDtcbiAgfVxufVxuXG52YXIgc3VwcG9ydHNBcnJheUJ1ZmZlcnMgPSB0eXBlb2YoQXJyYXlCdWZmZXIpICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGUgYXJyYXkgdG8gYSBidWZmZXIuICoqQ29waWVzLioqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlQXJyYXkyQnVmZmVyKGJ5dGVzOiBudW1iZXJbXSB8IEludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIgPSAwLCBsZW46IG51bWJlciA9IGJ5dGVzLmxlbmd0aCk6IE5vZGVCdWZmZXIge1xuICBpZiAoc3VwcG9ydHNBcnJheUJ1ZmZlcnMgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGJ5dGVzKSkge1xuICAgIGxldCBvZmZzZXQgPSAoPEludDhBcnJheT4gYnl0ZXMpLmJ5dGVPZmZzZXQ7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoPGFueT4gKDxJbnQ4QXJyYXk+IGJ5dGVzKS5idWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlcy5sZW5ndGgpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYnVmZiA9IG5ldyBCdWZmZXIobGVuKSwgaTogbnVtYmVyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYnVmZi53cml0ZUludDgoYnl0ZXNbb2Zmc2V0ICsgaV0sIGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZjtcbiAgfVxufVxuXG4vLyBDYWxsIHRoaXMgT05MWSBvbiB0aGUgcmVzdWx0IG9mIHR3byBub24tTmFOIG51bWJlcnMuXG5leHBvcnQgZnVuY3Rpb24gd3JhcEZsb2F0KGE6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChhID4gMy40MDI4MjM0NjYzODUyODg2MGUrMzgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGlmICgwIDwgYSAmJiBhIDwgMS40MDEyOTg0NjQzMjQ4MTcwN2UtNDUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoYSA8IC0zLjQwMjgyMzQ2NjM4NTI4ODYwZSszOCkge1xuICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gIH1cbiAgaWYgKDAgPiBhICYmIGEgPiAtMS40MDEyOTg0NjQzMjQ4MTcwN2UtNDUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy8gQ29udmVydCA6Y291bnQgY2hhcnMgc3RhcnRpbmcgZnJvbSA6b2Zmc2V0IGluIGEgSmF2YSBjaGFyYWN0ZXIgYXJyYXkgaW50byBhIEpTIHN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNoYXJzMmpzU3RyKGp2bUNhcnI6IEpWTVR5cGVzLkpWTUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyID0gMCwgY291bnQ6IG51bWJlciA9IGp2bUNhcnIuYXJyYXkubGVuZ3RoKTogc3RyaW5nIHtcbiAgdmFyIGkgOiBudW1iZXIsIGNhcnJBcnJheSA9IGp2bUNhcnIuYXJyYXksIHJ2ID0gXCJcIiwgZW5kT2Zmc2V0ID0gb2Zmc2V0ICsgY291bnQ7XG4gIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSsrKSB7XG4gICAgcnYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjYXJyQXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBydjtcbn1cblxuLy8gVE9ETzogSXMgdGhpcyB1c2VkIGFueXdoZXJlIHdoZXJlIHdlIGFyZSAqbm90KiBpbnNlcnRpbmcgdGhlIGJ5dGVzdHIgaW50b1xuLy8gYSBKVk1BcnJheSBvYmplY3Q/XG4vLyBUT0RPOiBDb3VsZCBpbmplY3QgdGhpcyBhcyBhIHN0YXRpYyBTdHJpbmcgbWV0aG9kLi4uXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXN0cjJBcnJheShieXRlU3RyOiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gIHZhciBydiA6IG51bWJlcltdID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZVN0ci5sZW5ndGg7IGkrKykge1xuICAgIHJ2LnB1c2goYnl0ZVN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gcnY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheTJieXRlc3RyKGJ5dGVBcnJheTogbnVtYmVyW10pOiBzdHJpbmcge1xuICAvLyBYWFg6IFdlJ2QgbGlrZSB0byB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlY29kZV9hcnJheS4uLilcbiAgLy8gIGJ1dCB0aGF0IGZhaWxzIG9uIFdlYmtpdCB3aXRoIGFycmF5cyBsb25nZXIgdGhhbiAyXjMxLiBTZWUgaXNzdWUgIzEyOSBmb3IgZGV0YWlscy5cbiAgdmFyIHJ2ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcnYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlQXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBydjtcbn1cblxuLyoqXG4gKiBCaXQgbWFza3MgZm9yIHRoZSBmbGFnIGJ5dGUuXG4gKi9cbmV4cG9ydCBlbnVtIEZsYWdNYXNrcyB7XG4gIFBVQkxJQyA9IDB4MSxcbiAgUFJJVkFURSA9IDB4MixcbiAgUFJPVEVDVEVEID0gMHg0LFxuICBTVEFUSUMgPSAweDgsXG4gIEZJTkFMID0gMHgxMCxcbiAgU1lOQ0hST05JWkVEID0gMHgyMCxcbiAgU1VQRVIgPSAweDIwLFxuICBWT0xBVElMRSA9IDB4NDAsXG4gIFRSQU5TSUVOVCA9IDB4ODAsXG4gIFZBUkFSR1MgPSAweDgwLFxuICBOQVRJVkUgPSAweDEwMCxcbiAgSU5URVJGQUNFID0gMHgyMDAsXG4gIEFCU1RSQUNUID0gMHg0MDAsXG4gIFNUUklDVCA9IDB4ODAwXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhICdmbGFnIGJ5dGUnLiBTZWUg77+9NCBvZiB0aGUgSlZNIHNwZWMuXG4gKiBAdG9kbyBTZXBhcmF0ZSBNRVRIT0QgZmxhZ3MgYW5kIENMQVNTIGZsYWdzLlxuICovXG5leHBvcnQgY2xhc3MgRmxhZ3Mge1xuICBwcml2YXRlIGJ5dGU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IoYnl0ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5ieXRlID0gYnl0ZTtcbiAgfVxuXG4gIHB1YmxpYyBpc1B1YmxpYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuYnl0ZSAmIEZsYWdNYXNrcy5QVUJMSUMpID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBpc1ByaXZhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLmJ5dGUgJiBGbGFnTWFza3MuUFJJVkFURSkgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzUHJvdGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLlBST1RFQ1RFRCkgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzU3RhdGljKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLlNUQVRJQykgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzRmluYWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLmJ5dGUgJiBGbGFnTWFza3MuRklOQUwpID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBpc1N5bmNocm9uaXplZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuYnl0ZSAmIEZsYWdNYXNrcy5TWU5DSFJPTklaRUQpID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBpc1N1cGVyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLlNVUEVSKSA+IDA7XG4gIH1cblxuICBwdWJsaWMgaXNWb2xhdGlsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuYnl0ZSAmIEZsYWdNYXNrcy5WT0xBVElMRSkgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzVHJhbnNpZW50KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLlRSQU5TSUVOVCkgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzTmF0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLk5BVElWRSkgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzSW50ZXJmYWNlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLklOVEVSRkFDRSkgPiAwO1xuICB9XG5cbiAgcHVibGljIGlzQWJzdHJhY3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLmJ5dGUgJiBGbGFnTWFza3MuQUJTVFJBQ1QpID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBpc1N0cmljdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuYnl0ZSAmIEZsYWdNYXNrcy5TVFJJQ1QpID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIGEgZnVuY3Rpb24gdG8gbmF0aXZlLiBVc2VkIGZvciB0cmFwcGVkIG1ldGhvZHMuXG4gICAqL1xuICBwdWJsaWMgc2V0TmF0aXZlKG46IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAobikge1xuICAgICAgdGhpcy5ieXRlID0gdGhpcy5ieXRlIHwgRmxhZ01hc2tzLk5BVElWRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ieXRlID0gdGhpcy5ieXRlICYgKH5GbGFnTWFza3MuTkFUSVZFKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaXNWYXJBcmdzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5ieXRlICYgRmxhZ01hc2tzLlZBUkFSR1MpID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSYXdCeXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbFZhbHVlKHR5cGVfc3RyOiBzdHJpbmcpOiBhbnkge1xuICBpZiAodHlwZV9zdHIgPT09ICdKJykgcmV0dXJuIGdMb25nLlpFUk87XG4gIHZhciBjID0gdHlwZV9zdHJbMF07XG4gIGlmIChjID09PSAnWycgfHwgYyA9PT0gJ0wnKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogSmF2YSBjbGFzc2VzIGFyZSByZXByZXNlbnRlZCBpbnRlcm5hbGx5IHVzaW5nIHNsYXNoZXMgYXMgZGVsaW1pdGVycy5cbiAqIFRoZXNlIGhlbHBlciBmdW5jdGlvbnMgY29udmVydCBiZXR3ZWVuIHRoZSB0d28gcmVwcmVzZW50YXRpb25zLlxuICogTGphdmEvbGFuZy9DbGFzczsgPT4gamF2YS5sYW5nLkNsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRfY2xhc3NuYW1lKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IydHlwZXN0cihzdHIpLnJlcGxhY2UoL1xcLy9nLCAnLicpO1xufVxuXG4vKipcbiAqIGphdmEubGFuZy5DbGFzcyA9PiBMamF2YS9sYW5nL0NsYXNzO1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW50X2NsYXNzbmFtZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB0eXBlc3RyMmRlc2NyaXB0b3Ioc3RyLnJlcGxhY2UoL1xcLi9nLCAnLycpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeV9pbnRfY2xhc3NuYW1lKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHZhciBhcnJheV9uZXN0aW5nID0gc3RyLm1hdGNoKC9eXFxbKi8pWzBdLmxlbmd0aDtcbiAgaWYgKGFycmF5X25lc3RpbmcgPiAyNTUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmF5X25lc3RpbmcgPiAwKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKGFycmF5X25lc3RpbmcpO1xuICB9XG4gIGlmIChzdHJbMF0gPT09ICdMJykge1xuICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdICE9PSAnOycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RyID0gc3RyLnNsaWNlKDEsIC0xKTtcbiAgfVxuICBpZiAoc3RyIGluIGludGVybmFsMmV4dGVybmFsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHN0ci5tYXRjaCgvXFwvezIsfS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnRzW2ldLm1hdGNoKC9bXiRfYS16MC05XS9pKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHZhciBpbnRlcm5hbDJleHRlcm5hbDogeyBbaW50ZXJuYWxUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgQjogJ2J5dGUnLFxuICBDOiAnY2hhcicsXG4gIEQ6ICdkb3VibGUnLFxuICBGOiAnZmxvYXQnLFxuICBJOiAnaW50JyxcbiAgSjogJ2xvbmcnLFxuICBTOiAnc2hvcnQnLFxuICBWOiAndm9pZCcsXG4gIFo6ICdib29sZWFuJ1xufTtcblxuZXhwb3J0IHZhciBleHRlcm5hbDJpbnRlcm5hbDogeyBbZXh0ZXJuYWxUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuZm9yICh2YXIgayBpbiBpbnRlcm5hbDJleHRlcm5hbCkge1xuICBleHRlcm5hbDJpbnRlcm5hbFtpbnRlcm5hbDJleHRlcm5hbFtrXV0gPSBrO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbWV0aG9kIGRlc2NyaXB0b3IsIHJldHVybnMgdGhlIHR5cGVzdHJpbmdzIGZvciB0aGUgcmV0dXJuIHR5cGVcbiAqIGFuZCB0aGUgcGFyYW1ldGVycy5cbiAqXG4gKiBlLmcuIChMamF2YS9sYW5nL0NsYXNzO1opTGphdmEvbGFuZy9TdHJpbmc7ID0+XG4gKiAgICAgICAgW1wiTGphdmEvbGFuZy9DbGFzcztcIiwgXCJaXCIsIFwiTGphdmEvbGFuZy9TdHJpbmc7XCJdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlcyhtZXRob2REZXNjcmlwdG9yOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIHZhciBpID0gMCwgdHlwZXM6IHN0cmluZ1tdID0gW10sIGVuZElkeDogbnVtYmVyO1xuICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kRGVzY3JpcHRvci5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAobWV0aG9kRGVzY3JpcHRvci5jaGFyQXQoaSkpIHtcbiAgICAgIGNhc2UgJygnOlxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIC8vU2tpcC5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgLy8gUmVmZXJlbmNlIHR5cGUuXG4gICAgICAgIGVuZElkeCA9IG1ldGhvZERlc2NyaXB0b3IuaW5kZXhPZignOycsIGkpO1xuICAgICAgICB0eXBlcy5wdXNoKG1ldGhvZERlc2NyaXB0b3Iuc2xpY2UoaSwgZW5kSWR4ICsgMSkpO1xuICAgICAgICBpID0gZW5kSWR4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICBlbmRJZHggPSBpICsgMTtcbiAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgd2hpbGUgKG1ldGhvZERlc2NyaXB0b3IuY2hhckF0KGVuZElkeCkgPT09ICdbJykge1xuICAgICAgICAgIGVuZElkeCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2REZXNjcmlwdG9yLmNoYXJBdChlbmRJZHgpID09PSAnTCcpIHtcbiAgICAgICAgICAvLyBSZWZlcmVuY2UgY29tcG9uZW50LiBSZWFkIGFoZWFkIHRvIGVuZC5cbiAgICAgICAgICBlbmRJZHggPSBtZXRob2REZXNjcmlwdG9yLmluZGV4T2YoJzsnLCBlbmRJZHgpO1xuICAgICAgICAgIHR5cGVzLnB1c2gobWV0aG9kRGVzY3JpcHRvci5zbGljZShpLCBlbmRJZHggKyAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUHJpbWl0aXZlIGNvbXBvbmVudC5cbiAgICAgICAgICB0eXBlcy5wdXNoKG1ldGhvZERlc2NyaXB0b3Iuc2xpY2UoaSwgZW5kSWR4ICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBlbmRJZHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gUHJpbWl0aXZlIHR5cGUuXG4gICAgICAgIHR5cGVzLnB1c2gobWV0aG9kRGVzY3JpcHRvci5jaGFyQXQoaSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHR5cGVzO1xufVxuXG4vLyBHZXQgdGhlIGNvbXBvbmVudCB0eXBlIG9mIGFuIGFycmF5IHR5cGUgc3RyaW5nLlxuLy8gQ3V0IG9mZiB0aGUgW0wgYW5kIDsgZm9yIGFycmF5cyBvZiBjbGFzc2VzLlxuZXhwb3J0IGZ1bmN0aW9uIGdldF9jb21wb25lbnRfdHlwZSh0eXBlX3N0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVfc3RyLnNsaWNlKDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNfYXJyYXlfdHlwZSh0eXBlX3N0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlX3N0clswXSA9PT0gJ1snO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJpbWl0aXZlX3R5cGUodHlwZV9zdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZV9zdHIgaW4gaW50ZXJuYWwyZXh0ZXJuYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc19yZWZlcmVuY2VfdHlwZSh0eXBlX3N0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlX3N0clswXSA9PT0gJ0wnO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHR5cGUgZGVzY3JpcHRvcnMgaW50byBzdGFuZGFyZGl6ZWQgaW50ZXJuYWwgdHlwZSBzdHJpbmdzLlxuICogTGphdmEvbGFuZy9DbGFzczsgPT4gamF2YS9sYW5nL0NsYXNzICAgUmVmZXJlbmNlIHR5cGVzXG4gKiBbTGphdmEvbGFuZy9DbGFzczsgaXMgdW5jaGFuZ2VkICAgICAgICBBcnJheSB0eXBlc1xuICogQyA9PiBjaGFyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpbWl0aXZlIHR5cGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmlwdG9yMnR5cGVzdHIodHlwZV9zdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHZhciBjID0gdHlwZV9zdHJbMF07XG4gIGlmIChjIGluIGludGVybmFsMmV4dGVybmFsKSByZXR1cm4gaW50ZXJuYWwyZXh0ZXJuYWxbY107XG4gIGlmIChjID09PSAnTCcpIHJldHVybiB0eXBlX3N0ci5zbGljZSgxLCAtMSk7XG4gIGlmIChjID09PSAnWycpIHJldHVybiB0eXBlX3N0cjtcbiAgLy8gbm8gbWF0Y2hcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHR5cGUgc3RyaW5nOiBcIiArIHR5cGVfc3RyKTtcbn1cblxuLy8gVGFrZXMgYSBjaGFyYWN0ZXIgYXJyYXkgb2YgY29uY2F0ZW5hdGVkIHR5cGUgZGVzY3JpcHRvcnMgYW5kIHJldHVybnMvcmVtb3ZlcyB0aGUgZmlyc3Qgb25lLlxuZXhwb3J0IGZ1bmN0aW9uIGNhcnIyZGVzY3JpcHRvcihjYXJyOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIHZhciBjID0gY2Fyci5zaGlmdCgpO1xuICBpZiAoYyA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKGludGVybmFsMmV4dGVybmFsW2NdICE9PSB2b2lkIDApIHJldHVybiBjO1xuICBpZiAoYyA9PT0gJ0wnKSB7XG4gICAgdmFyIHJ2ID0gJ0wnO1xuICAgIHdoaWxlICgoYyA9IGNhcnIuc2hpZnQoKSkgIT09ICc7Jykge1xuICAgICAgcnYgKz0gYztcbiAgICB9XG4gICAgcmV0dXJuIHJ2ICsgJzsnO1xuICB9XG4gIGlmIChjID09PSAnWycpIHJldHVybiBcIltcIiArIGNhcnIyZGVzY3JpcHRvcihjYXJyKTtcbiAgLy8gbm8gbWF0Y2hcbiAgY2Fyci51bnNoaWZ0KGMpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZGVzY3JpcHRvcjogXCIgKyBjYXJyLmpvaW4oJycpKTtcbn1cblxuLy8gQ29udmVydHMgaW50ZXJuYWwgdHlwZSBzdHJpbmdzIGludG8gdHlwZSBkZXNjcmlwdG9ycy4gUmV2ZXJzZSBvZiBkZXNjcmlwdG9yMnR5cGVzdHIuXG5leHBvcnQgZnVuY3Rpb24gdHlwZXN0cjJkZXNjcmlwdG9yKHR5cGVfc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoZXh0ZXJuYWwyaW50ZXJuYWxbdHlwZV9zdHJdICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZXh0ZXJuYWwyaW50ZXJuYWxbdHlwZV9zdHJdO1xuICB9IGVsc2UgaWYgKHR5cGVfc3RyWzBdID09PSAnWycpIHtcbiAgICByZXR1cm4gdHlwZV9zdHI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiTFwiICsgdHlwZV9zdHIgKyBcIjtcIjtcbiAgfVxufVxuXG4vKipcbiAqIEphdmEncyByZWZsZWN0aW9uIEFQSXMgbmVlZCB0byB1bmJveCBwcmltaXRpdmUgYXJndW1lbnRzIHRvIGZ1bmN0aW9uIGNhbGxzLFxuICogYXMgdGhleSBhcmUgYm94ZWQgaW4gYW4gT2JqZWN0IGFycmF5LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gY29udmVydHNcbiAqIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBmb3JtIHByaW9yIHRvIGZ1bmN0aW9uIGludm9jYXRpb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBpbmNsdWRlcyBwYWRkaW5nIGNhdGVnb3J5IDIgcHJpbWl0aXZlcywgd2hpY2ggY29uc3VtZSB0d29cbiAqIHNsb3RzIGluIHRoZSBhcnJheSAoZG91Ymxlcy9sb25ncykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmJveEFyZ3VtZW50cyh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHBhcmFtVHlwZXM6IHN0cmluZ1tdLCBhcmdzOiBKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0W10pOiBhbnlbXSB7XG4gIHZhciBydjogYW55W10gPSBbXSwgaTogbnVtYmVyLCB0eXBlOiBzdHJpbmcsIGFyZzogSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdDtcbiAgZm9yIChpID0gMDsgaSA8IHBhcmFtVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0eXBlID0gcGFyYW1UeXBlc1tpXTtcbiAgICBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChpc19wcmltaXRpdmVfdHlwZSh0eXBlKSkge1xuICAgICAgLy8gVW5ib3ggdGhlIHByaW1pdGl2ZSB0eXBlLlxuICAgICAgLy8gVE9ETzogUHJlY2lzZWx5IHR5cGUgdGhpcyBiZXR0ZXIuIE9uY2UgVHlwZVNjcmlwdCBsZXRzIHlvdSBpbXBvcnRcbiAgICAgIC8vIHVuaW9uIHR5cGVzLCB3ZSBjYW4gZGVmaW5lIGEgXCJKVk1QcmltaXRpdmVcIiB0eXBlLi4uXG4gICAgICBydi5wdXNoKCg8SlZNVHlwZXMuamF2YV9sYW5nX0ludGVnZXI+IGFyZykudW5ib3goKSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ0onIHx8IHR5cGUgPT09ICdEJykge1xuICAgICAgICAvLyA2NC1iaXQgcHJpbWl0aXZlcyB0YWtlIHVwIHR3byBhcmd1bWVudCBzbG90cy4gRG9wcGlvIHVzZXMgYSBOVUxMIGZvciB0aGUgc2Vjb25kIHNsb3QuXG4gICAgICAgIHJ2LnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZmVyZW5jZSB0eXBlOyBkbyBub3QgY2hhbmdlLlxuICAgICAgcnYucHVzaChhcmcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnY7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBtZXRob2QgZGVzY3JpcHRvciBhcyBhIEpTIHN0cmluZywgcmV0dXJucyBhIGNvcnJlc3BvbmRpbmcgTWV0aG9kVHlwZVxuICogb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWV0aG9kVHlwZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgZGVzY3JpcHRvcjogc3RyaW5nLCBjYjogKGU6IEpWTVR5cGVzLmphdmFfbGFuZ19UaHJvd2FibGUsIHR5cGU6IEpWTVR5cGVzLmphdmFfbGFuZ19pbnZva2VfTWV0aG9kVHlwZSkgPT4gdm9pZCkge1xuICBjbC5pbml0aWFsaXplQ2xhc3ModGhyZWFkLCAnTGphdmEvbGFuZy9pbnZva2UvTWV0aG9kSGFuZGxlTmF0aXZlczsnLCAoY2RhdGE6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RIYW5kbGVOYXRpdmVzPikgPT4ge1xuICAgIGlmIChjZGF0YSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGpzQ29ucyA9IDx0eXBlb2YgSlZNVHlwZXMuamF2YV9sYW5nX2ludm9rZV9NZXRob2RIYW5kbGVOYXRpdmVzPiBjZGF0YS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpLCBjbGFzc2VzID0gZ2V0VHlwZXMoZGVzY3JpcHRvcik7XG4gICAgICBjbGFzc2VzLnB1c2goJ1tMamF2YS9sYW5nL0NsYXNzOycpO1xuICAgICAgLy8gTmVlZCB0aGUgcmV0dXJuIHR5cGUgYW5kIHBhcmFtZXRlciB0eXBlcy5cbiAgICAgIGNsLnJlc29sdmVDbGFzc2VzKHRocmVhZCwgY2xhc3NlcywgKGNsYXNzTWFwOiB7IFtuYW1lOiBzdHJpbmddOiBDbGFzc0RhdGEuQ2xhc3NEYXRhIH0pID0+IHtcbiAgICAgICAgdmFyIHR5cGVzID0gY2xhc3Nlcy5tYXAoKGNsczogc3RyaW5nKSA9PiBjbGFzc01hcFtjbHNdLmdldENsYXNzT2JqZWN0KHRocmVhZCkpO1xuICAgICAgICB0eXBlcy5wb3AoKTsgLy8gRGlzY2FyZCAnW0xqYXZhL2xhbmcvQ2xhc3M7J1xuICAgICAgICB2YXIgcnR5cGUgPSB0eXBlcy5wb3AoKSwgLy8gUmV0dXJuIHR5cGUuXG4gICAgICAgICAgY2xzQXJyQ29ucyA9ICg8Q2xhc3NEYXRhLkFycmF5Q2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzcz4+IGNsYXNzTWFwWydbTGphdmEvbGFuZy9DbGFzczsnXSkuZ2V0Q29uc3RydWN0b3IodGhyZWFkKSxcbiAgICAgICAgICBwdHlwZXMgPSBuZXcgY2xzQXJyQ29ucyh0aHJlYWQsIHR5cGVzLmxlbmd0aCk7XG4gICAgICAgIHB0eXBlcy5hcnJheSA9IHR5cGVzO1xuXG4gICAgICAgIGpzQ29uc1snamF2YS9sYW5nL2ludm9rZS9NZXRob2RIYW5kbGVOYXRpdmVzL2ZpbmRNZXRob2RIYW5kbGVUeXBlKExqYXZhL2xhbmcvQ2xhc3M7W0xqYXZhL2xhbmcvQ2xhc3M7KUxqYXZhL2xhbmcvaW52b2tlL01ldGhvZFR5cGU7J10odGhyZWFkLCBbcnR5cGUsIHB0eXBlc10sIGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBtZXRob2QgZGVzY3JpcHRvciwgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHdvcmRzIHJlcXVpcmVkIHRvIHN0b3JlXG4gKiBpdHMgYXJndW1lbnRzLlxuICogRG9lcyBub3QgaW5jbHVkZSBjb25zaWRlcmF0aW9ucyBmb3IgZS5nLiB0aGUgJ3RoaXMnIGFyZ3VtZW50LCBzaW5jZSB0aGVcbiAqIGRlc2NyaXB0b3IgZG9lcyBub3Qgc3BlY2lmeSBpZiB0aGUgbWV0aG9kIGlzIHN0YXRpYyBvciBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRob2REZXNjcmlwdG9yV29yZFNpemUoZGVzY3JpcHRvcjogc3RyaW5nKTogbnVtYmVyIHtcbiAgdmFyIHBhcnNlZERlc2NyaXB0b3IgPSBnZXRUeXBlcyhkZXNjcmlwdG9yKSxcbiAgICB3b3JkcyA9IHBhcnNlZERlc2NyaXB0b3IubGVuZ3RoIC0gMSwgaTogbnVtYmVyLCBwOiBzdHJpbmc7XG4gIC8vIFJlbW92ZSByZXR1cm4gdHlwZS5cbiAgcGFyc2VkRGVzY3JpcHRvci5wb3AoKTtcblxuICAvLyBEb3VibGUgY291bnQgZG91YmxlcyAvIGxvbmdzLlxuICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkRGVzY3JpcHRvci5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBwYXJzZWREZXNjcmlwdG9yW2ldO1xuICAgIGlmIChwID09PSAnRCcgfHwgcCA9PT0gJ0onKSB7XG4gICAgICB3b3JkcysrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3Jkcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHJldHVybiB0eXBlIGFzIGEgQ2xhc3Mgb2JqZWN0LCBhbmQgYW4gYXJyYXkgb2YgY2xhc3Mgb2JqZWN0cyBmb3JcbiAqIHBhcmFtZXRlciB0eXBlcywgcmV0dXJucyB0aGUgZGVzY3JpcHRvciBzdHJpbmcgZm9yIHRoZSBtZXRob2QgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlc2NyaXB0b3JTdHJpbmcocnR5cGU6IEpWTVR5cGVzLmphdmFfbGFuZ19DbGFzcywgcHR5cGVzPzogSlZNVHlwZXMuSlZNQXJyYXk8SlZNVHlwZXMuamF2YV9sYW5nX0NsYXNzPik6IHN0cmluZyB7XG4gIHZhciBydiA9IFwiKFwiO1xuICBpZiAocHR5cGVzICE9PSB1bmRlZmluZWQgJiYgcHR5cGVzICE9PSBudWxsKSB7XG4gICAgcHR5cGVzLmFycmF5LmZvckVhY2goKHB0eXBlOiBKVk1UeXBlcy5qYXZhX2xhbmdfQ2xhc3MpID0+IHtcbiAgICAgIHJ2ICs9IHB0eXBlLiRjbHMuZ2V0SW50ZXJuYWxOYW1lKCk7XG4gICAgfSk7XG4gIH1cbiAgcnYgKz0gXCIpXCIgKyBydHlwZS4kY2xzLmdldEludGVybmFsTmFtZSgpO1xuICByZXR1cm4gcnY7XG59XG5cblxuLyoqXG4gKiBIYXZlIGEgSmF2YUNsYXNzTG9hZGVyT2JqZWN0IGFuZCBuZWVkIGl0cyBDbGFzc0xvYWRlciBvYmplY3Q/IFVzZSB0aGlzIG1ldGhvZCFcbiAqIEB0b2RvIEluc3RhbGwgb24gSmF2YSBDbGFzc0xvYWRlciBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9hZGVyKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgamNsbzogSlZNVHlwZXMuamF2YV9sYW5nX0NsYXNzTG9hZGVyKTogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIge1xuICBpZiAoKGpjbG8gIT0gbnVsbCkgJiYgKGpjbG8uJGxvYWRlciAhPSBudWxsKSkge1xuICAgIHJldHVybiBqY2xvLiRsb2FkZXI7XG4gIH1cbiAgcmV0dXJuIHRocmVhZC5nZXRCc0NsKCk7XG59XG5cbi8qKlxuICogXCJGYXN0XCIgYXJyYXkgY29weTsgZG9lcyBub3QgaGF2ZSB0byBjaGVjayBldmVyeSBlbGVtZW50IGZvciBpbGxlZ2FsXG4gKiBhc3NpZ25tZW50cy4gWW91IGNhbiBkbyB0cmlja3MgaGVyZSAoaWYgcG9zc2libGUpIHRvIGNvcHkgY2h1bmtzIG9mIHRoZSBhcnJheVxuICogYXQgYSB0aW1lIHJhdGhlciB0aGFuIGVsZW1lbnQtYnktZWxlbWVudC5cbiAqIFRoaXMgZnVuY3Rpb24gKmNhbm5vdCogYWNjZXNzIGFueSBhdHRyaWJ1dGUgb3RoZXIgdGhhbiAnYXJyYXknIG9uIHNyYyBkdWUgdG9cbiAqIHRoZSBzcGVjaWFsIGNhc2Ugd2hlbiBzcmMgPT0gZGVzdCAoc2VlIGNvZGUgZm9yIFN5c3RlbS5hcnJheWNvcHkgYmVsb3cpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXljb3B5Tm9DaGVjayhzcmM6IEpWTVR5cGVzLkpWTUFycmF5PGFueT4sIHNyY1BvczogbnVtYmVyLCBkZXN0OiBKVk1UeXBlcy5KVk1BcnJheTxhbnk+LCBkZXN0UG9zOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKTogdm9pZCB7XG4gIHZhciBqID0gZGVzdFBvcztcbiAgdmFyIGVuZCA9IHNyY1BvcyArIGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IHNyY1BvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgZGVzdC5hcnJheVtqKytdID0gc3JjLmFycmF5W2ldO1xuICB9XG59XG5cbi8qKlxuICogXCJTbG93XCIgYXJyYXkgY29weTsgaGFzIHRvIGNoZWNrIGV2ZXJ5IGVsZW1lbnQgZm9yIGlsbGVnYWwgYXNzaWdubWVudHMuXG4gKiBZb3UgY2Fubm90IGRvIGFueSB0cmlja3MgaGVyZTsgeW91IG11c3QgY29weSBlbGVtZW50IGJ5IGVsZW1lbnQgdW50aWwgeW91XG4gKiBoYXZlIGVpdGhlciBjb3BpZWQgZXZlcnl0aGluZywgb3IgZW5jb3VudGVyZWQgYW4gZWxlbWVudCB0aGF0IGNhbm5vdCBiZVxuICogYXNzaWduZWQgKHdoaWNoIGNhdXNlcyBhbiBleGNlcHRpb24pLlxuICogR3VhcmFudGVlczogc3JjIGFuZCBkZXN0IGFyZSB0d28gZGlmZmVyZW50IHJlZmVyZW5jZSB0eXBlcy4gVGhleSBjYW5ub3QgYmVcbiAqICAgICAgICAgICAgIHByaW1pdGl2ZSBhcnJheXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWNvcHlDaGVjayh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHNyYzogSlZNVHlwZXMuSlZNQXJyYXk8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIHNyY1BvczogbnVtYmVyLCBkZXN0OiBKVk1UeXBlcy5KVk1BcnJheTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0PiwgZGVzdFBvczogbnVtYmVyLCBsZW5ndGg6IG51bWJlcik6IHZvaWQge1xuICB2YXIgaiA9IGRlc3RQb3M7XG4gIHZhciBlbmQgPSBzcmNQb3MgKyBsZW5ndGg7XG4gIHZhciBkZXN0Q29tcENscyA9IGRlc3QuZ2V0Q2xhc3MoKS5nZXRDb21wb25lbnRDbGFzcygpO1xuICBmb3IgKHZhciBpID0gc3JjUG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICAvLyBDaGVjayBpZiBudWxsIG9yIGNhc3RhYmxlLlxuICAgIGlmIChzcmMuYXJyYXlbaV0gPT09IG51bGwgfHwgc3JjLmFycmF5W2ldLmdldENsYXNzKCkuaXNDYXN0YWJsZShkZXN0Q29tcENscykpIHtcbiAgICAgIGRlc3QuYXJyYXlbal0gPSBzcmMuYXJyYXlbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocmVhZC50aHJvd05ld0V4Y2VwdGlvbignTGphdmEvbGFuZy9BcnJheVN0b3JlRXhjZXB0aW9uOycsICdBcnJheSBlbGVtZW50IGluIHNyYyBjYW5ub3QgYmUgY2FzdCB0byBkZXN0IGFycmF5IHR5cGUuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGorKztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN0cmluZyhjbDogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIHN0cjogc3RyaW5nKTogSlZNVHlwZXMuamF2YV9sYW5nX1N0cmluZyB7XG4gIHZhciBjYXJyID0gaW5pdENhcnIoY2wsIHN0cik7XG4gIHZhciBzdHJDb25zID0gKDxDbGFzc0RhdGEuUmVmZXJlbmNlQ2xhc3NEYXRhPEpWTVR5cGVzLmphdmFfbGFuZ19TdHJpbmc+PiBjbC5nZXRSZXNvbHZlZENsYXNzKCdMamF2YS9sYW5nL1N0cmluZzsnKSkuZ2V0Q29uc3RydWN0b3IobnVsbCk7XG4gIHZhciBzdHJPYmogPSBuZXcgc3RyQ29ucyhudWxsKTtcbiAgc3RyT2JqWydqYXZhL2xhbmcvU3RyaW5nL3ZhbHVlJ10gPSBjYXJyO1xuICByZXR1cm4gc3RyT2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdENhcnIoY2w6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyLCBzdHI6IHN0cmluZyk6IEpWTVR5cGVzLkpWTUFycmF5PG51bWJlcj4ge1xuICB2YXIgYXJyQ2xzQ29ucyA9ICg8Q2xhc3NEYXRhLkFycmF5Q2xhc3NEYXRhPG51bWJlcj4+IGNsLmdldEluaXRpYWxpemVkQ2xhc3MobnVsbCwgJ1tDJykpLmdldENvbnN0cnVjdG9yKG51bGwpLFxuICAgIGNhcnIgPSBuZXcgYXJyQ2xzQ29ucyhudWxsLCBzdHIubGVuZ3RoKSxcbiAgICBjYXJyQXJyYXkgPSBjYXJyLmFycmF5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FyckFycmF5W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gY2Fycjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5RnJvbUNsYXNzPFQ+KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2xheno6IENsYXNzRGF0YS5BcnJheUNsYXNzRGF0YTxUPiwgbGVuZ3RoOiBudW1iZXIpOiBKVk1UeXBlcy5KVk1BcnJheTxUPiB7XG4gIHJldHVybiBuZXcgKGNsYXp6LmdldENvbnN0cnVjdG9yKHRocmVhZCkpKHRocmVhZCwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0FycmF5PFQ+KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2w6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyLCBkZXNjOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyKTogSlZNVHlwZXMuSlZNQXJyYXk8VD4ge1xuICB2YXIgY2xzID0gPENsYXNzRGF0YS5BcnJheUNsYXNzRGF0YTxUPj4gY2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsIGRlc2MpO1xuICByZXR1cm4gbmV3QXJyYXlGcm9tQ2xhc3ModGhyZWFkLCBjbHMsIGxlbmd0aCk7XG59XG5cbi8qKlxuICogU2VwYXJhdGUgZnJvbSBuZXdBcnJheSB0byBhdm9pZCBwcm9ncmFtbWluZyBtaXN0YWtlcyB3aGVyZSBuZXdBcnJheSBhbmQgbmV3QXJyYXlGcm9tRGF0YSBhcmUgY29uZmxhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlOZXdBcnJheTxUPih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsOiBDbGFzc0xvYWRlci5DbGFzc0xvYWRlciwgZGVzYzogc3RyaW5nLCBsZW5ndGhzOiBudW1iZXJbXSk6IEpWTVR5cGVzLkpWTUFycmF5PFQ+IHtcbiAgdmFyIGNscyA9IDxDbGFzc0RhdGEuQXJyYXlDbGFzc0RhdGE8VD4+IGNsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCBkZXNjKTtcbiAgcmV0dXJuIG5ldyAoY2xzLmdldENvbnN0cnVjdG9yKHRocmVhZCkpKHRocmVhZCwgbGVuZ3Rocyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdPYmplY3RGcm9tQ2xhc3M8VCBleHRlbmRzIEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2xheno6IENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8VD4pIHtcbiAgcmV0dXJuIG5ldyAoY2xhenouZ2V0Q29uc3RydWN0b3IodGhyZWFkKSkodGhyZWFkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld09iamVjdDxUIGV4dGVuZHMgSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4odGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjbDogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIGRlc2M6IHN0cmluZyk6IFQge1xuICB2YXIgY2xzID0gPENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8VD4+IGNsLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCBkZXNjKTtcbiAgcmV0dXJuIG5ld09iamVjdEZyb21DbGFzcyh0aHJlYWQsIGNscyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWNGaWVsZHM8VD4odGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkLCBjbDogQ2xhc3NMb2FkZXIuQ2xhc3NMb2FkZXIsIGRlc2M6IHN0cmluZyk6IFQge1xuICByZXR1cm4gPFQ+IDxhbnk+ICg8Q2xhc3NEYXRhLlJlZmVyZW5jZUNsYXNzRGF0YTxKVk1UeXBlcy5qYXZhX2xhbmdfT2JqZWN0Pj4gY2wuZ2V0SW5pdGlhbGl6ZWRDbGFzcyh0aHJlYWQsIGRlc2MpKS5nZXRDb25zdHJ1Y3Rvcih0aHJlYWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3QXJyYXlGcm9tRGF0YVdpdGhDbGFzczxUPih0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIGNsczogQ2xhc3NEYXRhLkFycmF5Q2xhc3NEYXRhPFQ+LCBkYXRhOiBUW10pOiBKVk1UeXBlcy5KVk1BcnJheTxUPiB7XG4gIHZhciBhcnIgPSBuZXdBcnJheUZyb21DbGFzczxUPih0aHJlYWQsIGNscywgMCk7XG4gIGFyci5hcnJheSA9IGRhdGE7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdBcnJheUZyb21EYXRhPFQ+KHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgY2w6IENsYXNzTG9hZGVyLkNsYXNzTG9hZGVyLCBkZXNjOiBzdHJpbmcsIGRhdGE6IFRbXSk6IEpWTVR5cGVzLkpWTUFycmF5PFQ+IHtcbiAgdmFyIGFyciA9IG5ld0FycmF5PFQ+KHRocmVhZCwgY2wsIGRlc2MsIDApO1xuICBhcnIuYXJyYXkgPSBkYXRhO1xuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJveGVkIGNsYXNzIG5hbWUgb2YgdGhlIGdpdmVuIHByaW1pdGl2ZSB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYm94Q2xhc3NOYW1lKHByaW1UeXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHByaW1UeXBlKSB7XG4gICAgY2FzZSAnQic6XG4gICAgICByZXR1cm4gJ0xqYXZhL2xhbmcvQnl0ZTsnO1xuICAgIGNhc2UgJ0MnOlxuICAgICAgcmV0dXJuICdMamF2YS9sYW5nL0NoYXJhY3RlcjsnO1xuICAgIGNhc2UgJ0QnOlxuICAgICAgcmV0dXJuICdMamF2YS9sYW5nL0RvdWJsZTsnO1xuICAgIGNhc2UgJ0YnOlxuICAgICAgcmV0dXJuICdMamF2YS9sYW5nL0Zsb2F0Oyc7XG4gICAgY2FzZSAnSSc6XG4gICAgICByZXR1cm4gJ0xqYXZhL2xhbmcvSW50ZWdlcjsnO1xuICAgIGNhc2UgJ0onOlxuICAgICAgcmV0dXJuICdMamF2YS9sYW5nL0xvbmc7JztcbiAgICBjYXNlICdTJzpcbiAgICAgIHJldHVybiAnTGphdmEvbGFuZy9TaG9ydDsnO1xuICAgIGNhc2UgJ1onOlxuICAgICAgcmV0dXJuICdMamF2YS9sYW5nL0Jvb2xlYW47JztcbiAgICBjYXNlICdWJzpcbiAgICAgIHJldHVybiAnTGphdmEvbGFuZy9Wb2lkOyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gYm94IGEgbm9uLXByaW1pdGl2ZSBjbGFzczogJHt0aGlzLmNsYXNzTmFtZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEJveGVzIHRoZSBnaXZlbiBwcmltaXRpdmUgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3hQcmltaXRpdmVWYWx1ZSh0aHJlYWQ6IHRocmVhZGluZy5KVk1UaHJlYWQsIHR5cGU6IHN0cmluZywgdmFsOiBhbnkpOiBKVk1UeXBlcy5qYXZhX2xhbmdfSW50ZWdlciB7XG4gIC8vIFhYWDogV2UgYXNzdW1lIEludGVnZXIgZm9yIHR5cGluZyBwdXJwb3NlcyBvbmx5OyBhdm9pZHMgYSBodWdlIHVuaW9uIHR5cGUuXG4gIHZhciBwcmltQ2xzID0gPENsYXNzRGF0YS5SZWZlcmVuY2VDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX0ludGVnZXI+PiB0aHJlYWQuZ2V0QnNDbCgpLmdldEluaXRpYWxpemVkQ2xhc3ModGhyZWFkLCBib3hDbGFzc05hbWUodHlwZSkpLFxuICAgcHJpbUNsc0NvbnMgPSA8dHlwZW9mIEpWTVR5cGVzLmphdmFfbGFuZ19JbnRlZ2VyPiBwcmltQ2xzLmdldENvbnN0cnVjdG9yKHRocmVhZCk7XG4gIHJldHVybiBwcmltQ2xzQ29ucy5ib3godmFsKTtcbn1cblxuLyoqXG4gKiBCb3hlcyB0aGUgZ2l2ZW4gYXJndW1lbnRzIGludG8gYW4gT2JqZWN0W10uXG4gKlxuICogQHBhcmFtIGRlc2NyaXB0b3IgVGhlIGRlc2NyaXB0b3IgYXQgdGhlICpjYWxsIHNpdGUqLlxuICogQHBhcmFtIGRhdGEgVGhlIGFjdHVhbCBhcmd1bWVudHMgZm9yIHRoaXMgZnVuY3Rpb24gY2FsbC5cbiAqIEBwYXJhbSBpc1N0YXRpYyBJZiBmYWxzZSwgZGlzcmVnYXJkIHRoZSBmaXJzdCB0eXBlIGluIHRoZSBkZXNjcmlwdG9yLCBhcyBpdCBpcyB0aGUgJ3RoaXMnIGFyZ3VtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYm94QXJndW1lbnRzKHRocmVhZDogdGhyZWFkaW5nLkpWTVRocmVhZCwgb2JqQXJyQ2xzOiBDbGFzc0RhdGEuQXJyYXlDbGFzc0RhdGE8SlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4sIGRlc2NyaXB0b3I6IHN0cmluZywgZGF0YTogYW55W10sIGlzU3RhdGljOiBib29sZWFuLCBza2lwQXJnczogbnVtYmVyID0gMCk6IEpWTVR5cGVzLkpWTUFycmF5PEpWTVR5cGVzLmphdmFfbGFuZ19PYmplY3Q+IHtcbiAgdmFyIHBhcmFtVHlwZXMgPSBnZXRUeXBlcyhkZXNjcmlwdG9yKSxcbiAgICBib3hlZEFyZ3MgPSBuZXdBcnJheUZyb21DbGFzcyh0aHJlYWQsIG9iakFyckNscywgcGFyYW1UeXBlcy5sZW5ndGggLSAoaXNTdGF0aWMgPyAxIDogMikgLSBza2lwQXJncyksXG4gICAgaTogbnVtYmVyLCBqOiBudW1iZXIgPSAwLCBib3hlZEFyZ3NBcnIgPSBib3hlZEFyZ3MuYXJyYXksIHR5cGU6IHN0cmluZztcblxuICAvLyBJZ25vcmUgcmV0dXJuIHZhbHVlLlxuICBwYXJhbVR5cGVzLnBvcCgpO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgLy8gSWdub3JlICd0aGlzJyBhcmd1bWVudC5cbiAgICBwYXJhbVR5cGVzLnNoaWZ0KCk7XG4gIH1cblxuICBpZiAoc2tpcEFyZ3MgPiAwKSB7XG4gICAgLy8gSWdub3JlIHJlZ3VsYXIgYXJndW1lbnRzXG4gICAgcGFyYW1UeXBlcyA9IHBhcmFtVHlwZXMuc2xpY2Uoc2tpcEFyZ3MpO1xuICAgIGRhdGEgPSBkYXRhLnNsaWNlKHNraXBBcmdzKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBwYXJhbVR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdHlwZSA9IHBhcmFtVHlwZXNbaV07XG4gICAgc3dpdGNoKHR5cGVbMF0pIHtcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIC8vIFNpbmdsZSBhcmd1bWVudCBzbG90LCBubyBib3hpbmcgcmVxdWlyZWQuXG4gICAgICAgIGJveGVkQXJnc0FycltpXSA9IGRhdGFbal07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSic6XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgYm94ZWRBcmdzQXJyW2ldID0gYm94UHJpbWl0aXZlVmFsdWUodGhyZWFkLCB0eXBlLCBkYXRhW2pdKTtcbiAgICAgICAgaisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJveGVkQXJnc0FycltpXSA9IGJveFByaW1pdGl2ZVZhbHVlKHRocmVhZCwgdHlwZSwgZGF0YVtqXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBqKys7XG4gIH1cblxuICByZXR1cm4gYm94ZWRBcmdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlc3VsdDxUIGV4dGVuZHMgSlZNVHlwZXMuamF2YV9sYW5nX09iamVjdD4odGhyZWFkOiB0aHJlYWRpbmcuSlZNVGhyZWFkKTogKGU/OiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlLCBydj86IFQpID0+IHZvaWQge1xuICByZXR1cm4gKGU/OiBKVk1UeXBlcy5qYXZhX2xhbmdfVGhyb3dhYmxlLCBydj86IFQpOiB2b2lkID0+IHtcbiAgICBpZiAoZSkge1xuICAgICAgdGhyZWFkLnRocm93RXhjZXB0aW9uKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJlYWQuYXN5bmNSZXR1cm4ocnYpO1xuICAgIH1cbiAgfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcInVybFwiOlwiaHR0cHM6Ly9naXRodWIuY29tL3BsYXNtYS11bWFzcy9kb3BwaW9famNsL3JlbGVhc2VzL2Rvd25sb2FkL3YzLjIvamF2YV9ob21lLnRhci5nelwiLFwiY2xhc3NwYXRoXCI6W1wibGliL3J0LmphclwiLFwibGliL2NoYXJzZXRzLmphclwiLFwibGliL2RvcHBpby5qYXJcIixcImxpYi9kdC5qYXJcIixcImxpYi9qY2UuamFyXCIsXCJsaWIvamNvbnNvbGUuamFyXCIsXCJsaWIvanNzZS5qYXJcIixcImxpYi9tYW5hZ2VtZW50LWFnZW50LmphclwiLFwibGliL3Jlc291cmNlcy5qYXJcIixcImxpYi9zYS1qZGkuamFyXCIsXCJsaWIvdG9vbHMuamFyXCJdfSJdfQ==
